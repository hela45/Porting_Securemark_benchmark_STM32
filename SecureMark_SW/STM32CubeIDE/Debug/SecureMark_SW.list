
SecureMark_SW.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000024c  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00015bf4  08000250  08000250  00001250  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000011fc  08015e48  08015e48  00016e48  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08017044  08017044  00019098  2**0
                  CONTENTS, READONLY
  4 .ARM          00000008  08017044  08017044  00018044  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0801704c  0801704c  00019098  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0801704c  0801704c  0001804c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08017050  08017050  00018050  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000098  20000000  08017054  00019000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00002434  20000098  080170ec  00019098  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  200024cc  080170ec  000194cc  2**0
                  ALLOC
 11 .ARM.attributes 00000036  00000000  00000000  00019098  2**0
                  CONTENTS, READONLY
 12 .debug_info   0001a788  00000000  00000000  000190ce  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000485e  00000000  00000000  00033856  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 000013a0  00000000  00000000  000380b8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_rnglists 00000f02  00000000  00000000  00039458  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  00036ed5  00000000  00000000  0003a35a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   0001faf7  00000000  00000000  0007122f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    0013f89e  00000000  00000000  00090d26  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000043  00000000  00000000  001d05c4  2**0
                  CONTENTS, READONLY
 20 .debug_frame  000055c8  00000000  00000000  001d0608  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 00000083  00000000  00000000  001d5bd0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000250 <__do_global_dtors_aux>:
 8000250:	b510      	push	{r4, lr}
 8000252:	4c05      	ldr	r4, [pc, #20]	@ (8000268 <__do_global_dtors_aux+0x18>)
 8000254:	7823      	ldrb	r3, [r4, #0]
 8000256:	b933      	cbnz	r3, 8000266 <__do_global_dtors_aux+0x16>
 8000258:	4b04      	ldr	r3, [pc, #16]	@ (800026c <__do_global_dtors_aux+0x1c>)
 800025a:	b113      	cbz	r3, 8000262 <__do_global_dtors_aux+0x12>
 800025c:	4804      	ldr	r0, [pc, #16]	@ (8000270 <__do_global_dtors_aux+0x20>)
 800025e:	f3af 8000 	nop.w
 8000262:	2301      	movs	r3, #1
 8000264:	7023      	strb	r3, [r4, #0]
 8000266:	bd10      	pop	{r4, pc}
 8000268:	20000098 	.word	0x20000098
 800026c:	00000000 	.word	0x00000000
 8000270:	08015e2c 	.word	0x08015e2c

08000274 <frame_dummy>:
 8000274:	b508      	push	{r3, lr}
 8000276:	4b03      	ldr	r3, [pc, #12]	@ (8000284 <frame_dummy+0x10>)
 8000278:	b11b      	cbz	r3, 8000282 <frame_dummy+0xe>
 800027a:	4903      	ldr	r1, [pc, #12]	@ (8000288 <frame_dummy+0x14>)
 800027c:	4803      	ldr	r0, [pc, #12]	@ (800028c <frame_dummy+0x18>)
 800027e:	f3af 8000 	nop.w
 8000282:	bd08      	pop	{r3, pc}
 8000284:	00000000 	.word	0x00000000
 8000288:	2000009c 	.word	0x2000009c
 800028c:	08015e2c 	.word	0x08015e2c

08000290 <__aeabi_uldivmod>:
 8000290:	b953      	cbnz	r3, 80002a8 <__aeabi_uldivmod+0x18>
 8000292:	b94a      	cbnz	r2, 80002a8 <__aeabi_uldivmod+0x18>
 8000294:	2900      	cmp	r1, #0
 8000296:	bf08      	it	eq
 8000298:	2800      	cmpeq	r0, #0
 800029a:	bf1c      	itt	ne
 800029c:	f04f 31ff 	movne.w	r1, #4294967295
 80002a0:	f04f 30ff 	movne.w	r0, #4294967295
 80002a4:	f000 b9b0 	b.w	8000608 <__aeabi_idiv0>
 80002a8:	f1ad 0c08 	sub.w	ip, sp, #8
 80002ac:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80002b0:	f000 f806 	bl	80002c0 <__udivmoddi4>
 80002b4:	f8dd e004 	ldr.w	lr, [sp, #4]
 80002b8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80002bc:	b004      	add	sp, #16
 80002be:	4770      	bx	lr

080002c0 <__udivmoddi4>:
 80002c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002c4:	9d09      	ldr	r5, [sp, #36]	@ 0x24
 80002c6:	4688      	mov	r8, r1
 80002c8:	4604      	mov	r4, r0
 80002ca:	468e      	mov	lr, r1
 80002cc:	2b00      	cmp	r3, #0
 80002ce:	d14a      	bne.n	8000366 <__udivmoddi4+0xa6>
 80002d0:	428a      	cmp	r2, r1
 80002d2:	4617      	mov	r7, r2
 80002d4:	d95f      	bls.n	8000396 <__udivmoddi4+0xd6>
 80002d6:	fab2 f682 	clz	r6, r2
 80002da:	b14e      	cbz	r6, 80002f0 <__udivmoddi4+0x30>
 80002dc:	f1c6 0320 	rsb	r3, r6, #32
 80002e0:	fa01 fe06 	lsl.w	lr, r1, r6
 80002e4:	40b7      	lsls	r7, r6
 80002e6:	40b4      	lsls	r4, r6
 80002e8:	fa20 f303 	lsr.w	r3, r0, r3
 80002ec:	ea43 0e0e 	orr.w	lr, r3, lr
 80002f0:	ea4f 4817 	mov.w	r8, r7, lsr #16
 80002f4:	fa1f fc87 	uxth.w	ip, r7
 80002f8:	0c23      	lsrs	r3, r4, #16
 80002fa:	fbbe f1f8 	udiv	r1, lr, r8
 80002fe:	fb08 ee11 	mls	lr, r8, r1, lr
 8000302:	fb01 f20c 	mul.w	r2, r1, ip
 8000306:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 800030a:	429a      	cmp	r2, r3
 800030c:	d907      	bls.n	800031e <__udivmoddi4+0x5e>
 800030e:	18fb      	adds	r3, r7, r3
 8000310:	f101 30ff 	add.w	r0, r1, #4294967295
 8000314:	d202      	bcs.n	800031c <__udivmoddi4+0x5c>
 8000316:	429a      	cmp	r2, r3
 8000318:	f200 8154 	bhi.w	80005c4 <__udivmoddi4+0x304>
 800031c:	4601      	mov	r1, r0
 800031e:	1a9b      	subs	r3, r3, r2
 8000320:	b2a2      	uxth	r2, r4
 8000322:	fbb3 f0f8 	udiv	r0, r3, r8
 8000326:	fb08 3310 	mls	r3, r8, r0, r3
 800032a:	fb00 fc0c 	mul.w	ip, r0, ip
 800032e:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 8000332:	4594      	cmp	ip, r2
 8000334:	d90b      	bls.n	800034e <__udivmoddi4+0x8e>
 8000336:	18ba      	adds	r2, r7, r2
 8000338:	f100 33ff 	add.w	r3, r0, #4294967295
 800033c:	bf2c      	ite	cs
 800033e:	2401      	movcs	r4, #1
 8000340:	2400      	movcc	r4, #0
 8000342:	4594      	cmp	ip, r2
 8000344:	d902      	bls.n	800034c <__udivmoddi4+0x8c>
 8000346:	2c00      	cmp	r4, #0
 8000348:	f000 813f 	beq.w	80005ca <__udivmoddi4+0x30a>
 800034c:	4618      	mov	r0, r3
 800034e:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8000352:	eba2 020c 	sub.w	r2, r2, ip
 8000356:	2100      	movs	r1, #0
 8000358:	b11d      	cbz	r5, 8000362 <__udivmoddi4+0xa2>
 800035a:	40f2      	lsrs	r2, r6
 800035c:	2300      	movs	r3, #0
 800035e:	e9c5 2300 	strd	r2, r3, [r5]
 8000362:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000366:	428b      	cmp	r3, r1
 8000368:	d905      	bls.n	8000376 <__udivmoddi4+0xb6>
 800036a:	b10d      	cbz	r5, 8000370 <__udivmoddi4+0xb0>
 800036c:	e9c5 0100 	strd	r0, r1, [r5]
 8000370:	2100      	movs	r1, #0
 8000372:	4608      	mov	r0, r1
 8000374:	e7f5      	b.n	8000362 <__udivmoddi4+0xa2>
 8000376:	fab3 f183 	clz	r1, r3
 800037a:	2900      	cmp	r1, #0
 800037c:	d14e      	bne.n	800041c <__udivmoddi4+0x15c>
 800037e:	4543      	cmp	r3, r8
 8000380:	f0c0 8112 	bcc.w	80005a8 <__udivmoddi4+0x2e8>
 8000384:	4282      	cmp	r2, r0
 8000386:	f240 810f 	bls.w	80005a8 <__udivmoddi4+0x2e8>
 800038a:	4608      	mov	r0, r1
 800038c:	2d00      	cmp	r5, #0
 800038e:	d0e8      	beq.n	8000362 <__udivmoddi4+0xa2>
 8000390:	e9c5 4e00 	strd	r4, lr, [r5]
 8000394:	e7e5      	b.n	8000362 <__udivmoddi4+0xa2>
 8000396:	2a00      	cmp	r2, #0
 8000398:	f000 80ac 	beq.w	80004f4 <__udivmoddi4+0x234>
 800039c:	fab2 f682 	clz	r6, r2
 80003a0:	2e00      	cmp	r6, #0
 80003a2:	f040 80bb 	bne.w	800051c <__udivmoddi4+0x25c>
 80003a6:	1a8b      	subs	r3, r1, r2
 80003a8:	ea4f 4e12 	mov.w	lr, r2, lsr #16
 80003ac:	b2bc      	uxth	r4, r7
 80003ae:	2101      	movs	r1, #1
 80003b0:	0c02      	lsrs	r2, r0, #16
 80003b2:	b280      	uxth	r0, r0
 80003b4:	fbb3 fcfe 	udiv	ip, r3, lr
 80003b8:	fb0e 331c 	mls	r3, lr, ip, r3
 80003bc:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 80003c0:	fb04 f20c 	mul.w	r2, r4, ip
 80003c4:	429a      	cmp	r2, r3
 80003c6:	d90e      	bls.n	80003e6 <__udivmoddi4+0x126>
 80003c8:	18fb      	adds	r3, r7, r3
 80003ca:	f10c 38ff 	add.w	r8, ip, #4294967295
 80003ce:	bf2c      	ite	cs
 80003d0:	f04f 0901 	movcs.w	r9, #1
 80003d4:	f04f 0900 	movcc.w	r9, #0
 80003d8:	429a      	cmp	r2, r3
 80003da:	d903      	bls.n	80003e4 <__udivmoddi4+0x124>
 80003dc:	f1b9 0f00 	cmp.w	r9, #0
 80003e0:	f000 80ec 	beq.w	80005bc <__udivmoddi4+0x2fc>
 80003e4:	46c4      	mov	ip, r8
 80003e6:	1a9b      	subs	r3, r3, r2
 80003e8:	fbb3 f8fe 	udiv	r8, r3, lr
 80003ec:	fb0e 3318 	mls	r3, lr, r8, r3
 80003f0:	fb04 f408 	mul.w	r4, r4, r8
 80003f4:	ea40 4203 	orr.w	r2, r0, r3, lsl #16
 80003f8:	4294      	cmp	r4, r2
 80003fa:	d90b      	bls.n	8000414 <__udivmoddi4+0x154>
 80003fc:	18ba      	adds	r2, r7, r2
 80003fe:	f108 33ff 	add.w	r3, r8, #4294967295
 8000402:	bf2c      	ite	cs
 8000404:	2001      	movcs	r0, #1
 8000406:	2000      	movcc	r0, #0
 8000408:	4294      	cmp	r4, r2
 800040a:	d902      	bls.n	8000412 <__udivmoddi4+0x152>
 800040c:	2800      	cmp	r0, #0
 800040e:	f000 80d1 	beq.w	80005b4 <__udivmoddi4+0x2f4>
 8000412:	4698      	mov	r8, r3
 8000414:	1b12      	subs	r2, r2, r4
 8000416:	ea48 400c 	orr.w	r0, r8, ip, lsl #16
 800041a:	e79d      	b.n	8000358 <__udivmoddi4+0x98>
 800041c:	f1c1 0620 	rsb	r6, r1, #32
 8000420:	408b      	lsls	r3, r1
 8000422:	fa08 f401 	lsl.w	r4, r8, r1
 8000426:	fa00 f901 	lsl.w	r9, r0, r1
 800042a:	fa22 f706 	lsr.w	r7, r2, r6
 800042e:	fa28 f806 	lsr.w	r8, r8, r6
 8000432:	408a      	lsls	r2, r1
 8000434:	431f      	orrs	r7, r3
 8000436:	fa20 f306 	lsr.w	r3, r0, r6
 800043a:	0c38      	lsrs	r0, r7, #16
 800043c:	4323      	orrs	r3, r4
 800043e:	fa1f fc87 	uxth.w	ip, r7
 8000442:	0c1c      	lsrs	r4, r3, #16
 8000444:	fbb8 fef0 	udiv	lr, r8, r0
 8000448:	fb00 881e 	mls	r8, r0, lr, r8
 800044c:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
 8000450:	fb0e f80c 	mul.w	r8, lr, ip
 8000454:	45a0      	cmp	r8, r4
 8000456:	d90e      	bls.n	8000476 <__udivmoddi4+0x1b6>
 8000458:	193c      	adds	r4, r7, r4
 800045a:	f10e 3aff 	add.w	sl, lr, #4294967295
 800045e:	bf2c      	ite	cs
 8000460:	f04f 0b01 	movcs.w	fp, #1
 8000464:	f04f 0b00 	movcc.w	fp, #0
 8000468:	45a0      	cmp	r8, r4
 800046a:	d903      	bls.n	8000474 <__udivmoddi4+0x1b4>
 800046c:	f1bb 0f00 	cmp.w	fp, #0
 8000470:	f000 80b8 	beq.w	80005e4 <__udivmoddi4+0x324>
 8000474:	46d6      	mov	lr, sl
 8000476:	eba4 0408 	sub.w	r4, r4, r8
 800047a:	fa1f f883 	uxth.w	r8, r3
 800047e:	fbb4 f3f0 	udiv	r3, r4, r0
 8000482:	fb00 4413 	mls	r4, r0, r3, r4
 8000486:	fb03 fc0c 	mul.w	ip, r3, ip
 800048a:	ea48 4404 	orr.w	r4, r8, r4, lsl #16
 800048e:	45a4      	cmp	ip, r4
 8000490:	d90e      	bls.n	80004b0 <__udivmoddi4+0x1f0>
 8000492:	193c      	adds	r4, r7, r4
 8000494:	f103 30ff 	add.w	r0, r3, #4294967295
 8000498:	bf2c      	ite	cs
 800049a:	f04f 0801 	movcs.w	r8, #1
 800049e:	f04f 0800 	movcc.w	r8, #0
 80004a2:	45a4      	cmp	ip, r4
 80004a4:	d903      	bls.n	80004ae <__udivmoddi4+0x1ee>
 80004a6:	f1b8 0f00 	cmp.w	r8, #0
 80004aa:	f000 809f 	beq.w	80005ec <__udivmoddi4+0x32c>
 80004ae:	4603      	mov	r3, r0
 80004b0:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
 80004b4:	eba4 040c 	sub.w	r4, r4, ip
 80004b8:	fba0 ec02 	umull	lr, ip, r0, r2
 80004bc:	4564      	cmp	r4, ip
 80004be:	4673      	mov	r3, lr
 80004c0:	46e0      	mov	r8, ip
 80004c2:	d302      	bcc.n	80004ca <__udivmoddi4+0x20a>
 80004c4:	d107      	bne.n	80004d6 <__udivmoddi4+0x216>
 80004c6:	45f1      	cmp	r9, lr
 80004c8:	d205      	bcs.n	80004d6 <__udivmoddi4+0x216>
 80004ca:	ebbe 0302 	subs.w	r3, lr, r2
 80004ce:	eb6c 0c07 	sbc.w	ip, ip, r7
 80004d2:	3801      	subs	r0, #1
 80004d4:	46e0      	mov	r8, ip
 80004d6:	b15d      	cbz	r5, 80004f0 <__udivmoddi4+0x230>
 80004d8:	ebb9 0203 	subs.w	r2, r9, r3
 80004dc:	eb64 0408 	sbc.w	r4, r4, r8
 80004e0:	fa04 f606 	lsl.w	r6, r4, r6
 80004e4:	fa22 f301 	lsr.w	r3, r2, r1
 80004e8:	40cc      	lsrs	r4, r1
 80004ea:	431e      	orrs	r6, r3
 80004ec:	e9c5 6400 	strd	r6, r4, [r5]
 80004f0:	2100      	movs	r1, #0
 80004f2:	e736      	b.n	8000362 <__udivmoddi4+0xa2>
 80004f4:	fbb1 fcf2 	udiv	ip, r1, r2
 80004f8:	0c01      	lsrs	r1, r0, #16
 80004fa:	4614      	mov	r4, r2
 80004fc:	b280      	uxth	r0, r0
 80004fe:	4696      	mov	lr, r2
 8000500:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
 8000504:	2620      	movs	r6, #32
 8000506:	4690      	mov	r8, r2
 8000508:	ea40 4301 	orr.w	r3, r0, r1, lsl #16
 800050c:	4610      	mov	r0, r2
 800050e:	fbb1 f1f2 	udiv	r1, r1, r2
 8000512:	eba3 0308 	sub.w	r3, r3, r8
 8000516:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
 800051a:	e74b      	b.n	80003b4 <__udivmoddi4+0xf4>
 800051c:	40b7      	lsls	r7, r6
 800051e:	f1c6 0320 	rsb	r3, r6, #32
 8000522:	fa01 f206 	lsl.w	r2, r1, r6
 8000526:	fa21 f803 	lsr.w	r8, r1, r3
 800052a:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 800052e:	fa20 f303 	lsr.w	r3, r0, r3
 8000532:	b2bc      	uxth	r4, r7
 8000534:	40b0      	lsls	r0, r6
 8000536:	4313      	orrs	r3, r2
 8000538:	0c02      	lsrs	r2, r0, #16
 800053a:	0c19      	lsrs	r1, r3, #16
 800053c:	b280      	uxth	r0, r0
 800053e:	fbb8 f9fe 	udiv	r9, r8, lr
 8000542:	fb0e 8819 	mls	r8, lr, r9, r8
 8000546:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
 800054a:	fb09 f804 	mul.w	r8, r9, r4
 800054e:	4588      	cmp	r8, r1
 8000550:	d951      	bls.n	80005f6 <__udivmoddi4+0x336>
 8000552:	1879      	adds	r1, r7, r1
 8000554:	f109 3cff 	add.w	ip, r9, #4294967295
 8000558:	bf2c      	ite	cs
 800055a:	f04f 0a01 	movcs.w	sl, #1
 800055e:	f04f 0a00 	movcc.w	sl, #0
 8000562:	4588      	cmp	r8, r1
 8000564:	d902      	bls.n	800056c <__udivmoddi4+0x2ac>
 8000566:	f1ba 0f00 	cmp.w	sl, #0
 800056a:	d031      	beq.n	80005d0 <__udivmoddi4+0x310>
 800056c:	eba1 0108 	sub.w	r1, r1, r8
 8000570:	fbb1 f9fe 	udiv	r9, r1, lr
 8000574:	fb09 f804 	mul.w	r8, r9, r4
 8000578:	fb0e 1119 	mls	r1, lr, r9, r1
 800057c:	b29b      	uxth	r3, r3
 800057e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000582:	4543      	cmp	r3, r8
 8000584:	d235      	bcs.n	80005f2 <__udivmoddi4+0x332>
 8000586:	18fb      	adds	r3, r7, r3
 8000588:	f109 31ff 	add.w	r1, r9, #4294967295
 800058c:	bf2c      	ite	cs
 800058e:	f04f 0a01 	movcs.w	sl, #1
 8000592:	f04f 0a00 	movcc.w	sl, #0
 8000596:	4543      	cmp	r3, r8
 8000598:	d2bb      	bcs.n	8000512 <__udivmoddi4+0x252>
 800059a:	f1ba 0f00 	cmp.w	sl, #0
 800059e:	d1b8      	bne.n	8000512 <__udivmoddi4+0x252>
 80005a0:	f1a9 0102 	sub.w	r1, r9, #2
 80005a4:	443b      	add	r3, r7
 80005a6:	e7b4      	b.n	8000512 <__udivmoddi4+0x252>
 80005a8:	1a84      	subs	r4, r0, r2
 80005aa:	eb68 0203 	sbc.w	r2, r8, r3
 80005ae:	2001      	movs	r0, #1
 80005b0:	4696      	mov	lr, r2
 80005b2:	e6eb      	b.n	800038c <__udivmoddi4+0xcc>
 80005b4:	443a      	add	r2, r7
 80005b6:	f1a8 0802 	sub.w	r8, r8, #2
 80005ba:	e72b      	b.n	8000414 <__udivmoddi4+0x154>
 80005bc:	f1ac 0c02 	sub.w	ip, ip, #2
 80005c0:	443b      	add	r3, r7
 80005c2:	e710      	b.n	80003e6 <__udivmoddi4+0x126>
 80005c4:	3902      	subs	r1, #2
 80005c6:	443b      	add	r3, r7
 80005c8:	e6a9      	b.n	800031e <__udivmoddi4+0x5e>
 80005ca:	443a      	add	r2, r7
 80005cc:	3802      	subs	r0, #2
 80005ce:	e6be      	b.n	800034e <__udivmoddi4+0x8e>
 80005d0:	eba7 0808 	sub.w	r8, r7, r8
 80005d4:	f1a9 0c02 	sub.w	ip, r9, #2
 80005d8:	4441      	add	r1, r8
 80005da:	fbb1 f9fe 	udiv	r9, r1, lr
 80005de:	fb09 f804 	mul.w	r8, r9, r4
 80005e2:	e7c9      	b.n	8000578 <__udivmoddi4+0x2b8>
 80005e4:	f1ae 0e02 	sub.w	lr, lr, #2
 80005e8:	443c      	add	r4, r7
 80005ea:	e744      	b.n	8000476 <__udivmoddi4+0x1b6>
 80005ec:	3b02      	subs	r3, #2
 80005ee:	443c      	add	r4, r7
 80005f0:	e75e      	b.n	80004b0 <__udivmoddi4+0x1f0>
 80005f2:	4649      	mov	r1, r9
 80005f4:	e78d      	b.n	8000512 <__udivmoddi4+0x252>
 80005f6:	eba1 0108 	sub.w	r1, r1, r8
 80005fa:	46cc      	mov	ip, r9
 80005fc:	fbb1 f9fe 	udiv	r9, r1, lr
 8000600:	fb09 f804 	mul.w	r8, r9, r4
 8000604:	e7b8      	b.n	8000578 <__udivmoddi4+0x2b8>
 8000606:	bf00      	nop

08000608 <__aeabi_idiv0>:
 8000608:	4770      	bx	lr
 800060a:	bf00      	nop

0800060c <aes_gen_tables>:
#define MUL(x,y) ( ( (x) && (y) ) ? pow[(log[(x)]+log[(y)]) % 255] : 0 )

static int aes_init_done = 0;

static void aes_gen_tables( void )
{
 800060c:	b480      	push	{r7}
 800060e:	f6ad 0d14 	subw	sp, sp, #2068	@ 0x814
 8000612:	af00      	add	r7, sp, #0
    int log[256];

    /*
     * compute pow and log tables over GF(2^8)
     */
    for( i = 0, x = 1; i < 256; i++ )
 8000614:	2300      	movs	r3, #0
 8000616:	f8c7 380c 	str.w	r3, [r7, #2060]	@ 0x80c
 800061a:	2301      	movs	r3, #1
 800061c:	f8c7 3808 	str.w	r3, [r7, #2056]	@ 0x808
 8000620:	e02b      	b.n	800067a <aes_gen_tables+0x6e>
    {
        pow[i] = x;
 8000622:	f507 6301 	add.w	r3, r7, #2064	@ 0x810
 8000626:	f5a3 6382 	sub.w	r3, r3, #1040	@ 0x410
 800062a:	f8d7 280c 	ldr.w	r2, [r7, #2060]	@ 0x80c
 800062e:	f8d7 1808 	ldr.w	r1, [r7, #2056]	@ 0x808
 8000632:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        log[x] = i;
 8000636:	f507 6301 	add.w	r3, r7, #2064	@ 0x810
 800063a:	f5a3 6301 	sub.w	r3, r3, #2064	@ 0x810
 800063e:	f8d7 2808 	ldr.w	r2, [r7, #2056]	@ 0x808
 8000642:	f8d7 180c 	ldr.w	r1, [r7, #2060]	@ 0x80c
 8000646:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        x = ( x ^ XTIME( x ) ) & 0xFF;
 800064a:	f8d7 3808 	ldr.w	r3, [r7, #2056]	@ 0x808
 800064e:	005b      	lsls	r3, r3, #1
 8000650:	f8d7 2808 	ldr.w	r2, [r7, #2056]	@ 0x808
 8000654:	f002 0280 	and.w	r2, r2, #128	@ 0x80
 8000658:	2a00      	cmp	r2, #0
 800065a:	d001      	beq.n	8000660 <aes_gen_tables+0x54>
 800065c:	221b      	movs	r2, #27
 800065e:	e000      	b.n	8000662 <aes_gen_tables+0x56>
 8000660:	2200      	movs	r2, #0
 8000662:	405a      	eors	r2, r3
 8000664:	f8d7 3808 	ldr.w	r3, [r7, #2056]	@ 0x808
 8000668:	4053      	eors	r3, r2
 800066a:	b2db      	uxtb	r3, r3
 800066c:	f8c7 3808 	str.w	r3, [r7, #2056]	@ 0x808
    for( i = 0, x = 1; i < 256; i++ )
 8000670:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 8000674:	3301      	adds	r3, #1
 8000676:	f8c7 380c 	str.w	r3, [r7, #2060]	@ 0x80c
 800067a:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 800067e:	2bff      	cmp	r3, #255	@ 0xff
 8000680:	ddcf      	ble.n	8000622 <aes_gen_tables+0x16>
    }

    /*
     * calculate the round constants
     */
    for( i = 0, x = 1; i < 10; i++ )
 8000682:	2300      	movs	r3, #0
 8000684:	f8c7 380c 	str.w	r3, [r7, #2060]	@ 0x80c
 8000688:	2301      	movs	r3, #1
 800068a:	f8c7 3808 	str.w	r3, [r7, #2056]	@ 0x808
 800068e:	e01b      	b.n	80006c8 <aes_gen_tables+0xbc>
    {
        RCON[i] = (uint32_t) x;
 8000690:	f8d7 2808 	ldr.w	r2, [r7, #2056]	@ 0x808
 8000694:	49cc      	ldr	r1, [pc, #816]	@ (80009c8 <aes_gen_tables+0x3bc>)
 8000696:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 800069a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
        x = XTIME( x ) & 0xFF;
 800069e:	f8d7 3808 	ldr.w	r3, [r7, #2056]	@ 0x808
 80006a2:	005b      	lsls	r3, r3, #1
 80006a4:	f8d7 2808 	ldr.w	r2, [r7, #2056]	@ 0x808
 80006a8:	f002 0280 	and.w	r2, r2, #128	@ 0x80
 80006ac:	2a00      	cmp	r2, #0
 80006ae:	d001      	beq.n	80006b4 <aes_gen_tables+0xa8>
 80006b0:	221b      	movs	r2, #27
 80006b2:	e000      	b.n	80006b6 <aes_gen_tables+0xaa>
 80006b4:	2200      	movs	r2, #0
 80006b6:	4053      	eors	r3, r2
 80006b8:	b2db      	uxtb	r3, r3
 80006ba:	f8c7 3808 	str.w	r3, [r7, #2056]	@ 0x808
    for( i = 0, x = 1; i < 10; i++ )
 80006be:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 80006c2:	3301      	adds	r3, #1
 80006c4:	f8c7 380c 	str.w	r3, [r7, #2060]	@ 0x80c
 80006c8:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 80006cc:	2b09      	cmp	r3, #9
 80006ce:	dddf      	ble.n	8000690 <aes_gen_tables+0x84>
    }

    /*
     * generate the forward and reverse S-boxes
     */
    FSb[0x00] = 0x63;
 80006d0:	4bbe      	ldr	r3, [pc, #760]	@ (80009cc <aes_gen_tables+0x3c0>)
 80006d2:	2263      	movs	r2, #99	@ 0x63
 80006d4:	701a      	strb	r2, [r3, #0]
    RSb[0x63] = 0x00;
 80006d6:	4bbe      	ldr	r3, [pc, #760]	@ (80009d0 <aes_gen_tables+0x3c4>)
 80006d8:	2200      	movs	r2, #0
 80006da:	f883 2063 	strb.w	r2, [r3, #99]	@ 0x63

    for( i = 1; i < 256; i++ )
 80006de:	2301      	movs	r3, #1
 80006e0:	f8c7 380c 	str.w	r3, [r7, #2060]	@ 0x80c
 80006e4:	e072      	b.n	80007cc <aes_gen_tables+0x1c0>
    {
        x = pow[255 - log[i]];
 80006e6:	f507 6301 	add.w	r3, r7, #2064	@ 0x810
 80006ea:	f5a3 6301 	sub.w	r3, r3, #2064	@ 0x810
 80006ee:	f8d7 280c 	ldr.w	r2, [r7, #2060]	@ 0x80c
 80006f2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80006f6:	f1c3 02ff 	rsb	r2, r3, #255	@ 0xff
 80006fa:	f507 6301 	add.w	r3, r7, #2064	@ 0x810
 80006fe:	f5a3 6382 	sub.w	r3, r3, #1040	@ 0x410
 8000702:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8000706:	f8c7 3808 	str.w	r3, [r7, #2056]	@ 0x808

        y  = x; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
 800070a:	f8d7 3808 	ldr.w	r3, [r7, #2056]	@ 0x808
 800070e:	f8c7 3804 	str.w	r3, [r7, #2052]	@ 0x804
 8000712:	f8d7 3804 	ldr.w	r3, [r7, #2052]	@ 0x804
 8000716:	005a      	lsls	r2, r3, #1
 8000718:	f8d7 3804 	ldr.w	r3, [r7, #2052]	@ 0x804
 800071c:	11db      	asrs	r3, r3, #7
 800071e:	4313      	orrs	r3, r2
 8000720:	b2db      	uxtb	r3, r3
 8000722:	f8c7 3804 	str.w	r3, [r7, #2052]	@ 0x804
        x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
 8000726:	f8d7 2808 	ldr.w	r2, [r7, #2056]	@ 0x808
 800072a:	f8d7 3804 	ldr.w	r3, [r7, #2052]	@ 0x804
 800072e:	4053      	eors	r3, r2
 8000730:	f8c7 3808 	str.w	r3, [r7, #2056]	@ 0x808
 8000734:	f8d7 3804 	ldr.w	r3, [r7, #2052]	@ 0x804
 8000738:	005a      	lsls	r2, r3, #1
 800073a:	f8d7 3804 	ldr.w	r3, [r7, #2052]	@ 0x804
 800073e:	11db      	asrs	r3, r3, #7
 8000740:	4313      	orrs	r3, r2
 8000742:	b2db      	uxtb	r3, r3
 8000744:	f8c7 3804 	str.w	r3, [r7, #2052]	@ 0x804
        x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
 8000748:	f8d7 2808 	ldr.w	r2, [r7, #2056]	@ 0x808
 800074c:	f8d7 3804 	ldr.w	r3, [r7, #2052]	@ 0x804
 8000750:	4053      	eors	r3, r2
 8000752:	f8c7 3808 	str.w	r3, [r7, #2056]	@ 0x808
 8000756:	f8d7 3804 	ldr.w	r3, [r7, #2052]	@ 0x804
 800075a:	005a      	lsls	r2, r3, #1
 800075c:	f8d7 3804 	ldr.w	r3, [r7, #2052]	@ 0x804
 8000760:	11db      	asrs	r3, r3, #7
 8000762:	4313      	orrs	r3, r2
 8000764:	b2db      	uxtb	r3, r3
 8000766:	f8c7 3804 	str.w	r3, [r7, #2052]	@ 0x804
        x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
 800076a:	f8d7 2808 	ldr.w	r2, [r7, #2056]	@ 0x808
 800076e:	f8d7 3804 	ldr.w	r3, [r7, #2052]	@ 0x804
 8000772:	4053      	eors	r3, r2
 8000774:	f8c7 3808 	str.w	r3, [r7, #2056]	@ 0x808
 8000778:	f8d7 3804 	ldr.w	r3, [r7, #2052]	@ 0x804
 800077c:	005a      	lsls	r2, r3, #1
 800077e:	f8d7 3804 	ldr.w	r3, [r7, #2052]	@ 0x804
 8000782:	11db      	asrs	r3, r3, #7
 8000784:	4313      	orrs	r3, r2
 8000786:	b2db      	uxtb	r3, r3
 8000788:	f8c7 3804 	str.w	r3, [r7, #2052]	@ 0x804
        x ^= y ^ 0x63;
 800078c:	f8d7 3804 	ldr.w	r3, [r7, #2052]	@ 0x804
 8000790:	f083 0363 	eor.w	r3, r3, #99	@ 0x63
 8000794:	f8d7 2808 	ldr.w	r2, [r7, #2056]	@ 0x808
 8000798:	4053      	eors	r3, r2
 800079a:	f8c7 3808 	str.w	r3, [r7, #2056]	@ 0x808

        FSb[i] = (unsigned char) x;
 800079e:	f8d7 3808 	ldr.w	r3, [r7, #2056]	@ 0x808
 80007a2:	b2d9      	uxtb	r1, r3
 80007a4:	4a89      	ldr	r2, [pc, #548]	@ (80009cc <aes_gen_tables+0x3c0>)
 80007a6:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 80007aa:	4413      	add	r3, r2
 80007ac:	460a      	mov	r2, r1
 80007ae:	701a      	strb	r2, [r3, #0]
        RSb[x] = (unsigned char) i;
 80007b0:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 80007b4:	b2d9      	uxtb	r1, r3
 80007b6:	4a86      	ldr	r2, [pc, #536]	@ (80009d0 <aes_gen_tables+0x3c4>)
 80007b8:	f8d7 3808 	ldr.w	r3, [r7, #2056]	@ 0x808
 80007bc:	4413      	add	r3, r2
 80007be:	460a      	mov	r2, r1
 80007c0:	701a      	strb	r2, [r3, #0]
    for( i = 1; i < 256; i++ )
 80007c2:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 80007c6:	3301      	adds	r3, #1
 80007c8:	f8c7 380c 	str.w	r3, [r7, #2060]	@ 0x80c
 80007cc:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 80007d0:	2bff      	cmp	r3, #255	@ 0xff
 80007d2:	dd88      	ble.n	80006e6 <aes_gen_tables+0xda>
    }

    /*
     * generate the forward and reverse tables
     */
    for( i = 0; i < 256; i++ )
 80007d4:	2300      	movs	r3, #0
 80007d6:	f8c7 380c 	str.w	r3, [r7, #2060]	@ 0x80c
 80007da:	e136      	b.n	8000a4a <aes_gen_tables+0x43e>
    {
        x = FSb[i];
 80007dc:	4a7b      	ldr	r2, [pc, #492]	@ (80009cc <aes_gen_tables+0x3c0>)
 80007de:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 80007e2:	4413      	add	r3, r2
 80007e4:	781b      	ldrb	r3, [r3, #0]
 80007e6:	f8c7 3808 	str.w	r3, [r7, #2056]	@ 0x808
        y = XTIME( x ) & 0xFF;
 80007ea:	f8d7 3808 	ldr.w	r3, [r7, #2056]	@ 0x808
 80007ee:	005b      	lsls	r3, r3, #1
 80007f0:	f8d7 2808 	ldr.w	r2, [r7, #2056]	@ 0x808
 80007f4:	f002 0280 	and.w	r2, r2, #128	@ 0x80
 80007f8:	2a00      	cmp	r2, #0
 80007fa:	d001      	beq.n	8000800 <aes_gen_tables+0x1f4>
 80007fc:	221b      	movs	r2, #27
 80007fe:	e000      	b.n	8000802 <aes_gen_tables+0x1f6>
 8000800:	2200      	movs	r2, #0
 8000802:	4053      	eors	r3, r2
 8000804:	b2db      	uxtb	r3, r3
 8000806:	f8c7 3804 	str.w	r3, [r7, #2052]	@ 0x804
        z =  ( y ^ x ) & 0xFF;
 800080a:	f8d7 2804 	ldr.w	r2, [r7, #2052]	@ 0x804
 800080e:	f8d7 3808 	ldr.w	r3, [r7, #2056]	@ 0x808
 8000812:	4053      	eors	r3, r2
 8000814:	b2db      	uxtb	r3, r3
 8000816:	f8c7 3800 	str.w	r3, [r7, #2048]	@ 0x800

        FT0[i] = ( (uint32_t) y       ) ^
                 ( (uint32_t) x <<  8 ) ^
 800081a:	f8d7 3808 	ldr.w	r3, [r7, #2056]	@ 0x808
 800081e:	021a      	lsls	r2, r3, #8
        FT0[i] = ( (uint32_t) y       ) ^
 8000820:	f8d7 3804 	ldr.w	r3, [r7, #2052]	@ 0x804
 8000824:	405a      	eors	r2, r3
                 ( (uint32_t) x << 16 ) ^
 8000826:	f8d7 3808 	ldr.w	r3, [r7, #2056]	@ 0x808
 800082a:	041b      	lsls	r3, r3, #16
                 ( (uint32_t) x <<  8 ) ^
 800082c:	405a      	eors	r2, r3
                 ( (uint32_t) z << 24 );
 800082e:	f8d7 3800 	ldr.w	r3, [r7, #2048]	@ 0x800
 8000832:	061b      	lsls	r3, r3, #24
                 ( (uint32_t) x << 16 ) ^
 8000834:	405a      	eors	r2, r3
        FT0[i] = ( (uint32_t) y       ) ^
 8000836:	4967      	ldr	r1, [pc, #412]	@ (80009d4 <aes_gen_tables+0x3c8>)
 8000838:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 800083c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

#if !defined(MBEDTLS_AES_FEWER_TABLES)
        FT1[i] = ROTL8( FT0[i] );
 8000840:	4a64      	ldr	r2, [pc, #400]	@ (80009d4 <aes_gen_tables+0x3c8>)
 8000842:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 8000846:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800084a:	ea4f 6233 	mov.w	r2, r3, ror #24
 800084e:	4962      	ldr	r1, [pc, #392]	@ (80009d8 <aes_gen_tables+0x3cc>)
 8000850:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 8000854:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
        FT2[i] = ROTL8( FT1[i] );
 8000858:	4a5f      	ldr	r2, [pc, #380]	@ (80009d8 <aes_gen_tables+0x3cc>)
 800085a:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 800085e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000862:	ea4f 6233 	mov.w	r2, r3, ror #24
 8000866:	495d      	ldr	r1, [pc, #372]	@ (80009dc <aes_gen_tables+0x3d0>)
 8000868:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 800086c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
        FT3[i] = ROTL8( FT2[i] );
 8000870:	4a5a      	ldr	r2, [pc, #360]	@ (80009dc <aes_gen_tables+0x3d0>)
 8000872:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 8000876:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800087a:	ea4f 6233 	mov.w	r2, r3, ror #24
 800087e:	4958      	ldr	r1, [pc, #352]	@ (80009e0 <aes_gen_tables+0x3d4>)
 8000880:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 8000884:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif /* !MBEDTLS_AES_FEWER_TABLES */

        x = RSb[i];
 8000888:	4a51      	ldr	r2, [pc, #324]	@ (80009d0 <aes_gen_tables+0x3c4>)
 800088a:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 800088e:	4413      	add	r3, r2
 8000890:	781b      	ldrb	r3, [r3, #0]
 8000892:	f8c7 3808 	str.w	r3, [r7, #2056]	@ 0x808

        RT0[i] = ( (uint32_t) MUL( 0x0E, x )       ) ^
 8000896:	f8d7 3808 	ldr.w	r3, [r7, #2056]	@ 0x808
 800089a:	2b00      	cmp	r3, #0
 800089c:	d020      	beq.n	80008e0 <aes_gen_tables+0x2d4>
 800089e:	f507 6301 	add.w	r3, r7, #2064	@ 0x810
 80008a2:	f5a3 6301 	sub.w	r3, r3, #2064	@ 0x810
 80008a6:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 80008a8:	f507 6301 	add.w	r3, r7, #2064	@ 0x810
 80008ac:	f5a3 6301 	sub.w	r3, r3, #2064	@ 0x810
 80008b0:	f8d7 1808 	ldr.w	r1, [r7, #2056]	@ 0x808
 80008b4:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80008b8:	441a      	add	r2, r3
 80008ba:	4b4a      	ldr	r3, [pc, #296]	@ (80009e4 <aes_gen_tables+0x3d8>)
 80008bc:	fb83 1302 	smull	r1, r3, r3, r2
 80008c0:	4413      	add	r3, r2
 80008c2:	11d9      	asrs	r1, r3, #7
 80008c4:	17d3      	asrs	r3, r2, #31
 80008c6:	1ac9      	subs	r1, r1, r3
 80008c8:	460b      	mov	r3, r1
 80008ca:	021b      	lsls	r3, r3, #8
 80008cc:	1a5b      	subs	r3, r3, r1
 80008ce:	1ad1      	subs	r1, r2, r3
 80008d0:	f507 6301 	add.w	r3, r7, #2064	@ 0x810
 80008d4:	f5a3 6382 	sub.w	r3, r3, #1040	@ 0x410
 80008d8:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80008dc:	4618      	mov	r0, r3
 80008de:	e000      	b.n	80008e2 <aes_gen_tables+0x2d6>
 80008e0:	2000      	movs	r0, #0
                 ( (uint32_t) MUL( 0x09, x ) <<  8 ) ^
 80008e2:	f8d7 3808 	ldr.w	r3, [r7, #2056]	@ 0x808
 80008e6:	2b00      	cmp	r3, #0
 80008e8:	d020      	beq.n	800092c <aes_gen_tables+0x320>
 80008ea:	f507 6301 	add.w	r3, r7, #2064	@ 0x810
 80008ee:	f5a3 6301 	sub.w	r3, r3, #2064	@ 0x810
 80008f2:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 80008f4:	f507 6301 	add.w	r3, r7, #2064	@ 0x810
 80008f8:	f5a3 6301 	sub.w	r3, r3, #2064	@ 0x810
 80008fc:	f8d7 1808 	ldr.w	r1, [r7, #2056]	@ 0x808
 8000900:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8000904:	441a      	add	r2, r3
 8000906:	4b37      	ldr	r3, [pc, #220]	@ (80009e4 <aes_gen_tables+0x3d8>)
 8000908:	fb83 1302 	smull	r1, r3, r3, r2
 800090c:	4413      	add	r3, r2
 800090e:	11d9      	asrs	r1, r3, #7
 8000910:	17d3      	asrs	r3, r2, #31
 8000912:	1ac9      	subs	r1, r1, r3
 8000914:	460b      	mov	r3, r1
 8000916:	021b      	lsls	r3, r3, #8
 8000918:	1a5b      	subs	r3, r3, r1
 800091a:	1ad1      	subs	r1, r2, r3
 800091c:	f507 6301 	add.w	r3, r7, #2064	@ 0x810
 8000920:	f5a3 6382 	sub.w	r3, r3, #1040	@ 0x410
 8000924:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8000928:	021b      	lsls	r3, r3, #8
 800092a:	e000      	b.n	800092e <aes_gen_tables+0x322>
 800092c:	2300      	movs	r3, #0
        RT0[i] = ( (uint32_t) MUL( 0x0E, x )       ) ^
 800092e:	4058      	eors	r0, r3
                 ( (uint32_t) MUL( 0x0D, x ) << 16 ) ^
 8000930:	f8d7 3808 	ldr.w	r3, [r7, #2056]	@ 0x808
 8000934:	2b00      	cmp	r3, #0
 8000936:	d020      	beq.n	800097a <aes_gen_tables+0x36e>
 8000938:	f507 6301 	add.w	r3, r7, #2064	@ 0x810
 800093c:	f5a3 6301 	sub.w	r3, r3, #2064	@ 0x810
 8000940:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8000942:	f507 6301 	add.w	r3, r7, #2064	@ 0x810
 8000946:	f5a3 6301 	sub.w	r3, r3, #2064	@ 0x810
 800094a:	f8d7 1808 	ldr.w	r1, [r7, #2056]	@ 0x808
 800094e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8000952:	441a      	add	r2, r3
 8000954:	4b23      	ldr	r3, [pc, #140]	@ (80009e4 <aes_gen_tables+0x3d8>)
 8000956:	fb83 1302 	smull	r1, r3, r3, r2
 800095a:	4413      	add	r3, r2
 800095c:	11d9      	asrs	r1, r3, #7
 800095e:	17d3      	asrs	r3, r2, #31
 8000960:	1ac9      	subs	r1, r1, r3
 8000962:	460b      	mov	r3, r1
 8000964:	021b      	lsls	r3, r3, #8
 8000966:	1a5b      	subs	r3, r3, r1
 8000968:	1ad1      	subs	r1, r2, r3
 800096a:	f507 6301 	add.w	r3, r7, #2064	@ 0x810
 800096e:	f5a3 6382 	sub.w	r3, r3, #1040	@ 0x410
 8000972:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8000976:	041b      	lsls	r3, r3, #16
 8000978:	e000      	b.n	800097c <aes_gen_tables+0x370>
 800097a:	2300      	movs	r3, #0
                 ( (uint32_t) MUL( 0x09, x ) <<  8 ) ^
 800097c:	4058      	eors	r0, r3
                 ( (uint32_t) MUL( 0x0B, x ) << 24 );
 800097e:	f8d7 3808 	ldr.w	r3, [r7, #2056]	@ 0x808
 8000982:	2b00      	cmp	r3, #0
 8000984:	d030      	beq.n	80009e8 <aes_gen_tables+0x3dc>
 8000986:	f507 6301 	add.w	r3, r7, #2064	@ 0x810
 800098a:	f5a3 6301 	sub.w	r3, r3, #2064	@ 0x810
 800098e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8000990:	f507 6301 	add.w	r3, r7, #2064	@ 0x810
 8000994:	f5a3 6301 	sub.w	r3, r3, #2064	@ 0x810
 8000998:	f8d7 1808 	ldr.w	r1, [r7, #2056]	@ 0x808
 800099c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80009a0:	441a      	add	r2, r3
 80009a2:	4b10      	ldr	r3, [pc, #64]	@ (80009e4 <aes_gen_tables+0x3d8>)
 80009a4:	fb83 1302 	smull	r1, r3, r3, r2
 80009a8:	4413      	add	r3, r2
 80009aa:	11d9      	asrs	r1, r3, #7
 80009ac:	17d3      	asrs	r3, r2, #31
 80009ae:	1ac9      	subs	r1, r1, r3
 80009b0:	460b      	mov	r3, r1
 80009b2:	021b      	lsls	r3, r3, #8
 80009b4:	1a5b      	subs	r3, r3, r1
 80009b6:	1ad1      	subs	r1, r2, r3
 80009b8:	f507 6301 	add.w	r3, r7, #2064	@ 0x810
 80009bc:	f5a3 6382 	sub.w	r3, r3, #1040	@ 0x410
 80009c0:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80009c4:	061b      	lsls	r3, r3, #24
 80009c6:	e010      	b.n	80009ea <aes_gen_tables+0x3de>
 80009c8:	200022b4 	.word	0x200022b4
 80009cc:	200000b4 	.word	0x200000b4
 80009d0:	200011b4 	.word	0x200011b4
 80009d4:	200001b4 	.word	0x200001b4
 80009d8:	200005b4 	.word	0x200005b4
 80009dc:	200009b4 	.word	0x200009b4
 80009e0:	20000db4 	.word	0x20000db4
 80009e4:	80808081 	.word	0x80808081
 80009e8:	2300      	movs	r3, #0
                 ( (uint32_t) MUL( 0x0D, x ) << 16 ) ^
 80009ea:	ea83 0200 	eor.w	r2, r3, r0
        RT0[i] = ( (uint32_t) MUL( 0x0E, x )       ) ^
 80009ee:	491d      	ldr	r1, [pc, #116]	@ (8000a64 <aes_gen_tables+0x458>)
 80009f0:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 80009f4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

#if !defined(MBEDTLS_AES_FEWER_TABLES)
        RT1[i] = ROTL8( RT0[i] );
 80009f8:	4a1a      	ldr	r2, [pc, #104]	@ (8000a64 <aes_gen_tables+0x458>)
 80009fa:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 80009fe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000a02:	ea4f 6233 	mov.w	r2, r3, ror #24
 8000a06:	4918      	ldr	r1, [pc, #96]	@ (8000a68 <aes_gen_tables+0x45c>)
 8000a08:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 8000a0c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
        RT2[i] = ROTL8( RT1[i] );
 8000a10:	4a15      	ldr	r2, [pc, #84]	@ (8000a68 <aes_gen_tables+0x45c>)
 8000a12:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 8000a16:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000a1a:	ea4f 6233 	mov.w	r2, r3, ror #24
 8000a1e:	4913      	ldr	r1, [pc, #76]	@ (8000a6c <aes_gen_tables+0x460>)
 8000a20:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 8000a24:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
        RT3[i] = ROTL8( RT2[i] );
 8000a28:	4a10      	ldr	r2, [pc, #64]	@ (8000a6c <aes_gen_tables+0x460>)
 8000a2a:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 8000a2e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000a32:	ea4f 6233 	mov.w	r2, r3, ror #24
 8000a36:	490e      	ldr	r1, [pc, #56]	@ (8000a70 <aes_gen_tables+0x464>)
 8000a38:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 8000a3c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    for( i = 0; i < 256; i++ )
 8000a40:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 8000a44:	3301      	adds	r3, #1
 8000a46:	f8c7 380c 	str.w	r3, [r7, #2060]	@ 0x80c
 8000a4a:	f8d7 380c 	ldr.w	r3, [r7, #2060]	@ 0x80c
 8000a4e:	2bff      	cmp	r3, #255	@ 0xff
 8000a50:	f77f aec4 	ble.w	80007dc <aes_gen_tables+0x1d0>
#endif /* !MBEDTLS_AES_FEWER_TABLES */
    }
}
 8000a54:	bf00      	nop
 8000a56:	bf00      	nop
 8000a58:	f607 0714 	addw	r7, r7, #2068	@ 0x814
 8000a5c:	46bd      	mov	sp, r7
 8000a5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a62:	4770      	bx	lr
 8000a64:	200012b4 	.word	0x200012b4
 8000a68:	200016b4 	.word	0x200016b4
 8000a6c:	20001ab4 	.word	0x20001ab4
 8000a70:	20001eb4 	.word	0x20001eb4

08000a74 <mbedtls_aes_init>:
#define AES_FT3(idx) FT3[idx]

#endif /* MBEDTLS_AES_FEWER_TABLES */

void mbedtls_aes_init( mbedtls_aes_context *ctx )
{
 8000a74:	b580      	push	{r7, lr}
 8000a76:	b082      	sub	sp, #8
 8000a78:	af00      	add	r7, sp, #0
 8000a7a:	6078      	str	r0, [r7, #4]
    AES_VALIDATE( ctx != NULL );

    memset( ctx, 0, sizeof( mbedtls_aes_context ) );
 8000a7c:	f44f 728c 	mov.w	r2, #280	@ 0x118
 8000a80:	2100      	movs	r1, #0
 8000a82:	6878      	ldr	r0, [r7, #4]
 8000a84:	f014 fce0 	bl	8015448 <memset>
}
 8000a88:	bf00      	nop
 8000a8a:	3708      	adds	r7, #8
 8000a8c:	46bd      	mov	sp, r7
 8000a8e:	bd80      	pop	{r7, pc}

08000a90 <mbedtls_aes_free>:

void mbedtls_aes_free( mbedtls_aes_context *ctx )
{
 8000a90:	b580      	push	{r7, lr}
 8000a92:	b082      	sub	sp, #8
 8000a94:	af00      	add	r7, sp, #0
 8000a96:	6078      	str	r0, [r7, #4]
    if( ctx == NULL )
 8000a98:	687b      	ldr	r3, [r7, #4]
 8000a9a:	2b00      	cmp	r3, #0
 8000a9c:	d005      	beq.n	8000aaa <mbedtls_aes_free+0x1a>
        return;

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_aes_context ) );
 8000a9e:	f44f 718c 	mov.w	r1, #280	@ 0x118
 8000aa2:	6878      	ldr	r0, [r7, #4]
 8000aa4:	f005 fb9c 	bl	80061e0 <mbedtls_platform_zeroize>
 8000aa8:	e000      	b.n	8000aac <mbedtls_aes_free+0x1c>
        return;
 8000aaa:	bf00      	nop
}
 8000aac:	3708      	adds	r7, #8
 8000aae:	46bd      	mov	sp, r7
 8000ab0:	bd80      	pop	{r7, pc}

08000ab2 <mbedtls_aes_xts_init>:

#if defined(MBEDTLS_CIPHER_MODE_XTS)
void mbedtls_aes_xts_init( mbedtls_aes_xts_context *ctx )
{
 8000ab2:	b580      	push	{r7, lr}
 8000ab4:	b082      	sub	sp, #8
 8000ab6:	af00      	add	r7, sp, #0
 8000ab8:	6078      	str	r0, [r7, #4]
    AES_VALIDATE( ctx != NULL );

    mbedtls_aes_init( &ctx->crypt );
 8000aba:	687b      	ldr	r3, [r7, #4]
 8000abc:	4618      	mov	r0, r3
 8000abe:	f7ff ffd9 	bl	8000a74 <mbedtls_aes_init>
    mbedtls_aes_init( &ctx->tweak );
 8000ac2:	687b      	ldr	r3, [r7, #4]
 8000ac4:	f503 738c 	add.w	r3, r3, #280	@ 0x118
 8000ac8:	4618      	mov	r0, r3
 8000aca:	f7ff ffd3 	bl	8000a74 <mbedtls_aes_init>
}
 8000ace:	bf00      	nop
 8000ad0:	3708      	adds	r7, #8
 8000ad2:	46bd      	mov	sp, r7
 8000ad4:	bd80      	pop	{r7, pc}

08000ad6 <mbedtls_aes_xts_free>:

void mbedtls_aes_xts_free( mbedtls_aes_xts_context *ctx )
{
 8000ad6:	b580      	push	{r7, lr}
 8000ad8:	b082      	sub	sp, #8
 8000ada:	af00      	add	r7, sp, #0
 8000adc:	6078      	str	r0, [r7, #4]
    if( ctx == NULL )
 8000ade:	687b      	ldr	r3, [r7, #4]
 8000ae0:	2b00      	cmp	r3, #0
 8000ae2:	d00a      	beq.n	8000afa <mbedtls_aes_xts_free+0x24>
        return;

    mbedtls_aes_free( &ctx->crypt );
 8000ae4:	687b      	ldr	r3, [r7, #4]
 8000ae6:	4618      	mov	r0, r3
 8000ae8:	f7ff ffd2 	bl	8000a90 <mbedtls_aes_free>
    mbedtls_aes_free( &ctx->tweak );
 8000aec:	687b      	ldr	r3, [r7, #4]
 8000aee:	f503 738c 	add.w	r3, r3, #280	@ 0x118
 8000af2:	4618      	mov	r0, r3
 8000af4:	f7ff ffcc 	bl	8000a90 <mbedtls_aes_free>
 8000af8:	e000      	b.n	8000afc <mbedtls_aes_xts_free+0x26>
        return;
 8000afa:	bf00      	nop
}
 8000afc:	3708      	adds	r7, #8
 8000afe:	46bd      	mov	sp, r7
 8000b00:	bd80      	pop	{r7, pc}
	...

08000b04 <mbedtls_aes_setkey_enc>:
 * AES key schedule (encryption)
 */
#if !defined(MBEDTLS_AES_SETKEY_ENC_ALT)
int mbedtls_aes_setkey_enc( mbedtls_aes_context *ctx, const unsigned char *key,
                    unsigned int keybits )
{
 8000b04:	b580      	push	{r7, lr}
 8000b06:	b086      	sub	sp, #24
 8000b08:	af00      	add	r7, sp, #0
 8000b0a:	60f8      	str	r0, [r7, #12]
 8000b0c:	60b9      	str	r1, [r7, #8]
 8000b0e:	607a      	str	r2, [r7, #4]
    uint32_t *RK;

    AES_VALIDATE_RET( ctx != NULL );
    AES_VALIDATE_RET( key != NULL );

    switch( keybits )
 8000b10:	687b      	ldr	r3, [r7, #4]
 8000b12:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8000b16:	d012      	beq.n	8000b3e <mbedtls_aes_setkey_enc+0x3a>
 8000b18:	687b      	ldr	r3, [r7, #4]
 8000b1a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8000b1e:	d812      	bhi.n	8000b46 <mbedtls_aes_setkey_enc+0x42>
 8000b20:	687b      	ldr	r3, [r7, #4]
 8000b22:	2b80      	cmp	r3, #128	@ 0x80
 8000b24:	d003      	beq.n	8000b2e <mbedtls_aes_setkey_enc+0x2a>
 8000b26:	687b      	ldr	r3, [r7, #4]
 8000b28:	2bc0      	cmp	r3, #192	@ 0xc0
 8000b2a:	d004      	beq.n	8000b36 <mbedtls_aes_setkey_enc+0x32>
 8000b2c:	e00b      	b.n	8000b46 <mbedtls_aes_setkey_enc+0x42>
    {
        case 128: ctx->nr = 10; break;
 8000b2e:	68fb      	ldr	r3, [r7, #12]
 8000b30:	220a      	movs	r2, #10
 8000b32:	601a      	str	r2, [r3, #0]
 8000b34:	e00a      	b.n	8000b4c <mbedtls_aes_setkey_enc+0x48>
        case 192: ctx->nr = 12; break;
 8000b36:	68fb      	ldr	r3, [r7, #12]
 8000b38:	220c      	movs	r2, #12
 8000b3a:	601a      	str	r2, [r3, #0]
 8000b3c:	e006      	b.n	8000b4c <mbedtls_aes_setkey_enc+0x48>
        case 256: ctx->nr = 14; break;
 8000b3e:	68fb      	ldr	r3, [r7, #12]
 8000b40:	220e      	movs	r2, #14
 8000b42:	601a      	str	r2, [r3, #0]
 8000b44:	e002      	b.n	8000b4c <mbedtls_aes_setkey_enc+0x48>
        default : return( MBEDTLS_ERR_AES_INVALID_KEY_LENGTH );
 8000b46:	f06f 031f 	mvn.w	r3, #31
 8000b4a:	e1b3      	b.n	8000eb4 <mbedtls_aes_setkey_enc+0x3b0>
    }

#if !defined(MBEDTLS_AES_ROM_TABLES)
    if( aes_init_done == 0 )
 8000b4c:	4b88      	ldr	r3, [pc, #544]	@ (8000d70 <mbedtls_aes_setkey_enc+0x26c>)
 8000b4e:	681b      	ldr	r3, [r3, #0]
 8000b50:	2b00      	cmp	r3, #0
 8000b52:	d104      	bne.n	8000b5e <mbedtls_aes_setkey_enc+0x5a>
    {
        aes_gen_tables();
 8000b54:	f7ff fd5a 	bl	800060c <aes_gen_tables>
        aes_init_done = 1;
 8000b58:	4b85      	ldr	r3, [pc, #532]	@ (8000d70 <mbedtls_aes_setkey_enc+0x26c>)
 8000b5a:	2201      	movs	r2, #1
 8000b5c:	601a      	str	r2, [r3, #0]

    if( aes_padlock_ace )
        ctx->rk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx->buf );
    else
#endif
    ctx->rk = RK = ctx->buf;
 8000b5e:	68fb      	ldr	r3, [r7, #12]
 8000b60:	3308      	adds	r3, #8
 8000b62:	613b      	str	r3, [r7, #16]
 8000b64:	68fb      	ldr	r3, [r7, #12]
 8000b66:	693a      	ldr	r2, [r7, #16]
 8000b68:	605a      	str	r2, [r3, #4]
#if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)
    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )
        return( mbedtls_aesni_setkey_enc( (unsigned char *) ctx->rk, key, keybits ) );
#endif

    for( i = 0; i < ( keybits >> 5 ); i++ )
 8000b6a:	2300      	movs	r3, #0
 8000b6c:	617b      	str	r3, [r7, #20]
 8000b6e:	e027      	b.n	8000bc0 <mbedtls_aes_setkey_enc+0xbc>
    {
        GET_UINT32_LE( RK[i], key, i << 2 );
 8000b70:	697b      	ldr	r3, [r7, #20]
 8000b72:	009b      	lsls	r3, r3, #2
 8000b74:	68ba      	ldr	r2, [r7, #8]
 8000b76:	4413      	add	r3, r2
 8000b78:	781b      	ldrb	r3, [r3, #0]
 8000b7a:	4619      	mov	r1, r3
 8000b7c:	697b      	ldr	r3, [r7, #20]
 8000b7e:	009b      	lsls	r3, r3, #2
 8000b80:	3301      	adds	r3, #1
 8000b82:	68ba      	ldr	r2, [r7, #8]
 8000b84:	4413      	add	r3, r2
 8000b86:	781b      	ldrb	r3, [r3, #0]
 8000b88:	021b      	lsls	r3, r3, #8
 8000b8a:	ea41 0203 	orr.w	r2, r1, r3
 8000b8e:	697b      	ldr	r3, [r7, #20]
 8000b90:	009b      	lsls	r3, r3, #2
 8000b92:	3302      	adds	r3, #2
 8000b94:	68b9      	ldr	r1, [r7, #8]
 8000b96:	440b      	add	r3, r1
 8000b98:	781b      	ldrb	r3, [r3, #0]
 8000b9a:	041b      	lsls	r3, r3, #16
 8000b9c:	ea42 0103 	orr.w	r1, r2, r3
 8000ba0:	697b      	ldr	r3, [r7, #20]
 8000ba2:	009b      	lsls	r3, r3, #2
 8000ba4:	3303      	adds	r3, #3
 8000ba6:	68ba      	ldr	r2, [r7, #8]
 8000ba8:	4413      	add	r3, r2
 8000baa:	781b      	ldrb	r3, [r3, #0]
 8000bac:	061a      	lsls	r2, r3, #24
 8000bae:	697b      	ldr	r3, [r7, #20]
 8000bb0:	009b      	lsls	r3, r3, #2
 8000bb2:	6938      	ldr	r0, [r7, #16]
 8000bb4:	4403      	add	r3, r0
 8000bb6:	430a      	orrs	r2, r1
 8000bb8:	601a      	str	r2, [r3, #0]
    for( i = 0; i < ( keybits >> 5 ); i++ )
 8000bba:	697b      	ldr	r3, [r7, #20]
 8000bbc:	3301      	adds	r3, #1
 8000bbe:	617b      	str	r3, [r7, #20]
 8000bc0:	687b      	ldr	r3, [r7, #4]
 8000bc2:	095b      	lsrs	r3, r3, #5
 8000bc4:	697a      	ldr	r2, [r7, #20]
 8000bc6:	429a      	cmp	r2, r3
 8000bc8:	d3d2      	bcc.n	8000b70 <mbedtls_aes_setkey_enc+0x6c>
    }

    switch( ctx->nr )
 8000bca:	68fb      	ldr	r3, [r7, #12]
 8000bcc:	681b      	ldr	r3, [r3, #0]
 8000bce:	2b0e      	cmp	r3, #14
 8000bd0:	f000 80ca 	beq.w	8000d68 <mbedtls_aes_setkey_enc+0x264>
 8000bd4:	2b0e      	cmp	r3, #14
 8000bd6:	f300 816c 	bgt.w	8000eb2 <mbedtls_aes_setkey_enc+0x3ae>
 8000bda:	2b0a      	cmp	r3, #10
 8000bdc:	d002      	beq.n	8000be4 <mbedtls_aes_setkey_enc+0xe0>
 8000bde:	2b0c      	cmp	r3, #12
 8000be0:	d057      	beq.n	8000c92 <mbedtls_aes_setkey_enc+0x18e>
 8000be2:	e166      	b.n	8000eb2 <mbedtls_aes_setkey_enc+0x3ae>
    {
        case 10:

            for( i = 0; i < 10; i++, RK += 4 )
 8000be4:	2300      	movs	r3, #0
 8000be6:	617b      	str	r3, [r7, #20]
 8000be8:	e04f      	b.n	8000c8a <mbedtls_aes_setkey_enc+0x186>
            {
                RK[4]  = RK[0] ^ RCON[i] ^
 8000bea:	693b      	ldr	r3, [r7, #16]
 8000bec:	681a      	ldr	r2, [r3, #0]
 8000bee:	4961      	ldr	r1, [pc, #388]	@ (8000d74 <mbedtls_aes_setkey_enc+0x270>)
 8000bf0:	697b      	ldr	r3, [r7, #20]
 8000bf2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8000bf6:	4053      	eors	r3, r2
                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
 8000bf8:	693a      	ldr	r2, [r7, #16]
 8000bfa:	320c      	adds	r2, #12
 8000bfc:	6812      	ldr	r2, [r2, #0]
 8000bfe:	0a12      	lsrs	r2, r2, #8
 8000c00:	b2d2      	uxtb	r2, r2
 8000c02:	495d      	ldr	r1, [pc, #372]	@ (8000d78 <mbedtls_aes_setkey_enc+0x274>)
 8000c04:	5c8a      	ldrb	r2, [r1, r2]
                RK[4]  = RK[0] ^ RCON[i] ^
 8000c06:	405a      	eors	r2, r3
                ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^
 8000c08:	693b      	ldr	r3, [r7, #16]
 8000c0a:	330c      	adds	r3, #12
 8000c0c:	681b      	ldr	r3, [r3, #0]
 8000c0e:	0c1b      	lsrs	r3, r3, #16
 8000c10:	b2db      	uxtb	r3, r3
 8000c12:	4959      	ldr	r1, [pc, #356]	@ (8000d78 <mbedtls_aes_setkey_enc+0x274>)
 8000c14:	5ccb      	ldrb	r3, [r1, r3]
 8000c16:	021b      	lsls	r3, r3, #8
                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
 8000c18:	405a      	eors	r2, r3
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
 8000c1a:	693b      	ldr	r3, [r7, #16]
 8000c1c:	330c      	adds	r3, #12
 8000c1e:	681b      	ldr	r3, [r3, #0]
 8000c20:	0e1b      	lsrs	r3, r3, #24
 8000c22:	4955      	ldr	r1, [pc, #340]	@ (8000d78 <mbedtls_aes_setkey_enc+0x274>)
 8000c24:	5ccb      	ldrb	r3, [r1, r3]
 8000c26:	041b      	lsls	r3, r3, #16
                ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^
 8000c28:	ea82 0103 	eor.w	r1, r2, r3
                ( (uint32_t) FSb[ ( RK[3]       ) & 0xFF ] << 24 );
 8000c2c:	693b      	ldr	r3, [r7, #16]
 8000c2e:	330c      	adds	r3, #12
 8000c30:	681b      	ldr	r3, [r3, #0]
 8000c32:	b2db      	uxtb	r3, r3
 8000c34:	4a50      	ldr	r2, [pc, #320]	@ (8000d78 <mbedtls_aes_setkey_enc+0x274>)
 8000c36:	5cd3      	ldrb	r3, [r2, r3]
 8000c38:	061a      	lsls	r2, r3, #24
                RK[4]  = RK[0] ^ RCON[i] ^
 8000c3a:	693b      	ldr	r3, [r7, #16]
 8000c3c:	3310      	adds	r3, #16
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
 8000c3e:	404a      	eors	r2, r1
                RK[4]  = RK[0] ^ RCON[i] ^
 8000c40:	601a      	str	r2, [r3, #0]

                RK[5]  = RK[1] ^ RK[4];
 8000c42:	693b      	ldr	r3, [r7, #16]
 8000c44:	3304      	adds	r3, #4
 8000c46:	6819      	ldr	r1, [r3, #0]
 8000c48:	693b      	ldr	r3, [r7, #16]
 8000c4a:	3310      	adds	r3, #16
 8000c4c:	681a      	ldr	r2, [r3, #0]
 8000c4e:	693b      	ldr	r3, [r7, #16]
 8000c50:	3314      	adds	r3, #20
 8000c52:	404a      	eors	r2, r1
 8000c54:	601a      	str	r2, [r3, #0]
                RK[6]  = RK[2] ^ RK[5];
 8000c56:	693b      	ldr	r3, [r7, #16]
 8000c58:	3308      	adds	r3, #8
 8000c5a:	6819      	ldr	r1, [r3, #0]
 8000c5c:	693b      	ldr	r3, [r7, #16]
 8000c5e:	3314      	adds	r3, #20
 8000c60:	681a      	ldr	r2, [r3, #0]
 8000c62:	693b      	ldr	r3, [r7, #16]
 8000c64:	3318      	adds	r3, #24
 8000c66:	404a      	eors	r2, r1
 8000c68:	601a      	str	r2, [r3, #0]
                RK[7]  = RK[3] ^ RK[6];
 8000c6a:	693b      	ldr	r3, [r7, #16]
 8000c6c:	330c      	adds	r3, #12
 8000c6e:	6819      	ldr	r1, [r3, #0]
 8000c70:	693b      	ldr	r3, [r7, #16]
 8000c72:	3318      	adds	r3, #24
 8000c74:	681a      	ldr	r2, [r3, #0]
 8000c76:	693b      	ldr	r3, [r7, #16]
 8000c78:	331c      	adds	r3, #28
 8000c7a:	404a      	eors	r2, r1
 8000c7c:	601a      	str	r2, [r3, #0]
            for( i = 0; i < 10; i++, RK += 4 )
 8000c7e:	697b      	ldr	r3, [r7, #20]
 8000c80:	3301      	adds	r3, #1
 8000c82:	617b      	str	r3, [r7, #20]
 8000c84:	693b      	ldr	r3, [r7, #16]
 8000c86:	3310      	adds	r3, #16
 8000c88:	613b      	str	r3, [r7, #16]
 8000c8a:	697b      	ldr	r3, [r7, #20]
 8000c8c:	2b09      	cmp	r3, #9
 8000c8e:	d9ac      	bls.n	8000bea <mbedtls_aes_setkey_enc+0xe6>
            }
            break;
 8000c90:	e10f      	b.n	8000eb2 <mbedtls_aes_setkey_enc+0x3ae>

        case 12:

            for( i = 0; i < 8; i++, RK += 6 )
 8000c92:	2300      	movs	r3, #0
 8000c94:	617b      	str	r3, [r7, #20]
 8000c96:	e063      	b.n	8000d60 <mbedtls_aes_setkey_enc+0x25c>
            {
                RK[6]  = RK[0] ^ RCON[i] ^
 8000c98:	693b      	ldr	r3, [r7, #16]
 8000c9a:	681a      	ldr	r2, [r3, #0]
 8000c9c:	4935      	ldr	r1, [pc, #212]	@ (8000d74 <mbedtls_aes_setkey_enc+0x270>)
 8000c9e:	697b      	ldr	r3, [r7, #20]
 8000ca0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8000ca4:	4053      	eors	r3, r2
                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
 8000ca6:	693a      	ldr	r2, [r7, #16]
 8000ca8:	3214      	adds	r2, #20
 8000caa:	6812      	ldr	r2, [r2, #0]
 8000cac:	0a12      	lsrs	r2, r2, #8
 8000cae:	b2d2      	uxtb	r2, r2
 8000cb0:	4931      	ldr	r1, [pc, #196]	@ (8000d78 <mbedtls_aes_setkey_enc+0x274>)
 8000cb2:	5c8a      	ldrb	r2, [r1, r2]
                RK[6]  = RK[0] ^ RCON[i] ^
 8000cb4:	405a      	eors	r2, r3
                ( (uint32_t) FSb[ ( RK[5] >> 16 ) & 0xFF ] <<  8 ) ^
 8000cb6:	693b      	ldr	r3, [r7, #16]
 8000cb8:	3314      	adds	r3, #20
 8000cba:	681b      	ldr	r3, [r3, #0]
 8000cbc:	0c1b      	lsrs	r3, r3, #16
 8000cbe:	b2db      	uxtb	r3, r3
 8000cc0:	492d      	ldr	r1, [pc, #180]	@ (8000d78 <mbedtls_aes_setkey_enc+0x274>)
 8000cc2:	5ccb      	ldrb	r3, [r1, r3]
 8000cc4:	021b      	lsls	r3, r3, #8
                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
 8000cc6:	405a      	eors	r2, r3
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
 8000cc8:	693b      	ldr	r3, [r7, #16]
 8000cca:	3314      	adds	r3, #20
 8000ccc:	681b      	ldr	r3, [r3, #0]
 8000cce:	0e1b      	lsrs	r3, r3, #24
 8000cd0:	4929      	ldr	r1, [pc, #164]	@ (8000d78 <mbedtls_aes_setkey_enc+0x274>)
 8000cd2:	5ccb      	ldrb	r3, [r1, r3]
 8000cd4:	041b      	lsls	r3, r3, #16
                ( (uint32_t) FSb[ ( RK[5] >> 16 ) & 0xFF ] <<  8 ) ^
 8000cd6:	ea82 0103 	eor.w	r1, r2, r3
                ( (uint32_t) FSb[ ( RK[5]       ) & 0xFF ] << 24 );
 8000cda:	693b      	ldr	r3, [r7, #16]
 8000cdc:	3314      	adds	r3, #20
 8000cde:	681b      	ldr	r3, [r3, #0]
 8000ce0:	b2db      	uxtb	r3, r3
 8000ce2:	4a25      	ldr	r2, [pc, #148]	@ (8000d78 <mbedtls_aes_setkey_enc+0x274>)
 8000ce4:	5cd3      	ldrb	r3, [r2, r3]
 8000ce6:	061a      	lsls	r2, r3, #24
                RK[6]  = RK[0] ^ RCON[i] ^
 8000ce8:	693b      	ldr	r3, [r7, #16]
 8000cea:	3318      	adds	r3, #24
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
 8000cec:	404a      	eors	r2, r1
                RK[6]  = RK[0] ^ RCON[i] ^
 8000cee:	601a      	str	r2, [r3, #0]

                RK[7]  = RK[1] ^ RK[6];
 8000cf0:	693b      	ldr	r3, [r7, #16]
 8000cf2:	3304      	adds	r3, #4
 8000cf4:	6819      	ldr	r1, [r3, #0]
 8000cf6:	693b      	ldr	r3, [r7, #16]
 8000cf8:	3318      	adds	r3, #24
 8000cfa:	681a      	ldr	r2, [r3, #0]
 8000cfc:	693b      	ldr	r3, [r7, #16]
 8000cfe:	331c      	adds	r3, #28
 8000d00:	404a      	eors	r2, r1
 8000d02:	601a      	str	r2, [r3, #0]
                RK[8]  = RK[2] ^ RK[7];
 8000d04:	693b      	ldr	r3, [r7, #16]
 8000d06:	3308      	adds	r3, #8
 8000d08:	6819      	ldr	r1, [r3, #0]
 8000d0a:	693b      	ldr	r3, [r7, #16]
 8000d0c:	331c      	adds	r3, #28
 8000d0e:	681a      	ldr	r2, [r3, #0]
 8000d10:	693b      	ldr	r3, [r7, #16]
 8000d12:	3320      	adds	r3, #32
 8000d14:	404a      	eors	r2, r1
 8000d16:	601a      	str	r2, [r3, #0]
                RK[9]  = RK[3] ^ RK[8];
 8000d18:	693b      	ldr	r3, [r7, #16]
 8000d1a:	330c      	adds	r3, #12
 8000d1c:	6819      	ldr	r1, [r3, #0]
 8000d1e:	693b      	ldr	r3, [r7, #16]
 8000d20:	3320      	adds	r3, #32
 8000d22:	681a      	ldr	r2, [r3, #0]
 8000d24:	693b      	ldr	r3, [r7, #16]
 8000d26:	3324      	adds	r3, #36	@ 0x24
 8000d28:	404a      	eors	r2, r1
 8000d2a:	601a      	str	r2, [r3, #0]
                RK[10] = RK[4] ^ RK[9];
 8000d2c:	693b      	ldr	r3, [r7, #16]
 8000d2e:	3310      	adds	r3, #16
 8000d30:	6819      	ldr	r1, [r3, #0]
 8000d32:	693b      	ldr	r3, [r7, #16]
 8000d34:	3324      	adds	r3, #36	@ 0x24
 8000d36:	681a      	ldr	r2, [r3, #0]
 8000d38:	693b      	ldr	r3, [r7, #16]
 8000d3a:	3328      	adds	r3, #40	@ 0x28
 8000d3c:	404a      	eors	r2, r1
 8000d3e:	601a      	str	r2, [r3, #0]
                RK[11] = RK[5] ^ RK[10];
 8000d40:	693b      	ldr	r3, [r7, #16]
 8000d42:	3314      	adds	r3, #20
 8000d44:	6819      	ldr	r1, [r3, #0]
 8000d46:	693b      	ldr	r3, [r7, #16]
 8000d48:	3328      	adds	r3, #40	@ 0x28
 8000d4a:	681a      	ldr	r2, [r3, #0]
 8000d4c:	693b      	ldr	r3, [r7, #16]
 8000d4e:	332c      	adds	r3, #44	@ 0x2c
 8000d50:	404a      	eors	r2, r1
 8000d52:	601a      	str	r2, [r3, #0]
            for( i = 0; i < 8; i++, RK += 6 )
 8000d54:	697b      	ldr	r3, [r7, #20]
 8000d56:	3301      	adds	r3, #1
 8000d58:	617b      	str	r3, [r7, #20]
 8000d5a:	693b      	ldr	r3, [r7, #16]
 8000d5c:	3318      	adds	r3, #24
 8000d5e:	613b      	str	r3, [r7, #16]
 8000d60:	697b      	ldr	r3, [r7, #20]
 8000d62:	2b07      	cmp	r3, #7
 8000d64:	d998      	bls.n	8000c98 <mbedtls_aes_setkey_enc+0x194>
            }
            break;
 8000d66:	e0a4      	b.n	8000eb2 <mbedtls_aes_setkey_enc+0x3ae>

        case 14:

            for( i = 0; i < 7; i++, RK += 8 )
 8000d68:	2300      	movs	r3, #0
 8000d6a:	617b      	str	r3, [r7, #20]
 8000d6c:	e09c      	b.n	8000ea8 <mbedtls_aes_setkey_enc+0x3a4>
 8000d6e:	bf00      	nop
 8000d70:	200022dc 	.word	0x200022dc
 8000d74:	200022b4 	.word	0x200022b4
 8000d78:	200000b4 	.word	0x200000b4
            {
                RK[8]  = RK[0] ^ RCON[i] ^
 8000d7c:	693b      	ldr	r3, [r7, #16]
 8000d7e:	681a      	ldr	r2, [r3, #0]
 8000d80:	494e      	ldr	r1, [pc, #312]	@ (8000ebc <mbedtls_aes_setkey_enc+0x3b8>)
 8000d82:	697b      	ldr	r3, [r7, #20]
 8000d84:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8000d88:	4053      	eors	r3, r2
                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
 8000d8a:	693a      	ldr	r2, [r7, #16]
 8000d8c:	321c      	adds	r2, #28
 8000d8e:	6812      	ldr	r2, [r2, #0]
 8000d90:	0a12      	lsrs	r2, r2, #8
 8000d92:	b2d2      	uxtb	r2, r2
 8000d94:	494a      	ldr	r1, [pc, #296]	@ (8000ec0 <mbedtls_aes_setkey_enc+0x3bc>)
 8000d96:	5c8a      	ldrb	r2, [r1, r2]
                RK[8]  = RK[0] ^ RCON[i] ^
 8000d98:	405a      	eors	r2, r3
                ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^
 8000d9a:	693b      	ldr	r3, [r7, #16]
 8000d9c:	331c      	adds	r3, #28
 8000d9e:	681b      	ldr	r3, [r3, #0]
 8000da0:	0c1b      	lsrs	r3, r3, #16
 8000da2:	b2db      	uxtb	r3, r3
 8000da4:	4946      	ldr	r1, [pc, #280]	@ (8000ec0 <mbedtls_aes_setkey_enc+0x3bc>)
 8000da6:	5ccb      	ldrb	r3, [r1, r3]
 8000da8:	021b      	lsls	r3, r3, #8
                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
 8000daa:	405a      	eors	r2, r3
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
 8000dac:	693b      	ldr	r3, [r7, #16]
 8000dae:	331c      	adds	r3, #28
 8000db0:	681b      	ldr	r3, [r3, #0]
 8000db2:	0e1b      	lsrs	r3, r3, #24
 8000db4:	4942      	ldr	r1, [pc, #264]	@ (8000ec0 <mbedtls_aes_setkey_enc+0x3bc>)
 8000db6:	5ccb      	ldrb	r3, [r1, r3]
 8000db8:	041b      	lsls	r3, r3, #16
                ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^
 8000dba:	ea82 0103 	eor.w	r1, r2, r3
                ( (uint32_t) FSb[ ( RK[7]       ) & 0xFF ] << 24 );
 8000dbe:	693b      	ldr	r3, [r7, #16]
 8000dc0:	331c      	adds	r3, #28
 8000dc2:	681b      	ldr	r3, [r3, #0]
 8000dc4:	b2db      	uxtb	r3, r3
 8000dc6:	4a3e      	ldr	r2, [pc, #248]	@ (8000ec0 <mbedtls_aes_setkey_enc+0x3bc>)
 8000dc8:	5cd3      	ldrb	r3, [r2, r3]
 8000dca:	061a      	lsls	r2, r3, #24
                RK[8]  = RK[0] ^ RCON[i] ^
 8000dcc:	693b      	ldr	r3, [r7, #16]
 8000dce:	3320      	adds	r3, #32
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
 8000dd0:	404a      	eors	r2, r1
                RK[8]  = RK[0] ^ RCON[i] ^
 8000dd2:	601a      	str	r2, [r3, #0]

                RK[9]  = RK[1] ^ RK[8];
 8000dd4:	693b      	ldr	r3, [r7, #16]
 8000dd6:	3304      	adds	r3, #4
 8000dd8:	6819      	ldr	r1, [r3, #0]
 8000dda:	693b      	ldr	r3, [r7, #16]
 8000ddc:	3320      	adds	r3, #32
 8000dde:	681a      	ldr	r2, [r3, #0]
 8000de0:	693b      	ldr	r3, [r7, #16]
 8000de2:	3324      	adds	r3, #36	@ 0x24
 8000de4:	404a      	eors	r2, r1
 8000de6:	601a      	str	r2, [r3, #0]
                RK[10] = RK[2] ^ RK[9];
 8000de8:	693b      	ldr	r3, [r7, #16]
 8000dea:	3308      	adds	r3, #8
 8000dec:	6819      	ldr	r1, [r3, #0]
 8000dee:	693b      	ldr	r3, [r7, #16]
 8000df0:	3324      	adds	r3, #36	@ 0x24
 8000df2:	681a      	ldr	r2, [r3, #0]
 8000df4:	693b      	ldr	r3, [r7, #16]
 8000df6:	3328      	adds	r3, #40	@ 0x28
 8000df8:	404a      	eors	r2, r1
 8000dfa:	601a      	str	r2, [r3, #0]
                RK[11] = RK[3] ^ RK[10];
 8000dfc:	693b      	ldr	r3, [r7, #16]
 8000dfe:	330c      	adds	r3, #12
 8000e00:	6819      	ldr	r1, [r3, #0]
 8000e02:	693b      	ldr	r3, [r7, #16]
 8000e04:	3328      	adds	r3, #40	@ 0x28
 8000e06:	681a      	ldr	r2, [r3, #0]
 8000e08:	693b      	ldr	r3, [r7, #16]
 8000e0a:	332c      	adds	r3, #44	@ 0x2c
 8000e0c:	404a      	eors	r2, r1
 8000e0e:	601a      	str	r2, [r3, #0]

                RK[12] = RK[4] ^
 8000e10:	693b      	ldr	r3, [r7, #16]
 8000e12:	3310      	adds	r3, #16
 8000e14:	681b      	ldr	r3, [r3, #0]
                ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^
 8000e16:	693a      	ldr	r2, [r7, #16]
 8000e18:	322c      	adds	r2, #44	@ 0x2c
 8000e1a:	6812      	ldr	r2, [r2, #0]
 8000e1c:	b2d2      	uxtb	r2, r2
 8000e1e:	4928      	ldr	r1, [pc, #160]	@ (8000ec0 <mbedtls_aes_setkey_enc+0x3bc>)
 8000e20:	5c8a      	ldrb	r2, [r1, r2]
                RK[12] = RK[4] ^
 8000e22:	405a      	eors	r2, r3
                ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^
 8000e24:	693b      	ldr	r3, [r7, #16]
 8000e26:	332c      	adds	r3, #44	@ 0x2c
 8000e28:	681b      	ldr	r3, [r3, #0]
 8000e2a:	0a1b      	lsrs	r3, r3, #8
 8000e2c:	b2db      	uxtb	r3, r3
 8000e2e:	4924      	ldr	r1, [pc, #144]	@ (8000ec0 <mbedtls_aes_setkey_enc+0x3bc>)
 8000e30:	5ccb      	ldrb	r3, [r1, r3]
 8000e32:	021b      	lsls	r3, r3, #8
                ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^
 8000e34:	405a      	eors	r2, r3
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
 8000e36:	693b      	ldr	r3, [r7, #16]
 8000e38:	332c      	adds	r3, #44	@ 0x2c
 8000e3a:	681b      	ldr	r3, [r3, #0]
 8000e3c:	0c1b      	lsrs	r3, r3, #16
 8000e3e:	b2db      	uxtb	r3, r3
 8000e40:	491f      	ldr	r1, [pc, #124]	@ (8000ec0 <mbedtls_aes_setkey_enc+0x3bc>)
 8000e42:	5ccb      	ldrb	r3, [r1, r3]
 8000e44:	041b      	lsls	r3, r3, #16
                ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^
 8000e46:	ea82 0103 	eor.w	r1, r2, r3
                ( (uint32_t) FSb[ ( RK[11] >> 24 ) & 0xFF ] << 24 );
 8000e4a:	693b      	ldr	r3, [r7, #16]
 8000e4c:	332c      	adds	r3, #44	@ 0x2c
 8000e4e:	681b      	ldr	r3, [r3, #0]
 8000e50:	0e1b      	lsrs	r3, r3, #24
 8000e52:	4a1b      	ldr	r2, [pc, #108]	@ (8000ec0 <mbedtls_aes_setkey_enc+0x3bc>)
 8000e54:	5cd3      	ldrb	r3, [r2, r3]
 8000e56:	061a      	lsls	r2, r3, #24
                RK[12] = RK[4] ^
 8000e58:	693b      	ldr	r3, [r7, #16]
 8000e5a:	3330      	adds	r3, #48	@ 0x30
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
 8000e5c:	404a      	eors	r2, r1
                RK[12] = RK[4] ^
 8000e5e:	601a      	str	r2, [r3, #0]

                RK[13] = RK[5] ^ RK[12];
 8000e60:	693b      	ldr	r3, [r7, #16]
 8000e62:	3314      	adds	r3, #20
 8000e64:	6819      	ldr	r1, [r3, #0]
 8000e66:	693b      	ldr	r3, [r7, #16]
 8000e68:	3330      	adds	r3, #48	@ 0x30
 8000e6a:	681a      	ldr	r2, [r3, #0]
 8000e6c:	693b      	ldr	r3, [r7, #16]
 8000e6e:	3334      	adds	r3, #52	@ 0x34
 8000e70:	404a      	eors	r2, r1
 8000e72:	601a      	str	r2, [r3, #0]
                RK[14] = RK[6] ^ RK[13];
 8000e74:	693b      	ldr	r3, [r7, #16]
 8000e76:	3318      	adds	r3, #24
 8000e78:	6819      	ldr	r1, [r3, #0]
 8000e7a:	693b      	ldr	r3, [r7, #16]
 8000e7c:	3334      	adds	r3, #52	@ 0x34
 8000e7e:	681a      	ldr	r2, [r3, #0]
 8000e80:	693b      	ldr	r3, [r7, #16]
 8000e82:	3338      	adds	r3, #56	@ 0x38
 8000e84:	404a      	eors	r2, r1
 8000e86:	601a      	str	r2, [r3, #0]
                RK[15] = RK[7] ^ RK[14];
 8000e88:	693b      	ldr	r3, [r7, #16]
 8000e8a:	331c      	adds	r3, #28
 8000e8c:	6819      	ldr	r1, [r3, #0]
 8000e8e:	693b      	ldr	r3, [r7, #16]
 8000e90:	3338      	adds	r3, #56	@ 0x38
 8000e92:	681a      	ldr	r2, [r3, #0]
 8000e94:	693b      	ldr	r3, [r7, #16]
 8000e96:	333c      	adds	r3, #60	@ 0x3c
 8000e98:	404a      	eors	r2, r1
 8000e9a:	601a      	str	r2, [r3, #0]
            for( i = 0; i < 7; i++, RK += 8 )
 8000e9c:	697b      	ldr	r3, [r7, #20]
 8000e9e:	3301      	adds	r3, #1
 8000ea0:	617b      	str	r3, [r7, #20]
 8000ea2:	693b      	ldr	r3, [r7, #16]
 8000ea4:	3320      	adds	r3, #32
 8000ea6:	613b      	str	r3, [r7, #16]
 8000ea8:	697b      	ldr	r3, [r7, #20]
 8000eaa:	2b06      	cmp	r3, #6
 8000eac:	f67f af66 	bls.w	8000d7c <mbedtls_aes_setkey_enc+0x278>
            }
            break;
 8000eb0:	bf00      	nop
    }

    return( 0 );
 8000eb2:	2300      	movs	r3, #0
}
 8000eb4:	4618      	mov	r0, r3
 8000eb6:	3718      	adds	r7, #24
 8000eb8:	46bd      	mov	sp, r7
 8000eba:	bd80      	pop	{r7, pc}
 8000ebc:	200022b4 	.word	0x200022b4
 8000ec0:	200000b4 	.word	0x200000b4

08000ec4 <mbedtls_aes_setkey_dec>:
 * AES key schedule (decryption)
 */
#if !defined(MBEDTLS_AES_SETKEY_DEC_ALT)
int mbedtls_aes_setkey_dec( mbedtls_aes_context *ctx, const unsigned char *key,
                    unsigned int keybits )
{
 8000ec4:	b580      	push	{r7, lr}
 8000ec6:	b0d0      	sub	sp, #320	@ 0x140
 8000ec8:	af00      	add	r7, sp, #0
 8000eca:	f507 73a0 	add.w	r3, r7, #320	@ 0x140
 8000ece:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
 8000ed2:	6018      	str	r0, [r3, #0]
 8000ed4:	f507 73a0 	add.w	r3, r7, #320	@ 0x140
 8000ed8:	f5a3 739c 	sub.w	r3, r3, #312	@ 0x138
 8000edc:	6019      	str	r1, [r3, #0]
 8000ede:	f507 73a0 	add.w	r3, r7, #320	@ 0x140
 8000ee2:	f5a3 739e 	sub.w	r3, r3, #316	@ 0x13c
 8000ee6:	601a      	str	r2, [r3, #0]
    uint32_t *SK;

    AES_VALIDATE_RET( ctx != NULL );
    AES_VALIDATE_RET( key != NULL );

    mbedtls_aes_init( &cty );
 8000ee8:	f107 0314 	add.w	r3, r7, #20
 8000eec:	4618      	mov	r0, r3
 8000eee:	f7ff fdc1 	bl	8000a74 <mbedtls_aes_init>

    if( aes_padlock_ace )
        ctx->rk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx->buf );
    else
#endif
    ctx->rk = RK = ctx->buf;
 8000ef2:	f507 73a0 	add.w	r3, r7, #320	@ 0x140
 8000ef6:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
 8000efa:	681b      	ldr	r3, [r3, #0]
 8000efc:	3308      	adds	r3, #8
 8000efe:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
 8000f02:	f507 73a0 	add.w	r3, r7, #320	@ 0x140
 8000f06:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
 8000f0a:	681b      	ldr	r3, [r3, #0]
 8000f0c:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8000f10:	605a      	str	r2, [r3, #4]

    /* Also checks keybits */
    if( ( ret = mbedtls_aes_setkey_enc( &cty, key, keybits ) ) != 0 )
 8000f12:	f507 73a0 	add.w	r3, r7, #320	@ 0x140
 8000f16:	f5a3 729e 	sub.w	r2, r3, #316	@ 0x13c
 8000f1a:	f507 73a0 	add.w	r3, r7, #320	@ 0x140
 8000f1e:	f5a3 739c 	sub.w	r3, r3, #312	@ 0x138
 8000f22:	f107 0014 	add.w	r0, r7, #20
 8000f26:	6812      	ldr	r2, [r2, #0]
 8000f28:	6819      	ldr	r1, [r3, #0]
 8000f2a:	f7ff fdeb 	bl	8000b04 <mbedtls_aes_setkey_enc>
 8000f2e:	f8c7 012c 	str.w	r0, [r7, #300]	@ 0x12c
 8000f32:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8000f36:	2b00      	cmp	r3, #0
 8000f38:	f040 80dd 	bne.w	80010f6 <mbedtls_aes_setkey_dec+0x232>
        goto exit;

    ctx->nr = cty.nr;
 8000f3c:	f507 73a0 	add.w	r3, r7, #320	@ 0x140
 8000f40:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8000f44:	681a      	ldr	r2, [r3, #0]
 8000f46:	f507 73a0 	add.w	r3, r7, #320	@ 0x140
 8000f4a:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
 8000f4e:	681b      	ldr	r3, [r3, #0]
 8000f50:	601a      	str	r2, [r3, #0]
                           (const unsigned char *) cty.rk, ctx->nr );
        goto exit;
    }
#endif

    SK = cty.rk + cty.nr * 4;
 8000f52:	f507 73a0 	add.w	r3, r7, #320	@ 0x140
 8000f56:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8000f5a:	685a      	ldr	r2, [r3, #4]
 8000f5c:	f507 73a0 	add.w	r3, r7, #320	@ 0x140
 8000f60:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8000f64:	681b      	ldr	r3, [r3, #0]
 8000f66:	011b      	lsls	r3, r3, #4
 8000f68:	4413      	add	r3, r2
 8000f6a:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130

    *RK++ = *SK++;
 8000f6e:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 8000f72:	1d13      	adds	r3, r2, #4
 8000f74:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 8000f78:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8000f7c:	1d19      	adds	r1, r3, #4
 8000f7e:	f8c7 1134 	str.w	r1, [r7, #308]	@ 0x134
 8000f82:	6812      	ldr	r2, [r2, #0]
 8000f84:	601a      	str	r2, [r3, #0]
    *RK++ = *SK++;
 8000f86:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 8000f8a:	1d13      	adds	r3, r2, #4
 8000f8c:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 8000f90:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8000f94:	1d19      	adds	r1, r3, #4
 8000f96:	f8c7 1134 	str.w	r1, [r7, #308]	@ 0x134
 8000f9a:	6812      	ldr	r2, [r2, #0]
 8000f9c:	601a      	str	r2, [r3, #0]
    *RK++ = *SK++;
 8000f9e:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 8000fa2:	1d13      	adds	r3, r2, #4
 8000fa4:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 8000fa8:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8000fac:	1d19      	adds	r1, r3, #4
 8000fae:	f8c7 1134 	str.w	r1, [r7, #308]	@ 0x134
 8000fb2:	6812      	ldr	r2, [r2, #0]
 8000fb4:	601a      	str	r2, [r3, #0]
    *RK++ = *SK++;
 8000fb6:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 8000fba:	1d13      	adds	r3, r2, #4
 8000fbc:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 8000fc0:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8000fc4:	1d19      	adds	r1, r3, #4
 8000fc6:	f8c7 1134 	str.w	r1, [r7, #308]	@ 0x134
 8000fca:	6812      	ldr	r2, [r2, #0]
 8000fcc:	601a      	str	r2, [r3, #0]

    for( i = ctx->nr - 1, SK -= 8; i > 0; i--, SK -= 8 )
 8000fce:	f507 73a0 	add.w	r3, r7, #320	@ 0x140
 8000fd2:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
 8000fd6:	681b      	ldr	r3, [r3, #0]
 8000fd8:	681b      	ldr	r3, [r3, #0]
 8000fda:	3b01      	subs	r3, #1
 8000fdc:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
 8000fe0:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8000fe4:	3b20      	subs	r3, #32
 8000fe6:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 8000fea:	e04f      	b.n	800108c <mbedtls_aes_setkey_dec+0x1c8>
    {
        for( j = 0; j < 4; j++, SK++ )
 8000fec:	2300      	movs	r3, #0
 8000fee:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
 8000ff2:	e03d      	b.n	8001070 <mbedtls_aes_setkey_dec+0x1ac>
        {
            *RK++ = AES_RT0( FSb[ ( *SK       ) & 0xFF ] ) ^
 8000ff4:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8000ff8:	681b      	ldr	r3, [r3, #0]
 8000ffa:	b2db      	uxtb	r3, r3
 8000ffc:	4a44      	ldr	r2, [pc, #272]	@ (8001110 <mbedtls_aes_setkey_dec+0x24c>)
 8000ffe:	5cd3      	ldrb	r3, [r2, r3]
 8001000:	461a      	mov	r2, r3
 8001002:	4b44      	ldr	r3, [pc, #272]	@ (8001114 <mbedtls_aes_setkey_dec+0x250>)
 8001004:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
                    AES_RT1( FSb[ ( *SK >>  8 ) & 0xFF ] ) ^
 8001008:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 800100c:	681b      	ldr	r3, [r3, #0]
 800100e:	0a1b      	lsrs	r3, r3, #8
 8001010:	b2db      	uxtb	r3, r3
 8001012:	493f      	ldr	r1, [pc, #252]	@ (8001110 <mbedtls_aes_setkey_dec+0x24c>)
 8001014:	5ccb      	ldrb	r3, [r1, r3]
 8001016:	4619      	mov	r1, r3
 8001018:	4b3f      	ldr	r3, [pc, #252]	@ (8001118 <mbedtls_aes_setkey_dec+0x254>)
 800101a:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
            *RK++ = AES_RT0( FSb[ ( *SK       ) & 0xFF ] ) ^
 800101e:	405a      	eors	r2, r3
                    AES_RT2( FSb[ ( *SK >> 16 ) & 0xFF ] ) ^
 8001020:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8001024:	681b      	ldr	r3, [r3, #0]
 8001026:	0c1b      	lsrs	r3, r3, #16
 8001028:	b2db      	uxtb	r3, r3
 800102a:	4939      	ldr	r1, [pc, #228]	@ (8001110 <mbedtls_aes_setkey_dec+0x24c>)
 800102c:	5ccb      	ldrb	r3, [r1, r3]
 800102e:	4619      	mov	r1, r3
 8001030:	4b3a      	ldr	r3, [pc, #232]	@ (800111c <mbedtls_aes_setkey_dec+0x258>)
 8001032:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
                    AES_RT1( FSb[ ( *SK >>  8 ) & 0xFF ] ) ^
 8001036:	ea82 0103 	eor.w	r1, r2, r3
                    AES_RT3( FSb[ ( *SK >> 24 ) & 0xFF ] );
 800103a:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 800103e:	681b      	ldr	r3, [r3, #0]
 8001040:	0e1b      	lsrs	r3, r3, #24
 8001042:	4a33      	ldr	r2, [pc, #204]	@ (8001110 <mbedtls_aes_setkey_dec+0x24c>)
 8001044:	5cd3      	ldrb	r3, [r2, r3]
 8001046:	461a      	mov	r2, r3
 8001048:	4b35      	ldr	r3, [pc, #212]	@ (8001120 <mbedtls_aes_setkey_dec+0x25c>)
 800104a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
            *RK++ = AES_RT0( FSb[ ( *SK       ) & 0xFF ] ) ^
 800104e:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8001052:	1d18      	adds	r0, r3, #4
 8001054:	f8c7 0134 	str.w	r0, [r7, #308]	@ 0x134
                    AES_RT2( FSb[ ( *SK >> 16 ) & 0xFF ] ) ^
 8001058:	404a      	eors	r2, r1
            *RK++ = AES_RT0( FSb[ ( *SK       ) & 0xFF ] ) ^
 800105a:	601a      	str	r2, [r3, #0]
        for( j = 0; j < 4; j++, SK++ )
 800105c:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8001060:	3301      	adds	r3, #1
 8001062:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
 8001066:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 800106a:	3304      	adds	r3, #4
 800106c:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 8001070:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8001074:	2b03      	cmp	r3, #3
 8001076:	ddbd      	ble.n	8000ff4 <mbedtls_aes_setkey_dec+0x130>
    for( i = ctx->nr - 1, SK -= 8; i > 0; i--, SK -= 8 )
 8001078:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 800107c:	3b01      	subs	r3, #1
 800107e:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
 8001082:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8001086:	3b20      	subs	r3, #32
 8001088:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 800108c:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8001090:	2b00      	cmp	r3, #0
 8001092:	dcab      	bgt.n	8000fec <mbedtls_aes_setkey_dec+0x128>
        }
    }

    *RK++ = *SK++;
 8001094:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 8001098:	1d13      	adds	r3, r2, #4
 800109a:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 800109e:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80010a2:	1d19      	adds	r1, r3, #4
 80010a4:	f8c7 1134 	str.w	r1, [r7, #308]	@ 0x134
 80010a8:	6812      	ldr	r2, [r2, #0]
 80010aa:	601a      	str	r2, [r3, #0]
    *RK++ = *SK++;
 80010ac:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 80010b0:	1d13      	adds	r3, r2, #4
 80010b2:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 80010b6:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80010ba:	1d19      	adds	r1, r3, #4
 80010bc:	f8c7 1134 	str.w	r1, [r7, #308]	@ 0x134
 80010c0:	6812      	ldr	r2, [r2, #0]
 80010c2:	601a      	str	r2, [r3, #0]
    *RK++ = *SK++;
 80010c4:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 80010c8:	1d13      	adds	r3, r2, #4
 80010ca:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 80010ce:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80010d2:	1d19      	adds	r1, r3, #4
 80010d4:	f8c7 1134 	str.w	r1, [r7, #308]	@ 0x134
 80010d8:	6812      	ldr	r2, [r2, #0]
 80010da:	601a      	str	r2, [r3, #0]
    *RK++ = *SK++;
 80010dc:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 80010e0:	1d13      	adds	r3, r2, #4
 80010e2:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 80010e6:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80010ea:	1d19      	adds	r1, r3, #4
 80010ec:	f8c7 1134 	str.w	r1, [r7, #308]	@ 0x134
 80010f0:	6812      	ldr	r2, [r2, #0]
 80010f2:	601a      	str	r2, [r3, #0]
 80010f4:	e000      	b.n	80010f8 <mbedtls_aes_setkey_dec+0x234>
        goto exit;
 80010f6:	bf00      	nop

exit:
    mbedtls_aes_free( &cty );
 80010f8:	f107 0314 	add.w	r3, r7, #20
 80010fc:	4618      	mov	r0, r3
 80010fe:	f7ff fcc7 	bl	8000a90 <mbedtls_aes_free>

    return( ret );
 8001102:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
}
 8001106:	4618      	mov	r0, r3
 8001108:	f507 77a0 	add.w	r7, r7, #320	@ 0x140
 800110c:	46bd      	mov	sp, r7
 800110e:	bd80      	pop	{r7, pc}
 8001110:	200000b4 	.word	0x200000b4
 8001114:	200012b4 	.word	0x200012b4
 8001118:	200016b4 	.word	0x200016b4
 800111c:	20001ab4 	.word	0x20001ab4
 8001120:	20001eb4 	.word	0x20001eb4

08001124 <mbedtls_aes_xts_decode_keys>:
                                        unsigned int keybits,
                                        const unsigned char **key1,
                                        unsigned int *key1bits,
                                        const unsigned char **key2,
                                        unsigned int *key2bits )
{
 8001124:	b480      	push	{r7}
 8001126:	b087      	sub	sp, #28
 8001128:	af00      	add	r7, sp, #0
 800112a:	60f8      	str	r0, [r7, #12]
 800112c:	60b9      	str	r1, [r7, #8]
 800112e:	607a      	str	r2, [r7, #4]
 8001130:	603b      	str	r3, [r7, #0]
    const unsigned int half_keybits = keybits / 2;
 8001132:	68bb      	ldr	r3, [r7, #8]
 8001134:	085b      	lsrs	r3, r3, #1
 8001136:	617b      	str	r3, [r7, #20]
    const unsigned int half_keybytes = half_keybits / 8;
 8001138:	697b      	ldr	r3, [r7, #20]
 800113a:	08db      	lsrs	r3, r3, #3
 800113c:	613b      	str	r3, [r7, #16]

    switch( keybits )
 800113e:	68bb      	ldr	r3, [r7, #8]
 8001140:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8001144:	d006      	beq.n	8001154 <mbedtls_aes_xts_decode_keys+0x30>
 8001146:	68bb      	ldr	r3, [r7, #8]
 8001148:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800114c:	d004      	beq.n	8001158 <mbedtls_aes_xts_decode_keys+0x34>
    {
        case 256: break;
        case 512: break;
        default : return( MBEDTLS_ERR_AES_INVALID_KEY_LENGTH );
 800114e:	f06f 031f 	mvn.w	r3, #31
 8001152:	e011      	b.n	8001178 <mbedtls_aes_xts_decode_keys+0x54>
        case 256: break;
 8001154:	bf00      	nop
 8001156:	e000      	b.n	800115a <mbedtls_aes_xts_decode_keys+0x36>
        case 512: break;
 8001158:	bf00      	nop
    }

    *key1bits = half_keybits;
 800115a:	683b      	ldr	r3, [r7, #0]
 800115c:	697a      	ldr	r2, [r7, #20]
 800115e:	601a      	str	r2, [r3, #0]
    *key2bits = half_keybits;
 8001160:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001162:	697a      	ldr	r2, [r7, #20]
 8001164:	601a      	str	r2, [r3, #0]
    *key1 = &key[0];
 8001166:	687b      	ldr	r3, [r7, #4]
 8001168:	68fa      	ldr	r2, [r7, #12]
 800116a:	601a      	str	r2, [r3, #0]
    *key2 = &key[half_keybytes];
 800116c:	68fa      	ldr	r2, [r7, #12]
 800116e:	693b      	ldr	r3, [r7, #16]
 8001170:	441a      	add	r2, r3
 8001172:	6a3b      	ldr	r3, [r7, #32]
 8001174:	601a      	str	r2, [r3, #0]

    return 0;
 8001176:	2300      	movs	r3, #0
}
 8001178:	4618      	mov	r0, r3
 800117a:	371c      	adds	r7, #28
 800117c:	46bd      	mov	sp, r7
 800117e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001182:	4770      	bx	lr

08001184 <mbedtls_aes_xts_setkey_enc>:

int mbedtls_aes_xts_setkey_enc( mbedtls_aes_xts_context *ctx,
                                const unsigned char *key,
                                unsigned int keybits)
{
 8001184:	b580      	push	{r7, lr}
 8001186:	b08c      	sub	sp, #48	@ 0x30
 8001188:	af02      	add	r7, sp, #8
 800118a:	60f8      	str	r0, [r7, #12]
 800118c:	60b9      	str	r1, [r7, #8]
 800118e:	607a      	str	r2, [r7, #4]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 8001190:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8001194:	627b      	str	r3, [r7, #36]	@ 0x24
    unsigned int key1bits, key2bits;

    AES_VALIDATE_RET( ctx != NULL );
    AES_VALIDATE_RET( key != NULL );

    ret = mbedtls_aes_xts_decode_keys( key, keybits, &key1, &key1bits,
 8001196:	f107 0118 	add.w	r1, r7, #24
 800119a:	f107 0220 	add.w	r2, r7, #32
 800119e:	f107 0314 	add.w	r3, r7, #20
 80011a2:	9301      	str	r3, [sp, #4]
 80011a4:	f107 031c 	add.w	r3, r7, #28
 80011a8:	9300      	str	r3, [sp, #0]
 80011aa:	460b      	mov	r3, r1
 80011ac:	6879      	ldr	r1, [r7, #4]
 80011ae:	68b8      	ldr	r0, [r7, #8]
 80011b0:	f7ff ffb8 	bl	8001124 <mbedtls_aes_xts_decode_keys>
 80011b4:	6278      	str	r0, [r7, #36]	@ 0x24
                                       &key2, &key2bits );
    if( ret != 0 )
 80011b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80011b8:	2b00      	cmp	r3, #0
 80011ba:	d001      	beq.n	80011c0 <mbedtls_aes_xts_setkey_enc+0x3c>
        return( ret );
 80011bc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80011be:	e014      	b.n	80011ea <mbedtls_aes_xts_setkey_enc+0x66>

    /* Set the tweak key. Always set tweak key for the encryption mode. */
    ret = mbedtls_aes_setkey_enc( &ctx->tweak, key2, key2bits );
 80011c0:	68fb      	ldr	r3, [r7, #12]
 80011c2:	f503 738c 	add.w	r3, r3, #280	@ 0x118
 80011c6:	69f9      	ldr	r1, [r7, #28]
 80011c8:	697a      	ldr	r2, [r7, #20]
 80011ca:	4618      	mov	r0, r3
 80011cc:	f7ff fc9a 	bl	8000b04 <mbedtls_aes_setkey_enc>
 80011d0:	6278      	str	r0, [r7, #36]	@ 0x24
    if( ret != 0 )
 80011d2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80011d4:	2b00      	cmp	r3, #0
 80011d6:	d001      	beq.n	80011dc <mbedtls_aes_xts_setkey_enc+0x58>
        return( ret );
 80011d8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80011da:	e006      	b.n	80011ea <mbedtls_aes_xts_setkey_enc+0x66>

    /* Set crypt key for encryption. */
    return mbedtls_aes_setkey_enc( &ctx->crypt, key1, key1bits );
 80011dc:	68fb      	ldr	r3, [r7, #12]
 80011de:	6a39      	ldr	r1, [r7, #32]
 80011e0:	69ba      	ldr	r2, [r7, #24]
 80011e2:	4618      	mov	r0, r3
 80011e4:	f7ff fc8e 	bl	8000b04 <mbedtls_aes_setkey_enc>
 80011e8:	4603      	mov	r3, r0
}
 80011ea:	4618      	mov	r0, r3
 80011ec:	3728      	adds	r7, #40	@ 0x28
 80011ee:	46bd      	mov	sp, r7
 80011f0:	bd80      	pop	{r7, pc}

080011f2 <mbedtls_aes_xts_setkey_dec>:

int mbedtls_aes_xts_setkey_dec( mbedtls_aes_xts_context *ctx,
                                const unsigned char *key,
                                unsigned int keybits)
{
 80011f2:	b580      	push	{r7, lr}
 80011f4:	b08c      	sub	sp, #48	@ 0x30
 80011f6:	af02      	add	r7, sp, #8
 80011f8:	60f8      	str	r0, [r7, #12]
 80011fa:	60b9      	str	r1, [r7, #8]
 80011fc:	607a      	str	r2, [r7, #4]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 80011fe:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8001202:	627b      	str	r3, [r7, #36]	@ 0x24
    unsigned int key1bits, key2bits;

    AES_VALIDATE_RET( ctx != NULL );
    AES_VALIDATE_RET( key != NULL );

    ret = mbedtls_aes_xts_decode_keys( key, keybits, &key1, &key1bits,
 8001204:	f107 0118 	add.w	r1, r7, #24
 8001208:	f107 0220 	add.w	r2, r7, #32
 800120c:	f107 0314 	add.w	r3, r7, #20
 8001210:	9301      	str	r3, [sp, #4]
 8001212:	f107 031c 	add.w	r3, r7, #28
 8001216:	9300      	str	r3, [sp, #0]
 8001218:	460b      	mov	r3, r1
 800121a:	6879      	ldr	r1, [r7, #4]
 800121c:	68b8      	ldr	r0, [r7, #8]
 800121e:	f7ff ff81 	bl	8001124 <mbedtls_aes_xts_decode_keys>
 8001222:	6278      	str	r0, [r7, #36]	@ 0x24
                                       &key2, &key2bits );
    if( ret != 0 )
 8001224:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001226:	2b00      	cmp	r3, #0
 8001228:	d001      	beq.n	800122e <mbedtls_aes_xts_setkey_dec+0x3c>
        return( ret );
 800122a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800122c:	e014      	b.n	8001258 <mbedtls_aes_xts_setkey_dec+0x66>

    /* Set the tweak key. Always set tweak key for encryption. */
    ret = mbedtls_aes_setkey_enc( &ctx->tweak, key2, key2bits );
 800122e:	68fb      	ldr	r3, [r7, #12]
 8001230:	f503 738c 	add.w	r3, r3, #280	@ 0x118
 8001234:	69f9      	ldr	r1, [r7, #28]
 8001236:	697a      	ldr	r2, [r7, #20]
 8001238:	4618      	mov	r0, r3
 800123a:	f7ff fc63 	bl	8000b04 <mbedtls_aes_setkey_enc>
 800123e:	6278      	str	r0, [r7, #36]	@ 0x24
    if( ret != 0 )
 8001240:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001242:	2b00      	cmp	r3, #0
 8001244:	d001      	beq.n	800124a <mbedtls_aes_xts_setkey_dec+0x58>
        return( ret );
 8001246:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001248:	e006      	b.n	8001258 <mbedtls_aes_xts_setkey_dec+0x66>

    /* Set crypt key for decryption. */
    return mbedtls_aes_setkey_dec( &ctx->crypt, key1, key1bits );
 800124a:	68fb      	ldr	r3, [r7, #12]
 800124c:	6a39      	ldr	r1, [r7, #32]
 800124e:	69ba      	ldr	r2, [r7, #24]
 8001250:	4618      	mov	r0, r3
 8001252:	f7ff fe37 	bl	8000ec4 <mbedtls_aes_setkey_dec>
 8001256:	4603      	mov	r3, r0
}
 8001258:	4618      	mov	r0, r3
 800125a:	3728      	adds	r7, #40	@ 0x28
 800125c:	46bd      	mov	sp, r7
 800125e:	bd80      	pop	{r7, pc}

08001260 <mbedtls_internal_aes_encrypt>:
 */
#if !defined(MBEDTLS_AES_ENCRYPT_ALT)
int mbedtls_internal_aes_encrypt( mbedtls_aes_context *ctx,
                                  const unsigned char input[16],
                                  unsigned char output[16] )
{
 8001260:	b580      	push	{r7, lr}
 8001262:	b08e      	sub	sp, #56	@ 0x38
 8001264:	af00      	add	r7, sp, #0
 8001266:	60f8      	str	r0, [r7, #12]
 8001268:	60b9      	str	r1, [r7, #8]
 800126a:	607a      	str	r2, [r7, #4]
    int i;
    uint32_t *RK = ctx->rk;
 800126c:	68fb      	ldr	r3, [r7, #12]
 800126e:	685b      	ldr	r3, [r3, #4]
 8001270:	633b      	str	r3, [r7, #48]	@ 0x30
    {
        uint32_t X[4];
        uint32_t Y[4];
    } t;

    GET_UINT32_LE( t.X[0], input,  0 ); t.X[0] ^= *RK++;
 8001272:	68bb      	ldr	r3, [r7, #8]
 8001274:	781b      	ldrb	r3, [r3, #0]
 8001276:	461a      	mov	r2, r3
 8001278:	68bb      	ldr	r3, [r7, #8]
 800127a:	3301      	adds	r3, #1
 800127c:	781b      	ldrb	r3, [r3, #0]
 800127e:	021b      	lsls	r3, r3, #8
 8001280:	431a      	orrs	r2, r3
 8001282:	68bb      	ldr	r3, [r7, #8]
 8001284:	3302      	adds	r3, #2
 8001286:	781b      	ldrb	r3, [r3, #0]
 8001288:	041b      	lsls	r3, r3, #16
 800128a:	431a      	orrs	r2, r3
 800128c:	68bb      	ldr	r3, [r7, #8]
 800128e:	3303      	adds	r3, #3
 8001290:	781b      	ldrb	r3, [r3, #0]
 8001292:	061b      	lsls	r3, r3, #24
 8001294:	4313      	orrs	r3, r2
 8001296:	613b      	str	r3, [r7, #16]
 8001298:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800129a:	1d1a      	adds	r2, r3, #4
 800129c:	633a      	str	r2, [r7, #48]	@ 0x30
 800129e:	681a      	ldr	r2, [r3, #0]
 80012a0:	693b      	ldr	r3, [r7, #16]
 80012a2:	4053      	eors	r3, r2
 80012a4:	613b      	str	r3, [r7, #16]
    GET_UINT32_LE( t.X[1], input,  4 ); t.X[1] ^= *RK++;
 80012a6:	68bb      	ldr	r3, [r7, #8]
 80012a8:	3304      	adds	r3, #4
 80012aa:	781b      	ldrb	r3, [r3, #0]
 80012ac:	461a      	mov	r2, r3
 80012ae:	68bb      	ldr	r3, [r7, #8]
 80012b0:	3305      	adds	r3, #5
 80012b2:	781b      	ldrb	r3, [r3, #0]
 80012b4:	021b      	lsls	r3, r3, #8
 80012b6:	431a      	orrs	r2, r3
 80012b8:	68bb      	ldr	r3, [r7, #8]
 80012ba:	3306      	adds	r3, #6
 80012bc:	781b      	ldrb	r3, [r3, #0]
 80012be:	041b      	lsls	r3, r3, #16
 80012c0:	431a      	orrs	r2, r3
 80012c2:	68bb      	ldr	r3, [r7, #8]
 80012c4:	3307      	adds	r3, #7
 80012c6:	781b      	ldrb	r3, [r3, #0]
 80012c8:	061b      	lsls	r3, r3, #24
 80012ca:	4313      	orrs	r3, r2
 80012cc:	617b      	str	r3, [r7, #20]
 80012ce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80012d0:	1d1a      	adds	r2, r3, #4
 80012d2:	633a      	str	r2, [r7, #48]	@ 0x30
 80012d4:	681a      	ldr	r2, [r3, #0]
 80012d6:	697b      	ldr	r3, [r7, #20]
 80012d8:	4053      	eors	r3, r2
 80012da:	617b      	str	r3, [r7, #20]
    GET_UINT32_LE( t.X[2], input,  8 ); t.X[2] ^= *RK++;
 80012dc:	68bb      	ldr	r3, [r7, #8]
 80012de:	3308      	adds	r3, #8
 80012e0:	781b      	ldrb	r3, [r3, #0]
 80012e2:	461a      	mov	r2, r3
 80012e4:	68bb      	ldr	r3, [r7, #8]
 80012e6:	3309      	adds	r3, #9
 80012e8:	781b      	ldrb	r3, [r3, #0]
 80012ea:	021b      	lsls	r3, r3, #8
 80012ec:	431a      	orrs	r2, r3
 80012ee:	68bb      	ldr	r3, [r7, #8]
 80012f0:	330a      	adds	r3, #10
 80012f2:	781b      	ldrb	r3, [r3, #0]
 80012f4:	041b      	lsls	r3, r3, #16
 80012f6:	431a      	orrs	r2, r3
 80012f8:	68bb      	ldr	r3, [r7, #8]
 80012fa:	330b      	adds	r3, #11
 80012fc:	781b      	ldrb	r3, [r3, #0]
 80012fe:	061b      	lsls	r3, r3, #24
 8001300:	4313      	orrs	r3, r2
 8001302:	61bb      	str	r3, [r7, #24]
 8001304:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001306:	1d1a      	adds	r2, r3, #4
 8001308:	633a      	str	r2, [r7, #48]	@ 0x30
 800130a:	681a      	ldr	r2, [r3, #0]
 800130c:	69bb      	ldr	r3, [r7, #24]
 800130e:	4053      	eors	r3, r2
 8001310:	61bb      	str	r3, [r7, #24]
    GET_UINT32_LE( t.X[3], input, 12 ); t.X[3] ^= *RK++;
 8001312:	68bb      	ldr	r3, [r7, #8]
 8001314:	330c      	adds	r3, #12
 8001316:	781b      	ldrb	r3, [r3, #0]
 8001318:	461a      	mov	r2, r3
 800131a:	68bb      	ldr	r3, [r7, #8]
 800131c:	330d      	adds	r3, #13
 800131e:	781b      	ldrb	r3, [r3, #0]
 8001320:	021b      	lsls	r3, r3, #8
 8001322:	431a      	orrs	r2, r3
 8001324:	68bb      	ldr	r3, [r7, #8]
 8001326:	330e      	adds	r3, #14
 8001328:	781b      	ldrb	r3, [r3, #0]
 800132a:	041b      	lsls	r3, r3, #16
 800132c:	431a      	orrs	r2, r3
 800132e:	68bb      	ldr	r3, [r7, #8]
 8001330:	330f      	adds	r3, #15
 8001332:	781b      	ldrb	r3, [r3, #0]
 8001334:	061b      	lsls	r3, r3, #24
 8001336:	4313      	orrs	r3, r2
 8001338:	61fb      	str	r3, [r7, #28]
 800133a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800133c:	1d1a      	adds	r2, r3, #4
 800133e:	633a      	str	r2, [r7, #48]	@ 0x30
 8001340:	681a      	ldr	r2, [r3, #0]
 8001342:	69fb      	ldr	r3, [r7, #28]
 8001344:	4053      	eors	r3, r2
 8001346:	61fb      	str	r3, [r7, #28]

    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8001348:	68fb      	ldr	r3, [r7, #12]
 800134a:	681b      	ldr	r3, [r3, #0]
 800134c:	105b      	asrs	r3, r3, #1
 800134e:	3b01      	subs	r3, #1
 8001350:	637b      	str	r3, [r7, #52]	@ 0x34
 8001352:	e0fa      	b.n	800154a <mbedtls_internal_aes_encrypt+0x2ea>
    {
        AES_FROUND( t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3] );
 8001354:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001356:	1d1a      	adds	r2, r3, #4
 8001358:	633a      	str	r2, [r7, #48]	@ 0x30
 800135a:	681a      	ldr	r2, [r3, #0]
 800135c:	693b      	ldr	r3, [r7, #16]
 800135e:	b2db      	uxtb	r3, r3
 8001360:	49ab      	ldr	r1, [pc, #684]	@ (8001610 <mbedtls_internal_aes_encrypt+0x3b0>)
 8001362:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001366:	405a      	eors	r2, r3
 8001368:	697b      	ldr	r3, [r7, #20]
 800136a:	0a1b      	lsrs	r3, r3, #8
 800136c:	b2db      	uxtb	r3, r3
 800136e:	49a9      	ldr	r1, [pc, #676]	@ (8001614 <mbedtls_internal_aes_encrypt+0x3b4>)
 8001370:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001374:	405a      	eors	r2, r3
 8001376:	69bb      	ldr	r3, [r7, #24]
 8001378:	0c1b      	lsrs	r3, r3, #16
 800137a:	b2db      	uxtb	r3, r3
 800137c:	49a6      	ldr	r1, [pc, #664]	@ (8001618 <mbedtls_internal_aes_encrypt+0x3b8>)
 800137e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001382:	405a      	eors	r2, r3
 8001384:	69fb      	ldr	r3, [r7, #28]
 8001386:	0e1b      	lsrs	r3, r3, #24
 8001388:	49a4      	ldr	r1, [pc, #656]	@ (800161c <mbedtls_internal_aes_encrypt+0x3bc>)
 800138a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800138e:	4053      	eors	r3, r2
 8001390:	623b      	str	r3, [r7, #32]
 8001392:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001394:	1d1a      	adds	r2, r3, #4
 8001396:	633a      	str	r2, [r7, #48]	@ 0x30
 8001398:	681a      	ldr	r2, [r3, #0]
 800139a:	697b      	ldr	r3, [r7, #20]
 800139c:	b2db      	uxtb	r3, r3
 800139e:	499c      	ldr	r1, [pc, #624]	@ (8001610 <mbedtls_internal_aes_encrypt+0x3b0>)
 80013a0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80013a4:	405a      	eors	r2, r3
 80013a6:	69bb      	ldr	r3, [r7, #24]
 80013a8:	0a1b      	lsrs	r3, r3, #8
 80013aa:	b2db      	uxtb	r3, r3
 80013ac:	4999      	ldr	r1, [pc, #612]	@ (8001614 <mbedtls_internal_aes_encrypt+0x3b4>)
 80013ae:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80013b2:	405a      	eors	r2, r3
 80013b4:	69fb      	ldr	r3, [r7, #28]
 80013b6:	0c1b      	lsrs	r3, r3, #16
 80013b8:	b2db      	uxtb	r3, r3
 80013ba:	4997      	ldr	r1, [pc, #604]	@ (8001618 <mbedtls_internal_aes_encrypt+0x3b8>)
 80013bc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80013c0:	405a      	eors	r2, r3
 80013c2:	693b      	ldr	r3, [r7, #16]
 80013c4:	0e1b      	lsrs	r3, r3, #24
 80013c6:	4995      	ldr	r1, [pc, #596]	@ (800161c <mbedtls_internal_aes_encrypt+0x3bc>)
 80013c8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80013cc:	4053      	eors	r3, r2
 80013ce:	627b      	str	r3, [r7, #36]	@ 0x24
 80013d0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80013d2:	1d1a      	adds	r2, r3, #4
 80013d4:	633a      	str	r2, [r7, #48]	@ 0x30
 80013d6:	681a      	ldr	r2, [r3, #0]
 80013d8:	69bb      	ldr	r3, [r7, #24]
 80013da:	b2db      	uxtb	r3, r3
 80013dc:	498c      	ldr	r1, [pc, #560]	@ (8001610 <mbedtls_internal_aes_encrypt+0x3b0>)
 80013de:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80013e2:	405a      	eors	r2, r3
 80013e4:	69fb      	ldr	r3, [r7, #28]
 80013e6:	0a1b      	lsrs	r3, r3, #8
 80013e8:	b2db      	uxtb	r3, r3
 80013ea:	498a      	ldr	r1, [pc, #552]	@ (8001614 <mbedtls_internal_aes_encrypt+0x3b4>)
 80013ec:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80013f0:	405a      	eors	r2, r3
 80013f2:	693b      	ldr	r3, [r7, #16]
 80013f4:	0c1b      	lsrs	r3, r3, #16
 80013f6:	b2db      	uxtb	r3, r3
 80013f8:	4987      	ldr	r1, [pc, #540]	@ (8001618 <mbedtls_internal_aes_encrypt+0x3b8>)
 80013fa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80013fe:	405a      	eors	r2, r3
 8001400:	697b      	ldr	r3, [r7, #20]
 8001402:	0e1b      	lsrs	r3, r3, #24
 8001404:	4985      	ldr	r1, [pc, #532]	@ (800161c <mbedtls_internal_aes_encrypt+0x3bc>)
 8001406:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800140a:	4053      	eors	r3, r2
 800140c:	62bb      	str	r3, [r7, #40]	@ 0x28
 800140e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001410:	1d1a      	adds	r2, r3, #4
 8001412:	633a      	str	r2, [r7, #48]	@ 0x30
 8001414:	681a      	ldr	r2, [r3, #0]
 8001416:	69fb      	ldr	r3, [r7, #28]
 8001418:	b2db      	uxtb	r3, r3
 800141a:	497d      	ldr	r1, [pc, #500]	@ (8001610 <mbedtls_internal_aes_encrypt+0x3b0>)
 800141c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001420:	405a      	eors	r2, r3
 8001422:	693b      	ldr	r3, [r7, #16]
 8001424:	0a1b      	lsrs	r3, r3, #8
 8001426:	b2db      	uxtb	r3, r3
 8001428:	497a      	ldr	r1, [pc, #488]	@ (8001614 <mbedtls_internal_aes_encrypt+0x3b4>)
 800142a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800142e:	405a      	eors	r2, r3
 8001430:	697b      	ldr	r3, [r7, #20]
 8001432:	0c1b      	lsrs	r3, r3, #16
 8001434:	b2db      	uxtb	r3, r3
 8001436:	4978      	ldr	r1, [pc, #480]	@ (8001618 <mbedtls_internal_aes_encrypt+0x3b8>)
 8001438:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800143c:	405a      	eors	r2, r3
 800143e:	69bb      	ldr	r3, [r7, #24]
 8001440:	0e1b      	lsrs	r3, r3, #24
 8001442:	4976      	ldr	r1, [pc, #472]	@ (800161c <mbedtls_internal_aes_encrypt+0x3bc>)
 8001444:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001448:	4053      	eors	r3, r2
 800144a:	62fb      	str	r3, [r7, #44]	@ 0x2c
        AES_FROUND( t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3] );
 800144c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800144e:	1d1a      	adds	r2, r3, #4
 8001450:	633a      	str	r2, [r7, #48]	@ 0x30
 8001452:	681a      	ldr	r2, [r3, #0]
 8001454:	6a3b      	ldr	r3, [r7, #32]
 8001456:	b2db      	uxtb	r3, r3
 8001458:	496d      	ldr	r1, [pc, #436]	@ (8001610 <mbedtls_internal_aes_encrypt+0x3b0>)
 800145a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800145e:	405a      	eors	r2, r3
 8001460:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001462:	0a1b      	lsrs	r3, r3, #8
 8001464:	b2db      	uxtb	r3, r3
 8001466:	496b      	ldr	r1, [pc, #428]	@ (8001614 <mbedtls_internal_aes_encrypt+0x3b4>)
 8001468:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800146c:	405a      	eors	r2, r3
 800146e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001470:	0c1b      	lsrs	r3, r3, #16
 8001472:	b2db      	uxtb	r3, r3
 8001474:	4968      	ldr	r1, [pc, #416]	@ (8001618 <mbedtls_internal_aes_encrypt+0x3b8>)
 8001476:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800147a:	405a      	eors	r2, r3
 800147c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800147e:	0e1b      	lsrs	r3, r3, #24
 8001480:	4966      	ldr	r1, [pc, #408]	@ (800161c <mbedtls_internal_aes_encrypt+0x3bc>)
 8001482:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001486:	4053      	eors	r3, r2
 8001488:	613b      	str	r3, [r7, #16]
 800148a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800148c:	1d1a      	adds	r2, r3, #4
 800148e:	633a      	str	r2, [r7, #48]	@ 0x30
 8001490:	681a      	ldr	r2, [r3, #0]
 8001492:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001494:	b2db      	uxtb	r3, r3
 8001496:	495e      	ldr	r1, [pc, #376]	@ (8001610 <mbedtls_internal_aes_encrypt+0x3b0>)
 8001498:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800149c:	405a      	eors	r2, r3
 800149e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80014a0:	0a1b      	lsrs	r3, r3, #8
 80014a2:	b2db      	uxtb	r3, r3
 80014a4:	495b      	ldr	r1, [pc, #364]	@ (8001614 <mbedtls_internal_aes_encrypt+0x3b4>)
 80014a6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80014aa:	405a      	eors	r2, r3
 80014ac:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80014ae:	0c1b      	lsrs	r3, r3, #16
 80014b0:	b2db      	uxtb	r3, r3
 80014b2:	4959      	ldr	r1, [pc, #356]	@ (8001618 <mbedtls_internal_aes_encrypt+0x3b8>)
 80014b4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80014b8:	405a      	eors	r2, r3
 80014ba:	6a3b      	ldr	r3, [r7, #32]
 80014bc:	0e1b      	lsrs	r3, r3, #24
 80014be:	4957      	ldr	r1, [pc, #348]	@ (800161c <mbedtls_internal_aes_encrypt+0x3bc>)
 80014c0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80014c4:	4053      	eors	r3, r2
 80014c6:	617b      	str	r3, [r7, #20]
 80014c8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80014ca:	1d1a      	adds	r2, r3, #4
 80014cc:	633a      	str	r2, [r7, #48]	@ 0x30
 80014ce:	681a      	ldr	r2, [r3, #0]
 80014d0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80014d2:	b2db      	uxtb	r3, r3
 80014d4:	494e      	ldr	r1, [pc, #312]	@ (8001610 <mbedtls_internal_aes_encrypt+0x3b0>)
 80014d6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80014da:	405a      	eors	r2, r3
 80014dc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80014de:	0a1b      	lsrs	r3, r3, #8
 80014e0:	b2db      	uxtb	r3, r3
 80014e2:	494c      	ldr	r1, [pc, #304]	@ (8001614 <mbedtls_internal_aes_encrypt+0x3b4>)
 80014e4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80014e8:	405a      	eors	r2, r3
 80014ea:	6a3b      	ldr	r3, [r7, #32]
 80014ec:	0c1b      	lsrs	r3, r3, #16
 80014ee:	b2db      	uxtb	r3, r3
 80014f0:	4949      	ldr	r1, [pc, #292]	@ (8001618 <mbedtls_internal_aes_encrypt+0x3b8>)
 80014f2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80014f6:	405a      	eors	r2, r3
 80014f8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80014fa:	0e1b      	lsrs	r3, r3, #24
 80014fc:	4947      	ldr	r1, [pc, #284]	@ (800161c <mbedtls_internal_aes_encrypt+0x3bc>)
 80014fe:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001502:	4053      	eors	r3, r2
 8001504:	61bb      	str	r3, [r7, #24]
 8001506:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001508:	1d1a      	adds	r2, r3, #4
 800150a:	633a      	str	r2, [r7, #48]	@ 0x30
 800150c:	681a      	ldr	r2, [r3, #0]
 800150e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8001510:	b2db      	uxtb	r3, r3
 8001512:	493f      	ldr	r1, [pc, #252]	@ (8001610 <mbedtls_internal_aes_encrypt+0x3b0>)
 8001514:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001518:	405a      	eors	r2, r3
 800151a:	6a3b      	ldr	r3, [r7, #32]
 800151c:	0a1b      	lsrs	r3, r3, #8
 800151e:	b2db      	uxtb	r3, r3
 8001520:	493c      	ldr	r1, [pc, #240]	@ (8001614 <mbedtls_internal_aes_encrypt+0x3b4>)
 8001522:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001526:	405a      	eors	r2, r3
 8001528:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800152a:	0c1b      	lsrs	r3, r3, #16
 800152c:	b2db      	uxtb	r3, r3
 800152e:	493a      	ldr	r1, [pc, #232]	@ (8001618 <mbedtls_internal_aes_encrypt+0x3b8>)
 8001530:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001534:	405a      	eors	r2, r3
 8001536:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001538:	0e1b      	lsrs	r3, r3, #24
 800153a:	4938      	ldr	r1, [pc, #224]	@ (800161c <mbedtls_internal_aes_encrypt+0x3bc>)
 800153c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001540:	4053      	eors	r3, r2
 8001542:	61fb      	str	r3, [r7, #28]
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8001544:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8001546:	3b01      	subs	r3, #1
 8001548:	637b      	str	r3, [r7, #52]	@ 0x34
 800154a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800154c:	2b00      	cmp	r3, #0
 800154e:	f73f af01 	bgt.w	8001354 <mbedtls_internal_aes_encrypt+0xf4>
    }

    AES_FROUND( t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3] );
 8001552:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001554:	1d1a      	adds	r2, r3, #4
 8001556:	633a      	str	r2, [r7, #48]	@ 0x30
 8001558:	681a      	ldr	r2, [r3, #0]
 800155a:	693b      	ldr	r3, [r7, #16]
 800155c:	b2db      	uxtb	r3, r3
 800155e:	492c      	ldr	r1, [pc, #176]	@ (8001610 <mbedtls_internal_aes_encrypt+0x3b0>)
 8001560:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001564:	405a      	eors	r2, r3
 8001566:	697b      	ldr	r3, [r7, #20]
 8001568:	0a1b      	lsrs	r3, r3, #8
 800156a:	b2db      	uxtb	r3, r3
 800156c:	4929      	ldr	r1, [pc, #164]	@ (8001614 <mbedtls_internal_aes_encrypt+0x3b4>)
 800156e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001572:	405a      	eors	r2, r3
 8001574:	69bb      	ldr	r3, [r7, #24]
 8001576:	0c1b      	lsrs	r3, r3, #16
 8001578:	b2db      	uxtb	r3, r3
 800157a:	4927      	ldr	r1, [pc, #156]	@ (8001618 <mbedtls_internal_aes_encrypt+0x3b8>)
 800157c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001580:	405a      	eors	r2, r3
 8001582:	69fb      	ldr	r3, [r7, #28]
 8001584:	0e1b      	lsrs	r3, r3, #24
 8001586:	4925      	ldr	r1, [pc, #148]	@ (800161c <mbedtls_internal_aes_encrypt+0x3bc>)
 8001588:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800158c:	4053      	eors	r3, r2
 800158e:	623b      	str	r3, [r7, #32]
 8001590:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001592:	1d1a      	adds	r2, r3, #4
 8001594:	633a      	str	r2, [r7, #48]	@ 0x30
 8001596:	681a      	ldr	r2, [r3, #0]
 8001598:	697b      	ldr	r3, [r7, #20]
 800159a:	b2db      	uxtb	r3, r3
 800159c:	491c      	ldr	r1, [pc, #112]	@ (8001610 <mbedtls_internal_aes_encrypt+0x3b0>)
 800159e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80015a2:	405a      	eors	r2, r3
 80015a4:	69bb      	ldr	r3, [r7, #24]
 80015a6:	0a1b      	lsrs	r3, r3, #8
 80015a8:	b2db      	uxtb	r3, r3
 80015aa:	491a      	ldr	r1, [pc, #104]	@ (8001614 <mbedtls_internal_aes_encrypt+0x3b4>)
 80015ac:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80015b0:	405a      	eors	r2, r3
 80015b2:	69fb      	ldr	r3, [r7, #28]
 80015b4:	0c1b      	lsrs	r3, r3, #16
 80015b6:	b2db      	uxtb	r3, r3
 80015b8:	4917      	ldr	r1, [pc, #92]	@ (8001618 <mbedtls_internal_aes_encrypt+0x3b8>)
 80015ba:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80015be:	405a      	eors	r2, r3
 80015c0:	693b      	ldr	r3, [r7, #16]
 80015c2:	0e1b      	lsrs	r3, r3, #24
 80015c4:	4915      	ldr	r1, [pc, #84]	@ (800161c <mbedtls_internal_aes_encrypt+0x3bc>)
 80015c6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80015ca:	4053      	eors	r3, r2
 80015cc:	627b      	str	r3, [r7, #36]	@ 0x24
 80015ce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80015d0:	1d1a      	adds	r2, r3, #4
 80015d2:	633a      	str	r2, [r7, #48]	@ 0x30
 80015d4:	681a      	ldr	r2, [r3, #0]
 80015d6:	69bb      	ldr	r3, [r7, #24]
 80015d8:	b2db      	uxtb	r3, r3
 80015da:	490d      	ldr	r1, [pc, #52]	@ (8001610 <mbedtls_internal_aes_encrypt+0x3b0>)
 80015dc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80015e0:	405a      	eors	r2, r3
 80015e2:	69fb      	ldr	r3, [r7, #28]
 80015e4:	0a1b      	lsrs	r3, r3, #8
 80015e6:	b2db      	uxtb	r3, r3
 80015e8:	490a      	ldr	r1, [pc, #40]	@ (8001614 <mbedtls_internal_aes_encrypt+0x3b4>)
 80015ea:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80015ee:	405a      	eors	r2, r3
 80015f0:	693b      	ldr	r3, [r7, #16]
 80015f2:	0c1b      	lsrs	r3, r3, #16
 80015f4:	b2db      	uxtb	r3, r3
 80015f6:	4908      	ldr	r1, [pc, #32]	@ (8001618 <mbedtls_internal_aes_encrypt+0x3b8>)
 80015f8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80015fc:	405a      	eors	r2, r3
 80015fe:	697b      	ldr	r3, [r7, #20]
 8001600:	0e1b      	lsrs	r3, r3, #24
 8001602:	4906      	ldr	r1, [pc, #24]	@ (800161c <mbedtls_internal_aes_encrypt+0x3bc>)
 8001604:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001608:	4053      	eors	r3, r2
 800160a:	62bb      	str	r3, [r7, #40]	@ 0x28
 800160c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800160e:	e007      	b.n	8001620 <mbedtls_internal_aes_encrypt+0x3c0>
 8001610:	200001b4 	.word	0x200001b4
 8001614:	200005b4 	.word	0x200005b4
 8001618:	200009b4 	.word	0x200009b4
 800161c:	20000db4 	.word	0x20000db4
 8001620:	1d1a      	adds	r2, r3, #4
 8001622:	633a      	str	r2, [r7, #48]	@ 0x30
 8001624:	681a      	ldr	r2, [r3, #0]
 8001626:	69fb      	ldr	r3, [r7, #28]
 8001628:	b2db      	uxtb	r3, r3
 800162a:	497b      	ldr	r1, [pc, #492]	@ (8001818 <mbedtls_internal_aes_encrypt+0x5b8>)
 800162c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001630:	405a      	eors	r2, r3
 8001632:	693b      	ldr	r3, [r7, #16]
 8001634:	0a1b      	lsrs	r3, r3, #8
 8001636:	b2db      	uxtb	r3, r3
 8001638:	4978      	ldr	r1, [pc, #480]	@ (800181c <mbedtls_internal_aes_encrypt+0x5bc>)
 800163a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800163e:	405a      	eors	r2, r3
 8001640:	697b      	ldr	r3, [r7, #20]
 8001642:	0c1b      	lsrs	r3, r3, #16
 8001644:	b2db      	uxtb	r3, r3
 8001646:	4976      	ldr	r1, [pc, #472]	@ (8001820 <mbedtls_internal_aes_encrypt+0x5c0>)
 8001648:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800164c:	405a      	eors	r2, r3
 800164e:	69bb      	ldr	r3, [r7, #24]
 8001650:	0e1b      	lsrs	r3, r3, #24
 8001652:	4974      	ldr	r1, [pc, #464]	@ (8001824 <mbedtls_internal_aes_encrypt+0x5c4>)
 8001654:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001658:	4053      	eors	r3, r2
 800165a:	62fb      	str	r3, [r7, #44]	@ 0x2c

    t.X[0] = *RK++ ^ \
 800165c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800165e:	1d1a      	adds	r2, r3, #4
 8001660:	633a      	str	r2, [r7, #48]	@ 0x30
 8001662:	681b      	ldr	r3, [r3, #0]
            ( (uint32_t) FSb[ ( t.Y[0]       ) & 0xFF ]       ) ^
 8001664:	6a3a      	ldr	r2, [r7, #32]
 8001666:	b2d2      	uxtb	r2, r2
 8001668:	496f      	ldr	r1, [pc, #444]	@ (8001828 <mbedtls_internal_aes_encrypt+0x5c8>)
 800166a:	5c8a      	ldrb	r2, [r1, r2]
    t.X[0] = *RK++ ^ \
 800166c:	405a      	eors	r2, r3
            ( (uint32_t) FSb[ ( t.Y[1] >>  8 ) & 0xFF ] <<  8 ) ^
 800166e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001670:	0a1b      	lsrs	r3, r3, #8
 8001672:	b2db      	uxtb	r3, r3
 8001674:	496c      	ldr	r1, [pc, #432]	@ (8001828 <mbedtls_internal_aes_encrypt+0x5c8>)
 8001676:	5ccb      	ldrb	r3, [r1, r3]
 8001678:	021b      	lsls	r3, r3, #8
            ( (uint32_t) FSb[ ( t.Y[0]       ) & 0xFF ]       ) ^
 800167a:	405a      	eors	r2, r3
            ( (uint32_t) FSb[ ( t.Y[2] >> 16 ) & 0xFF ] << 16 ) ^
 800167c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800167e:	0c1b      	lsrs	r3, r3, #16
 8001680:	b2db      	uxtb	r3, r3
 8001682:	4969      	ldr	r1, [pc, #420]	@ (8001828 <mbedtls_internal_aes_encrypt+0x5c8>)
 8001684:	5ccb      	ldrb	r3, [r1, r3]
 8001686:	041b      	lsls	r3, r3, #16
            ( (uint32_t) FSb[ ( t.Y[1] >>  8 ) & 0xFF ] <<  8 ) ^
 8001688:	405a      	eors	r2, r3
            ( (uint32_t) FSb[ ( t.Y[3] >> 24 ) & 0xFF ] << 24 );
 800168a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800168c:	0e1b      	lsrs	r3, r3, #24
 800168e:	4966      	ldr	r1, [pc, #408]	@ (8001828 <mbedtls_internal_aes_encrypt+0x5c8>)
 8001690:	5ccb      	ldrb	r3, [r1, r3]
 8001692:	061b      	lsls	r3, r3, #24
            ( (uint32_t) FSb[ ( t.Y[2] >> 16 ) & 0xFF ] << 16 ) ^
 8001694:	4053      	eors	r3, r2
    t.X[0] = *RK++ ^ \
 8001696:	613b      	str	r3, [r7, #16]

    t.X[1] = *RK++ ^ \
 8001698:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800169a:	1d1a      	adds	r2, r3, #4
 800169c:	633a      	str	r2, [r7, #48]	@ 0x30
 800169e:	681b      	ldr	r3, [r3, #0]
            ( (uint32_t) FSb[ ( t.Y[1]       ) & 0xFF ]       ) ^
 80016a0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80016a2:	b2d2      	uxtb	r2, r2
 80016a4:	4960      	ldr	r1, [pc, #384]	@ (8001828 <mbedtls_internal_aes_encrypt+0x5c8>)
 80016a6:	5c8a      	ldrb	r2, [r1, r2]
    t.X[1] = *RK++ ^ \
 80016a8:	405a      	eors	r2, r3
            ( (uint32_t) FSb[ ( t.Y[2] >>  8 ) & 0xFF ] <<  8 ) ^
 80016aa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80016ac:	0a1b      	lsrs	r3, r3, #8
 80016ae:	b2db      	uxtb	r3, r3
 80016b0:	495d      	ldr	r1, [pc, #372]	@ (8001828 <mbedtls_internal_aes_encrypt+0x5c8>)
 80016b2:	5ccb      	ldrb	r3, [r1, r3]
 80016b4:	021b      	lsls	r3, r3, #8
            ( (uint32_t) FSb[ ( t.Y[1]       ) & 0xFF ]       ) ^
 80016b6:	405a      	eors	r2, r3
            ( (uint32_t) FSb[ ( t.Y[3] >> 16 ) & 0xFF ] << 16 ) ^
 80016b8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80016ba:	0c1b      	lsrs	r3, r3, #16
 80016bc:	b2db      	uxtb	r3, r3
 80016be:	495a      	ldr	r1, [pc, #360]	@ (8001828 <mbedtls_internal_aes_encrypt+0x5c8>)
 80016c0:	5ccb      	ldrb	r3, [r1, r3]
 80016c2:	041b      	lsls	r3, r3, #16
            ( (uint32_t) FSb[ ( t.Y[2] >>  8 ) & 0xFF ] <<  8 ) ^
 80016c4:	405a      	eors	r2, r3
            ( (uint32_t) FSb[ ( t.Y[0] >> 24 ) & 0xFF ] << 24 );
 80016c6:	6a3b      	ldr	r3, [r7, #32]
 80016c8:	0e1b      	lsrs	r3, r3, #24
 80016ca:	4957      	ldr	r1, [pc, #348]	@ (8001828 <mbedtls_internal_aes_encrypt+0x5c8>)
 80016cc:	5ccb      	ldrb	r3, [r1, r3]
 80016ce:	061b      	lsls	r3, r3, #24
            ( (uint32_t) FSb[ ( t.Y[3] >> 16 ) & 0xFF ] << 16 ) ^
 80016d0:	4053      	eors	r3, r2
    t.X[1] = *RK++ ^ \
 80016d2:	617b      	str	r3, [r7, #20]

    t.X[2] = *RK++ ^ \
 80016d4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80016d6:	1d1a      	adds	r2, r3, #4
 80016d8:	633a      	str	r2, [r7, #48]	@ 0x30
 80016da:	681b      	ldr	r3, [r3, #0]
            ( (uint32_t) FSb[ ( t.Y[2]       ) & 0xFF ]       ) ^
 80016dc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80016de:	b2d2      	uxtb	r2, r2
 80016e0:	4951      	ldr	r1, [pc, #324]	@ (8001828 <mbedtls_internal_aes_encrypt+0x5c8>)
 80016e2:	5c8a      	ldrb	r2, [r1, r2]
    t.X[2] = *RK++ ^ \
 80016e4:	405a      	eors	r2, r3
            ( (uint32_t) FSb[ ( t.Y[3] >>  8 ) & 0xFF ] <<  8 ) ^
 80016e6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80016e8:	0a1b      	lsrs	r3, r3, #8
 80016ea:	b2db      	uxtb	r3, r3
 80016ec:	494e      	ldr	r1, [pc, #312]	@ (8001828 <mbedtls_internal_aes_encrypt+0x5c8>)
 80016ee:	5ccb      	ldrb	r3, [r1, r3]
 80016f0:	021b      	lsls	r3, r3, #8
            ( (uint32_t) FSb[ ( t.Y[2]       ) & 0xFF ]       ) ^
 80016f2:	405a      	eors	r2, r3
            ( (uint32_t) FSb[ ( t.Y[0] >> 16 ) & 0xFF ] << 16 ) ^
 80016f4:	6a3b      	ldr	r3, [r7, #32]
 80016f6:	0c1b      	lsrs	r3, r3, #16
 80016f8:	b2db      	uxtb	r3, r3
 80016fa:	494b      	ldr	r1, [pc, #300]	@ (8001828 <mbedtls_internal_aes_encrypt+0x5c8>)
 80016fc:	5ccb      	ldrb	r3, [r1, r3]
 80016fe:	041b      	lsls	r3, r3, #16
            ( (uint32_t) FSb[ ( t.Y[3] >>  8 ) & 0xFF ] <<  8 ) ^
 8001700:	405a      	eors	r2, r3
            ( (uint32_t) FSb[ ( t.Y[1] >> 24 ) & 0xFF ] << 24 );
 8001702:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001704:	0e1b      	lsrs	r3, r3, #24
 8001706:	4948      	ldr	r1, [pc, #288]	@ (8001828 <mbedtls_internal_aes_encrypt+0x5c8>)
 8001708:	5ccb      	ldrb	r3, [r1, r3]
 800170a:	061b      	lsls	r3, r3, #24
            ( (uint32_t) FSb[ ( t.Y[0] >> 16 ) & 0xFF ] << 16 ) ^
 800170c:	4053      	eors	r3, r2
    t.X[2] = *RK++ ^ \
 800170e:	61bb      	str	r3, [r7, #24]

    t.X[3] = *RK++ ^ \
 8001710:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001712:	1d1a      	adds	r2, r3, #4
 8001714:	633a      	str	r2, [r7, #48]	@ 0x30
 8001716:	681b      	ldr	r3, [r3, #0]
            ( (uint32_t) FSb[ ( t.Y[3]       ) & 0xFF ]       ) ^
 8001718:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800171a:	b2d2      	uxtb	r2, r2
 800171c:	4942      	ldr	r1, [pc, #264]	@ (8001828 <mbedtls_internal_aes_encrypt+0x5c8>)
 800171e:	5c8a      	ldrb	r2, [r1, r2]
    t.X[3] = *RK++ ^ \
 8001720:	405a      	eors	r2, r3
            ( (uint32_t) FSb[ ( t.Y[0] >>  8 ) & 0xFF ] <<  8 ) ^
 8001722:	6a3b      	ldr	r3, [r7, #32]
 8001724:	0a1b      	lsrs	r3, r3, #8
 8001726:	b2db      	uxtb	r3, r3
 8001728:	493f      	ldr	r1, [pc, #252]	@ (8001828 <mbedtls_internal_aes_encrypt+0x5c8>)
 800172a:	5ccb      	ldrb	r3, [r1, r3]
 800172c:	021b      	lsls	r3, r3, #8
            ( (uint32_t) FSb[ ( t.Y[3]       ) & 0xFF ]       ) ^
 800172e:	405a      	eors	r2, r3
            ( (uint32_t) FSb[ ( t.Y[1] >> 16 ) & 0xFF ] << 16 ) ^
 8001730:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001732:	0c1b      	lsrs	r3, r3, #16
 8001734:	b2db      	uxtb	r3, r3
 8001736:	493c      	ldr	r1, [pc, #240]	@ (8001828 <mbedtls_internal_aes_encrypt+0x5c8>)
 8001738:	5ccb      	ldrb	r3, [r1, r3]
 800173a:	041b      	lsls	r3, r3, #16
            ( (uint32_t) FSb[ ( t.Y[0] >>  8 ) & 0xFF ] <<  8 ) ^
 800173c:	405a      	eors	r2, r3
            ( (uint32_t) FSb[ ( t.Y[2] >> 24 ) & 0xFF ] << 24 );
 800173e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001740:	0e1b      	lsrs	r3, r3, #24
 8001742:	4939      	ldr	r1, [pc, #228]	@ (8001828 <mbedtls_internal_aes_encrypt+0x5c8>)
 8001744:	5ccb      	ldrb	r3, [r1, r3]
 8001746:	061b      	lsls	r3, r3, #24
            ( (uint32_t) FSb[ ( t.Y[1] >> 16 ) & 0xFF ] << 16 ) ^
 8001748:	4053      	eors	r3, r2
    t.X[3] = *RK++ ^ \
 800174a:	61fb      	str	r3, [r7, #28]

    PUT_UINT32_LE( t.X[0], output,  0 );
 800174c:	693b      	ldr	r3, [r7, #16]
 800174e:	b2da      	uxtb	r2, r3
 8001750:	687b      	ldr	r3, [r7, #4]
 8001752:	701a      	strb	r2, [r3, #0]
 8001754:	693b      	ldr	r3, [r7, #16]
 8001756:	0a1a      	lsrs	r2, r3, #8
 8001758:	687b      	ldr	r3, [r7, #4]
 800175a:	3301      	adds	r3, #1
 800175c:	b2d2      	uxtb	r2, r2
 800175e:	701a      	strb	r2, [r3, #0]
 8001760:	693b      	ldr	r3, [r7, #16]
 8001762:	0c1a      	lsrs	r2, r3, #16
 8001764:	687b      	ldr	r3, [r7, #4]
 8001766:	3302      	adds	r3, #2
 8001768:	b2d2      	uxtb	r2, r2
 800176a:	701a      	strb	r2, [r3, #0]
 800176c:	693b      	ldr	r3, [r7, #16]
 800176e:	0e1a      	lsrs	r2, r3, #24
 8001770:	687b      	ldr	r3, [r7, #4]
 8001772:	3303      	adds	r3, #3
 8001774:	b2d2      	uxtb	r2, r2
 8001776:	701a      	strb	r2, [r3, #0]
    PUT_UINT32_LE( t.X[1], output,  4 );
 8001778:	697a      	ldr	r2, [r7, #20]
 800177a:	687b      	ldr	r3, [r7, #4]
 800177c:	3304      	adds	r3, #4
 800177e:	b2d2      	uxtb	r2, r2
 8001780:	701a      	strb	r2, [r3, #0]
 8001782:	697b      	ldr	r3, [r7, #20]
 8001784:	0a1a      	lsrs	r2, r3, #8
 8001786:	687b      	ldr	r3, [r7, #4]
 8001788:	3305      	adds	r3, #5
 800178a:	b2d2      	uxtb	r2, r2
 800178c:	701a      	strb	r2, [r3, #0]
 800178e:	697b      	ldr	r3, [r7, #20]
 8001790:	0c1a      	lsrs	r2, r3, #16
 8001792:	687b      	ldr	r3, [r7, #4]
 8001794:	3306      	adds	r3, #6
 8001796:	b2d2      	uxtb	r2, r2
 8001798:	701a      	strb	r2, [r3, #0]
 800179a:	697b      	ldr	r3, [r7, #20]
 800179c:	0e1a      	lsrs	r2, r3, #24
 800179e:	687b      	ldr	r3, [r7, #4]
 80017a0:	3307      	adds	r3, #7
 80017a2:	b2d2      	uxtb	r2, r2
 80017a4:	701a      	strb	r2, [r3, #0]
    PUT_UINT32_LE( t.X[2], output,  8 );
 80017a6:	69ba      	ldr	r2, [r7, #24]
 80017a8:	687b      	ldr	r3, [r7, #4]
 80017aa:	3308      	adds	r3, #8
 80017ac:	b2d2      	uxtb	r2, r2
 80017ae:	701a      	strb	r2, [r3, #0]
 80017b0:	69bb      	ldr	r3, [r7, #24]
 80017b2:	0a1a      	lsrs	r2, r3, #8
 80017b4:	687b      	ldr	r3, [r7, #4]
 80017b6:	3309      	adds	r3, #9
 80017b8:	b2d2      	uxtb	r2, r2
 80017ba:	701a      	strb	r2, [r3, #0]
 80017bc:	69bb      	ldr	r3, [r7, #24]
 80017be:	0c1a      	lsrs	r2, r3, #16
 80017c0:	687b      	ldr	r3, [r7, #4]
 80017c2:	330a      	adds	r3, #10
 80017c4:	b2d2      	uxtb	r2, r2
 80017c6:	701a      	strb	r2, [r3, #0]
 80017c8:	69bb      	ldr	r3, [r7, #24]
 80017ca:	0e1a      	lsrs	r2, r3, #24
 80017cc:	687b      	ldr	r3, [r7, #4]
 80017ce:	330b      	adds	r3, #11
 80017d0:	b2d2      	uxtb	r2, r2
 80017d2:	701a      	strb	r2, [r3, #0]
    PUT_UINT32_LE( t.X[3], output, 12 );
 80017d4:	69fa      	ldr	r2, [r7, #28]
 80017d6:	687b      	ldr	r3, [r7, #4]
 80017d8:	330c      	adds	r3, #12
 80017da:	b2d2      	uxtb	r2, r2
 80017dc:	701a      	strb	r2, [r3, #0]
 80017de:	69fb      	ldr	r3, [r7, #28]
 80017e0:	0a1a      	lsrs	r2, r3, #8
 80017e2:	687b      	ldr	r3, [r7, #4]
 80017e4:	330d      	adds	r3, #13
 80017e6:	b2d2      	uxtb	r2, r2
 80017e8:	701a      	strb	r2, [r3, #0]
 80017ea:	69fb      	ldr	r3, [r7, #28]
 80017ec:	0c1a      	lsrs	r2, r3, #16
 80017ee:	687b      	ldr	r3, [r7, #4]
 80017f0:	330e      	adds	r3, #14
 80017f2:	b2d2      	uxtb	r2, r2
 80017f4:	701a      	strb	r2, [r3, #0]
 80017f6:	69fb      	ldr	r3, [r7, #28]
 80017f8:	0e1a      	lsrs	r2, r3, #24
 80017fa:	687b      	ldr	r3, [r7, #4]
 80017fc:	330f      	adds	r3, #15
 80017fe:	b2d2      	uxtb	r2, r2
 8001800:	701a      	strb	r2, [r3, #0]

    mbedtls_platform_zeroize( &t, sizeof( t ) );
 8001802:	f107 0310 	add.w	r3, r7, #16
 8001806:	2120      	movs	r1, #32
 8001808:	4618      	mov	r0, r3
 800180a:	f004 fce9 	bl	80061e0 <mbedtls_platform_zeroize>

    return( 0 );
 800180e:	2300      	movs	r3, #0
}
 8001810:	4618      	mov	r0, r3
 8001812:	3738      	adds	r7, #56	@ 0x38
 8001814:	46bd      	mov	sp, r7
 8001816:	bd80      	pop	{r7, pc}
 8001818:	200001b4 	.word	0x200001b4
 800181c:	200005b4 	.word	0x200005b4
 8001820:	200009b4 	.word	0x200009b4
 8001824:	20000db4 	.word	0x20000db4
 8001828:	200000b4 	.word	0x200000b4

0800182c <mbedtls_internal_aes_decrypt>:
 */
#if !defined(MBEDTLS_AES_DECRYPT_ALT)
int mbedtls_internal_aes_decrypt( mbedtls_aes_context *ctx,
                                  const unsigned char input[16],
                                  unsigned char output[16] )
{
 800182c:	b580      	push	{r7, lr}
 800182e:	b08e      	sub	sp, #56	@ 0x38
 8001830:	af00      	add	r7, sp, #0
 8001832:	60f8      	str	r0, [r7, #12]
 8001834:	60b9      	str	r1, [r7, #8]
 8001836:	607a      	str	r2, [r7, #4]
    int i;
    uint32_t *RK = ctx->rk;
 8001838:	68fb      	ldr	r3, [r7, #12]
 800183a:	685b      	ldr	r3, [r3, #4]
 800183c:	633b      	str	r3, [r7, #48]	@ 0x30
    {
        uint32_t X[4];
        uint32_t Y[4];
    } t;

    GET_UINT32_LE( t.X[0], input,  0 ); t.X[0] ^= *RK++;
 800183e:	68bb      	ldr	r3, [r7, #8]
 8001840:	781b      	ldrb	r3, [r3, #0]
 8001842:	461a      	mov	r2, r3
 8001844:	68bb      	ldr	r3, [r7, #8]
 8001846:	3301      	adds	r3, #1
 8001848:	781b      	ldrb	r3, [r3, #0]
 800184a:	021b      	lsls	r3, r3, #8
 800184c:	431a      	orrs	r2, r3
 800184e:	68bb      	ldr	r3, [r7, #8]
 8001850:	3302      	adds	r3, #2
 8001852:	781b      	ldrb	r3, [r3, #0]
 8001854:	041b      	lsls	r3, r3, #16
 8001856:	431a      	orrs	r2, r3
 8001858:	68bb      	ldr	r3, [r7, #8]
 800185a:	3303      	adds	r3, #3
 800185c:	781b      	ldrb	r3, [r3, #0]
 800185e:	061b      	lsls	r3, r3, #24
 8001860:	4313      	orrs	r3, r2
 8001862:	613b      	str	r3, [r7, #16]
 8001864:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001866:	1d1a      	adds	r2, r3, #4
 8001868:	633a      	str	r2, [r7, #48]	@ 0x30
 800186a:	681a      	ldr	r2, [r3, #0]
 800186c:	693b      	ldr	r3, [r7, #16]
 800186e:	4053      	eors	r3, r2
 8001870:	613b      	str	r3, [r7, #16]
    GET_UINT32_LE( t.X[1], input,  4 ); t.X[1] ^= *RK++;
 8001872:	68bb      	ldr	r3, [r7, #8]
 8001874:	3304      	adds	r3, #4
 8001876:	781b      	ldrb	r3, [r3, #0]
 8001878:	461a      	mov	r2, r3
 800187a:	68bb      	ldr	r3, [r7, #8]
 800187c:	3305      	adds	r3, #5
 800187e:	781b      	ldrb	r3, [r3, #0]
 8001880:	021b      	lsls	r3, r3, #8
 8001882:	431a      	orrs	r2, r3
 8001884:	68bb      	ldr	r3, [r7, #8]
 8001886:	3306      	adds	r3, #6
 8001888:	781b      	ldrb	r3, [r3, #0]
 800188a:	041b      	lsls	r3, r3, #16
 800188c:	431a      	orrs	r2, r3
 800188e:	68bb      	ldr	r3, [r7, #8]
 8001890:	3307      	adds	r3, #7
 8001892:	781b      	ldrb	r3, [r3, #0]
 8001894:	061b      	lsls	r3, r3, #24
 8001896:	4313      	orrs	r3, r2
 8001898:	617b      	str	r3, [r7, #20]
 800189a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800189c:	1d1a      	adds	r2, r3, #4
 800189e:	633a      	str	r2, [r7, #48]	@ 0x30
 80018a0:	681a      	ldr	r2, [r3, #0]
 80018a2:	697b      	ldr	r3, [r7, #20]
 80018a4:	4053      	eors	r3, r2
 80018a6:	617b      	str	r3, [r7, #20]
    GET_UINT32_LE( t.X[2], input,  8 ); t.X[2] ^= *RK++;
 80018a8:	68bb      	ldr	r3, [r7, #8]
 80018aa:	3308      	adds	r3, #8
 80018ac:	781b      	ldrb	r3, [r3, #0]
 80018ae:	461a      	mov	r2, r3
 80018b0:	68bb      	ldr	r3, [r7, #8]
 80018b2:	3309      	adds	r3, #9
 80018b4:	781b      	ldrb	r3, [r3, #0]
 80018b6:	021b      	lsls	r3, r3, #8
 80018b8:	431a      	orrs	r2, r3
 80018ba:	68bb      	ldr	r3, [r7, #8]
 80018bc:	330a      	adds	r3, #10
 80018be:	781b      	ldrb	r3, [r3, #0]
 80018c0:	041b      	lsls	r3, r3, #16
 80018c2:	431a      	orrs	r2, r3
 80018c4:	68bb      	ldr	r3, [r7, #8]
 80018c6:	330b      	adds	r3, #11
 80018c8:	781b      	ldrb	r3, [r3, #0]
 80018ca:	061b      	lsls	r3, r3, #24
 80018cc:	4313      	orrs	r3, r2
 80018ce:	61bb      	str	r3, [r7, #24]
 80018d0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80018d2:	1d1a      	adds	r2, r3, #4
 80018d4:	633a      	str	r2, [r7, #48]	@ 0x30
 80018d6:	681a      	ldr	r2, [r3, #0]
 80018d8:	69bb      	ldr	r3, [r7, #24]
 80018da:	4053      	eors	r3, r2
 80018dc:	61bb      	str	r3, [r7, #24]
    GET_UINT32_LE( t.X[3], input, 12 ); t.X[3] ^= *RK++;
 80018de:	68bb      	ldr	r3, [r7, #8]
 80018e0:	330c      	adds	r3, #12
 80018e2:	781b      	ldrb	r3, [r3, #0]
 80018e4:	461a      	mov	r2, r3
 80018e6:	68bb      	ldr	r3, [r7, #8]
 80018e8:	330d      	adds	r3, #13
 80018ea:	781b      	ldrb	r3, [r3, #0]
 80018ec:	021b      	lsls	r3, r3, #8
 80018ee:	431a      	orrs	r2, r3
 80018f0:	68bb      	ldr	r3, [r7, #8]
 80018f2:	330e      	adds	r3, #14
 80018f4:	781b      	ldrb	r3, [r3, #0]
 80018f6:	041b      	lsls	r3, r3, #16
 80018f8:	431a      	orrs	r2, r3
 80018fa:	68bb      	ldr	r3, [r7, #8]
 80018fc:	330f      	adds	r3, #15
 80018fe:	781b      	ldrb	r3, [r3, #0]
 8001900:	061b      	lsls	r3, r3, #24
 8001902:	4313      	orrs	r3, r2
 8001904:	61fb      	str	r3, [r7, #28]
 8001906:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001908:	1d1a      	adds	r2, r3, #4
 800190a:	633a      	str	r2, [r7, #48]	@ 0x30
 800190c:	681a      	ldr	r2, [r3, #0]
 800190e:	69fb      	ldr	r3, [r7, #28]
 8001910:	4053      	eors	r3, r2
 8001912:	61fb      	str	r3, [r7, #28]

    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8001914:	68fb      	ldr	r3, [r7, #12]
 8001916:	681b      	ldr	r3, [r3, #0]
 8001918:	105b      	asrs	r3, r3, #1
 800191a:	3b01      	subs	r3, #1
 800191c:	637b      	str	r3, [r7, #52]	@ 0x34
 800191e:	e0fa      	b.n	8001b16 <mbedtls_internal_aes_decrypt+0x2ea>
    {
        AES_RROUND( t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3] );
 8001920:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001922:	1d1a      	adds	r2, r3, #4
 8001924:	633a      	str	r2, [r7, #48]	@ 0x30
 8001926:	681a      	ldr	r2, [r3, #0]
 8001928:	693b      	ldr	r3, [r7, #16]
 800192a:	b2db      	uxtb	r3, r3
 800192c:	49ab      	ldr	r1, [pc, #684]	@ (8001bdc <mbedtls_internal_aes_decrypt+0x3b0>)
 800192e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001932:	405a      	eors	r2, r3
 8001934:	69fb      	ldr	r3, [r7, #28]
 8001936:	0a1b      	lsrs	r3, r3, #8
 8001938:	b2db      	uxtb	r3, r3
 800193a:	49a9      	ldr	r1, [pc, #676]	@ (8001be0 <mbedtls_internal_aes_decrypt+0x3b4>)
 800193c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001940:	405a      	eors	r2, r3
 8001942:	69bb      	ldr	r3, [r7, #24]
 8001944:	0c1b      	lsrs	r3, r3, #16
 8001946:	b2db      	uxtb	r3, r3
 8001948:	49a6      	ldr	r1, [pc, #664]	@ (8001be4 <mbedtls_internal_aes_decrypt+0x3b8>)
 800194a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800194e:	405a      	eors	r2, r3
 8001950:	697b      	ldr	r3, [r7, #20]
 8001952:	0e1b      	lsrs	r3, r3, #24
 8001954:	49a4      	ldr	r1, [pc, #656]	@ (8001be8 <mbedtls_internal_aes_decrypt+0x3bc>)
 8001956:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800195a:	4053      	eors	r3, r2
 800195c:	623b      	str	r3, [r7, #32]
 800195e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001960:	1d1a      	adds	r2, r3, #4
 8001962:	633a      	str	r2, [r7, #48]	@ 0x30
 8001964:	681a      	ldr	r2, [r3, #0]
 8001966:	697b      	ldr	r3, [r7, #20]
 8001968:	b2db      	uxtb	r3, r3
 800196a:	499c      	ldr	r1, [pc, #624]	@ (8001bdc <mbedtls_internal_aes_decrypt+0x3b0>)
 800196c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001970:	405a      	eors	r2, r3
 8001972:	693b      	ldr	r3, [r7, #16]
 8001974:	0a1b      	lsrs	r3, r3, #8
 8001976:	b2db      	uxtb	r3, r3
 8001978:	4999      	ldr	r1, [pc, #612]	@ (8001be0 <mbedtls_internal_aes_decrypt+0x3b4>)
 800197a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800197e:	405a      	eors	r2, r3
 8001980:	69fb      	ldr	r3, [r7, #28]
 8001982:	0c1b      	lsrs	r3, r3, #16
 8001984:	b2db      	uxtb	r3, r3
 8001986:	4997      	ldr	r1, [pc, #604]	@ (8001be4 <mbedtls_internal_aes_decrypt+0x3b8>)
 8001988:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800198c:	405a      	eors	r2, r3
 800198e:	69bb      	ldr	r3, [r7, #24]
 8001990:	0e1b      	lsrs	r3, r3, #24
 8001992:	4995      	ldr	r1, [pc, #596]	@ (8001be8 <mbedtls_internal_aes_decrypt+0x3bc>)
 8001994:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001998:	4053      	eors	r3, r2
 800199a:	627b      	str	r3, [r7, #36]	@ 0x24
 800199c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800199e:	1d1a      	adds	r2, r3, #4
 80019a0:	633a      	str	r2, [r7, #48]	@ 0x30
 80019a2:	681a      	ldr	r2, [r3, #0]
 80019a4:	69bb      	ldr	r3, [r7, #24]
 80019a6:	b2db      	uxtb	r3, r3
 80019a8:	498c      	ldr	r1, [pc, #560]	@ (8001bdc <mbedtls_internal_aes_decrypt+0x3b0>)
 80019aa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80019ae:	405a      	eors	r2, r3
 80019b0:	697b      	ldr	r3, [r7, #20]
 80019b2:	0a1b      	lsrs	r3, r3, #8
 80019b4:	b2db      	uxtb	r3, r3
 80019b6:	498a      	ldr	r1, [pc, #552]	@ (8001be0 <mbedtls_internal_aes_decrypt+0x3b4>)
 80019b8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80019bc:	405a      	eors	r2, r3
 80019be:	693b      	ldr	r3, [r7, #16]
 80019c0:	0c1b      	lsrs	r3, r3, #16
 80019c2:	b2db      	uxtb	r3, r3
 80019c4:	4987      	ldr	r1, [pc, #540]	@ (8001be4 <mbedtls_internal_aes_decrypt+0x3b8>)
 80019c6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80019ca:	405a      	eors	r2, r3
 80019cc:	69fb      	ldr	r3, [r7, #28]
 80019ce:	0e1b      	lsrs	r3, r3, #24
 80019d0:	4985      	ldr	r1, [pc, #532]	@ (8001be8 <mbedtls_internal_aes_decrypt+0x3bc>)
 80019d2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80019d6:	4053      	eors	r3, r2
 80019d8:	62bb      	str	r3, [r7, #40]	@ 0x28
 80019da:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80019dc:	1d1a      	adds	r2, r3, #4
 80019de:	633a      	str	r2, [r7, #48]	@ 0x30
 80019e0:	681a      	ldr	r2, [r3, #0]
 80019e2:	69fb      	ldr	r3, [r7, #28]
 80019e4:	b2db      	uxtb	r3, r3
 80019e6:	497d      	ldr	r1, [pc, #500]	@ (8001bdc <mbedtls_internal_aes_decrypt+0x3b0>)
 80019e8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80019ec:	405a      	eors	r2, r3
 80019ee:	69bb      	ldr	r3, [r7, #24]
 80019f0:	0a1b      	lsrs	r3, r3, #8
 80019f2:	b2db      	uxtb	r3, r3
 80019f4:	497a      	ldr	r1, [pc, #488]	@ (8001be0 <mbedtls_internal_aes_decrypt+0x3b4>)
 80019f6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80019fa:	405a      	eors	r2, r3
 80019fc:	697b      	ldr	r3, [r7, #20]
 80019fe:	0c1b      	lsrs	r3, r3, #16
 8001a00:	b2db      	uxtb	r3, r3
 8001a02:	4978      	ldr	r1, [pc, #480]	@ (8001be4 <mbedtls_internal_aes_decrypt+0x3b8>)
 8001a04:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001a08:	405a      	eors	r2, r3
 8001a0a:	693b      	ldr	r3, [r7, #16]
 8001a0c:	0e1b      	lsrs	r3, r3, #24
 8001a0e:	4976      	ldr	r1, [pc, #472]	@ (8001be8 <mbedtls_internal_aes_decrypt+0x3bc>)
 8001a10:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001a14:	4053      	eors	r3, r2
 8001a16:	62fb      	str	r3, [r7, #44]	@ 0x2c
        AES_RROUND( t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3] );
 8001a18:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001a1a:	1d1a      	adds	r2, r3, #4
 8001a1c:	633a      	str	r2, [r7, #48]	@ 0x30
 8001a1e:	681a      	ldr	r2, [r3, #0]
 8001a20:	6a3b      	ldr	r3, [r7, #32]
 8001a22:	b2db      	uxtb	r3, r3
 8001a24:	496d      	ldr	r1, [pc, #436]	@ (8001bdc <mbedtls_internal_aes_decrypt+0x3b0>)
 8001a26:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001a2a:	405a      	eors	r2, r3
 8001a2c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8001a2e:	0a1b      	lsrs	r3, r3, #8
 8001a30:	b2db      	uxtb	r3, r3
 8001a32:	496b      	ldr	r1, [pc, #428]	@ (8001be0 <mbedtls_internal_aes_decrypt+0x3b4>)
 8001a34:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001a38:	405a      	eors	r2, r3
 8001a3a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001a3c:	0c1b      	lsrs	r3, r3, #16
 8001a3e:	b2db      	uxtb	r3, r3
 8001a40:	4968      	ldr	r1, [pc, #416]	@ (8001be4 <mbedtls_internal_aes_decrypt+0x3b8>)
 8001a42:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001a46:	405a      	eors	r2, r3
 8001a48:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001a4a:	0e1b      	lsrs	r3, r3, #24
 8001a4c:	4966      	ldr	r1, [pc, #408]	@ (8001be8 <mbedtls_internal_aes_decrypt+0x3bc>)
 8001a4e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001a52:	4053      	eors	r3, r2
 8001a54:	613b      	str	r3, [r7, #16]
 8001a56:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001a58:	1d1a      	adds	r2, r3, #4
 8001a5a:	633a      	str	r2, [r7, #48]	@ 0x30
 8001a5c:	681a      	ldr	r2, [r3, #0]
 8001a5e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001a60:	b2db      	uxtb	r3, r3
 8001a62:	495e      	ldr	r1, [pc, #376]	@ (8001bdc <mbedtls_internal_aes_decrypt+0x3b0>)
 8001a64:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001a68:	405a      	eors	r2, r3
 8001a6a:	6a3b      	ldr	r3, [r7, #32]
 8001a6c:	0a1b      	lsrs	r3, r3, #8
 8001a6e:	b2db      	uxtb	r3, r3
 8001a70:	495b      	ldr	r1, [pc, #364]	@ (8001be0 <mbedtls_internal_aes_decrypt+0x3b4>)
 8001a72:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001a76:	405a      	eors	r2, r3
 8001a78:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8001a7a:	0c1b      	lsrs	r3, r3, #16
 8001a7c:	b2db      	uxtb	r3, r3
 8001a7e:	4959      	ldr	r1, [pc, #356]	@ (8001be4 <mbedtls_internal_aes_decrypt+0x3b8>)
 8001a80:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001a84:	405a      	eors	r2, r3
 8001a86:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001a88:	0e1b      	lsrs	r3, r3, #24
 8001a8a:	4957      	ldr	r1, [pc, #348]	@ (8001be8 <mbedtls_internal_aes_decrypt+0x3bc>)
 8001a8c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001a90:	4053      	eors	r3, r2
 8001a92:	617b      	str	r3, [r7, #20]
 8001a94:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001a96:	1d1a      	adds	r2, r3, #4
 8001a98:	633a      	str	r2, [r7, #48]	@ 0x30
 8001a9a:	681a      	ldr	r2, [r3, #0]
 8001a9c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001a9e:	b2db      	uxtb	r3, r3
 8001aa0:	494e      	ldr	r1, [pc, #312]	@ (8001bdc <mbedtls_internal_aes_decrypt+0x3b0>)
 8001aa2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001aa6:	405a      	eors	r2, r3
 8001aa8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001aaa:	0a1b      	lsrs	r3, r3, #8
 8001aac:	b2db      	uxtb	r3, r3
 8001aae:	494c      	ldr	r1, [pc, #304]	@ (8001be0 <mbedtls_internal_aes_decrypt+0x3b4>)
 8001ab0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001ab4:	405a      	eors	r2, r3
 8001ab6:	6a3b      	ldr	r3, [r7, #32]
 8001ab8:	0c1b      	lsrs	r3, r3, #16
 8001aba:	b2db      	uxtb	r3, r3
 8001abc:	4949      	ldr	r1, [pc, #292]	@ (8001be4 <mbedtls_internal_aes_decrypt+0x3b8>)
 8001abe:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001ac2:	405a      	eors	r2, r3
 8001ac4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8001ac6:	0e1b      	lsrs	r3, r3, #24
 8001ac8:	4947      	ldr	r1, [pc, #284]	@ (8001be8 <mbedtls_internal_aes_decrypt+0x3bc>)
 8001aca:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001ace:	4053      	eors	r3, r2
 8001ad0:	61bb      	str	r3, [r7, #24]
 8001ad2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001ad4:	1d1a      	adds	r2, r3, #4
 8001ad6:	633a      	str	r2, [r7, #48]	@ 0x30
 8001ad8:	681a      	ldr	r2, [r3, #0]
 8001ada:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8001adc:	b2db      	uxtb	r3, r3
 8001ade:	493f      	ldr	r1, [pc, #252]	@ (8001bdc <mbedtls_internal_aes_decrypt+0x3b0>)
 8001ae0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001ae4:	405a      	eors	r2, r3
 8001ae6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001ae8:	0a1b      	lsrs	r3, r3, #8
 8001aea:	b2db      	uxtb	r3, r3
 8001aec:	493c      	ldr	r1, [pc, #240]	@ (8001be0 <mbedtls_internal_aes_decrypt+0x3b4>)
 8001aee:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001af2:	405a      	eors	r2, r3
 8001af4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001af6:	0c1b      	lsrs	r3, r3, #16
 8001af8:	b2db      	uxtb	r3, r3
 8001afa:	493a      	ldr	r1, [pc, #232]	@ (8001be4 <mbedtls_internal_aes_decrypt+0x3b8>)
 8001afc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001b00:	405a      	eors	r2, r3
 8001b02:	6a3b      	ldr	r3, [r7, #32]
 8001b04:	0e1b      	lsrs	r3, r3, #24
 8001b06:	4938      	ldr	r1, [pc, #224]	@ (8001be8 <mbedtls_internal_aes_decrypt+0x3bc>)
 8001b08:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001b0c:	4053      	eors	r3, r2
 8001b0e:	61fb      	str	r3, [r7, #28]
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8001b10:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8001b12:	3b01      	subs	r3, #1
 8001b14:	637b      	str	r3, [r7, #52]	@ 0x34
 8001b16:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8001b18:	2b00      	cmp	r3, #0
 8001b1a:	f73f af01 	bgt.w	8001920 <mbedtls_internal_aes_decrypt+0xf4>
    }

    AES_RROUND( t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3] );
 8001b1e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001b20:	1d1a      	adds	r2, r3, #4
 8001b22:	633a      	str	r2, [r7, #48]	@ 0x30
 8001b24:	681a      	ldr	r2, [r3, #0]
 8001b26:	693b      	ldr	r3, [r7, #16]
 8001b28:	b2db      	uxtb	r3, r3
 8001b2a:	492c      	ldr	r1, [pc, #176]	@ (8001bdc <mbedtls_internal_aes_decrypt+0x3b0>)
 8001b2c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001b30:	405a      	eors	r2, r3
 8001b32:	69fb      	ldr	r3, [r7, #28]
 8001b34:	0a1b      	lsrs	r3, r3, #8
 8001b36:	b2db      	uxtb	r3, r3
 8001b38:	4929      	ldr	r1, [pc, #164]	@ (8001be0 <mbedtls_internal_aes_decrypt+0x3b4>)
 8001b3a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001b3e:	405a      	eors	r2, r3
 8001b40:	69bb      	ldr	r3, [r7, #24]
 8001b42:	0c1b      	lsrs	r3, r3, #16
 8001b44:	b2db      	uxtb	r3, r3
 8001b46:	4927      	ldr	r1, [pc, #156]	@ (8001be4 <mbedtls_internal_aes_decrypt+0x3b8>)
 8001b48:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001b4c:	405a      	eors	r2, r3
 8001b4e:	697b      	ldr	r3, [r7, #20]
 8001b50:	0e1b      	lsrs	r3, r3, #24
 8001b52:	4925      	ldr	r1, [pc, #148]	@ (8001be8 <mbedtls_internal_aes_decrypt+0x3bc>)
 8001b54:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001b58:	4053      	eors	r3, r2
 8001b5a:	623b      	str	r3, [r7, #32]
 8001b5c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001b5e:	1d1a      	adds	r2, r3, #4
 8001b60:	633a      	str	r2, [r7, #48]	@ 0x30
 8001b62:	681a      	ldr	r2, [r3, #0]
 8001b64:	697b      	ldr	r3, [r7, #20]
 8001b66:	b2db      	uxtb	r3, r3
 8001b68:	491c      	ldr	r1, [pc, #112]	@ (8001bdc <mbedtls_internal_aes_decrypt+0x3b0>)
 8001b6a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001b6e:	405a      	eors	r2, r3
 8001b70:	693b      	ldr	r3, [r7, #16]
 8001b72:	0a1b      	lsrs	r3, r3, #8
 8001b74:	b2db      	uxtb	r3, r3
 8001b76:	491a      	ldr	r1, [pc, #104]	@ (8001be0 <mbedtls_internal_aes_decrypt+0x3b4>)
 8001b78:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001b7c:	405a      	eors	r2, r3
 8001b7e:	69fb      	ldr	r3, [r7, #28]
 8001b80:	0c1b      	lsrs	r3, r3, #16
 8001b82:	b2db      	uxtb	r3, r3
 8001b84:	4917      	ldr	r1, [pc, #92]	@ (8001be4 <mbedtls_internal_aes_decrypt+0x3b8>)
 8001b86:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001b8a:	405a      	eors	r2, r3
 8001b8c:	69bb      	ldr	r3, [r7, #24]
 8001b8e:	0e1b      	lsrs	r3, r3, #24
 8001b90:	4915      	ldr	r1, [pc, #84]	@ (8001be8 <mbedtls_internal_aes_decrypt+0x3bc>)
 8001b92:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001b96:	4053      	eors	r3, r2
 8001b98:	627b      	str	r3, [r7, #36]	@ 0x24
 8001b9a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001b9c:	1d1a      	adds	r2, r3, #4
 8001b9e:	633a      	str	r2, [r7, #48]	@ 0x30
 8001ba0:	681a      	ldr	r2, [r3, #0]
 8001ba2:	69bb      	ldr	r3, [r7, #24]
 8001ba4:	b2db      	uxtb	r3, r3
 8001ba6:	490d      	ldr	r1, [pc, #52]	@ (8001bdc <mbedtls_internal_aes_decrypt+0x3b0>)
 8001ba8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001bac:	405a      	eors	r2, r3
 8001bae:	697b      	ldr	r3, [r7, #20]
 8001bb0:	0a1b      	lsrs	r3, r3, #8
 8001bb2:	b2db      	uxtb	r3, r3
 8001bb4:	490a      	ldr	r1, [pc, #40]	@ (8001be0 <mbedtls_internal_aes_decrypt+0x3b4>)
 8001bb6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001bba:	405a      	eors	r2, r3
 8001bbc:	693b      	ldr	r3, [r7, #16]
 8001bbe:	0c1b      	lsrs	r3, r3, #16
 8001bc0:	b2db      	uxtb	r3, r3
 8001bc2:	4908      	ldr	r1, [pc, #32]	@ (8001be4 <mbedtls_internal_aes_decrypt+0x3b8>)
 8001bc4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001bc8:	405a      	eors	r2, r3
 8001bca:	69fb      	ldr	r3, [r7, #28]
 8001bcc:	0e1b      	lsrs	r3, r3, #24
 8001bce:	4906      	ldr	r1, [pc, #24]	@ (8001be8 <mbedtls_internal_aes_decrypt+0x3bc>)
 8001bd0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001bd4:	4053      	eors	r3, r2
 8001bd6:	62bb      	str	r3, [r7, #40]	@ 0x28
 8001bd8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001bda:	e007      	b.n	8001bec <mbedtls_internal_aes_decrypt+0x3c0>
 8001bdc:	200012b4 	.word	0x200012b4
 8001be0:	200016b4 	.word	0x200016b4
 8001be4:	20001ab4 	.word	0x20001ab4
 8001be8:	20001eb4 	.word	0x20001eb4
 8001bec:	1d1a      	adds	r2, r3, #4
 8001bee:	633a      	str	r2, [r7, #48]	@ 0x30
 8001bf0:	681a      	ldr	r2, [r3, #0]
 8001bf2:	69fb      	ldr	r3, [r7, #28]
 8001bf4:	b2db      	uxtb	r3, r3
 8001bf6:	497b      	ldr	r1, [pc, #492]	@ (8001de4 <mbedtls_internal_aes_decrypt+0x5b8>)
 8001bf8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001bfc:	405a      	eors	r2, r3
 8001bfe:	69bb      	ldr	r3, [r7, #24]
 8001c00:	0a1b      	lsrs	r3, r3, #8
 8001c02:	b2db      	uxtb	r3, r3
 8001c04:	4978      	ldr	r1, [pc, #480]	@ (8001de8 <mbedtls_internal_aes_decrypt+0x5bc>)
 8001c06:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001c0a:	405a      	eors	r2, r3
 8001c0c:	697b      	ldr	r3, [r7, #20]
 8001c0e:	0c1b      	lsrs	r3, r3, #16
 8001c10:	b2db      	uxtb	r3, r3
 8001c12:	4976      	ldr	r1, [pc, #472]	@ (8001dec <mbedtls_internal_aes_decrypt+0x5c0>)
 8001c14:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001c18:	405a      	eors	r2, r3
 8001c1a:	693b      	ldr	r3, [r7, #16]
 8001c1c:	0e1b      	lsrs	r3, r3, #24
 8001c1e:	4974      	ldr	r1, [pc, #464]	@ (8001df0 <mbedtls_internal_aes_decrypt+0x5c4>)
 8001c20:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001c24:	4053      	eors	r3, r2
 8001c26:	62fb      	str	r3, [r7, #44]	@ 0x2c

    t.X[0] = *RK++ ^ \
 8001c28:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001c2a:	1d1a      	adds	r2, r3, #4
 8001c2c:	633a      	str	r2, [r7, #48]	@ 0x30
 8001c2e:	681b      	ldr	r3, [r3, #0]
            ( (uint32_t) RSb[ ( t.Y[0]       ) & 0xFF ]       ) ^
 8001c30:	6a3a      	ldr	r2, [r7, #32]
 8001c32:	b2d2      	uxtb	r2, r2
 8001c34:	496f      	ldr	r1, [pc, #444]	@ (8001df4 <mbedtls_internal_aes_decrypt+0x5c8>)
 8001c36:	5c8a      	ldrb	r2, [r1, r2]
    t.X[0] = *RK++ ^ \
 8001c38:	405a      	eors	r2, r3
            ( (uint32_t) RSb[ ( t.Y[3] >>  8 ) & 0xFF ] <<  8 ) ^
 8001c3a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8001c3c:	0a1b      	lsrs	r3, r3, #8
 8001c3e:	b2db      	uxtb	r3, r3
 8001c40:	496c      	ldr	r1, [pc, #432]	@ (8001df4 <mbedtls_internal_aes_decrypt+0x5c8>)
 8001c42:	5ccb      	ldrb	r3, [r1, r3]
 8001c44:	021b      	lsls	r3, r3, #8
            ( (uint32_t) RSb[ ( t.Y[0]       ) & 0xFF ]       ) ^
 8001c46:	405a      	eors	r2, r3
            ( (uint32_t) RSb[ ( t.Y[2] >> 16 ) & 0xFF ] << 16 ) ^
 8001c48:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001c4a:	0c1b      	lsrs	r3, r3, #16
 8001c4c:	b2db      	uxtb	r3, r3
 8001c4e:	4969      	ldr	r1, [pc, #420]	@ (8001df4 <mbedtls_internal_aes_decrypt+0x5c8>)
 8001c50:	5ccb      	ldrb	r3, [r1, r3]
 8001c52:	041b      	lsls	r3, r3, #16
            ( (uint32_t) RSb[ ( t.Y[3] >>  8 ) & 0xFF ] <<  8 ) ^
 8001c54:	405a      	eors	r2, r3
            ( (uint32_t) RSb[ ( t.Y[1] >> 24 ) & 0xFF ] << 24 );
 8001c56:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001c58:	0e1b      	lsrs	r3, r3, #24
 8001c5a:	4966      	ldr	r1, [pc, #408]	@ (8001df4 <mbedtls_internal_aes_decrypt+0x5c8>)
 8001c5c:	5ccb      	ldrb	r3, [r1, r3]
 8001c5e:	061b      	lsls	r3, r3, #24
            ( (uint32_t) RSb[ ( t.Y[2] >> 16 ) & 0xFF ] << 16 ) ^
 8001c60:	4053      	eors	r3, r2
    t.X[0] = *RK++ ^ \
 8001c62:	613b      	str	r3, [r7, #16]

    t.X[1] = *RK++ ^ \
 8001c64:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001c66:	1d1a      	adds	r2, r3, #4
 8001c68:	633a      	str	r2, [r7, #48]	@ 0x30
 8001c6a:	681b      	ldr	r3, [r3, #0]
            ( (uint32_t) RSb[ ( t.Y[1]       ) & 0xFF ]       ) ^
 8001c6c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8001c6e:	b2d2      	uxtb	r2, r2
 8001c70:	4960      	ldr	r1, [pc, #384]	@ (8001df4 <mbedtls_internal_aes_decrypt+0x5c8>)
 8001c72:	5c8a      	ldrb	r2, [r1, r2]
    t.X[1] = *RK++ ^ \
 8001c74:	405a      	eors	r2, r3
            ( (uint32_t) RSb[ ( t.Y[0] >>  8 ) & 0xFF ] <<  8 ) ^
 8001c76:	6a3b      	ldr	r3, [r7, #32]
 8001c78:	0a1b      	lsrs	r3, r3, #8
 8001c7a:	b2db      	uxtb	r3, r3
 8001c7c:	495d      	ldr	r1, [pc, #372]	@ (8001df4 <mbedtls_internal_aes_decrypt+0x5c8>)
 8001c7e:	5ccb      	ldrb	r3, [r1, r3]
 8001c80:	021b      	lsls	r3, r3, #8
            ( (uint32_t) RSb[ ( t.Y[1]       ) & 0xFF ]       ) ^
 8001c82:	405a      	eors	r2, r3
            ( (uint32_t) RSb[ ( t.Y[3] >> 16 ) & 0xFF ] << 16 ) ^
 8001c84:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8001c86:	0c1b      	lsrs	r3, r3, #16
 8001c88:	b2db      	uxtb	r3, r3
 8001c8a:	495a      	ldr	r1, [pc, #360]	@ (8001df4 <mbedtls_internal_aes_decrypt+0x5c8>)
 8001c8c:	5ccb      	ldrb	r3, [r1, r3]
 8001c8e:	041b      	lsls	r3, r3, #16
            ( (uint32_t) RSb[ ( t.Y[0] >>  8 ) & 0xFF ] <<  8 ) ^
 8001c90:	405a      	eors	r2, r3
            ( (uint32_t) RSb[ ( t.Y[2] >> 24 ) & 0xFF ] << 24 );
 8001c92:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001c94:	0e1b      	lsrs	r3, r3, #24
 8001c96:	4957      	ldr	r1, [pc, #348]	@ (8001df4 <mbedtls_internal_aes_decrypt+0x5c8>)
 8001c98:	5ccb      	ldrb	r3, [r1, r3]
 8001c9a:	061b      	lsls	r3, r3, #24
            ( (uint32_t) RSb[ ( t.Y[3] >> 16 ) & 0xFF ] << 16 ) ^
 8001c9c:	4053      	eors	r3, r2
    t.X[1] = *RK++ ^ \
 8001c9e:	617b      	str	r3, [r7, #20]

    t.X[2] = *RK++ ^ \
 8001ca0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001ca2:	1d1a      	adds	r2, r3, #4
 8001ca4:	633a      	str	r2, [r7, #48]	@ 0x30
 8001ca6:	681b      	ldr	r3, [r3, #0]
            ( (uint32_t) RSb[ ( t.Y[2]       ) & 0xFF ]       ) ^
 8001ca8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8001caa:	b2d2      	uxtb	r2, r2
 8001cac:	4951      	ldr	r1, [pc, #324]	@ (8001df4 <mbedtls_internal_aes_decrypt+0x5c8>)
 8001cae:	5c8a      	ldrb	r2, [r1, r2]
    t.X[2] = *RK++ ^ \
 8001cb0:	405a      	eors	r2, r3
            ( (uint32_t) RSb[ ( t.Y[1] >>  8 ) & 0xFF ] <<  8 ) ^
 8001cb2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001cb4:	0a1b      	lsrs	r3, r3, #8
 8001cb6:	b2db      	uxtb	r3, r3
 8001cb8:	494e      	ldr	r1, [pc, #312]	@ (8001df4 <mbedtls_internal_aes_decrypt+0x5c8>)
 8001cba:	5ccb      	ldrb	r3, [r1, r3]
 8001cbc:	021b      	lsls	r3, r3, #8
            ( (uint32_t) RSb[ ( t.Y[2]       ) & 0xFF ]       ) ^
 8001cbe:	405a      	eors	r2, r3
            ( (uint32_t) RSb[ ( t.Y[0] >> 16 ) & 0xFF ] << 16 ) ^
 8001cc0:	6a3b      	ldr	r3, [r7, #32]
 8001cc2:	0c1b      	lsrs	r3, r3, #16
 8001cc4:	b2db      	uxtb	r3, r3
 8001cc6:	494b      	ldr	r1, [pc, #300]	@ (8001df4 <mbedtls_internal_aes_decrypt+0x5c8>)
 8001cc8:	5ccb      	ldrb	r3, [r1, r3]
 8001cca:	041b      	lsls	r3, r3, #16
            ( (uint32_t) RSb[ ( t.Y[1] >>  8 ) & 0xFF ] <<  8 ) ^
 8001ccc:	405a      	eors	r2, r3
            ( (uint32_t) RSb[ ( t.Y[3] >> 24 ) & 0xFF ] << 24 );
 8001cce:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8001cd0:	0e1b      	lsrs	r3, r3, #24
 8001cd2:	4948      	ldr	r1, [pc, #288]	@ (8001df4 <mbedtls_internal_aes_decrypt+0x5c8>)
 8001cd4:	5ccb      	ldrb	r3, [r1, r3]
 8001cd6:	061b      	lsls	r3, r3, #24
            ( (uint32_t) RSb[ ( t.Y[0] >> 16 ) & 0xFF ] << 16 ) ^
 8001cd8:	4053      	eors	r3, r2
    t.X[2] = *RK++ ^ \
 8001cda:	61bb      	str	r3, [r7, #24]

    t.X[3] = *RK++ ^ \
 8001cdc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001cde:	1d1a      	adds	r2, r3, #4
 8001ce0:	633a      	str	r2, [r7, #48]	@ 0x30
 8001ce2:	681b      	ldr	r3, [r3, #0]
            ( (uint32_t) RSb[ ( t.Y[3]       ) & 0xFF ]       ) ^
 8001ce4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8001ce6:	b2d2      	uxtb	r2, r2
 8001ce8:	4942      	ldr	r1, [pc, #264]	@ (8001df4 <mbedtls_internal_aes_decrypt+0x5c8>)
 8001cea:	5c8a      	ldrb	r2, [r1, r2]
    t.X[3] = *RK++ ^ \
 8001cec:	405a      	eors	r2, r3
            ( (uint32_t) RSb[ ( t.Y[2] >>  8 ) & 0xFF ] <<  8 ) ^
 8001cee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001cf0:	0a1b      	lsrs	r3, r3, #8
 8001cf2:	b2db      	uxtb	r3, r3
 8001cf4:	493f      	ldr	r1, [pc, #252]	@ (8001df4 <mbedtls_internal_aes_decrypt+0x5c8>)
 8001cf6:	5ccb      	ldrb	r3, [r1, r3]
 8001cf8:	021b      	lsls	r3, r3, #8
            ( (uint32_t) RSb[ ( t.Y[3]       ) & 0xFF ]       ) ^
 8001cfa:	405a      	eors	r2, r3
            ( (uint32_t) RSb[ ( t.Y[1] >> 16 ) & 0xFF ] << 16 ) ^
 8001cfc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001cfe:	0c1b      	lsrs	r3, r3, #16
 8001d00:	b2db      	uxtb	r3, r3
 8001d02:	493c      	ldr	r1, [pc, #240]	@ (8001df4 <mbedtls_internal_aes_decrypt+0x5c8>)
 8001d04:	5ccb      	ldrb	r3, [r1, r3]
 8001d06:	041b      	lsls	r3, r3, #16
            ( (uint32_t) RSb[ ( t.Y[2] >>  8 ) & 0xFF ] <<  8 ) ^
 8001d08:	405a      	eors	r2, r3
            ( (uint32_t) RSb[ ( t.Y[0] >> 24 ) & 0xFF ] << 24 );
 8001d0a:	6a3b      	ldr	r3, [r7, #32]
 8001d0c:	0e1b      	lsrs	r3, r3, #24
 8001d0e:	4939      	ldr	r1, [pc, #228]	@ (8001df4 <mbedtls_internal_aes_decrypt+0x5c8>)
 8001d10:	5ccb      	ldrb	r3, [r1, r3]
 8001d12:	061b      	lsls	r3, r3, #24
            ( (uint32_t) RSb[ ( t.Y[1] >> 16 ) & 0xFF ] << 16 ) ^
 8001d14:	4053      	eors	r3, r2
    t.X[3] = *RK++ ^ \
 8001d16:	61fb      	str	r3, [r7, #28]

    PUT_UINT32_LE( t.X[0], output,  0 );
 8001d18:	693b      	ldr	r3, [r7, #16]
 8001d1a:	b2da      	uxtb	r2, r3
 8001d1c:	687b      	ldr	r3, [r7, #4]
 8001d1e:	701a      	strb	r2, [r3, #0]
 8001d20:	693b      	ldr	r3, [r7, #16]
 8001d22:	0a1a      	lsrs	r2, r3, #8
 8001d24:	687b      	ldr	r3, [r7, #4]
 8001d26:	3301      	adds	r3, #1
 8001d28:	b2d2      	uxtb	r2, r2
 8001d2a:	701a      	strb	r2, [r3, #0]
 8001d2c:	693b      	ldr	r3, [r7, #16]
 8001d2e:	0c1a      	lsrs	r2, r3, #16
 8001d30:	687b      	ldr	r3, [r7, #4]
 8001d32:	3302      	adds	r3, #2
 8001d34:	b2d2      	uxtb	r2, r2
 8001d36:	701a      	strb	r2, [r3, #0]
 8001d38:	693b      	ldr	r3, [r7, #16]
 8001d3a:	0e1a      	lsrs	r2, r3, #24
 8001d3c:	687b      	ldr	r3, [r7, #4]
 8001d3e:	3303      	adds	r3, #3
 8001d40:	b2d2      	uxtb	r2, r2
 8001d42:	701a      	strb	r2, [r3, #0]
    PUT_UINT32_LE( t.X[1], output,  4 );
 8001d44:	697a      	ldr	r2, [r7, #20]
 8001d46:	687b      	ldr	r3, [r7, #4]
 8001d48:	3304      	adds	r3, #4
 8001d4a:	b2d2      	uxtb	r2, r2
 8001d4c:	701a      	strb	r2, [r3, #0]
 8001d4e:	697b      	ldr	r3, [r7, #20]
 8001d50:	0a1a      	lsrs	r2, r3, #8
 8001d52:	687b      	ldr	r3, [r7, #4]
 8001d54:	3305      	adds	r3, #5
 8001d56:	b2d2      	uxtb	r2, r2
 8001d58:	701a      	strb	r2, [r3, #0]
 8001d5a:	697b      	ldr	r3, [r7, #20]
 8001d5c:	0c1a      	lsrs	r2, r3, #16
 8001d5e:	687b      	ldr	r3, [r7, #4]
 8001d60:	3306      	adds	r3, #6
 8001d62:	b2d2      	uxtb	r2, r2
 8001d64:	701a      	strb	r2, [r3, #0]
 8001d66:	697b      	ldr	r3, [r7, #20]
 8001d68:	0e1a      	lsrs	r2, r3, #24
 8001d6a:	687b      	ldr	r3, [r7, #4]
 8001d6c:	3307      	adds	r3, #7
 8001d6e:	b2d2      	uxtb	r2, r2
 8001d70:	701a      	strb	r2, [r3, #0]
    PUT_UINT32_LE( t.X[2], output,  8 );
 8001d72:	69ba      	ldr	r2, [r7, #24]
 8001d74:	687b      	ldr	r3, [r7, #4]
 8001d76:	3308      	adds	r3, #8
 8001d78:	b2d2      	uxtb	r2, r2
 8001d7a:	701a      	strb	r2, [r3, #0]
 8001d7c:	69bb      	ldr	r3, [r7, #24]
 8001d7e:	0a1a      	lsrs	r2, r3, #8
 8001d80:	687b      	ldr	r3, [r7, #4]
 8001d82:	3309      	adds	r3, #9
 8001d84:	b2d2      	uxtb	r2, r2
 8001d86:	701a      	strb	r2, [r3, #0]
 8001d88:	69bb      	ldr	r3, [r7, #24]
 8001d8a:	0c1a      	lsrs	r2, r3, #16
 8001d8c:	687b      	ldr	r3, [r7, #4]
 8001d8e:	330a      	adds	r3, #10
 8001d90:	b2d2      	uxtb	r2, r2
 8001d92:	701a      	strb	r2, [r3, #0]
 8001d94:	69bb      	ldr	r3, [r7, #24]
 8001d96:	0e1a      	lsrs	r2, r3, #24
 8001d98:	687b      	ldr	r3, [r7, #4]
 8001d9a:	330b      	adds	r3, #11
 8001d9c:	b2d2      	uxtb	r2, r2
 8001d9e:	701a      	strb	r2, [r3, #0]
    PUT_UINT32_LE( t.X[3], output, 12 );
 8001da0:	69fa      	ldr	r2, [r7, #28]
 8001da2:	687b      	ldr	r3, [r7, #4]
 8001da4:	330c      	adds	r3, #12
 8001da6:	b2d2      	uxtb	r2, r2
 8001da8:	701a      	strb	r2, [r3, #0]
 8001daa:	69fb      	ldr	r3, [r7, #28]
 8001dac:	0a1a      	lsrs	r2, r3, #8
 8001dae:	687b      	ldr	r3, [r7, #4]
 8001db0:	330d      	adds	r3, #13
 8001db2:	b2d2      	uxtb	r2, r2
 8001db4:	701a      	strb	r2, [r3, #0]
 8001db6:	69fb      	ldr	r3, [r7, #28]
 8001db8:	0c1a      	lsrs	r2, r3, #16
 8001dba:	687b      	ldr	r3, [r7, #4]
 8001dbc:	330e      	adds	r3, #14
 8001dbe:	b2d2      	uxtb	r2, r2
 8001dc0:	701a      	strb	r2, [r3, #0]
 8001dc2:	69fb      	ldr	r3, [r7, #28]
 8001dc4:	0e1a      	lsrs	r2, r3, #24
 8001dc6:	687b      	ldr	r3, [r7, #4]
 8001dc8:	330f      	adds	r3, #15
 8001dca:	b2d2      	uxtb	r2, r2
 8001dcc:	701a      	strb	r2, [r3, #0]

    mbedtls_platform_zeroize( &t, sizeof( t ) );
 8001dce:	f107 0310 	add.w	r3, r7, #16
 8001dd2:	2120      	movs	r1, #32
 8001dd4:	4618      	mov	r0, r3
 8001dd6:	f004 fa03 	bl	80061e0 <mbedtls_platform_zeroize>

    return( 0 );
 8001dda:	2300      	movs	r3, #0
}
 8001ddc:	4618      	mov	r0, r3
 8001dde:	3738      	adds	r7, #56	@ 0x38
 8001de0:	46bd      	mov	sp, r7
 8001de2:	bd80      	pop	{r7, pc}
 8001de4:	200012b4 	.word	0x200012b4
 8001de8:	200016b4 	.word	0x200016b4
 8001dec:	20001ab4 	.word	0x20001ab4
 8001df0:	20001eb4 	.word	0x20001eb4
 8001df4:	200011b4 	.word	0x200011b4

08001df8 <mbedtls_aes_crypt_ecb>:
 */
int mbedtls_aes_crypt_ecb( mbedtls_aes_context *ctx,
                           int mode,
                           const unsigned char input[16],
                           unsigned char output[16] )
{
 8001df8:	b580      	push	{r7, lr}
 8001dfa:	b084      	sub	sp, #16
 8001dfc:	af00      	add	r7, sp, #0
 8001dfe:	60f8      	str	r0, [r7, #12]
 8001e00:	60b9      	str	r1, [r7, #8]
 8001e02:	607a      	str	r2, [r7, #4]
 8001e04:	603b      	str	r3, [r7, #0]
        // unaccelerated mode
        //
    }
#endif

    if( mode == MBEDTLS_AES_ENCRYPT )
 8001e06:	68bb      	ldr	r3, [r7, #8]
 8001e08:	2b01      	cmp	r3, #1
 8001e0a:	d106      	bne.n	8001e1a <mbedtls_aes_crypt_ecb+0x22>
        return( mbedtls_internal_aes_encrypt( ctx, input, output ) );
 8001e0c:	683a      	ldr	r2, [r7, #0]
 8001e0e:	6879      	ldr	r1, [r7, #4]
 8001e10:	68f8      	ldr	r0, [r7, #12]
 8001e12:	f7ff fa25 	bl	8001260 <mbedtls_internal_aes_encrypt>
 8001e16:	4603      	mov	r3, r0
 8001e18:	e005      	b.n	8001e26 <mbedtls_aes_crypt_ecb+0x2e>
    else
        return( mbedtls_internal_aes_decrypt( ctx, input, output ) );
 8001e1a:	683a      	ldr	r2, [r7, #0]
 8001e1c:	6879      	ldr	r1, [r7, #4]
 8001e1e:	68f8      	ldr	r0, [r7, #12]
 8001e20:	f7ff fd04 	bl	800182c <mbedtls_internal_aes_decrypt>
 8001e24:	4603      	mov	r3, r0
}
 8001e26:	4618      	mov	r0, r3
 8001e28:	3710      	adds	r7, #16
 8001e2a:	46bd      	mov	sp, r7
 8001e2c:	bd80      	pop	{r7, pc}

08001e2e <mbedtls_aes_crypt_cbc>:
                    int mode,
                    size_t length,
                    unsigned char iv[16],
                    const unsigned char *input,
                    unsigned char *output )
{
 8001e2e:	b5b0      	push	{r4, r5, r7, lr}
 8001e30:	b08a      	sub	sp, #40	@ 0x28
 8001e32:	af00      	add	r7, sp, #0
 8001e34:	60f8      	str	r0, [r7, #12]
 8001e36:	60b9      	str	r1, [r7, #8]
 8001e38:	607a      	str	r2, [r7, #4]
 8001e3a:	603b      	str	r3, [r7, #0]
                      mode == MBEDTLS_AES_DECRYPT );
    AES_VALIDATE_RET( iv != NULL );
    AES_VALIDATE_RET( input != NULL );
    AES_VALIDATE_RET( output != NULL );

    if( length % 16 )
 8001e3c:	687b      	ldr	r3, [r7, #4]
 8001e3e:	f003 030f 	and.w	r3, r3, #15
 8001e42:	2b00      	cmp	r3, #0
 8001e44:	d002      	beq.n	8001e4c <mbedtls_aes_crypt_cbc+0x1e>
        return( MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH );
 8001e46:	f06f 0321 	mvn.w	r3, #33	@ 0x21
 8001e4a:	e06d      	b.n	8001f28 <mbedtls_aes_crypt_cbc+0xfa>
        // unaccelerated mode
        //
    }
#endif

    if( mode == MBEDTLS_AES_DECRYPT )
 8001e4c:	68bb      	ldr	r3, [r7, #8]
 8001e4e:	2b00      	cmp	r3, #0
 8001e50:	d166      	bne.n	8001f20 <mbedtls_aes_crypt_cbc+0xf2>
    {
        while( length > 0 )
 8001e52:	e036      	b.n	8001ec2 <mbedtls_aes_crypt_cbc+0x94>
        {
            memcpy( temp, input, 16 );
 8001e54:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8001e56:	f107 0414 	add.w	r4, r7, #20
 8001e5a:	6818      	ldr	r0, [r3, #0]
 8001e5c:	6859      	ldr	r1, [r3, #4]
 8001e5e:	689a      	ldr	r2, [r3, #8]
 8001e60:	68db      	ldr	r3, [r3, #12]
 8001e62:	c40f      	stmia	r4!, {r0, r1, r2, r3}
            mbedtls_aes_crypt_ecb( ctx, mode, input, output );
 8001e64:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8001e66:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8001e68:	68b9      	ldr	r1, [r7, #8]
 8001e6a:	68f8      	ldr	r0, [r7, #12]
 8001e6c:	f7ff ffc4 	bl	8001df8 <mbedtls_aes_crypt_ecb>

            for( i = 0; i < 16; i++ )
 8001e70:	2300      	movs	r3, #0
 8001e72:	627b      	str	r3, [r7, #36]	@ 0x24
 8001e74:	e010      	b.n	8001e98 <mbedtls_aes_crypt_cbc+0x6a>
                output[i] = (unsigned char)( output[i] ^ iv[i] );
 8001e76:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001e78:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8001e7a:	4413      	add	r3, r2
 8001e7c:	7819      	ldrb	r1, [r3, #0]
 8001e7e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001e80:	683a      	ldr	r2, [r7, #0]
 8001e82:	4413      	add	r3, r2
 8001e84:	781a      	ldrb	r2, [r3, #0]
 8001e86:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001e88:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8001e8a:	4403      	add	r3, r0
 8001e8c:	404a      	eors	r2, r1
 8001e8e:	b2d2      	uxtb	r2, r2
 8001e90:	701a      	strb	r2, [r3, #0]
            for( i = 0; i < 16; i++ )
 8001e92:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001e94:	3301      	adds	r3, #1
 8001e96:	627b      	str	r3, [r7, #36]	@ 0x24
 8001e98:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001e9a:	2b0f      	cmp	r3, #15
 8001e9c:	ddeb      	ble.n	8001e76 <mbedtls_aes_crypt_cbc+0x48>

            memcpy( iv, temp, 16 );
 8001e9e:	683b      	ldr	r3, [r7, #0]
 8001ea0:	461d      	mov	r5, r3
 8001ea2:	f107 0414 	add.w	r4, r7, #20
 8001ea6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8001ea8:	6028      	str	r0, [r5, #0]
 8001eaa:	6069      	str	r1, [r5, #4]
 8001eac:	60aa      	str	r2, [r5, #8]
 8001eae:	60eb      	str	r3, [r5, #12]

            input  += 16;
 8001eb0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8001eb2:	3310      	adds	r3, #16
 8001eb4:	63bb      	str	r3, [r7, #56]	@ 0x38
            output += 16;
 8001eb6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8001eb8:	3310      	adds	r3, #16
 8001eba:	63fb      	str	r3, [r7, #60]	@ 0x3c
            length -= 16;
 8001ebc:	687b      	ldr	r3, [r7, #4]
 8001ebe:	3b10      	subs	r3, #16
 8001ec0:	607b      	str	r3, [r7, #4]
        while( length > 0 )
 8001ec2:	687b      	ldr	r3, [r7, #4]
 8001ec4:	2b00      	cmp	r3, #0
 8001ec6:	d1c5      	bne.n	8001e54 <mbedtls_aes_crypt_cbc+0x26>
 8001ec8:	e02d      	b.n	8001f26 <mbedtls_aes_crypt_cbc+0xf8>
    }
    else
    {
        while( length > 0 )
        {
            for( i = 0; i < 16; i++ )
 8001eca:	2300      	movs	r3, #0
 8001ecc:	627b      	str	r3, [r7, #36]	@ 0x24
 8001ece:	e010      	b.n	8001ef2 <mbedtls_aes_crypt_cbc+0xc4>
                output[i] = (unsigned char)( input[i] ^ iv[i] );
 8001ed0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001ed2:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8001ed4:	4413      	add	r3, r2
 8001ed6:	7819      	ldrb	r1, [r3, #0]
 8001ed8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001eda:	683a      	ldr	r2, [r7, #0]
 8001edc:	4413      	add	r3, r2
 8001ede:	781a      	ldrb	r2, [r3, #0]
 8001ee0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001ee2:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8001ee4:	4403      	add	r3, r0
 8001ee6:	404a      	eors	r2, r1
 8001ee8:	b2d2      	uxtb	r2, r2
 8001eea:	701a      	strb	r2, [r3, #0]
            for( i = 0; i < 16; i++ )
 8001eec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001eee:	3301      	adds	r3, #1
 8001ef0:	627b      	str	r3, [r7, #36]	@ 0x24
 8001ef2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001ef4:	2b0f      	cmp	r3, #15
 8001ef6:	ddeb      	ble.n	8001ed0 <mbedtls_aes_crypt_cbc+0xa2>

            mbedtls_aes_crypt_ecb( ctx, mode, output, output );
 8001ef8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8001efa:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8001efc:	68b9      	ldr	r1, [r7, #8]
 8001efe:	68f8      	ldr	r0, [r7, #12]
 8001f00:	f7ff ff7a 	bl	8001df8 <mbedtls_aes_crypt_ecb>
            memcpy( iv, output, 16 );
 8001f04:	2210      	movs	r2, #16
 8001f06:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8001f08:	6838      	ldr	r0, [r7, #0]
 8001f0a:	f013 fb28 	bl	801555e <memcpy>

            input  += 16;
 8001f0e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8001f10:	3310      	adds	r3, #16
 8001f12:	63bb      	str	r3, [r7, #56]	@ 0x38
            output += 16;
 8001f14:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8001f16:	3310      	adds	r3, #16
 8001f18:	63fb      	str	r3, [r7, #60]	@ 0x3c
            length -= 16;
 8001f1a:	687b      	ldr	r3, [r7, #4]
 8001f1c:	3b10      	subs	r3, #16
 8001f1e:	607b      	str	r3, [r7, #4]
        while( length > 0 )
 8001f20:	687b      	ldr	r3, [r7, #4]
 8001f22:	2b00      	cmp	r3, #0
 8001f24:	d1d1      	bne.n	8001eca <mbedtls_aes_crypt_cbc+0x9c>
        }
    }

    return( 0 );
 8001f26:	2300      	movs	r3, #0
}
 8001f28:	4618      	mov	r0, r3
 8001f2a:	3728      	adds	r7, #40	@ 0x28
 8001f2c:	46bd      	mov	sp, r7
 8001f2e:	bdb0      	pop	{r4, r5, r7, pc}

08001f30 <mbedtls_gf128mul_x_ble>:
 * for machine endianess and hence works correctly on both big and little
 * endian machines.
 */
static void mbedtls_gf128mul_x_ble( unsigned char r[16],
                                    const unsigned char x[16] )
{
 8001f30:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001f34:	b0ce      	sub	sp, #312	@ 0x138
 8001f36:	af00      	add	r7, sp, #0
 8001f38:	f8c7 0114 	str.w	r0, [r7, #276]	@ 0x114
 8001f3c:	f8c7 1110 	str.w	r1, [r7, #272]	@ 0x110
    uint64_t a, b, ra, rb;

    GET_UINT64_LE( a, x, 0 );
 8001f40:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8001f44:	3307      	adds	r3, #7
 8001f46:	781b      	ldrb	r3, [r3, #0]
 8001f48:	b2db      	uxtb	r3, r3
 8001f4a:	2200      	movs	r2, #0
 8001f4c:	469a      	mov	sl, r3
 8001f4e:	4693      	mov	fp, r2
 8001f50:	f04f 0000 	mov.w	r0, #0
 8001f54:	f04f 0100 	mov.w	r1, #0
 8001f58:	ea4f 610a 	mov.w	r1, sl, lsl #24
 8001f5c:	2000      	movs	r0, #0
 8001f5e:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8001f62:	3306      	adds	r3, #6
 8001f64:	781b      	ldrb	r3, [r3, #0]
 8001f66:	b2db      	uxtb	r3, r3
 8001f68:	2200      	movs	r2, #0
 8001f6a:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 8001f6e:	f8c7 210c 	str.w	r2, [r7, #268]	@ 0x10c
 8001f72:	f04f 0200 	mov.w	r2, #0
 8001f76:	f04f 0300 	mov.w	r3, #0
 8001f7a:	f8d7 6108 	ldr.w	r6, [r7, #264]	@ 0x108
 8001f7e:	0433      	lsls	r3, r6, #16
 8001f80:	2200      	movs	r2, #0
 8001f82:	ea40 0402 	orr.w	r4, r0, r2
 8001f86:	ea41 0503 	orr.w	r5, r1, r3
 8001f8a:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8001f8e:	3305      	adds	r3, #5
 8001f90:	781b      	ldrb	r3, [r3, #0]
 8001f92:	b2db      	uxtb	r3, r3
 8001f94:	2200      	movs	r2, #0
 8001f96:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
 8001f9a:	f8c7 2104 	str.w	r2, [r7, #260]	@ 0x104
 8001f9e:	f04f 0200 	mov.w	r2, #0
 8001fa2:	f04f 0300 	mov.w	r3, #0
 8001fa6:	f8d7 1100 	ldr.w	r1, [r7, #256]	@ 0x100
 8001faa:	020b      	lsls	r3, r1, #8
 8001fac:	2200      	movs	r2, #0
 8001fae:	ea44 0802 	orr.w	r8, r4, r2
 8001fb2:	ea45 0903 	orr.w	r9, r5, r3
 8001fb6:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8001fba:	3304      	adds	r3, #4
 8001fbc:	781b      	ldrb	r3, [r3, #0]
 8001fbe:	b2db      	uxtb	r3, r3
 8001fc0:	2200      	movs	r2, #0
 8001fc2:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 8001fc6:	f8c7 20fc 	str.w	r2, [r7, #252]	@ 0xfc
 8001fca:	f04f 0200 	mov.w	r2, #0
 8001fce:	f04f 0300 	mov.w	r3, #0
 8001fd2:	f8d7 10f8 	ldr.w	r1, [r7, #248]	@ 0xf8
 8001fd6:	000b      	movs	r3, r1
 8001fd8:	2200      	movs	r2, #0
 8001fda:	ea48 0102 	orr.w	r1, r8, r2
 8001fde:	f8c7 10f0 	str.w	r1, [r7, #240]	@ 0xf0
 8001fe2:	ea49 0303 	orr.w	r3, r9, r3
 8001fe6:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
 8001fea:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8001fee:	3303      	adds	r3, #3
 8001ff0:	781b      	ldrb	r3, [r3, #0]
 8001ff2:	b2db      	uxtb	r3, r3
 8001ff4:	2200      	movs	r2, #0
 8001ff6:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
 8001ffa:	f8c7 20ec 	str.w	r2, [r7, #236]	@ 0xec
 8001ffe:	e9d7 123a 	ldrd	r1, r2, [r7, #232]	@ 0xe8
 8002002:	460b      	mov	r3, r1
 8002004:	0a1b      	lsrs	r3, r3, #8
 8002006:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 800200a:	460b      	mov	r3, r1
 800200c:	061b      	lsls	r3, r3, #24
 800200e:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 8002012:	e9d7 453c 	ldrd	r4, r5, [r7, #240]	@ 0xf0
 8002016:	4623      	mov	r3, r4
 8002018:	e9d7 0138 	ldrd	r0, r1, [r7, #224]	@ 0xe0
 800201c:	4602      	mov	r2, r0
 800201e:	4313      	orrs	r3, r2
 8002020:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
 8002024:	462b      	mov	r3, r5
 8002026:	460a      	mov	r2, r1
 8002028:	4313      	orrs	r3, r2
 800202a:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
 800202e:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8002032:	3302      	adds	r3, #2
 8002034:	781b      	ldrb	r3, [r3, #0]
 8002036:	b2db      	uxtb	r3, r3
 8002038:	2200      	movs	r2, #0
 800203a:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 800203e:	f8c7 20d4 	str.w	r2, [r7, #212]	@ 0xd4
 8002042:	f04f 0200 	mov.w	r2, #0
 8002046:	f04f 0300 	mov.w	r3, #0
 800204a:	e9d7 4534 	ldrd	r4, r5, [r7, #208]	@ 0xd0
 800204e:	4629      	mov	r1, r5
 8002050:	040b      	lsls	r3, r1, #16
 8002052:	4621      	mov	r1, r4
 8002054:	ea43 4311 	orr.w	r3, r3, r1, lsr #16
 8002058:	4621      	mov	r1, r4
 800205a:	040a      	lsls	r2, r1, #16
 800205c:	e9d7 4536 	ldrd	r4, r5, [r7, #216]	@ 0xd8
 8002060:	4621      	mov	r1, r4
 8002062:	4311      	orrs	r1, r2
 8002064:	f8c7 10c8 	str.w	r1, [r7, #200]	@ 0xc8
 8002068:	4629      	mov	r1, r5
 800206a:	4319      	orrs	r1, r3
 800206c:	f8c7 10cc 	str.w	r1, [r7, #204]	@ 0xcc
 8002070:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8002074:	3301      	adds	r3, #1
 8002076:	781b      	ldrb	r3, [r3, #0]
 8002078:	b2db      	uxtb	r3, r3
 800207a:	2200      	movs	r2, #0
 800207c:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 8002080:	f8c7 20c4 	str.w	r2, [r7, #196]	@ 0xc4
 8002084:	f04f 0200 	mov.w	r2, #0
 8002088:	f04f 0300 	mov.w	r3, #0
 800208c:	e9d7 4530 	ldrd	r4, r5, [r7, #192]	@ 0xc0
 8002090:	4629      	mov	r1, r5
 8002092:	020b      	lsls	r3, r1, #8
 8002094:	4621      	mov	r1, r4
 8002096:	ea43 6311 	orr.w	r3, r3, r1, lsr #24
 800209a:	4621      	mov	r1, r4
 800209c:	020a      	lsls	r2, r1, #8
 800209e:	e9d7 4532 	ldrd	r4, r5, [r7, #200]	@ 0xc8
 80020a2:	4621      	mov	r1, r4
 80020a4:	4311      	orrs	r1, r2
 80020a6:	f8c7 10b8 	str.w	r1, [r7, #184]	@ 0xb8
 80020aa:	4629      	mov	r1, r5
 80020ac:	4319      	orrs	r1, r3
 80020ae:	f8c7 10bc 	str.w	r1, [r7, #188]	@ 0xbc
 80020b2:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 80020b6:	781b      	ldrb	r3, [r3, #0]
 80020b8:	b2db      	uxtb	r3, r3
 80020ba:	2200      	movs	r2, #0
 80020bc:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
 80020c0:	f8c7 20b4 	str.w	r2, [r7, #180]	@ 0xb4
 80020c4:	e9d7 452e 	ldrd	r4, r5, [r7, #184]	@ 0xb8
 80020c8:	4623      	mov	r3, r4
 80020ca:	e9d7 012c 	ldrd	r0, r1, [r7, #176]	@ 0xb0
 80020ce:	4602      	mov	r2, r0
 80020d0:	4313      	orrs	r3, r2
 80020d2:	62bb      	str	r3, [r7, #40]	@ 0x28
 80020d4:	462b      	mov	r3, r5
 80020d6:	460a      	mov	r2, r1
 80020d8:	4313      	orrs	r3, r2
 80020da:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80020dc:	e9d7 340a 	ldrd	r3, r4, [r7, #40]	@ 0x28
 80020e0:	e9c7 344c 	strd	r3, r4, [r7, #304]	@ 0x130
    GET_UINT64_LE( b, x, 8 );
 80020e4:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 80020e8:	330f      	adds	r3, #15
 80020ea:	781b      	ldrb	r3, [r3, #0]
 80020ec:	b2db      	uxtb	r3, r3
 80020ee:	2200      	movs	r2, #0
 80020f0:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
 80020f4:	f8c7 20ac 	str.w	r2, [r7, #172]	@ 0xac
 80020f8:	f04f 0000 	mov.w	r0, #0
 80020fc:	f04f 0100 	mov.w	r1, #0
 8002100:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8002104:	0619      	lsls	r1, r3, #24
 8002106:	2000      	movs	r0, #0
 8002108:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 800210c:	330e      	adds	r3, #14
 800210e:	781b      	ldrb	r3, [r3, #0]
 8002110:	b2db      	uxtb	r3, r3
 8002112:	2200      	movs	r2, #0
 8002114:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 8002118:	f8c7 20a4 	str.w	r2, [r7, #164]	@ 0xa4
 800211c:	f04f 0200 	mov.w	r2, #0
 8002120:	f04f 0300 	mov.w	r3, #0
 8002124:	f8d7 40a0 	ldr.w	r4, [r7, #160]	@ 0xa0
 8002128:	0423      	lsls	r3, r4, #16
 800212a:	2200      	movs	r2, #0
 800212c:	ea40 0402 	orr.w	r4, r0, r2
 8002130:	f8c7 4098 	str.w	r4, [r7, #152]	@ 0x98
 8002134:	430b      	orrs	r3, r1
 8002136:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
 800213a:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 800213e:	330d      	adds	r3, #13
 8002140:	781b      	ldrb	r3, [r3, #0]
 8002142:	b2db      	uxtb	r3, r3
 8002144:	2200      	movs	r2, #0
 8002146:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 800214a:	f8c7 2094 	str.w	r2, [r7, #148]	@ 0x94
 800214e:	f04f 0200 	mov.w	r2, #0
 8002152:	f04f 0300 	mov.w	r3, #0
 8002156:	f8d7 1090 	ldr.w	r1, [r7, #144]	@ 0x90
 800215a:	020b      	lsls	r3, r1, #8
 800215c:	2200      	movs	r2, #0
 800215e:	e9d7 4526 	ldrd	r4, r5, [r7, #152]	@ 0x98
 8002162:	4621      	mov	r1, r4
 8002164:	4311      	orrs	r1, r2
 8002166:	f8c7 1088 	str.w	r1, [r7, #136]	@ 0x88
 800216a:	4629      	mov	r1, r5
 800216c:	4319      	orrs	r1, r3
 800216e:	f8c7 108c 	str.w	r1, [r7, #140]	@ 0x8c
 8002172:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8002176:	330c      	adds	r3, #12
 8002178:	781b      	ldrb	r3, [r3, #0]
 800217a:	b2db      	uxtb	r3, r3
 800217c:	2200      	movs	r2, #0
 800217e:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 8002182:	f8c7 2084 	str.w	r2, [r7, #132]	@ 0x84
 8002186:	f04f 0200 	mov.w	r2, #0
 800218a:	f04f 0300 	mov.w	r3, #0
 800218e:	f8d7 1080 	ldr.w	r1, [r7, #128]	@ 0x80
 8002192:	000b      	movs	r3, r1
 8002194:	2200      	movs	r2, #0
 8002196:	e9d7 4522 	ldrd	r4, r5, [r7, #136]	@ 0x88
 800219a:	4621      	mov	r1, r4
 800219c:	4311      	orrs	r1, r2
 800219e:	67b9      	str	r1, [r7, #120]	@ 0x78
 80021a0:	4629      	mov	r1, r5
 80021a2:	4319      	orrs	r1, r3
 80021a4:	67f9      	str	r1, [r7, #124]	@ 0x7c
 80021a6:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 80021aa:	330b      	adds	r3, #11
 80021ac:	781b      	ldrb	r3, [r3, #0]
 80021ae:	b2db      	uxtb	r3, r3
 80021b0:	2200      	movs	r2, #0
 80021b2:	673b      	str	r3, [r7, #112]	@ 0x70
 80021b4:	677a      	str	r2, [r7, #116]	@ 0x74
 80021b6:	e9d7 121c 	ldrd	r1, r2, [r7, #112]	@ 0x70
 80021ba:	460b      	mov	r3, r1
 80021bc:	0a1b      	lsrs	r3, r3, #8
 80021be:	66fb      	str	r3, [r7, #108]	@ 0x6c
 80021c0:	460b      	mov	r3, r1
 80021c2:	061b      	lsls	r3, r3, #24
 80021c4:	66bb      	str	r3, [r7, #104]	@ 0x68
 80021c6:	e9d7 451e 	ldrd	r4, r5, [r7, #120]	@ 0x78
 80021ca:	4623      	mov	r3, r4
 80021cc:	e9d7 011a 	ldrd	r0, r1, [r7, #104]	@ 0x68
 80021d0:	4602      	mov	r2, r0
 80021d2:	4313      	orrs	r3, r2
 80021d4:	663b      	str	r3, [r7, #96]	@ 0x60
 80021d6:	462b      	mov	r3, r5
 80021d8:	460a      	mov	r2, r1
 80021da:	4313      	orrs	r3, r2
 80021dc:	667b      	str	r3, [r7, #100]	@ 0x64
 80021de:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 80021e2:	330a      	adds	r3, #10
 80021e4:	781b      	ldrb	r3, [r3, #0]
 80021e6:	b2db      	uxtb	r3, r3
 80021e8:	2200      	movs	r2, #0
 80021ea:	65bb      	str	r3, [r7, #88]	@ 0x58
 80021ec:	65fa      	str	r2, [r7, #92]	@ 0x5c
 80021ee:	f04f 0200 	mov.w	r2, #0
 80021f2:	f04f 0300 	mov.w	r3, #0
 80021f6:	e9d7 4516 	ldrd	r4, r5, [r7, #88]	@ 0x58
 80021fa:	4629      	mov	r1, r5
 80021fc:	040b      	lsls	r3, r1, #16
 80021fe:	4621      	mov	r1, r4
 8002200:	ea43 4311 	orr.w	r3, r3, r1, lsr #16
 8002204:	4621      	mov	r1, r4
 8002206:	040a      	lsls	r2, r1, #16
 8002208:	e9d7 4518 	ldrd	r4, r5, [r7, #96]	@ 0x60
 800220c:	4621      	mov	r1, r4
 800220e:	4311      	orrs	r1, r2
 8002210:	6539      	str	r1, [r7, #80]	@ 0x50
 8002212:	4629      	mov	r1, r5
 8002214:	4319      	orrs	r1, r3
 8002216:	6579      	str	r1, [r7, #84]	@ 0x54
 8002218:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 800221c:	3309      	adds	r3, #9
 800221e:	781b      	ldrb	r3, [r3, #0]
 8002220:	b2db      	uxtb	r3, r3
 8002222:	2200      	movs	r2, #0
 8002224:	64bb      	str	r3, [r7, #72]	@ 0x48
 8002226:	64fa      	str	r2, [r7, #76]	@ 0x4c
 8002228:	f04f 0200 	mov.w	r2, #0
 800222c:	f04f 0300 	mov.w	r3, #0
 8002230:	e9d7 4512 	ldrd	r4, r5, [r7, #72]	@ 0x48
 8002234:	4629      	mov	r1, r5
 8002236:	020b      	lsls	r3, r1, #8
 8002238:	4621      	mov	r1, r4
 800223a:	ea43 6311 	orr.w	r3, r3, r1, lsr #24
 800223e:	4621      	mov	r1, r4
 8002240:	020a      	lsls	r2, r1, #8
 8002242:	e9d7 4514 	ldrd	r4, r5, [r7, #80]	@ 0x50
 8002246:	4621      	mov	r1, r4
 8002248:	4311      	orrs	r1, r2
 800224a:	6439      	str	r1, [r7, #64]	@ 0x40
 800224c:	4629      	mov	r1, r5
 800224e:	4319      	orrs	r1, r3
 8002250:	6479      	str	r1, [r7, #68]	@ 0x44
 8002252:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8002256:	3308      	adds	r3, #8
 8002258:	781b      	ldrb	r3, [r3, #0]
 800225a:	b2db      	uxtb	r3, r3
 800225c:	2200      	movs	r2, #0
 800225e:	63bb      	str	r3, [r7, #56]	@ 0x38
 8002260:	63fa      	str	r2, [r7, #60]	@ 0x3c
 8002262:	e9d7 4510 	ldrd	r4, r5, [r7, #64]	@ 0x40
 8002266:	4623      	mov	r3, r4
 8002268:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
 800226c:	4602      	mov	r2, r0
 800226e:	4313      	orrs	r3, r2
 8002270:	623b      	str	r3, [r7, #32]
 8002272:	462b      	mov	r3, r5
 8002274:	460a      	mov	r2, r1
 8002276:	4313      	orrs	r3, r2
 8002278:	627b      	str	r3, [r7, #36]	@ 0x24
 800227a:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
 800227e:	e9c7 344a 	strd	r3, r4, [r7, #296]	@ 0x128

    ra = ( a << 1 )  ^ 0x0087 >> ( 8 - ( ( b >> 63 ) << 3 ) );
 8002282:	e9d7 234c 	ldrd	r2, r3, [r7, #304]	@ 0x130
 8002286:	1891      	adds	r1, r2, r2
 8002288:	61b9      	str	r1, [r7, #24]
 800228a:	415b      	adcs	r3, r3
 800228c:	61fb      	str	r3, [r7, #28]
 800228e:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8002292:	e9d7 454a 	ldrd	r4, r5, [r7, #296]	@ 0x128
 8002296:	f04f 0200 	mov.w	r2, #0
 800229a:	f04f 0300 	mov.w	r3, #0
 800229e:	0fea      	lsrs	r2, r5, #31
 80022a0:	2300      	movs	r3, #0
 80022a2:	4613      	mov	r3, r2
 80022a4:	00db      	lsls	r3, r3, #3
 80022a6:	f1c3 0308 	rsb	r3, r3, #8
 80022aa:	2287      	movs	r2, #135	@ 0x87
 80022ac:	fa42 f303 	asr.w	r3, r2, r3
 80022b0:	17da      	asrs	r2, r3, #31
 80022b2:	633b      	str	r3, [r7, #48]	@ 0x30
 80022b4:	637a      	str	r2, [r7, #52]	@ 0x34
 80022b6:	e9d7 450c 	ldrd	r4, r5, [r7, #48]	@ 0x30
 80022ba:	4623      	mov	r3, r4
 80022bc:	4043      	eors	r3, r0
 80022be:	613b      	str	r3, [r7, #16]
 80022c0:	462b      	mov	r3, r5
 80022c2:	404b      	eors	r3, r1
 80022c4:	617b      	str	r3, [r7, #20]
 80022c6:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 80022ca:	e9c7 3448 	strd	r3, r4, [r7, #288]	@ 0x120
    rb = ( a >> 63 ) | ( b << 1 );
 80022ce:	e9d7 234c 	ldrd	r2, r3, [r7, #304]	@ 0x130
 80022d2:	f04f 0000 	mov.w	r0, #0
 80022d6:	f04f 0100 	mov.w	r1, #0
 80022da:	0fd8      	lsrs	r0, r3, #31
 80022dc:	2100      	movs	r1, #0
 80022de:	e9d7 234a 	ldrd	r2, r3, [r7, #296]	@ 0x128
 80022e2:	1894      	adds	r4, r2, r2
 80022e4:	60bc      	str	r4, [r7, #8]
 80022e6:	415b      	adcs	r3, r3
 80022e8:	60fb      	str	r3, [r7, #12]
 80022ea:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 80022ee:	ea40 0402 	orr.w	r4, r0, r2
 80022f2:	603c      	str	r4, [r7, #0]
 80022f4:	430b      	orrs	r3, r1
 80022f6:	607b      	str	r3, [r7, #4]
 80022f8:	e9d7 3400 	ldrd	r3, r4, [r7]
 80022fc:	e9c7 3446 	strd	r3, r4, [r7, #280]	@ 0x118

    PUT_UINT64_LE( ra, r, 0 );
 8002300:	e9d7 0148 	ldrd	r0, r1, [r7, #288]	@ 0x120
 8002304:	f04f 0200 	mov.w	r2, #0
 8002308:	f04f 0300 	mov.w	r3, #0
 800230c:	0e0a      	lsrs	r2, r1, #24
 800230e:	2300      	movs	r3, #0
 8002310:	f8d7 1114 	ldr.w	r1, [r7, #276]	@ 0x114
 8002314:	3107      	adds	r1, #7
 8002316:	b2d3      	uxtb	r3, r2
 8002318:	700b      	strb	r3, [r1, #0]
 800231a:	e9d7 0148 	ldrd	r0, r1, [r7, #288]	@ 0x120
 800231e:	f04f 0200 	mov.w	r2, #0
 8002322:	f04f 0300 	mov.w	r3, #0
 8002326:	0c0a      	lsrs	r2, r1, #16
 8002328:	2300      	movs	r3, #0
 800232a:	f8d7 1114 	ldr.w	r1, [r7, #276]	@ 0x114
 800232e:	3106      	adds	r1, #6
 8002330:	b2d3      	uxtb	r3, r2
 8002332:	700b      	strb	r3, [r1, #0]
 8002334:	e9d7 0148 	ldrd	r0, r1, [r7, #288]	@ 0x120
 8002338:	f04f 0200 	mov.w	r2, #0
 800233c:	f04f 0300 	mov.w	r3, #0
 8002340:	0a0a      	lsrs	r2, r1, #8
 8002342:	2300      	movs	r3, #0
 8002344:	f8d7 1114 	ldr.w	r1, [r7, #276]	@ 0x114
 8002348:	3105      	adds	r1, #5
 800234a:	b2d3      	uxtb	r3, r2
 800234c:	700b      	strb	r3, [r1, #0]
 800234e:	e9d7 0148 	ldrd	r0, r1, [r7, #288]	@ 0x120
 8002352:	f04f 0200 	mov.w	r2, #0
 8002356:	f04f 0300 	mov.w	r3, #0
 800235a:	000a      	movs	r2, r1
 800235c:	2300      	movs	r3, #0
 800235e:	f8d7 1114 	ldr.w	r1, [r7, #276]	@ 0x114
 8002362:	3104      	adds	r1, #4
 8002364:	b2d3      	uxtb	r3, r2
 8002366:	700b      	strb	r3, [r1, #0]
 8002368:	e9d7 0148 	ldrd	r0, r1, [r7, #288]	@ 0x120
 800236c:	f04f 0200 	mov.w	r2, #0
 8002370:	f04f 0300 	mov.w	r3, #0
 8002374:	0e02      	lsrs	r2, r0, #24
 8002376:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800237a:	0e0b      	lsrs	r3, r1, #24
 800237c:	f8d7 1114 	ldr.w	r1, [r7, #276]	@ 0x114
 8002380:	3103      	adds	r1, #3
 8002382:	b2d3      	uxtb	r3, r2
 8002384:	700b      	strb	r3, [r1, #0]
 8002386:	e9d7 0148 	ldrd	r0, r1, [r7, #288]	@ 0x120
 800238a:	f04f 0200 	mov.w	r2, #0
 800238e:	f04f 0300 	mov.w	r3, #0
 8002392:	0c02      	lsrs	r2, r0, #16
 8002394:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8002398:	0c0b      	lsrs	r3, r1, #16
 800239a:	f8d7 1114 	ldr.w	r1, [r7, #276]	@ 0x114
 800239e:	3102      	adds	r1, #2
 80023a0:	b2d3      	uxtb	r3, r2
 80023a2:	700b      	strb	r3, [r1, #0]
 80023a4:	e9d7 0148 	ldrd	r0, r1, [r7, #288]	@ 0x120
 80023a8:	f04f 0200 	mov.w	r2, #0
 80023ac:	f04f 0300 	mov.w	r3, #0
 80023b0:	0a02      	lsrs	r2, r0, #8
 80023b2:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 80023b6:	0a0b      	lsrs	r3, r1, #8
 80023b8:	f8d7 1114 	ldr.w	r1, [r7, #276]	@ 0x114
 80023bc:	3101      	adds	r1, #1
 80023be:	b2d3      	uxtb	r3, r2
 80023c0:	700b      	strb	r3, [r1, #0]
 80023c2:	f897 2120 	ldrb.w	r2, [r7, #288]	@ 0x120
 80023c6:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80023ca:	701a      	strb	r2, [r3, #0]
    PUT_UINT64_LE( rb, r, 8 );
 80023cc:	e9d7 0146 	ldrd	r0, r1, [r7, #280]	@ 0x118
 80023d0:	f04f 0200 	mov.w	r2, #0
 80023d4:	f04f 0300 	mov.w	r3, #0
 80023d8:	0e0a      	lsrs	r2, r1, #24
 80023da:	2300      	movs	r3, #0
 80023dc:	f8d7 1114 	ldr.w	r1, [r7, #276]	@ 0x114
 80023e0:	310f      	adds	r1, #15
 80023e2:	b2d3      	uxtb	r3, r2
 80023e4:	700b      	strb	r3, [r1, #0]
 80023e6:	e9d7 0146 	ldrd	r0, r1, [r7, #280]	@ 0x118
 80023ea:	f04f 0200 	mov.w	r2, #0
 80023ee:	f04f 0300 	mov.w	r3, #0
 80023f2:	0c0a      	lsrs	r2, r1, #16
 80023f4:	2300      	movs	r3, #0
 80023f6:	f8d7 1114 	ldr.w	r1, [r7, #276]	@ 0x114
 80023fa:	310e      	adds	r1, #14
 80023fc:	b2d3      	uxtb	r3, r2
 80023fe:	700b      	strb	r3, [r1, #0]
 8002400:	e9d7 0146 	ldrd	r0, r1, [r7, #280]	@ 0x118
 8002404:	f04f 0200 	mov.w	r2, #0
 8002408:	f04f 0300 	mov.w	r3, #0
 800240c:	0a0a      	lsrs	r2, r1, #8
 800240e:	2300      	movs	r3, #0
 8002410:	f8d7 1114 	ldr.w	r1, [r7, #276]	@ 0x114
 8002414:	310d      	adds	r1, #13
 8002416:	b2d3      	uxtb	r3, r2
 8002418:	700b      	strb	r3, [r1, #0]
 800241a:	e9d7 0146 	ldrd	r0, r1, [r7, #280]	@ 0x118
 800241e:	f04f 0200 	mov.w	r2, #0
 8002422:	f04f 0300 	mov.w	r3, #0
 8002426:	000a      	movs	r2, r1
 8002428:	2300      	movs	r3, #0
 800242a:	f8d7 1114 	ldr.w	r1, [r7, #276]	@ 0x114
 800242e:	310c      	adds	r1, #12
 8002430:	b2d3      	uxtb	r3, r2
 8002432:	700b      	strb	r3, [r1, #0]
 8002434:	e9d7 0146 	ldrd	r0, r1, [r7, #280]	@ 0x118
 8002438:	f04f 0200 	mov.w	r2, #0
 800243c:	f04f 0300 	mov.w	r3, #0
 8002440:	0e02      	lsrs	r2, r0, #24
 8002442:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8002446:	0e0b      	lsrs	r3, r1, #24
 8002448:	f8d7 1114 	ldr.w	r1, [r7, #276]	@ 0x114
 800244c:	310b      	adds	r1, #11
 800244e:	b2d3      	uxtb	r3, r2
 8002450:	700b      	strb	r3, [r1, #0]
 8002452:	e9d7 0146 	ldrd	r0, r1, [r7, #280]	@ 0x118
 8002456:	f04f 0200 	mov.w	r2, #0
 800245a:	f04f 0300 	mov.w	r3, #0
 800245e:	0c02      	lsrs	r2, r0, #16
 8002460:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8002464:	0c0b      	lsrs	r3, r1, #16
 8002466:	f8d7 1114 	ldr.w	r1, [r7, #276]	@ 0x114
 800246a:	310a      	adds	r1, #10
 800246c:	b2d3      	uxtb	r3, r2
 800246e:	700b      	strb	r3, [r1, #0]
 8002470:	e9d7 0146 	ldrd	r0, r1, [r7, #280]	@ 0x118
 8002474:	f04f 0200 	mov.w	r2, #0
 8002478:	f04f 0300 	mov.w	r3, #0
 800247c:	0a02      	lsrs	r2, r0, #8
 800247e:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 8002482:	0a0b      	lsrs	r3, r1, #8
 8002484:	f8d7 1114 	ldr.w	r1, [r7, #276]	@ 0x114
 8002488:	3109      	adds	r1, #9
 800248a:	b2d3      	uxtb	r3, r2
 800248c:	700b      	strb	r3, [r1, #0]
 800248e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8002492:	3308      	adds	r3, #8
 8002494:	f897 2118 	ldrb.w	r2, [r7, #280]	@ 0x118
 8002498:	701a      	strb	r2, [r3, #0]
}
 800249a:	bf00      	nop
 800249c:	f507 779c 	add.w	r7, r7, #312	@ 0x138
 80024a0:	46bd      	mov	sp, r7
 80024a2:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80024a6:	4770      	bx	lr

080024a8 <mbedtls_aes_crypt_xts>:
                           int mode,
                           size_t length,
                           const unsigned char data_unit[16],
                           const unsigned char *input,
                           unsigned char *output )
{
 80024a8:	b590      	push	{r4, r7, lr}
 80024aa:	b099      	sub	sp, #100	@ 0x64
 80024ac:	af00      	add	r7, sp, #0
 80024ae:	60f8      	str	r0, [r7, #12]
 80024b0:	60b9      	str	r1, [r7, #8]
 80024b2:	607a      	str	r2, [r7, #4]
 80024b4:	603b      	str	r3, [r7, #0]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 80024b6:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 80024ba:	653b      	str	r3, [r7, #80]	@ 0x50
    size_t blocks = length / 16;
 80024bc:	687b      	ldr	r3, [r7, #4]
 80024be:	091b      	lsrs	r3, r3, #4
 80024c0:	65fb      	str	r3, [r7, #92]	@ 0x5c
    size_t leftover = length % 16;
 80024c2:	687b      	ldr	r3, [r7, #4]
 80024c4:	f003 030f 	and.w	r3, r3, #15
 80024c8:	64fb      	str	r3, [r7, #76]	@ 0x4c
    AES_VALIDATE_RET( data_unit != NULL );
    AES_VALIDATE_RET( input != NULL );
    AES_VALIDATE_RET( output != NULL );

    /* Data units must be at least 16 bytes long. */
    if( length < 16 )
 80024ca:	687b      	ldr	r3, [r7, #4]
 80024cc:	2b0f      	cmp	r3, #15
 80024ce:	d802      	bhi.n	80024d6 <mbedtls_aes_crypt_xts+0x2e>
        return MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH;
 80024d0:	f06f 0321 	mvn.w	r3, #33	@ 0x21
 80024d4:	e0f0      	b.n	80026b8 <mbedtls_aes_crypt_xts+0x210>

    /* NIST SP 800-38E disallows data units larger than 2**20 blocks. */
    if( length > ( 1 << 20 ) * 16 )
 80024d6:	687b      	ldr	r3, [r7, #4]
 80024d8:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 80024dc:	d902      	bls.n	80024e4 <mbedtls_aes_crypt_xts+0x3c>
        return MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH;
 80024de:	f06f 0321 	mvn.w	r3, #33	@ 0x21
 80024e2:	e0e9      	b.n	80026b8 <mbedtls_aes_crypt_xts+0x210>

    /* Compute the tweak. */
    ret = mbedtls_aes_crypt_ecb( &ctx->tweak, MBEDTLS_AES_ENCRYPT,
 80024e4:	68fb      	ldr	r3, [r7, #12]
 80024e6:	f503 708c 	add.w	r0, r3, #280	@ 0x118
 80024ea:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 80024ee:	683a      	ldr	r2, [r7, #0]
 80024f0:	2101      	movs	r1, #1
 80024f2:	f7ff fc81 	bl	8001df8 <mbedtls_aes_crypt_ecb>
 80024f6:	6538      	str	r0, [r7, #80]	@ 0x50
                                 data_unit, tweak );
    if( ret != 0 )
 80024f8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80024fa:	2b00      	cmp	r3, #0
 80024fc:	d068      	beq.n	80025d0 <mbedtls_aes_crypt_xts+0x128>
        return( ret );
 80024fe:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8002500:	e0da      	b.n	80026b8 <mbedtls_aes_crypt_xts+0x210>

    while( blocks-- )
    {
        size_t i;

        if( leftover && ( mode == MBEDTLS_AES_DECRYPT ) && blocks == 0 )
 8002502:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8002504:	2b00      	cmp	r3, #0
 8002506:	d014      	beq.n	8002532 <mbedtls_aes_crypt_xts+0x8a>
 8002508:	68bb      	ldr	r3, [r7, #8]
 800250a:	2b00      	cmp	r3, #0
 800250c:	d111      	bne.n	8002532 <mbedtls_aes_crypt_xts+0x8a>
 800250e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8002510:	2b00      	cmp	r3, #0
 8002512:	d10e      	bne.n	8002532 <mbedtls_aes_crypt_xts+0x8a>
            /* We are on the last block in a decrypt operation that has
             * leftover bytes, so we need to use the next tweak for this block,
             * and this tweak for the lefover bytes. Save the current tweak for
             * the leftovers and then update the current tweak for use on this,
             * the last full block. */
            memcpy( prev_tweak, tweak, sizeof( tweak ) );
 8002514:	f107 0424 	add.w	r4, r7, #36	@ 0x24
 8002518:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 800251c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800251e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
            mbedtls_gf128mul_x_ble( tweak, tweak );
 8002522:	f107 0234 	add.w	r2, r7, #52	@ 0x34
 8002526:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 800252a:	4611      	mov	r1, r2
 800252c:	4618      	mov	r0, r3
 800252e:	f7ff fcff 	bl	8001f30 <mbedtls_gf128mul_x_ble>
        }

        for( i = 0; i < 16; i++ )
 8002532:	2300      	movs	r3, #0
 8002534:	65bb      	str	r3, [r7, #88]	@ 0x58
 8002536:	e013      	b.n	8002560 <mbedtls_aes_crypt_xts+0xb8>
            tmp[i] = input[i] ^ tweak[i];
 8002538:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 800253a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800253c:	4413      	add	r3, r2
 800253e:	781a      	ldrb	r2, [r3, #0]
 8002540:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 8002544:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8002546:	440b      	add	r3, r1
 8002548:	781b      	ldrb	r3, [r3, #0]
 800254a:	4053      	eors	r3, r2
 800254c:	b2d9      	uxtb	r1, r3
 800254e:	f107 0214 	add.w	r2, r7, #20
 8002552:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8002554:	4413      	add	r3, r2
 8002556:	460a      	mov	r2, r1
 8002558:	701a      	strb	r2, [r3, #0]
        for( i = 0; i < 16; i++ )
 800255a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800255c:	3301      	adds	r3, #1
 800255e:	65bb      	str	r3, [r7, #88]	@ 0x58
 8002560:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8002562:	2b0f      	cmp	r3, #15
 8002564:	d9e8      	bls.n	8002538 <mbedtls_aes_crypt_xts+0x90>

        ret = mbedtls_aes_crypt_ecb( &ctx->crypt, mode, tmp, tmp );
 8002566:	68f8      	ldr	r0, [r7, #12]
 8002568:	f107 0314 	add.w	r3, r7, #20
 800256c:	f107 0214 	add.w	r2, r7, #20
 8002570:	68b9      	ldr	r1, [r7, #8]
 8002572:	f7ff fc41 	bl	8001df8 <mbedtls_aes_crypt_ecb>
 8002576:	6538      	str	r0, [r7, #80]	@ 0x50
        if( ret != 0 )
 8002578:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800257a:	2b00      	cmp	r3, #0
 800257c:	d001      	beq.n	8002582 <mbedtls_aes_crypt_xts+0xda>
            return( ret );
 800257e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8002580:	e09a      	b.n	80026b8 <mbedtls_aes_crypt_xts+0x210>

        for( i = 0; i < 16; i++ )
 8002582:	2300      	movs	r3, #0
 8002584:	65bb      	str	r3, [r7, #88]	@ 0x58
 8002586:	e012      	b.n	80025ae <mbedtls_aes_crypt_xts+0x106>
            output[i] = tmp[i] ^ tweak[i];
 8002588:	f107 0214 	add.w	r2, r7, #20
 800258c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800258e:	4413      	add	r3, r2
 8002590:	7819      	ldrb	r1, [r3, #0]
 8002592:	f107 0234 	add.w	r2, r7, #52	@ 0x34
 8002596:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8002598:	4413      	add	r3, r2
 800259a:	781a      	ldrb	r2, [r3, #0]
 800259c:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 800259e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80025a0:	4403      	add	r3, r0
 80025a2:	404a      	eors	r2, r1
 80025a4:	b2d2      	uxtb	r2, r2
 80025a6:	701a      	strb	r2, [r3, #0]
        for( i = 0; i < 16; i++ )
 80025a8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80025aa:	3301      	adds	r3, #1
 80025ac:	65bb      	str	r3, [r7, #88]	@ 0x58
 80025ae:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80025b0:	2b0f      	cmp	r3, #15
 80025b2:	d9e9      	bls.n	8002588 <mbedtls_aes_crypt_xts+0xe0>

        /* Update the tweak for the next block. */
        mbedtls_gf128mul_x_ble( tweak, tweak );
 80025b4:	f107 0234 	add.w	r2, r7, #52	@ 0x34
 80025b8:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 80025bc:	4611      	mov	r1, r2
 80025be:	4618      	mov	r0, r3
 80025c0:	f7ff fcb6 	bl	8001f30 <mbedtls_gf128mul_x_ble>

        output += 16;
 80025c4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80025c6:	3310      	adds	r3, #16
 80025c8:	677b      	str	r3, [r7, #116]	@ 0x74
        input += 16;
 80025ca:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80025cc:	3310      	adds	r3, #16
 80025ce:	673b      	str	r3, [r7, #112]	@ 0x70
    while( blocks-- )
 80025d0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80025d2:	1e5a      	subs	r2, r3, #1
 80025d4:	65fa      	str	r2, [r7, #92]	@ 0x5c
 80025d6:	2b00      	cmp	r3, #0
 80025d8:	d193      	bne.n	8002502 <mbedtls_aes_crypt_xts+0x5a>
    }

    if( leftover )
 80025da:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80025dc:	2b00      	cmp	r3, #0
 80025de:	d06a      	beq.n	80026b6 <mbedtls_aes_crypt_xts+0x20e>
    {
        /* If we are on the leftover bytes in a decrypt operation, we need to
         * use the previous tweak for these bytes (as saved in prev_tweak). */
        unsigned char *t = mode == MBEDTLS_AES_DECRYPT ? prev_tweak : tweak;
 80025e0:	68bb      	ldr	r3, [r7, #8]
 80025e2:	2b00      	cmp	r3, #0
 80025e4:	d102      	bne.n	80025ec <mbedtls_aes_crypt_xts+0x144>
 80025e6:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 80025ea:	e001      	b.n	80025f0 <mbedtls_aes_crypt_xts+0x148>
 80025ec:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 80025f0:	64bb      	str	r3, [r7, #72]	@ 0x48

        /* We are now on the final part of the data unit, which doesn't divide
         * evenly by 16. It's time for ciphertext stealing. */
        size_t i;
        unsigned char *prev_output = output - 16;
 80025f2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80025f4:	3b10      	subs	r3, #16
 80025f6:	647b      	str	r3, [r7, #68]	@ 0x44

        /* Copy ciphertext bytes from the previous block to our output for each
         * byte of cyphertext we won't steal. At the same time, copy the
         * remainder of the input for this final round (since the loop bounds
         * are the same). */
        for( i = 0; i < leftover; i++ )
 80025f8:	2300      	movs	r3, #0
 80025fa:	657b      	str	r3, [r7, #84]	@ 0x54
 80025fc:	e01a      	b.n	8002634 <mbedtls_aes_crypt_xts+0x18c>
        {
            output[i] = prev_output[i];
 80025fe:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8002600:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002602:	441a      	add	r2, r3
 8002604:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 8002606:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002608:	440b      	add	r3, r1
 800260a:	7812      	ldrb	r2, [r2, #0]
 800260c:	701a      	strb	r2, [r3, #0]
            tmp[i] = input[i] ^ t[i];
 800260e:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8002610:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002612:	4413      	add	r3, r2
 8002614:	781a      	ldrb	r2, [r3, #0]
 8002616:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 8002618:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800261a:	440b      	add	r3, r1
 800261c:	781b      	ldrb	r3, [r3, #0]
 800261e:	4053      	eors	r3, r2
 8002620:	b2d9      	uxtb	r1, r3
 8002622:	f107 0214 	add.w	r2, r7, #20
 8002626:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002628:	4413      	add	r3, r2
 800262a:	460a      	mov	r2, r1
 800262c:	701a      	strb	r2, [r3, #0]
        for( i = 0; i < leftover; i++ )
 800262e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002630:	3301      	adds	r3, #1
 8002632:	657b      	str	r3, [r7, #84]	@ 0x54
 8002634:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8002636:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8002638:	429a      	cmp	r2, r3
 800263a:	d3e0      	bcc.n	80025fe <mbedtls_aes_crypt_xts+0x156>
        }

        /* Copy ciphertext bytes from the previous block for input in this
         * round. */
        for( ; i < 16; i++ )
 800263c:	e012      	b.n	8002664 <mbedtls_aes_crypt_xts+0x1bc>
            tmp[i] = prev_output[i] ^ t[i];
 800263e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8002640:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002642:	4413      	add	r3, r2
 8002644:	781a      	ldrb	r2, [r3, #0]
 8002646:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 8002648:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800264a:	440b      	add	r3, r1
 800264c:	781b      	ldrb	r3, [r3, #0]
 800264e:	4053      	eors	r3, r2
 8002650:	b2d9      	uxtb	r1, r3
 8002652:	f107 0214 	add.w	r2, r7, #20
 8002656:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002658:	4413      	add	r3, r2
 800265a:	460a      	mov	r2, r1
 800265c:	701a      	strb	r2, [r3, #0]
        for( ; i < 16; i++ )
 800265e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002660:	3301      	adds	r3, #1
 8002662:	657b      	str	r3, [r7, #84]	@ 0x54
 8002664:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002666:	2b0f      	cmp	r3, #15
 8002668:	d9e9      	bls.n	800263e <mbedtls_aes_crypt_xts+0x196>

        ret = mbedtls_aes_crypt_ecb( &ctx->crypt, mode, tmp, tmp );
 800266a:	68f8      	ldr	r0, [r7, #12]
 800266c:	f107 0314 	add.w	r3, r7, #20
 8002670:	f107 0214 	add.w	r2, r7, #20
 8002674:	68b9      	ldr	r1, [r7, #8]
 8002676:	f7ff fbbf 	bl	8001df8 <mbedtls_aes_crypt_ecb>
 800267a:	6538      	str	r0, [r7, #80]	@ 0x50
        if( ret != 0 )
 800267c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800267e:	2b00      	cmp	r3, #0
 8002680:	d001      	beq.n	8002686 <mbedtls_aes_crypt_xts+0x1de>
            return ret;
 8002682:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8002684:	e018      	b.n	80026b8 <mbedtls_aes_crypt_xts+0x210>

        /* Write the result back to the previous block, overriding the previous
         * output we copied. */
        for( i = 0; i < 16; i++ )
 8002686:	2300      	movs	r3, #0
 8002688:	657b      	str	r3, [r7, #84]	@ 0x54
 800268a:	e011      	b.n	80026b0 <mbedtls_aes_crypt_xts+0x208>
            prev_output[i] = tmp[i] ^ t[i];
 800268c:	f107 0214 	add.w	r2, r7, #20
 8002690:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002692:	4413      	add	r3, r2
 8002694:	7819      	ldrb	r1, [r3, #0]
 8002696:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8002698:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800269a:	4413      	add	r3, r2
 800269c:	781a      	ldrb	r2, [r3, #0]
 800269e:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 80026a0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80026a2:	4403      	add	r3, r0
 80026a4:	404a      	eors	r2, r1
 80026a6:	b2d2      	uxtb	r2, r2
 80026a8:	701a      	strb	r2, [r3, #0]
        for( i = 0; i < 16; i++ )
 80026aa:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80026ac:	3301      	adds	r3, #1
 80026ae:	657b      	str	r3, [r7, #84]	@ 0x54
 80026b0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80026b2:	2b0f      	cmp	r3, #15
 80026b4:	d9ea      	bls.n	800268c <mbedtls_aes_crypt_xts+0x1e4>
    }

    return( 0 );
 80026b6:	2300      	movs	r3, #0
}
 80026b8:	4618      	mov	r0, r3
 80026ba:	3764      	adds	r7, #100	@ 0x64
 80026bc:	46bd      	mov	sp, r7
 80026be:	bd90      	pop	{r4, r7, pc}

080026c0 <mbedtls_aes_crypt_cfb128>:
                       size_t length,
                       size_t *iv_off,
                       unsigned char iv[16],
                       const unsigned char *input,
                       unsigned char *output )
{
 80026c0:	b580      	push	{r7, lr}
 80026c2:	b086      	sub	sp, #24
 80026c4:	af00      	add	r7, sp, #0
 80026c6:	60f8      	str	r0, [r7, #12]
 80026c8:	60b9      	str	r1, [r7, #8]
 80026ca:	607a      	str	r2, [r7, #4]
 80026cc:	603b      	str	r3, [r7, #0]
    AES_VALIDATE_RET( iv_off != NULL );
    AES_VALIDATE_RET( iv != NULL );
    AES_VALIDATE_RET( input != NULL );
    AES_VALIDATE_RET( output != NULL );

    n = *iv_off;
 80026ce:	683b      	ldr	r3, [r7, #0]
 80026d0:	681b      	ldr	r3, [r3, #0]
 80026d2:	617b      	str	r3, [r7, #20]

    if( n > 15 )
 80026d4:	697b      	ldr	r3, [r7, #20]
 80026d6:	2b0f      	cmp	r3, #15
 80026d8:	d902      	bls.n	80026e0 <mbedtls_aes_crypt_cfb128+0x20>
        return( MBEDTLS_ERR_AES_BAD_INPUT_DATA );
 80026da:	f06f 0320 	mvn.w	r3, #32
 80026de:	e05a      	b.n	8002796 <mbedtls_aes_crypt_cfb128+0xd6>

    if( mode == MBEDTLS_AES_DECRYPT )
 80026e0:	68bb      	ldr	r3, [r7, #8]
 80026e2:	2b00      	cmp	r3, #0
 80026e4:	d14e      	bne.n	8002784 <mbedtls_aes_crypt_cfb128+0xc4>
    {
        while( length-- )
 80026e6:	e026      	b.n	8002736 <mbedtls_aes_crypt_cfb128+0x76>
        {
            if( n == 0 )
 80026e8:	697b      	ldr	r3, [r7, #20]
 80026ea:	2b00      	cmp	r3, #0
 80026ec:	d105      	bne.n	80026fa <mbedtls_aes_crypt_cfb128+0x3a>
                mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );
 80026ee:	6a3b      	ldr	r3, [r7, #32]
 80026f0:	6a3a      	ldr	r2, [r7, #32]
 80026f2:	2101      	movs	r1, #1
 80026f4:	68f8      	ldr	r0, [r7, #12]
 80026f6:	f7ff fb7f 	bl	8001df8 <mbedtls_aes_crypt_ecb>

            c = *input++;
 80026fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80026fc:	1c5a      	adds	r2, r3, #1
 80026fe:	627a      	str	r2, [r7, #36]	@ 0x24
 8002700:	781b      	ldrb	r3, [r3, #0]
 8002702:	613b      	str	r3, [r7, #16]
            *output++ = (unsigned char)( c ^ iv[n] );
 8002704:	693b      	ldr	r3, [r7, #16]
 8002706:	b25a      	sxtb	r2, r3
 8002708:	6a39      	ldr	r1, [r7, #32]
 800270a:	697b      	ldr	r3, [r7, #20]
 800270c:	440b      	add	r3, r1
 800270e:	781b      	ldrb	r3, [r3, #0]
 8002710:	b25b      	sxtb	r3, r3
 8002712:	4053      	eors	r3, r2
 8002714:	b259      	sxtb	r1, r3
 8002716:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8002718:	1c5a      	adds	r2, r3, #1
 800271a:	62ba      	str	r2, [r7, #40]	@ 0x28
 800271c:	b2ca      	uxtb	r2, r1
 800271e:	701a      	strb	r2, [r3, #0]
            iv[n] = (unsigned char) c;
 8002720:	6a3a      	ldr	r2, [r7, #32]
 8002722:	697b      	ldr	r3, [r7, #20]
 8002724:	4413      	add	r3, r2
 8002726:	693a      	ldr	r2, [r7, #16]
 8002728:	b2d2      	uxtb	r2, r2
 800272a:	701a      	strb	r2, [r3, #0]

            n = ( n + 1 ) & 0x0F;
 800272c:	697b      	ldr	r3, [r7, #20]
 800272e:	3301      	adds	r3, #1
 8002730:	f003 030f 	and.w	r3, r3, #15
 8002734:	617b      	str	r3, [r7, #20]
        while( length-- )
 8002736:	687b      	ldr	r3, [r7, #4]
 8002738:	1e5a      	subs	r2, r3, #1
 800273a:	607a      	str	r2, [r7, #4]
 800273c:	2b00      	cmp	r3, #0
 800273e:	d1d3      	bne.n	80026e8 <mbedtls_aes_crypt_cfb128+0x28>
 8002740:	e025      	b.n	800278e <mbedtls_aes_crypt_cfb128+0xce>
    }
    else
    {
        while( length-- )
        {
            if( n == 0 )
 8002742:	697b      	ldr	r3, [r7, #20]
 8002744:	2b00      	cmp	r3, #0
 8002746:	d105      	bne.n	8002754 <mbedtls_aes_crypt_cfb128+0x94>
                mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );
 8002748:	6a3b      	ldr	r3, [r7, #32]
 800274a:	6a3a      	ldr	r2, [r7, #32]
 800274c:	2101      	movs	r1, #1
 800274e:	68f8      	ldr	r0, [r7, #12]
 8002750:	f7ff fb52 	bl	8001df8 <mbedtls_aes_crypt_ecb>

            iv[n] = *output++ = (unsigned char)( iv[n] ^ *input++ );
 8002754:	6a3a      	ldr	r2, [r7, #32]
 8002756:	697b      	ldr	r3, [r7, #20]
 8002758:	4413      	add	r3, r2
 800275a:	7819      	ldrb	r1, [r3, #0]
 800275c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800275e:	1c5a      	adds	r2, r3, #1
 8002760:	627a      	str	r2, [r7, #36]	@ 0x24
 8002762:	781a      	ldrb	r2, [r3, #0]
 8002764:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8002766:	1c58      	adds	r0, r3, #1
 8002768:	62b8      	str	r0, [r7, #40]	@ 0x28
 800276a:	404a      	eors	r2, r1
 800276c:	b2d2      	uxtb	r2, r2
 800276e:	701a      	strb	r2, [r3, #0]
 8002770:	6a39      	ldr	r1, [r7, #32]
 8002772:	697a      	ldr	r2, [r7, #20]
 8002774:	440a      	add	r2, r1
 8002776:	781b      	ldrb	r3, [r3, #0]
 8002778:	7013      	strb	r3, [r2, #0]

            n = ( n + 1 ) & 0x0F;
 800277a:	697b      	ldr	r3, [r7, #20]
 800277c:	3301      	adds	r3, #1
 800277e:	f003 030f 	and.w	r3, r3, #15
 8002782:	617b      	str	r3, [r7, #20]
        while( length-- )
 8002784:	687b      	ldr	r3, [r7, #4]
 8002786:	1e5a      	subs	r2, r3, #1
 8002788:	607a      	str	r2, [r7, #4]
 800278a:	2b00      	cmp	r3, #0
 800278c:	d1d9      	bne.n	8002742 <mbedtls_aes_crypt_cfb128+0x82>
        }
    }

    *iv_off = n;
 800278e:	683b      	ldr	r3, [r7, #0]
 8002790:	697a      	ldr	r2, [r7, #20]
 8002792:	601a      	str	r2, [r3, #0]

    return( 0 );
 8002794:	2300      	movs	r3, #0
}
 8002796:	4618      	mov	r0, r3
 8002798:	3718      	adds	r7, #24
 800279a:	46bd      	mov	sp, r7
 800279c:	bd80      	pop	{r7, pc}

0800279e <mbedtls_aes_crypt_ofb>:
                           size_t length,
                           size_t *iv_off,
                           unsigned char iv[16],
                           const unsigned char *input,
                           unsigned char *output )
{
 800279e:	b580      	push	{r7, lr}
 80027a0:	b086      	sub	sp, #24
 80027a2:	af00      	add	r7, sp, #0
 80027a4:	60f8      	str	r0, [r7, #12]
 80027a6:	60b9      	str	r1, [r7, #8]
 80027a8:	607a      	str	r2, [r7, #4]
 80027aa:	603b      	str	r3, [r7, #0]
    int ret = 0;
 80027ac:	2300      	movs	r3, #0
 80027ae:	617b      	str	r3, [r7, #20]
    AES_VALIDATE_RET( iv_off != NULL );
    AES_VALIDATE_RET( iv != NULL );
    AES_VALIDATE_RET( input != NULL );
    AES_VALIDATE_RET( output != NULL );

    n = *iv_off;
 80027b0:	687b      	ldr	r3, [r7, #4]
 80027b2:	681b      	ldr	r3, [r3, #0]
 80027b4:	613b      	str	r3, [r7, #16]

    if( n > 15 )
 80027b6:	693b      	ldr	r3, [r7, #16]
 80027b8:	2b0f      	cmp	r3, #15
 80027ba:	d922      	bls.n	8002802 <mbedtls_aes_crypt_ofb+0x64>
        return( MBEDTLS_ERR_AES_BAD_INPUT_DATA );
 80027bc:	f06f 0320 	mvn.w	r3, #32
 80027c0:	e02a      	b.n	8002818 <mbedtls_aes_crypt_ofb+0x7a>

    while( length-- )
    {
        if( n == 0 )
 80027c2:	693b      	ldr	r3, [r7, #16]
 80027c4:	2b00      	cmp	r3, #0
 80027c6:	d109      	bne.n	80027dc <mbedtls_aes_crypt_ofb+0x3e>
        {
            ret = mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );
 80027c8:	683b      	ldr	r3, [r7, #0]
 80027ca:	683a      	ldr	r2, [r7, #0]
 80027cc:	2101      	movs	r1, #1
 80027ce:	68f8      	ldr	r0, [r7, #12]
 80027d0:	f7ff fb12 	bl	8001df8 <mbedtls_aes_crypt_ecb>
 80027d4:	6178      	str	r0, [r7, #20]
            if( ret != 0 )
 80027d6:	697b      	ldr	r3, [r7, #20]
 80027d8:	2b00      	cmp	r3, #0
 80027da:	d11b      	bne.n	8002814 <mbedtls_aes_crypt_ofb+0x76>
                goto exit;
        }
        *output++ =  *input++ ^ iv[n];
 80027dc:	6a3b      	ldr	r3, [r7, #32]
 80027de:	1c5a      	adds	r2, r3, #1
 80027e0:	623a      	str	r2, [r7, #32]
 80027e2:	7819      	ldrb	r1, [r3, #0]
 80027e4:	683a      	ldr	r2, [r7, #0]
 80027e6:	693b      	ldr	r3, [r7, #16]
 80027e8:	4413      	add	r3, r2
 80027ea:	781a      	ldrb	r2, [r3, #0]
 80027ec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80027ee:	1c58      	adds	r0, r3, #1
 80027f0:	6278      	str	r0, [r7, #36]	@ 0x24
 80027f2:	404a      	eors	r2, r1
 80027f4:	b2d2      	uxtb	r2, r2
 80027f6:	701a      	strb	r2, [r3, #0]

        n = ( n + 1 ) & 0x0F;
 80027f8:	693b      	ldr	r3, [r7, #16]
 80027fa:	3301      	adds	r3, #1
 80027fc:	f003 030f 	and.w	r3, r3, #15
 8002800:	613b      	str	r3, [r7, #16]
    while( length-- )
 8002802:	68bb      	ldr	r3, [r7, #8]
 8002804:	1e5a      	subs	r2, r3, #1
 8002806:	60ba      	str	r2, [r7, #8]
 8002808:	2b00      	cmp	r3, #0
 800280a:	d1da      	bne.n	80027c2 <mbedtls_aes_crypt_ofb+0x24>
    }

    *iv_off = n;
 800280c:	687b      	ldr	r3, [r7, #4]
 800280e:	693a      	ldr	r2, [r7, #16]
 8002810:	601a      	str	r2, [r3, #0]
 8002812:	e000      	b.n	8002816 <mbedtls_aes_crypt_ofb+0x78>
                goto exit;
 8002814:	bf00      	nop

exit:
    return( ret );
 8002816:	697b      	ldr	r3, [r7, #20]
}
 8002818:	4618      	mov	r0, r3
 800281a:	3718      	adds	r7, #24
 800281c:	46bd      	mov	sp, r7
 800281e:	bd80      	pop	{r7, pc}

08002820 <mbedtls_aes_crypt_ctr>:
                       size_t *nc_off,
                       unsigned char nonce_counter[16],
                       unsigned char stream_block[16],
                       const unsigned char *input,
                       unsigned char *output )
{
 8002820:	b580      	push	{r7, lr}
 8002822:	b088      	sub	sp, #32
 8002824:	af00      	add	r7, sp, #0
 8002826:	60f8      	str	r0, [r7, #12]
 8002828:	60b9      	str	r1, [r7, #8]
 800282a:	607a      	str	r2, [r7, #4]
 800282c:	603b      	str	r3, [r7, #0]
    AES_VALIDATE_RET( nonce_counter != NULL );
    AES_VALIDATE_RET( stream_block != NULL );
    AES_VALIDATE_RET( input != NULL );
    AES_VALIDATE_RET( output != NULL );

    n = *nc_off;
 800282e:	687b      	ldr	r3, [r7, #4]
 8002830:	681b      	ldr	r3, [r3, #0]
 8002832:	61bb      	str	r3, [r7, #24]

    if ( n > 0x0F )
 8002834:	69bb      	ldr	r3, [r7, #24]
 8002836:	2b0f      	cmp	r3, #15
 8002838:	d939      	bls.n	80028ae <mbedtls_aes_crypt_ctr+0x8e>
        return( MBEDTLS_ERR_AES_BAD_INPUT_DATA );
 800283a:	f06f 0320 	mvn.w	r3, #32
 800283e:	e03f      	b.n	80028c0 <mbedtls_aes_crypt_ctr+0xa0>

    while( length-- )
    {
        if( n == 0 ) {
 8002840:	69bb      	ldr	r3, [r7, #24]
 8002842:	2b00      	cmp	r3, #0
 8002844:	d11b      	bne.n	800287e <mbedtls_aes_crypt_ctr+0x5e>
            mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, nonce_counter, stream_block );
 8002846:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8002848:	683a      	ldr	r2, [r7, #0]
 800284a:	2101      	movs	r1, #1
 800284c:	68f8      	ldr	r0, [r7, #12]
 800284e:	f7ff fad3 	bl	8001df8 <mbedtls_aes_crypt_ecb>

            for( i = 16; i > 0; i-- )
 8002852:	2310      	movs	r3, #16
 8002854:	61fb      	str	r3, [r7, #28]
 8002856:	e00d      	b.n	8002874 <mbedtls_aes_crypt_ctr+0x54>
                if( ++nonce_counter[i - 1] != 0 )
 8002858:	69fb      	ldr	r3, [r7, #28]
 800285a:	3b01      	subs	r3, #1
 800285c:	683a      	ldr	r2, [r7, #0]
 800285e:	4413      	add	r3, r2
 8002860:	781a      	ldrb	r2, [r3, #0]
 8002862:	3201      	adds	r2, #1
 8002864:	b2d2      	uxtb	r2, r2
 8002866:	701a      	strb	r2, [r3, #0]
 8002868:	781b      	ldrb	r3, [r3, #0]
 800286a:	2b00      	cmp	r3, #0
 800286c:	d106      	bne.n	800287c <mbedtls_aes_crypt_ctr+0x5c>
            for( i = 16; i > 0; i-- )
 800286e:	69fb      	ldr	r3, [r7, #28]
 8002870:	3b01      	subs	r3, #1
 8002872:	61fb      	str	r3, [r7, #28]
 8002874:	69fb      	ldr	r3, [r7, #28]
 8002876:	2b00      	cmp	r3, #0
 8002878:	dcee      	bgt.n	8002858 <mbedtls_aes_crypt_ctr+0x38>
 800287a:	e000      	b.n	800287e <mbedtls_aes_crypt_ctr+0x5e>
                    break;
 800287c:	bf00      	nop
        }
        c = *input++;
 800287e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8002880:	1c5a      	adds	r2, r3, #1
 8002882:	62fa      	str	r2, [r7, #44]	@ 0x2c
 8002884:	781b      	ldrb	r3, [r3, #0]
 8002886:	617b      	str	r3, [r7, #20]
        *output++ = (unsigned char)( c ^ stream_block[n] );
 8002888:	697b      	ldr	r3, [r7, #20]
 800288a:	b25a      	sxtb	r2, r3
 800288c:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800288e:	69bb      	ldr	r3, [r7, #24]
 8002890:	440b      	add	r3, r1
 8002892:	781b      	ldrb	r3, [r3, #0]
 8002894:	b25b      	sxtb	r3, r3
 8002896:	4053      	eors	r3, r2
 8002898:	b259      	sxtb	r1, r3
 800289a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800289c:	1c5a      	adds	r2, r3, #1
 800289e:	633a      	str	r2, [r7, #48]	@ 0x30
 80028a0:	b2ca      	uxtb	r2, r1
 80028a2:	701a      	strb	r2, [r3, #0]

        n = ( n + 1 ) & 0x0F;
 80028a4:	69bb      	ldr	r3, [r7, #24]
 80028a6:	3301      	adds	r3, #1
 80028a8:	f003 030f 	and.w	r3, r3, #15
 80028ac:	61bb      	str	r3, [r7, #24]
    while( length-- )
 80028ae:	68bb      	ldr	r3, [r7, #8]
 80028b0:	1e5a      	subs	r2, r3, #1
 80028b2:	60ba      	str	r2, [r7, #8]
 80028b4:	2b00      	cmp	r3, #0
 80028b6:	d1c3      	bne.n	8002840 <mbedtls_aes_crypt_ctr+0x20>
    }

    *nc_off = n;
 80028b8:	687b      	ldr	r3, [r7, #4]
 80028ba:	69ba      	ldr	r2, [r7, #24]
 80028bc:	601a      	str	r2, [r3, #0]

    return( 0 );
 80028be:	2300      	movs	r3, #0
}
 80028c0:	4618      	mov	r0, r3
 80028c2:	3720      	adds	r7, #32
 80028c4:	46bd      	mov	sp, r7
 80028c6:	bd80      	pop	{r7, pc}

080028c8 <mbedtls_ccm_init>:

/*
 * Initialize context
 */
void mbedtls_ccm_init( mbedtls_ccm_context *ctx )
{
 80028c8:	b580      	push	{r7, lr}
 80028ca:	b082      	sub	sp, #8
 80028cc:	af00      	add	r7, sp, #0
 80028ce:	6078      	str	r0, [r7, #4]
    CCM_VALIDATE( ctx != NULL );
    memset( ctx, 0, sizeof( mbedtls_ccm_context ) );
 80028d0:	2244      	movs	r2, #68	@ 0x44
 80028d2:	2100      	movs	r1, #0
 80028d4:	6878      	ldr	r0, [r7, #4]
 80028d6:	f012 fdb7 	bl	8015448 <memset>
}
 80028da:	bf00      	nop
 80028dc:	3708      	adds	r7, #8
 80028de:	46bd      	mov	sp, r7
 80028e0:	bd80      	pop	{r7, pc}

080028e2 <mbedtls_ccm_setkey>:

int mbedtls_ccm_setkey( mbedtls_ccm_context *ctx,
                        mbedtls_cipher_id_t cipher,
                        const unsigned char *key,
                        unsigned int keybits )
{
 80028e2:	b580      	push	{r7, lr}
 80028e4:	b086      	sub	sp, #24
 80028e6:	af00      	add	r7, sp, #0
 80028e8:	60f8      	str	r0, [r7, #12]
 80028ea:	607a      	str	r2, [r7, #4]
 80028ec:	603b      	str	r3, [r7, #0]
 80028ee:	460b      	mov	r3, r1
 80028f0:	72fb      	strb	r3, [r7, #11]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 80028f2:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 80028f6:	617b      	str	r3, [r7, #20]
    const mbedtls_cipher_info_t *cipher_info;

    CCM_VALIDATE_RET( ctx != NULL );
    CCM_VALIDATE_RET( key != NULL );

    cipher_info = mbedtls_cipher_info_from_values( cipher, keybits,
 80028f8:	6839      	ldr	r1, [r7, #0]
 80028fa:	7afb      	ldrb	r3, [r7, #11]
 80028fc:	2201      	movs	r2, #1
 80028fe:	4618      	mov	r0, r3
 8002900:	f001 fb7a 	bl	8003ff8 <mbedtls_cipher_info_from_values>
 8002904:	6138      	str	r0, [r7, #16]
                                                   MBEDTLS_MODE_ECB );
    if( cipher_info == NULL )
 8002906:	693b      	ldr	r3, [r7, #16]
 8002908:	2b00      	cmp	r3, #0
 800290a:	d102      	bne.n	8002912 <mbedtls_ccm_setkey+0x30>
        return( MBEDTLS_ERR_CCM_BAD_INPUT );
 800290c:	f06f 030c 	mvn.w	r3, #12
 8002910:	e022      	b.n	8002958 <mbedtls_ccm_setkey+0x76>

    if( cipher_info->block_size != 16 )
 8002912:	693b      	ldr	r3, [r7, #16]
 8002914:	695b      	ldr	r3, [r3, #20]
 8002916:	2b10      	cmp	r3, #16
 8002918:	d002      	beq.n	8002920 <mbedtls_ccm_setkey+0x3e>
        return( MBEDTLS_ERR_CCM_BAD_INPUT );
 800291a:	f06f 030c 	mvn.w	r3, #12
 800291e:	e01b      	b.n	8002958 <mbedtls_ccm_setkey+0x76>

    mbedtls_cipher_free( &ctx->cipher_ctx );
 8002920:	68fb      	ldr	r3, [r7, #12]
 8002922:	4618      	mov	r0, r3
 8002924:	f001 fb9a 	bl	800405c <mbedtls_cipher_free>

    if( ( ret = mbedtls_cipher_setup( &ctx->cipher_ctx, cipher_info ) ) != 0 )
 8002928:	68fb      	ldr	r3, [r7, #12]
 800292a:	6939      	ldr	r1, [r7, #16]
 800292c:	4618      	mov	r0, r3
 800292e:	f001 fbc1 	bl	80040b4 <mbedtls_cipher_setup>
 8002932:	6178      	str	r0, [r7, #20]
 8002934:	697b      	ldr	r3, [r7, #20]
 8002936:	2b00      	cmp	r3, #0
 8002938:	d001      	beq.n	800293e <mbedtls_ccm_setkey+0x5c>
        return( ret );
 800293a:	697b      	ldr	r3, [r7, #20]
 800293c:	e00c      	b.n	8002958 <mbedtls_ccm_setkey+0x76>

    if( ( ret = mbedtls_cipher_setkey( &ctx->cipher_ctx, key, keybits,
 800293e:	68f8      	ldr	r0, [r7, #12]
 8002940:	683a      	ldr	r2, [r7, #0]
 8002942:	2301      	movs	r3, #1
 8002944:	6879      	ldr	r1, [r7, #4]
 8002946:	f001 fbe1 	bl	800410c <mbedtls_cipher_setkey>
 800294a:	6178      	str	r0, [r7, #20]
 800294c:	697b      	ldr	r3, [r7, #20]
 800294e:	2b00      	cmp	r3, #0
 8002950:	d001      	beq.n	8002956 <mbedtls_ccm_setkey+0x74>
                               MBEDTLS_ENCRYPT ) ) != 0 )
    {
        return( ret );
 8002952:	697b      	ldr	r3, [r7, #20]
 8002954:	e000      	b.n	8002958 <mbedtls_ccm_setkey+0x76>
    }

    return( 0 );
 8002956:	2300      	movs	r3, #0
}
 8002958:	4618      	mov	r0, r3
 800295a:	3718      	adds	r7, #24
 800295c:	46bd      	mov	sp, r7
 800295e:	bd80      	pop	{r7, pc}

08002960 <mbedtls_ccm_free>:

/*
 * Free context
 */
void mbedtls_ccm_free( mbedtls_ccm_context *ctx )
{
 8002960:	b580      	push	{r7, lr}
 8002962:	b082      	sub	sp, #8
 8002964:	af00      	add	r7, sp, #0
 8002966:	6078      	str	r0, [r7, #4]
    if( ctx == NULL )
 8002968:	687b      	ldr	r3, [r7, #4]
 800296a:	2b00      	cmp	r3, #0
 800296c:	d008      	beq.n	8002980 <mbedtls_ccm_free+0x20>
        return;
    mbedtls_cipher_free( &ctx->cipher_ctx );
 800296e:	687b      	ldr	r3, [r7, #4]
 8002970:	4618      	mov	r0, r3
 8002972:	f001 fb73 	bl	800405c <mbedtls_cipher_free>
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_ccm_context ) );
 8002976:	2144      	movs	r1, #68	@ 0x44
 8002978:	6878      	ldr	r0, [r7, #4]
 800297a:	f003 fc31 	bl	80061e0 <mbedtls_platform_zeroize>
 800297e:	e000      	b.n	8002982 <mbedtls_ccm_free+0x22>
        return;
 8002980:	bf00      	nop
}
 8002982:	3708      	adds	r7, #8
 8002984:	46bd      	mov	sp, r7
 8002986:	bd80      	pop	{r7, pc}

08002988 <ccm_auth_crypt>:
static int ccm_auth_crypt( mbedtls_ccm_context *ctx, int mode, size_t length,
                           const unsigned char *iv, size_t iv_len,
                           const unsigned char *add, size_t add_len,
                           const unsigned char *input, unsigned char *output,
                           unsigned char *tag, size_t tag_len )
{
 8002988:	b580      	push	{r7, lr}
 800298a:	b09c      	sub	sp, #112	@ 0x70
 800298c:	af02      	add	r7, sp, #8
 800298e:	60f8      	str	r0, [r7, #12]
 8002990:	60b9      	str	r1, [r7, #8]
 8002992:	607a      	str	r2, [r7, #4]
 8002994:	603b      	str	r3, [r7, #0]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 8002996:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 800299a:	657b      	str	r3, [r7, #84]	@ 0x54
     * Additional requirement: a < 2^16 - 2^8 to simplify the code.
     * 'length' checked later (when writing it to the first block)
     *
     * Also, loosen the requirements to enable support for CCM* (IEEE 802.15.4).
     */
    if( tag_len == 2 || tag_len > 16 || tag_len % 2 != 0 )
 800299c:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 80029a0:	2b02      	cmp	r3, #2
 80029a2:	d009      	beq.n	80029b8 <ccm_auth_crypt+0x30>
 80029a4:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 80029a8:	2b10      	cmp	r3, #16
 80029aa:	d805      	bhi.n	80029b8 <ccm_auth_crypt+0x30>
 80029ac:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 80029b0:	f003 0301 	and.w	r3, r3, #1
 80029b4:	2b00      	cmp	r3, #0
 80029b6:	d002      	beq.n	80029be <ccm_auth_crypt+0x36>
        return( MBEDTLS_ERR_CCM_BAD_INPUT );
 80029b8:	f06f 030c 	mvn.w	r3, #12
 80029bc:	e2c5      	b.n	8002f4a <ccm_auth_crypt+0x5c2>

    /* Also implies q is within bounds */
    if( iv_len < 7 || iv_len > 13 )
 80029be:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80029c0:	2b06      	cmp	r3, #6
 80029c2:	d902      	bls.n	80029ca <ccm_auth_crypt+0x42>
 80029c4:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80029c6:	2b0d      	cmp	r3, #13
 80029c8:	d902      	bls.n	80029d0 <ccm_auth_crypt+0x48>
        return( MBEDTLS_ERR_CCM_BAD_INPUT );
 80029ca:	f06f 030c 	mvn.w	r3, #12
 80029ce:	e2bc      	b.n	8002f4a <ccm_auth_crypt+0x5c2>

    if( add_len >= 0xFF00 )
 80029d0:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 80029d2:	f5b3 4f7f 	cmp.w	r3, #65280	@ 0xff00
 80029d6:	d302      	bcc.n	80029de <ccm_auth_crypt+0x56>
        return( MBEDTLS_ERR_CCM_BAD_INPUT );
 80029d8:	f06f 030c 	mvn.w	r3, #12
 80029dc:	e2b5      	b.n	8002f4a <ccm_auth_crypt+0x5c2>

    q = 16 - 1 - (unsigned char) iv_len;
 80029de:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80029e0:	b2db      	uxtb	r3, r3
 80029e2:	f1c3 030f 	rsb	r3, r3, #15
 80029e6:	f887 3053 	strb.w	r3, [r7, #83]	@ 0x53
     * 7        0
     * 6        add present?
     * 5 .. 3   (t - 2) / 2
     * 2 .. 0   q - 1
     */
    b[0] = 0;
 80029ea:	2300      	movs	r3, #0
 80029ec:	f887 3034 	strb.w	r3, [r7, #52]	@ 0x34
    b[0] |= ( add_len > 0 ) << 6;
 80029f0:	f897 3034 	ldrb.w	r3, [r7, #52]	@ 0x34
 80029f4:	b25b      	sxtb	r3, r3
 80029f6:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 80029f8:	2a00      	cmp	r2, #0
 80029fa:	d001      	beq.n	8002a00 <ccm_auth_crypt+0x78>
 80029fc:	2240      	movs	r2, #64	@ 0x40
 80029fe:	e000      	b.n	8002a02 <ccm_auth_crypt+0x7a>
 8002a00:	2200      	movs	r2, #0
 8002a02:	4313      	orrs	r3, r2
 8002a04:	b25b      	sxtb	r3, r3
 8002a06:	b2db      	uxtb	r3, r3
 8002a08:	f887 3034 	strb.w	r3, [r7, #52]	@ 0x34
    b[0] |= ( ( tag_len - 2 ) / 2 ) << 3;
 8002a0c:	f897 2034 	ldrb.w	r2, [r7, #52]	@ 0x34
 8002a10:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8002a14:	3b02      	subs	r3, #2
 8002a16:	085b      	lsrs	r3, r3, #1
 8002a18:	b2db      	uxtb	r3, r3
 8002a1a:	00db      	lsls	r3, r3, #3
 8002a1c:	b2db      	uxtb	r3, r3
 8002a1e:	4313      	orrs	r3, r2
 8002a20:	b2db      	uxtb	r3, r3
 8002a22:	f887 3034 	strb.w	r3, [r7, #52]	@ 0x34
    b[0] |= q - 1;
 8002a26:	f897 3034 	ldrb.w	r3, [r7, #52]	@ 0x34
 8002a2a:	b25a      	sxtb	r2, r3
 8002a2c:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 8002a30:	3b01      	subs	r3, #1
 8002a32:	b2db      	uxtb	r3, r3
 8002a34:	b25b      	sxtb	r3, r3
 8002a36:	4313      	orrs	r3, r2
 8002a38:	b25b      	sxtb	r3, r3
 8002a3a:	b2db      	uxtb	r3, r3
 8002a3c:	f887 3034 	strb.w	r3, [r7, #52]	@ 0x34

    memcpy( b + 1, iv, iv_len );
 8002a40:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 8002a44:	3301      	adds	r3, #1
 8002a46:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8002a48:	6839      	ldr	r1, [r7, #0]
 8002a4a:	4618      	mov	r0, r3
 8002a4c:	f012 fd87 	bl	801555e <memcpy>

    for( i = 0, len_left = length; i < q; i++, len_left >>= 8 )
 8002a50:	2300      	movs	r3, #0
 8002a52:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002a56:	687b      	ldr	r3, [r7, #4]
 8002a58:	663b      	str	r3, [r7, #96]	@ 0x60
 8002a5a:	e011      	b.n	8002a80 <ccm_auth_crypt+0xf8>
        b[15-i] = (unsigned char)( len_left & 0xFF );
 8002a5c:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002a60:	f1c3 030f 	rsb	r3, r3, #15
 8002a64:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8002a66:	b2d2      	uxtb	r2, r2
 8002a68:	3368      	adds	r3, #104	@ 0x68
 8002a6a:	443b      	add	r3, r7
 8002a6c:	f803 2c34 	strb.w	r2, [r3, #-52]
    for( i = 0, len_left = length; i < q; i++, len_left >>= 8 )
 8002a70:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002a74:	3301      	adds	r3, #1
 8002a76:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002a7a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8002a7c:	0a1b      	lsrs	r3, r3, #8
 8002a7e:	663b      	str	r3, [r7, #96]	@ 0x60
 8002a80:	f897 2067 	ldrb.w	r2, [r7, #103]	@ 0x67
 8002a84:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 8002a88:	429a      	cmp	r2, r3
 8002a8a:	d3e7      	bcc.n	8002a5c <ccm_auth_crypt+0xd4>

    if( len_left > 0 )
 8002a8c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8002a8e:	2b00      	cmp	r3, #0
 8002a90:	d002      	beq.n	8002a98 <ccm_auth_crypt+0x110>
        return( MBEDTLS_ERR_CCM_BAD_INPUT );
 8002a92:	f06f 030c 	mvn.w	r3, #12
 8002a96:	e258      	b.n	8002f4a <ccm_auth_crypt+0x5c2>


    /* Start CBC-MAC with first block */
    memset( y, 0, 16 );
 8002a98:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8002a9c:	2210      	movs	r2, #16
 8002a9e:	2100      	movs	r1, #0
 8002aa0:	4618      	mov	r0, r3
 8002aa2:	f012 fcd1 	bl	8015448 <memset>
    UPDATE_CBC_MAC;
 8002aa6:	2300      	movs	r3, #0
 8002aa8:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002aac:	e018      	b.n	8002ae0 <ccm_auth_crypt+0x158>
 8002aae:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002ab2:	3368      	adds	r3, #104	@ 0x68
 8002ab4:	443b      	add	r3, r7
 8002ab6:	f813 1c44 	ldrb.w	r1, [r3, #-68]
 8002aba:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002abe:	3368      	adds	r3, #104	@ 0x68
 8002ac0:	443b      	add	r3, r7
 8002ac2:	f813 2c34 	ldrb.w	r2, [r3, #-52]
 8002ac6:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002aca:	404a      	eors	r2, r1
 8002acc:	b2d2      	uxtb	r2, r2
 8002ace:	3368      	adds	r3, #104	@ 0x68
 8002ad0:	443b      	add	r3, r7
 8002ad2:	f803 2c44 	strb.w	r2, [r3, #-68]
 8002ad6:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002ada:	3301      	adds	r3, #1
 8002adc:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002ae0:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002ae4:	2b0f      	cmp	r3, #15
 8002ae6:	d9e2      	bls.n	8002aae <ccm_auth_crypt+0x126>
 8002ae8:	68f8      	ldr	r0, [r7, #12]
 8002aea:	f107 0224 	add.w	r2, r7, #36	@ 0x24
 8002aee:	f107 0124 	add.w	r1, r7, #36	@ 0x24
 8002af2:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 8002af6:	9300      	str	r3, [sp, #0]
 8002af8:	4613      	mov	r3, r2
 8002afa:	2210      	movs	r2, #16
 8002afc:	f001 fb60 	bl	80041c0 <mbedtls_cipher_update>
 8002b00:	6578      	str	r0, [r7, #84]	@ 0x54
 8002b02:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002b04:	2b00      	cmp	r3, #0
 8002b06:	d001      	beq.n	8002b0c <ccm_auth_crypt+0x184>
 8002b08:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002b0a:	e21e      	b.n	8002f4a <ccm_auth_crypt+0x5c2>

    /*
     * If there is additional data, update CBC-MAC with
     * add_len, add, 0 (padding to a block boundary)
     */
    if( add_len > 0 )
 8002b0c:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8002b0e:	2b00      	cmp	r3, #0
 8002b10:	f000 80ad 	beq.w	8002c6e <ccm_auth_crypt+0x2e6>
    {
        size_t use_len;
        len_left = add_len;
 8002b14:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8002b16:	663b      	str	r3, [r7, #96]	@ 0x60
        src = add;
 8002b18:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8002b1a:	65fb      	str	r3, [r7, #92]	@ 0x5c

        memset( b, 0, 16 );
 8002b1c:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 8002b20:	2210      	movs	r2, #16
 8002b22:	2100      	movs	r1, #0
 8002b24:	4618      	mov	r0, r3
 8002b26:	f012 fc8f 	bl	8015448 <memset>
        b[0] = (unsigned char)( ( add_len >> 8 ) & 0xFF );
 8002b2a:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8002b2c:	0a1b      	lsrs	r3, r3, #8
 8002b2e:	b2db      	uxtb	r3, r3
 8002b30:	f887 3034 	strb.w	r3, [r7, #52]	@ 0x34
        b[1] = (unsigned char)( ( add_len      ) & 0xFF );
 8002b34:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8002b36:	b2db      	uxtb	r3, r3
 8002b38:	f887 3035 	strb.w	r3, [r7, #53]	@ 0x35

        use_len = len_left < 16 - 2 ? len_left : 16 - 2;
 8002b3c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8002b3e:	2b0e      	cmp	r3, #14
 8002b40:	bf28      	it	cs
 8002b42:	230e      	movcs	r3, #14
 8002b44:	64fb      	str	r3, [r7, #76]	@ 0x4c
        memcpy( b + 2, src, use_len );
 8002b46:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 8002b4a:	3302      	adds	r3, #2
 8002b4c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8002b4e:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8002b50:	4618      	mov	r0, r3
 8002b52:	f012 fd04 	bl	801555e <memcpy>
        len_left -= use_len;
 8002b56:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8002b58:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8002b5a:	1ad3      	subs	r3, r2, r3
 8002b5c:	663b      	str	r3, [r7, #96]	@ 0x60
        src += use_len;
 8002b5e:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8002b60:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8002b62:	4413      	add	r3, r2
 8002b64:	65fb      	str	r3, [r7, #92]	@ 0x5c

        UPDATE_CBC_MAC;
 8002b66:	2300      	movs	r3, #0
 8002b68:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002b6c:	e018      	b.n	8002ba0 <ccm_auth_crypt+0x218>
 8002b6e:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002b72:	3368      	adds	r3, #104	@ 0x68
 8002b74:	443b      	add	r3, r7
 8002b76:	f813 1c44 	ldrb.w	r1, [r3, #-68]
 8002b7a:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002b7e:	3368      	adds	r3, #104	@ 0x68
 8002b80:	443b      	add	r3, r7
 8002b82:	f813 2c34 	ldrb.w	r2, [r3, #-52]
 8002b86:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002b8a:	404a      	eors	r2, r1
 8002b8c:	b2d2      	uxtb	r2, r2
 8002b8e:	3368      	adds	r3, #104	@ 0x68
 8002b90:	443b      	add	r3, r7
 8002b92:	f803 2c44 	strb.w	r2, [r3, #-68]
 8002b96:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002b9a:	3301      	adds	r3, #1
 8002b9c:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002ba0:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002ba4:	2b0f      	cmp	r3, #15
 8002ba6:	d9e2      	bls.n	8002b6e <ccm_auth_crypt+0x1e6>
 8002ba8:	68f8      	ldr	r0, [r7, #12]
 8002baa:	f107 0224 	add.w	r2, r7, #36	@ 0x24
 8002bae:	f107 0124 	add.w	r1, r7, #36	@ 0x24
 8002bb2:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 8002bb6:	9300      	str	r3, [sp, #0]
 8002bb8:	4613      	mov	r3, r2
 8002bba:	2210      	movs	r2, #16
 8002bbc:	f001 fb00 	bl	80041c0 <mbedtls_cipher_update>
 8002bc0:	6578      	str	r0, [r7, #84]	@ 0x54
 8002bc2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002bc4:	2b00      	cmp	r3, #0
 8002bc6:	d04f      	beq.n	8002c68 <ccm_auth_crypt+0x2e0>
 8002bc8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002bca:	e1be      	b.n	8002f4a <ccm_auth_crypt+0x5c2>

        while( len_left > 0 )
        {
            use_len = len_left > 16 ? 16 : len_left;
 8002bcc:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8002bce:	2b10      	cmp	r3, #16
 8002bd0:	bf28      	it	cs
 8002bd2:	2310      	movcs	r3, #16
 8002bd4:	64fb      	str	r3, [r7, #76]	@ 0x4c

            memset( b, 0, 16 );
 8002bd6:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 8002bda:	2210      	movs	r2, #16
 8002bdc:	2100      	movs	r1, #0
 8002bde:	4618      	mov	r0, r3
 8002be0:	f012 fc32 	bl	8015448 <memset>
            memcpy( b, src, use_len );
 8002be4:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 8002be8:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8002bea:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8002bec:	4618      	mov	r0, r3
 8002bee:	f012 fcb6 	bl	801555e <memcpy>
            UPDATE_CBC_MAC;
 8002bf2:	2300      	movs	r3, #0
 8002bf4:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002bf8:	e018      	b.n	8002c2c <ccm_auth_crypt+0x2a4>
 8002bfa:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002bfe:	3368      	adds	r3, #104	@ 0x68
 8002c00:	443b      	add	r3, r7
 8002c02:	f813 1c44 	ldrb.w	r1, [r3, #-68]
 8002c06:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002c0a:	3368      	adds	r3, #104	@ 0x68
 8002c0c:	443b      	add	r3, r7
 8002c0e:	f813 2c34 	ldrb.w	r2, [r3, #-52]
 8002c12:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002c16:	404a      	eors	r2, r1
 8002c18:	b2d2      	uxtb	r2, r2
 8002c1a:	3368      	adds	r3, #104	@ 0x68
 8002c1c:	443b      	add	r3, r7
 8002c1e:	f803 2c44 	strb.w	r2, [r3, #-68]
 8002c22:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002c26:	3301      	adds	r3, #1
 8002c28:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002c2c:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002c30:	2b0f      	cmp	r3, #15
 8002c32:	d9e2      	bls.n	8002bfa <ccm_auth_crypt+0x272>
 8002c34:	68f8      	ldr	r0, [r7, #12]
 8002c36:	f107 0224 	add.w	r2, r7, #36	@ 0x24
 8002c3a:	f107 0124 	add.w	r1, r7, #36	@ 0x24
 8002c3e:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 8002c42:	9300      	str	r3, [sp, #0]
 8002c44:	4613      	mov	r3, r2
 8002c46:	2210      	movs	r2, #16
 8002c48:	f001 faba 	bl	80041c0 <mbedtls_cipher_update>
 8002c4c:	6578      	str	r0, [r7, #84]	@ 0x54
 8002c4e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002c50:	2b00      	cmp	r3, #0
 8002c52:	d001      	beq.n	8002c58 <ccm_auth_crypt+0x2d0>
 8002c54:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002c56:	e178      	b.n	8002f4a <ccm_auth_crypt+0x5c2>

            len_left -= use_len;
 8002c58:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8002c5a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8002c5c:	1ad3      	subs	r3, r2, r3
 8002c5e:	663b      	str	r3, [r7, #96]	@ 0x60
            src += use_len;
 8002c60:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8002c62:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8002c64:	4413      	add	r3, r2
 8002c66:	65fb      	str	r3, [r7, #92]	@ 0x5c
        while( len_left > 0 )
 8002c68:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8002c6a:	2b00      	cmp	r3, #0
 8002c6c:	d1ae      	bne.n	8002bcc <ccm_auth_crypt+0x244>
     *
     * With flags as (bits):
     * 7 .. 3   0
     * 2 .. 0   q - 1
     */
    ctr[0] = q - 1;
 8002c6e:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 8002c72:	3b01      	subs	r3, #1
 8002c74:	b2db      	uxtb	r3, r3
 8002c76:	753b      	strb	r3, [r7, #20]
    memcpy( ctr + 1, iv, iv_len );
 8002c78:	f107 0314 	add.w	r3, r7, #20
 8002c7c:	3301      	adds	r3, #1
 8002c7e:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8002c80:	6839      	ldr	r1, [r7, #0]
 8002c82:	4618      	mov	r0, r3
 8002c84:	f012 fc6b 	bl	801555e <memcpy>
    memset( ctr + 1 + iv_len, 0, q );
 8002c88:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8002c8a:	3301      	adds	r3, #1
 8002c8c:	f107 0214 	add.w	r2, r7, #20
 8002c90:	4413      	add	r3, r2
 8002c92:	f897 2053 	ldrb.w	r2, [r7, #83]	@ 0x53
 8002c96:	2100      	movs	r1, #0
 8002c98:	4618      	mov	r0, r3
 8002c9a:	f012 fbd5 	bl	8015448 <memset>
    ctr[15] = 1;
 8002c9e:	2301      	movs	r3, #1
 8002ca0:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
     * Authenticate and {en,de}crypt the message.
     *
     * The only difference between encryption and decryption is
     * the respective order of authentication and {en,de}cryption.
     */
    len_left = length;
 8002ca4:	687b      	ldr	r3, [r7, #4]
 8002ca6:	663b      	str	r3, [r7, #96]	@ 0x60
    src = input;
 8002ca8:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8002caa:	65fb      	str	r3, [r7, #92]	@ 0x5c
    dst = output;
 8002cac:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8002cb0:	65bb      	str	r3, [r7, #88]	@ 0x58

    while( len_left > 0 )
 8002cb2:	e0f1      	b.n	8002e98 <ccm_auth_crypt+0x510>
    {
        size_t use_len = len_left > 16 ? 16 : len_left;
 8002cb4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8002cb6:	2b10      	cmp	r3, #16
 8002cb8:	bf28      	it	cs
 8002cba:	2310      	movcs	r3, #16
 8002cbc:	64bb      	str	r3, [r7, #72]	@ 0x48

        if( mode == CCM_ENCRYPT )
 8002cbe:	68bb      	ldr	r3, [r7, #8]
 8002cc0:	2b00      	cmp	r3, #0
 8002cc2:	d140      	bne.n	8002d46 <ccm_auth_crypt+0x3be>
        {
            memset( b, 0, 16 );
 8002cc4:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 8002cc8:	2210      	movs	r2, #16
 8002cca:	2100      	movs	r1, #0
 8002ccc:	4618      	mov	r0, r3
 8002cce:	f012 fbbb 	bl	8015448 <memset>
            memcpy( b, src, use_len );
 8002cd2:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 8002cd6:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8002cd8:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8002cda:	4618      	mov	r0, r3
 8002cdc:	f012 fc3f 	bl	801555e <memcpy>
            UPDATE_CBC_MAC;
 8002ce0:	2300      	movs	r3, #0
 8002ce2:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002ce6:	e018      	b.n	8002d1a <ccm_auth_crypt+0x392>
 8002ce8:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002cec:	3368      	adds	r3, #104	@ 0x68
 8002cee:	443b      	add	r3, r7
 8002cf0:	f813 1c44 	ldrb.w	r1, [r3, #-68]
 8002cf4:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002cf8:	3368      	adds	r3, #104	@ 0x68
 8002cfa:	443b      	add	r3, r7
 8002cfc:	f813 2c34 	ldrb.w	r2, [r3, #-52]
 8002d00:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002d04:	404a      	eors	r2, r1
 8002d06:	b2d2      	uxtb	r2, r2
 8002d08:	3368      	adds	r3, #104	@ 0x68
 8002d0a:	443b      	add	r3, r7
 8002d0c:	f803 2c44 	strb.w	r2, [r3, #-68]
 8002d10:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002d14:	3301      	adds	r3, #1
 8002d16:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002d1a:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002d1e:	2b0f      	cmp	r3, #15
 8002d20:	d9e2      	bls.n	8002ce8 <ccm_auth_crypt+0x360>
 8002d22:	68f8      	ldr	r0, [r7, #12]
 8002d24:	f107 0224 	add.w	r2, r7, #36	@ 0x24
 8002d28:	f107 0124 	add.w	r1, r7, #36	@ 0x24
 8002d2c:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 8002d30:	9300      	str	r3, [sp, #0]
 8002d32:	4613      	mov	r3, r2
 8002d34:	2210      	movs	r2, #16
 8002d36:	f001 fa43 	bl	80041c0 <mbedtls_cipher_update>
 8002d3a:	6578      	str	r0, [r7, #84]	@ 0x54
 8002d3c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002d3e:	2b00      	cmp	r3, #0
 8002d40:	d001      	beq.n	8002d46 <ccm_auth_crypt+0x3be>
 8002d42:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002d44:	e101      	b.n	8002f4a <ccm_auth_crypt+0x5c2>
        }

        CTR_CRYPT( dst, src, use_len );
 8002d46:	68f8      	ldr	r0, [r7, #12]
 8002d48:	f107 0234 	add.w	r2, r7, #52	@ 0x34
 8002d4c:	f107 0114 	add.w	r1, r7, #20
 8002d50:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 8002d54:	9300      	str	r3, [sp, #0]
 8002d56:	4613      	mov	r3, r2
 8002d58:	2210      	movs	r2, #16
 8002d5a:	f001 fa31 	bl	80041c0 <mbedtls_cipher_update>
 8002d5e:	6578      	str	r0, [r7, #84]	@ 0x54
 8002d60:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002d62:	2b00      	cmp	r3, #0
 8002d64:	d001      	beq.n	8002d6a <ccm_auth_crypt+0x3e2>
 8002d66:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002d68:	e0ef      	b.n	8002f4a <ccm_auth_crypt+0x5c2>
 8002d6a:	2300      	movs	r3, #0
 8002d6c:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002d70:	e016      	b.n	8002da0 <ccm_auth_crypt+0x418>
 8002d72:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002d76:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8002d78:	4413      	add	r3, r2
 8002d7a:	7819      	ldrb	r1, [r3, #0]
 8002d7c:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002d80:	3368      	adds	r3, #104	@ 0x68
 8002d82:	443b      	add	r3, r7
 8002d84:	f813 2c34 	ldrb.w	r2, [r3, #-52]
 8002d88:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002d8c:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8002d8e:	4403      	add	r3, r0
 8002d90:	404a      	eors	r2, r1
 8002d92:	b2d2      	uxtb	r2, r2
 8002d94:	701a      	strb	r2, [r3, #0]
 8002d96:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002d9a:	3301      	adds	r3, #1
 8002d9c:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002da0:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002da4:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8002da6:	429a      	cmp	r2, r3
 8002da8:	d8e3      	bhi.n	8002d72 <ccm_auth_crypt+0x3ea>

        if( mode == CCM_DECRYPT )
 8002daa:	68bb      	ldr	r3, [r7, #8]
 8002dac:	2b01      	cmp	r3, #1
 8002dae:	d140      	bne.n	8002e32 <ccm_auth_crypt+0x4aa>
        {
            memset( b, 0, 16 );
 8002db0:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 8002db4:	2210      	movs	r2, #16
 8002db6:	2100      	movs	r1, #0
 8002db8:	4618      	mov	r0, r3
 8002dba:	f012 fb45 	bl	8015448 <memset>
            memcpy( b, dst, use_len );
 8002dbe:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 8002dc2:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8002dc4:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 8002dc6:	4618      	mov	r0, r3
 8002dc8:	f012 fbc9 	bl	801555e <memcpy>
            UPDATE_CBC_MAC;
 8002dcc:	2300      	movs	r3, #0
 8002dce:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002dd2:	e018      	b.n	8002e06 <ccm_auth_crypt+0x47e>
 8002dd4:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002dd8:	3368      	adds	r3, #104	@ 0x68
 8002dda:	443b      	add	r3, r7
 8002ddc:	f813 1c44 	ldrb.w	r1, [r3, #-68]
 8002de0:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002de4:	3368      	adds	r3, #104	@ 0x68
 8002de6:	443b      	add	r3, r7
 8002de8:	f813 2c34 	ldrb.w	r2, [r3, #-52]
 8002dec:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002df0:	404a      	eors	r2, r1
 8002df2:	b2d2      	uxtb	r2, r2
 8002df4:	3368      	adds	r3, #104	@ 0x68
 8002df6:	443b      	add	r3, r7
 8002df8:	f803 2c44 	strb.w	r2, [r3, #-68]
 8002dfc:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002e00:	3301      	adds	r3, #1
 8002e02:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002e06:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002e0a:	2b0f      	cmp	r3, #15
 8002e0c:	d9e2      	bls.n	8002dd4 <ccm_auth_crypt+0x44c>
 8002e0e:	68f8      	ldr	r0, [r7, #12]
 8002e10:	f107 0224 	add.w	r2, r7, #36	@ 0x24
 8002e14:	f107 0124 	add.w	r1, r7, #36	@ 0x24
 8002e18:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 8002e1c:	9300      	str	r3, [sp, #0]
 8002e1e:	4613      	mov	r3, r2
 8002e20:	2210      	movs	r2, #16
 8002e22:	f001 f9cd 	bl	80041c0 <mbedtls_cipher_update>
 8002e26:	6578      	str	r0, [r7, #84]	@ 0x54
 8002e28:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002e2a:	2b00      	cmp	r3, #0
 8002e2c:	d001      	beq.n	8002e32 <ccm_auth_crypt+0x4aa>
 8002e2e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002e30:	e08b      	b.n	8002f4a <ccm_auth_crypt+0x5c2>
        }

        dst += use_len;
 8002e32:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8002e34:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8002e36:	4413      	add	r3, r2
 8002e38:	65bb      	str	r3, [r7, #88]	@ 0x58
        src += use_len;
 8002e3a:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8002e3c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8002e3e:	4413      	add	r3, r2
 8002e40:	65fb      	str	r3, [r7, #92]	@ 0x5c
        len_left -= use_len;
 8002e42:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8002e44:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8002e46:	1ad3      	subs	r3, r2, r3
 8002e48:	663b      	str	r3, [r7, #96]	@ 0x60

        /*
         * Increment counter.
         * No need to check for overflow thanks to the length check above.
         */
        for( i = 0; i < q; i++ )
 8002e4a:	2300      	movs	r3, #0
 8002e4c:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002e50:	e01a      	b.n	8002e88 <ccm_auth_crypt+0x500>
            if( ++ctr[15-i] != 0 )
 8002e52:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002e56:	f1c3 030f 	rsb	r3, r3, #15
 8002e5a:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 8002e5e:	443a      	add	r2, r7
 8002e60:	f812 2c54 	ldrb.w	r2, [r2, #-84]
 8002e64:	3201      	adds	r2, #1
 8002e66:	b2d1      	uxtb	r1, r2
 8002e68:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 8002e6c:	443a      	add	r2, r7
 8002e6e:	f802 1c54 	strb.w	r1, [r2, #-84]
 8002e72:	3368      	adds	r3, #104	@ 0x68
 8002e74:	443b      	add	r3, r7
 8002e76:	f813 3c54 	ldrb.w	r3, [r3, #-84]
 8002e7a:	2b00      	cmp	r3, #0
 8002e7c:	d10b      	bne.n	8002e96 <ccm_auth_crypt+0x50e>
        for( i = 0; i < q; i++ )
 8002e7e:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002e82:	3301      	adds	r3, #1
 8002e84:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002e88:	f897 2067 	ldrb.w	r2, [r7, #103]	@ 0x67
 8002e8c:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 8002e90:	429a      	cmp	r2, r3
 8002e92:	d3de      	bcc.n	8002e52 <ccm_auth_crypt+0x4ca>
 8002e94:	e000      	b.n	8002e98 <ccm_auth_crypt+0x510>
                break;
 8002e96:	bf00      	nop
    while( len_left > 0 )
 8002e98:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8002e9a:	2b00      	cmp	r3, #0
 8002e9c:	f47f af0a 	bne.w	8002cb4 <ccm_auth_crypt+0x32c>
    }

    /*
     * Authentication: reset counter and crypt/mask internal tag
     */
    for( i = 0; i < q; i++ )
 8002ea0:	2300      	movs	r3, #0
 8002ea2:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002ea6:	e00d      	b.n	8002ec4 <ccm_auth_crypt+0x53c>
        ctr[15-i] = 0;
 8002ea8:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002eac:	f1c3 030f 	rsb	r3, r3, #15
 8002eb0:	3368      	adds	r3, #104	@ 0x68
 8002eb2:	443b      	add	r3, r7
 8002eb4:	2200      	movs	r2, #0
 8002eb6:	f803 2c54 	strb.w	r2, [r3, #-84]
    for( i = 0; i < q; i++ )
 8002eba:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002ebe:	3301      	adds	r3, #1
 8002ec0:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002ec4:	f897 2067 	ldrb.w	r2, [r7, #103]	@ 0x67
 8002ec8:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 8002ecc:	429a      	cmp	r2, r3
 8002ece:	d3eb      	bcc.n	8002ea8 <ccm_auth_crypt+0x520>

    CTR_CRYPT( y, y, 16 );
 8002ed0:	68f8      	ldr	r0, [r7, #12]
 8002ed2:	f107 0234 	add.w	r2, r7, #52	@ 0x34
 8002ed6:	f107 0114 	add.w	r1, r7, #20
 8002eda:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 8002ede:	9300      	str	r3, [sp, #0]
 8002ee0:	4613      	mov	r3, r2
 8002ee2:	2210      	movs	r2, #16
 8002ee4:	f001 f96c 	bl	80041c0 <mbedtls_cipher_update>
 8002ee8:	6578      	str	r0, [r7, #84]	@ 0x54
 8002eea:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002eec:	2b00      	cmp	r3, #0
 8002eee:	d001      	beq.n	8002ef4 <ccm_auth_crypt+0x56c>
 8002ef0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8002ef2:	e02a      	b.n	8002f4a <ccm_auth_crypt+0x5c2>
 8002ef4:	2300      	movs	r3, #0
 8002ef6:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002efa:	e018      	b.n	8002f2e <ccm_auth_crypt+0x5a6>
 8002efc:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002f00:	3368      	adds	r3, #104	@ 0x68
 8002f02:	443b      	add	r3, r7
 8002f04:	f813 1c44 	ldrb.w	r1, [r3, #-68]
 8002f08:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002f0c:	3368      	adds	r3, #104	@ 0x68
 8002f0e:	443b      	add	r3, r7
 8002f10:	f813 2c34 	ldrb.w	r2, [r3, #-52]
 8002f14:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002f18:	404a      	eors	r2, r1
 8002f1a:	b2d2      	uxtb	r2, r2
 8002f1c:	3368      	adds	r3, #104	@ 0x68
 8002f1e:	443b      	add	r3, r7
 8002f20:	f803 2c44 	strb.w	r2, [r3, #-68]
 8002f24:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002f28:	3301      	adds	r3, #1
 8002f2a:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8002f2e:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8002f32:	2b0f      	cmp	r3, #15
 8002f34:	d9e2      	bls.n	8002efc <ccm_auth_crypt+0x574>
    memcpy( tag, y, tag_len );
 8002f36:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8002f3a:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 8002f3e:	4619      	mov	r1, r3
 8002f40:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 8002f44:	f012 fb0b 	bl	801555e <memcpy>

    return( 0 );
 8002f48:	2300      	movs	r3, #0
}
 8002f4a:	4618      	mov	r0, r3
 8002f4c:	3768      	adds	r7, #104	@ 0x68
 8002f4e:	46bd      	mov	sp, r7
 8002f50:	bd80      	pop	{r7, pc}

08002f52 <mbedtls_ccm_star_encrypt_and_tag>:
int mbedtls_ccm_star_encrypt_and_tag( mbedtls_ccm_context *ctx, size_t length,
                         const unsigned char *iv, size_t iv_len,
                         const unsigned char *add, size_t add_len,
                         const unsigned char *input, unsigned char *output,
                         unsigned char *tag, size_t tag_len )
{
 8002f52:	b580      	push	{r7, lr}
 8002f54:	b08c      	sub	sp, #48	@ 0x30
 8002f56:	af08      	add	r7, sp, #32
 8002f58:	60f8      	str	r0, [r7, #12]
 8002f5a:	60b9      	str	r1, [r7, #8]
 8002f5c:	607a      	str	r2, [r7, #4]
 8002f5e:	603b      	str	r3, [r7, #0]
    CCM_VALIDATE_RET( iv != NULL );
    CCM_VALIDATE_RET( add_len == 0 || add != NULL );
    CCM_VALIDATE_RET( length == 0 || input != NULL );
    CCM_VALIDATE_RET( length == 0 || output != NULL );
    CCM_VALIDATE_RET( tag_len == 0 || tag != NULL );
    return( ccm_auth_crypt( ctx, CCM_ENCRYPT, length, iv, iv_len,
 8002f60:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8002f62:	9306      	str	r3, [sp, #24]
 8002f64:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8002f66:	9305      	str	r3, [sp, #20]
 8002f68:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8002f6a:	9304      	str	r3, [sp, #16]
 8002f6c:	6a3b      	ldr	r3, [r7, #32]
 8002f6e:	9303      	str	r3, [sp, #12]
 8002f70:	69fb      	ldr	r3, [r7, #28]
 8002f72:	9302      	str	r3, [sp, #8]
 8002f74:	69bb      	ldr	r3, [r7, #24]
 8002f76:	9301      	str	r3, [sp, #4]
 8002f78:	683b      	ldr	r3, [r7, #0]
 8002f7a:	9300      	str	r3, [sp, #0]
 8002f7c:	687b      	ldr	r3, [r7, #4]
 8002f7e:	68ba      	ldr	r2, [r7, #8]
 8002f80:	2100      	movs	r1, #0
 8002f82:	68f8      	ldr	r0, [r7, #12]
 8002f84:	f7ff fd00 	bl	8002988 <ccm_auth_crypt>
 8002f88:	4603      	mov	r3, r0
                            add, add_len, input, output, tag, tag_len ) );
}
 8002f8a:	4618      	mov	r0, r3
 8002f8c:	3710      	adds	r7, #16
 8002f8e:	46bd      	mov	sp, r7
 8002f90:	bd80      	pop	{r7, pc}

08002f92 <mbedtls_ccm_encrypt_and_tag>:
int mbedtls_ccm_encrypt_and_tag( mbedtls_ccm_context *ctx, size_t length,
                         const unsigned char *iv, size_t iv_len,
                         const unsigned char *add, size_t add_len,
                         const unsigned char *input, unsigned char *output,
                         unsigned char *tag, size_t tag_len )
{
 8002f92:	b580      	push	{r7, lr}
 8002f94:	b08a      	sub	sp, #40	@ 0x28
 8002f96:	af06      	add	r7, sp, #24
 8002f98:	60f8      	str	r0, [r7, #12]
 8002f9a:	60b9      	str	r1, [r7, #8]
 8002f9c:	607a      	str	r2, [r7, #4]
 8002f9e:	603b      	str	r3, [r7, #0]
    CCM_VALIDATE_RET( iv != NULL );
    CCM_VALIDATE_RET( add_len == 0 || add != NULL );
    CCM_VALIDATE_RET( length == 0 || input != NULL );
    CCM_VALIDATE_RET( length == 0 || output != NULL );
    CCM_VALIDATE_RET( tag_len == 0 || tag != NULL );
    if( tag_len == 0 )
 8002fa0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8002fa2:	2b00      	cmp	r3, #0
 8002fa4:	d102      	bne.n	8002fac <mbedtls_ccm_encrypt_and_tag+0x1a>
        return( MBEDTLS_ERR_CCM_BAD_INPUT );
 8002fa6:	f06f 030c 	mvn.w	r3, #12
 8002faa:	e012      	b.n	8002fd2 <mbedtls_ccm_encrypt_and_tag+0x40>

    return( mbedtls_ccm_star_encrypt_and_tag( ctx, length, iv, iv_len, add,
 8002fac:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8002fae:	9305      	str	r3, [sp, #20]
 8002fb0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8002fb2:	9304      	str	r3, [sp, #16]
 8002fb4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8002fb6:	9303      	str	r3, [sp, #12]
 8002fb8:	6a3b      	ldr	r3, [r7, #32]
 8002fba:	9302      	str	r3, [sp, #8]
 8002fbc:	69fb      	ldr	r3, [r7, #28]
 8002fbe:	9301      	str	r3, [sp, #4]
 8002fc0:	69bb      	ldr	r3, [r7, #24]
 8002fc2:	9300      	str	r3, [sp, #0]
 8002fc4:	683b      	ldr	r3, [r7, #0]
 8002fc6:	687a      	ldr	r2, [r7, #4]
 8002fc8:	68b9      	ldr	r1, [r7, #8]
 8002fca:	68f8      	ldr	r0, [r7, #12]
 8002fcc:	f7ff ffc1 	bl	8002f52 <mbedtls_ccm_star_encrypt_and_tag>
 8002fd0:	4603      	mov	r3, r0
                add_len, input, output, tag, tag_len ) );
}
 8002fd2:	4618      	mov	r0, r3
 8002fd4:	3710      	adds	r7, #16
 8002fd6:	46bd      	mov	sp, r7
 8002fd8:	bd80      	pop	{r7, pc}

08002fda <mbedtls_ccm_star_auth_decrypt>:
int mbedtls_ccm_star_auth_decrypt( mbedtls_ccm_context *ctx, size_t length,
                      const unsigned char *iv, size_t iv_len,
                      const unsigned char *add, size_t add_len,
                      const unsigned char *input, unsigned char *output,
                      const unsigned char *tag, size_t tag_len )
{
 8002fda:	b580      	push	{r7, lr}
 8002fdc:	b094      	sub	sp, #80	@ 0x50
 8002fde:	af08      	add	r7, sp, #32
 8002fe0:	60f8      	str	r0, [r7, #12]
 8002fe2:	60b9      	str	r1, [r7, #8]
 8002fe4:	607a      	str	r2, [r7, #4]
 8002fe6:	603b      	str	r3, [r7, #0]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 8002fe8:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8002fec:	627b      	str	r3, [r7, #36]	@ 0x24
    CCM_VALIDATE_RET( add_len == 0 || add != NULL );
    CCM_VALIDATE_RET( length == 0 || input != NULL );
    CCM_VALIDATE_RET( length == 0 || output != NULL );
    CCM_VALIDATE_RET( tag_len == 0 || tag != NULL );

    if( ( ret = ccm_auth_crypt( ctx, CCM_DECRYPT, length,
 8002fee:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8002ff0:	9306      	str	r3, [sp, #24]
 8002ff2:	f107 0314 	add.w	r3, r7, #20
 8002ff6:	9305      	str	r3, [sp, #20]
 8002ff8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8002ffa:	9304      	str	r3, [sp, #16]
 8002ffc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8002ffe:	9303      	str	r3, [sp, #12]
 8003000:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8003002:	9302      	str	r3, [sp, #8]
 8003004:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8003006:	9301      	str	r3, [sp, #4]
 8003008:	683b      	ldr	r3, [r7, #0]
 800300a:	9300      	str	r3, [sp, #0]
 800300c:	687b      	ldr	r3, [r7, #4]
 800300e:	68ba      	ldr	r2, [r7, #8]
 8003010:	2101      	movs	r1, #1
 8003012:	68f8      	ldr	r0, [r7, #12]
 8003014:	f7ff fcb8 	bl	8002988 <ccm_auth_crypt>
 8003018:	6278      	str	r0, [r7, #36]	@ 0x24
 800301a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800301c:	2b00      	cmp	r3, #0
 800301e:	d001      	beq.n	8003024 <mbedtls_ccm_star_auth_decrypt+0x4a>
                                iv, iv_len, add, add_len,
                                input, output, check_tag, tag_len ) ) != 0 )
    {
        return( ret );
 8003020:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003022:	e02b      	b.n	800307c <mbedtls_ccm_star_auth_decrypt+0xa2>
    }

    /* Check tag in "constant-time" */
    for( diff = 0, i = 0; i < tag_len; i++ )
 8003024:	2300      	movs	r3, #0
 8003026:	62bb      	str	r3, [r7, #40]	@ 0x28
 8003028:	2300      	movs	r3, #0
 800302a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
 800302e:	e015      	b.n	800305c <mbedtls_ccm_star_auth_decrypt+0x82>
        diff |= tag[i] ^ check_tag[i];
 8003030:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8003034:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8003036:	4413      	add	r3, r2
 8003038:	781a      	ldrb	r2, [r3, #0]
 800303a:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800303e:	3330      	adds	r3, #48	@ 0x30
 8003040:	443b      	add	r3, r7
 8003042:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
 8003046:	4053      	eors	r3, r2
 8003048:	b2db      	uxtb	r3, r3
 800304a:	461a      	mov	r2, r3
 800304c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800304e:	4313      	orrs	r3, r2
 8003050:	62bb      	str	r3, [r7, #40]	@ 0x28
    for( diff = 0, i = 0; i < tag_len; i++ )
 8003052:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8003056:	3301      	adds	r3, #1
 8003058:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
 800305c:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8003060:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8003062:	429a      	cmp	r2, r3
 8003064:	d8e4      	bhi.n	8003030 <mbedtls_ccm_star_auth_decrypt+0x56>

    if( diff != 0 )
 8003066:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8003068:	2b00      	cmp	r3, #0
 800306a:	d006      	beq.n	800307a <mbedtls_ccm_star_auth_decrypt+0xa0>
    {
        mbedtls_platform_zeroize( output, length );
 800306c:	68b9      	ldr	r1, [r7, #8]
 800306e:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 8003070:	f003 f8b6 	bl	80061e0 <mbedtls_platform_zeroize>
        return( MBEDTLS_ERR_CCM_AUTH_FAILED );
 8003074:	f06f 030e 	mvn.w	r3, #14
 8003078:	e000      	b.n	800307c <mbedtls_ccm_star_auth_decrypt+0xa2>
    }

    return( 0 );
 800307a:	2300      	movs	r3, #0
}
 800307c:	4618      	mov	r0, r3
 800307e:	3730      	adds	r7, #48	@ 0x30
 8003080:	46bd      	mov	sp, r7
 8003082:	bd80      	pop	{r7, pc}

08003084 <mbedtls_ccm_auth_decrypt>:
int mbedtls_ccm_auth_decrypt( mbedtls_ccm_context *ctx, size_t length,
                      const unsigned char *iv, size_t iv_len,
                      const unsigned char *add, size_t add_len,
                      const unsigned char *input, unsigned char *output,
                      const unsigned char *tag, size_t tag_len )
{
 8003084:	b580      	push	{r7, lr}
 8003086:	b08a      	sub	sp, #40	@ 0x28
 8003088:	af06      	add	r7, sp, #24
 800308a:	60f8      	str	r0, [r7, #12]
 800308c:	60b9      	str	r1, [r7, #8]
 800308e:	607a      	str	r2, [r7, #4]
 8003090:	603b      	str	r3, [r7, #0]
    CCM_VALIDATE_RET( add_len == 0 || add != NULL );
    CCM_VALIDATE_RET( length == 0 || input != NULL );
    CCM_VALIDATE_RET( length == 0 || output != NULL );
    CCM_VALIDATE_RET( tag_len == 0 || tag != NULL );

    if( tag_len == 0 )
 8003092:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003094:	2b00      	cmp	r3, #0
 8003096:	d102      	bne.n	800309e <mbedtls_ccm_auth_decrypt+0x1a>
        return( MBEDTLS_ERR_CCM_BAD_INPUT );
 8003098:	f06f 030c 	mvn.w	r3, #12
 800309c:	e012      	b.n	80030c4 <mbedtls_ccm_auth_decrypt+0x40>

    return( mbedtls_ccm_star_auth_decrypt( ctx, length, iv, iv_len, add,
 800309e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80030a0:	9305      	str	r3, [sp, #20]
 80030a2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80030a4:	9304      	str	r3, [sp, #16]
 80030a6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80030a8:	9303      	str	r3, [sp, #12]
 80030aa:	6a3b      	ldr	r3, [r7, #32]
 80030ac:	9302      	str	r3, [sp, #8]
 80030ae:	69fb      	ldr	r3, [r7, #28]
 80030b0:	9301      	str	r3, [sp, #4]
 80030b2:	69bb      	ldr	r3, [r7, #24]
 80030b4:	9300      	str	r3, [sp, #0]
 80030b6:	683b      	ldr	r3, [r7, #0]
 80030b8:	687a      	ldr	r2, [r7, #4]
 80030ba:	68b9      	ldr	r1, [r7, #8]
 80030bc:	68f8      	ldr	r0, [r7, #12]
 80030be:	f7ff ff8c 	bl	8002fda <mbedtls_ccm_star_auth_decrypt>
 80030c2:	4603      	mov	r3, r0
                add_len, input, output, tag, tag_len ) );
}
 80030c4:	4618      	mov	r0, r3
 80030c6:	3710      	adds	r7, #16
 80030c8:	46bd      	mov	sp, r7
 80030ca:	bd80      	pop	{r7, pc}

080030cc <chacha20_quarter_round>:
static inline void chacha20_quarter_round( uint32_t state[16],
                                           size_t a,
                                           size_t b,
                                           size_t c,
                                           size_t d )
{
 80030cc:	b480      	push	{r7}
 80030ce:	b085      	sub	sp, #20
 80030d0:	af00      	add	r7, sp, #0
 80030d2:	60f8      	str	r0, [r7, #12]
 80030d4:	60b9      	str	r1, [r7, #8]
 80030d6:	607a      	str	r2, [r7, #4]
 80030d8:	603b      	str	r3, [r7, #0]
    /* a += b; d ^= a; d <<<= 16; */
    state[a] += state[b];
 80030da:	68bb      	ldr	r3, [r7, #8]
 80030dc:	009b      	lsls	r3, r3, #2
 80030de:	68fa      	ldr	r2, [r7, #12]
 80030e0:	4413      	add	r3, r2
 80030e2:	6819      	ldr	r1, [r3, #0]
 80030e4:	687b      	ldr	r3, [r7, #4]
 80030e6:	009b      	lsls	r3, r3, #2
 80030e8:	68fa      	ldr	r2, [r7, #12]
 80030ea:	4413      	add	r3, r2
 80030ec:	681a      	ldr	r2, [r3, #0]
 80030ee:	68bb      	ldr	r3, [r7, #8]
 80030f0:	009b      	lsls	r3, r3, #2
 80030f2:	68f8      	ldr	r0, [r7, #12]
 80030f4:	4403      	add	r3, r0
 80030f6:	440a      	add	r2, r1
 80030f8:	601a      	str	r2, [r3, #0]
    state[d] ^= state[a];
 80030fa:	69bb      	ldr	r3, [r7, #24]
 80030fc:	009b      	lsls	r3, r3, #2
 80030fe:	68fa      	ldr	r2, [r7, #12]
 8003100:	4413      	add	r3, r2
 8003102:	6819      	ldr	r1, [r3, #0]
 8003104:	68bb      	ldr	r3, [r7, #8]
 8003106:	009b      	lsls	r3, r3, #2
 8003108:	68fa      	ldr	r2, [r7, #12]
 800310a:	4413      	add	r3, r2
 800310c:	681a      	ldr	r2, [r3, #0]
 800310e:	69bb      	ldr	r3, [r7, #24]
 8003110:	009b      	lsls	r3, r3, #2
 8003112:	68f8      	ldr	r0, [r7, #12]
 8003114:	4403      	add	r3, r0
 8003116:	404a      	eors	r2, r1
 8003118:	601a      	str	r2, [r3, #0]
    state[d] = ROTL32( state[d], 16 );
 800311a:	69bb      	ldr	r3, [r7, #24]
 800311c:	009b      	lsls	r3, r3, #2
 800311e:	68fa      	ldr	r2, [r7, #12]
 8003120:	4413      	add	r3, r2
 8003122:	681a      	ldr	r2, [r3, #0]
 8003124:	69bb      	ldr	r3, [r7, #24]
 8003126:	009b      	lsls	r3, r3, #2
 8003128:	68f9      	ldr	r1, [r7, #12]
 800312a:	440b      	add	r3, r1
 800312c:	ea4f 4232 	mov.w	r2, r2, ror #16
 8003130:	601a      	str	r2, [r3, #0]

    /* c += d; b ^= c; b <<<= 12 */
    state[c] += state[d];
 8003132:	683b      	ldr	r3, [r7, #0]
 8003134:	009b      	lsls	r3, r3, #2
 8003136:	68fa      	ldr	r2, [r7, #12]
 8003138:	4413      	add	r3, r2
 800313a:	6819      	ldr	r1, [r3, #0]
 800313c:	69bb      	ldr	r3, [r7, #24]
 800313e:	009b      	lsls	r3, r3, #2
 8003140:	68fa      	ldr	r2, [r7, #12]
 8003142:	4413      	add	r3, r2
 8003144:	681a      	ldr	r2, [r3, #0]
 8003146:	683b      	ldr	r3, [r7, #0]
 8003148:	009b      	lsls	r3, r3, #2
 800314a:	68f8      	ldr	r0, [r7, #12]
 800314c:	4403      	add	r3, r0
 800314e:	440a      	add	r2, r1
 8003150:	601a      	str	r2, [r3, #0]
    state[b] ^= state[c];
 8003152:	687b      	ldr	r3, [r7, #4]
 8003154:	009b      	lsls	r3, r3, #2
 8003156:	68fa      	ldr	r2, [r7, #12]
 8003158:	4413      	add	r3, r2
 800315a:	6819      	ldr	r1, [r3, #0]
 800315c:	683b      	ldr	r3, [r7, #0]
 800315e:	009b      	lsls	r3, r3, #2
 8003160:	68fa      	ldr	r2, [r7, #12]
 8003162:	4413      	add	r3, r2
 8003164:	681a      	ldr	r2, [r3, #0]
 8003166:	687b      	ldr	r3, [r7, #4]
 8003168:	009b      	lsls	r3, r3, #2
 800316a:	68f8      	ldr	r0, [r7, #12]
 800316c:	4403      	add	r3, r0
 800316e:	404a      	eors	r2, r1
 8003170:	601a      	str	r2, [r3, #0]
    state[b] = ROTL32( state[b], 12 );
 8003172:	687b      	ldr	r3, [r7, #4]
 8003174:	009b      	lsls	r3, r3, #2
 8003176:	68fa      	ldr	r2, [r7, #12]
 8003178:	4413      	add	r3, r2
 800317a:	681a      	ldr	r2, [r3, #0]
 800317c:	687b      	ldr	r3, [r7, #4]
 800317e:	009b      	lsls	r3, r3, #2
 8003180:	68f9      	ldr	r1, [r7, #12]
 8003182:	440b      	add	r3, r1
 8003184:	ea4f 5232 	mov.w	r2, r2, ror #20
 8003188:	601a      	str	r2, [r3, #0]

    /* a += b; d ^= a; d <<<= 8; */
    state[a] += state[b];
 800318a:	68bb      	ldr	r3, [r7, #8]
 800318c:	009b      	lsls	r3, r3, #2
 800318e:	68fa      	ldr	r2, [r7, #12]
 8003190:	4413      	add	r3, r2
 8003192:	6819      	ldr	r1, [r3, #0]
 8003194:	687b      	ldr	r3, [r7, #4]
 8003196:	009b      	lsls	r3, r3, #2
 8003198:	68fa      	ldr	r2, [r7, #12]
 800319a:	4413      	add	r3, r2
 800319c:	681a      	ldr	r2, [r3, #0]
 800319e:	68bb      	ldr	r3, [r7, #8]
 80031a0:	009b      	lsls	r3, r3, #2
 80031a2:	68f8      	ldr	r0, [r7, #12]
 80031a4:	4403      	add	r3, r0
 80031a6:	440a      	add	r2, r1
 80031a8:	601a      	str	r2, [r3, #0]
    state[d] ^= state[a];
 80031aa:	69bb      	ldr	r3, [r7, #24]
 80031ac:	009b      	lsls	r3, r3, #2
 80031ae:	68fa      	ldr	r2, [r7, #12]
 80031b0:	4413      	add	r3, r2
 80031b2:	6819      	ldr	r1, [r3, #0]
 80031b4:	68bb      	ldr	r3, [r7, #8]
 80031b6:	009b      	lsls	r3, r3, #2
 80031b8:	68fa      	ldr	r2, [r7, #12]
 80031ba:	4413      	add	r3, r2
 80031bc:	681a      	ldr	r2, [r3, #0]
 80031be:	69bb      	ldr	r3, [r7, #24]
 80031c0:	009b      	lsls	r3, r3, #2
 80031c2:	68f8      	ldr	r0, [r7, #12]
 80031c4:	4403      	add	r3, r0
 80031c6:	404a      	eors	r2, r1
 80031c8:	601a      	str	r2, [r3, #0]
    state[d] = ROTL32( state[d], 8 );
 80031ca:	69bb      	ldr	r3, [r7, #24]
 80031cc:	009b      	lsls	r3, r3, #2
 80031ce:	68fa      	ldr	r2, [r7, #12]
 80031d0:	4413      	add	r3, r2
 80031d2:	681a      	ldr	r2, [r3, #0]
 80031d4:	69bb      	ldr	r3, [r7, #24]
 80031d6:	009b      	lsls	r3, r3, #2
 80031d8:	68f9      	ldr	r1, [r7, #12]
 80031da:	440b      	add	r3, r1
 80031dc:	ea4f 6232 	mov.w	r2, r2, ror #24
 80031e0:	601a      	str	r2, [r3, #0]

    /* c += d; b ^= c; b <<<= 7; */
    state[c] += state[d];
 80031e2:	683b      	ldr	r3, [r7, #0]
 80031e4:	009b      	lsls	r3, r3, #2
 80031e6:	68fa      	ldr	r2, [r7, #12]
 80031e8:	4413      	add	r3, r2
 80031ea:	6819      	ldr	r1, [r3, #0]
 80031ec:	69bb      	ldr	r3, [r7, #24]
 80031ee:	009b      	lsls	r3, r3, #2
 80031f0:	68fa      	ldr	r2, [r7, #12]
 80031f2:	4413      	add	r3, r2
 80031f4:	681a      	ldr	r2, [r3, #0]
 80031f6:	683b      	ldr	r3, [r7, #0]
 80031f8:	009b      	lsls	r3, r3, #2
 80031fa:	68f8      	ldr	r0, [r7, #12]
 80031fc:	4403      	add	r3, r0
 80031fe:	440a      	add	r2, r1
 8003200:	601a      	str	r2, [r3, #0]
    state[b] ^= state[c];
 8003202:	687b      	ldr	r3, [r7, #4]
 8003204:	009b      	lsls	r3, r3, #2
 8003206:	68fa      	ldr	r2, [r7, #12]
 8003208:	4413      	add	r3, r2
 800320a:	6819      	ldr	r1, [r3, #0]
 800320c:	683b      	ldr	r3, [r7, #0]
 800320e:	009b      	lsls	r3, r3, #2
 8003210:	68fa      	ldr	r2, [r7, #12]
 8003212:	4413      	add	r3, r2
 8003214:	681a      	ldr	r2, [r3, #0]
 8003216:	687b      	ldr	r3, [r7, #4]
 8003218:	009b      	lsls	r3, r3, #2
 800321a:	68f8      	ldr	r0, [r7, #12]
 800321c:	4403      	add	r3, r0
 800321e:	404a      	eors	r2, r1
 8003220:	601a      	str	r2, [r3, #0]
    state[b] = ROTL32( state[b], 7 );
 8003222:	687b      	ldr	r3, [r7, #4]
 8003224:	009b      	lsls	r3, r3, #2
 8003226:	68fa      	ldr	r2, [r7, #12]
 8003228:	4413      	add	r3, r2
 800322a:	681a      	ldr	r2, [r3, #0]
 800322c:	687b      	ldr	r3, [r7, #4]
 800322e:	009b      	lsls	r3, r3, #2
 8003230:	68f9      	ldr	r1, [r7, #12]
 8003232:	440b      	add	r3, r1
 8003234:	ea4f 6272 	mov.w	r2, r2, ror #25
 8003238:	601a      	str	r2, [r3, #0]
}
 800323a:	bf00      	nop
 800323c:	3714      	adds	r7, #20
 800323e:	46bd      	mov	sp, r7
 8003240:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003244:	4770      	bx	lr

08003246 <chacha20_inner_block>:
 *                  diagonal round.
 *
 * \param state     The ChaCha20 state to update.
 */
static void chacha20_inner_block( uint32_t state[16] )
{
 8003246:	b580      	push	{r7, lr}
 8003248:	b084      	sub	sp, #16
 800324a:	af02      	add	r7, sp, #8
 800324c:	6078      	str	r0, [r7, #4]
    chacha20_quarter_round( state, 0, 4, 8,  12 );
 800324e:	230c      	movs	r3, #12
 8003250:	9300      	str	r3, [sp, #0]
 8003252:	2308      	movs	r3, #8
 8003254:	2204      	movs	r2, #4
 8003256:	2100      	movs	r1, #0
 8003258:	6878      	ldr	r0, [r7, #4]
 800325a:	f7ff ff37 	bl	80030cc <chacha20_quarter_round>
    chacha20_quarter_round( state, 1, 5, 9,  13 );
 800325e:	230d      	movs	r3, #13
 8003260:	9300      	str	r3, [sp, #0]
 8003262:	2309      	movs	r3, #9
 8003264:	2205      	movs	r2, #5
 8003266:	2101      	movs	r1, #1
 8003268:	6878      	ldr	r0, [r7, #4]
 800326a:	f7ff ff2f 	bl	80030cc <chacha20_quarter_round>
    chacha20_quarter_round( state, 2, 6, 10, 14 );
 800326e:	230e      	movs	r3, #14
 8003270:	9300      	str	r3, [sp, #0]
 8003272:	230a      	movs	r3, #10
 8003274:	2206      	movs	r2, #6
 8003276:	2102      	movs	r1, #2
 8003278:	6878      	ldr	r0, [r7, #4]
 800327a:	f7ff ff27 	bl	80030cc <chacha20_quarter_round>
    chacha20_quarter_round( state, 3, 7, 11, 15 );
 800327e:	230f      	movs	r3, #15
 8003280:	9300      	str	r3, [sp, #0]
 8003282:	230b      	movs	r3, #11
 8003284:	2207      	movs	r2, #7
 8003286:	2103      	movs	r1, #3
 8003288:	6878      	ldr	r0, [r7, #4]
 800328a:	f7ff ff1f 	bl	80030cc <chacha20_quarter_round>

    chacha20_quarter_round( state, 0, 5, 10, 15 );
 800328e:	230f      	movs	r3, #15
 8003290:	9300      	str	r3, [sp, #0]
 8003292:	230a      	movs	r3, #10
 8003294:	2205      	movs	r2, #5
 8003296:	2100      	movs	r1, #0
 8003298:	6878      	ldr	r0, [r7, #4]
 800329a:	f7ff ff17 	bl	80030cc <chacha20_quarter_round>
    chacha20_quarter_round( state, 1, 6, 11, 12 );
 800329e:	230c      	movs	r3, #12
 80032a0:	9300      	str	r3, [sp, #0]
 80032a2:	230b      	movs	r3, #11
 80032a4:	2206      	movs	r2, #6
 80032a6:	2101      	movs	r1, #1
 80032a8:	6878      	ldr	r0, [r7, #4]
 80032aa:	f7ff ff0f 	bl	80030cc <chacha20_quarter_round>
    chacha20_quarter_round( state, 2, 7, 8,  13 );
 80032ae:	230d      	movs	r3, #13
 80032b0:	9300      	str	r3, [sp, #0]
 80032b2:	2308      	movs	r3, #8
 80032b4:	2207      	movs	r2, #7
 80032b6:	2102      	movs	r1, #2
 80032b8:	6878      	ldr	r0, [r7, #4]
 80032ba:	f7ff ff07 	bl	80030cc <chacha20_quarter_round>
    chacha20_quarter_round( state, 3, 4, 9,  14 );
 80032be:	230e      	movs	r3, #14
 80032c0:	9300      	str	r3, [sp, #0]
 80032c2:	2309      	movs	r3, #9
 80032c4:	2204      	movs	r2, #4
 80032c6:	2103      	movs	r1, #3
 80032c8:	6878      	ldr	r0, [r7, #4]
 80032ca:	f7ff feff 	bl	80030cc <chacha20_quarter_round>
}
 80032ce:	bf00      	nop
 80032d0:	3708      	adds	r7, #8
 80032d2:	46bd      	mov	sp, r7
 80032d4:	bd80      	pop	{r7, pc}

080032d6 <chacha20_block>:
 * \param initial_state The initial ChaCha20 state (key, nonce, counter).
 * \param keystream     Generated keystream bytes are written to this buffer.
 */
static void chacha20_block( const uint32_t initial_state[16],
                            unsigned char keystream[64] )
{
 80032d6:	b580      	push	{r7, lr}
 80032d8:	b094      	sub	sp, #80	@ 0x50
 80032da:	af00      	add	r7, sp, #0
 80032dc:	6078      	str	r0, [r7, #4]
 80032de:	6039      	str	r1, [r7, #0]
    uint32_t working_state[16];
    size_t i;

    memcpy( working_state,
 80032e0:	f107 0308 	add.w	r3, r7, #8
 80032e4:	2240      	movs	r2, #64	@ 0x40
 80032e6:	6879      	ldr	r1, [r7, #4]
 80032e8:	4618      	mov	r0, r3
 80032ea:	f012 f938 	bl	801555e <memcpy>
            initial_state,
            CHACHA20_BLOCK_SIZE_BYTES );

    for( i = 0U; i < 10U; i++ )
 80032ee:	2300      	movs	r3, #0
 80032f0:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80032f2:	e007      	b.n	8003304 <chacha20_block+0x2e>
        chacha20_inner_block( working_state );
 80032f4:	f107 0308 	add.w	r3, r7, #8
 80032f8:	4618      	mov	r0, r3
 80032fa:	f7ff ffa4 	bl	8003246 <chacha20_inner_block>
    for( i = 0U; i < 10U; i++ )
 80032fe:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8003300:	3301      	adds	r3, #1
 8003302:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8003304:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8003306:	2b09      	cmp	r3, #9
 8003308:	d9f4      	bls.n	80032f4 <chacha20_block+0x1e>

    working_state[ 0] += initial_state[ 0];
 800330a:	68ba      	ldr	r2, [r7, #8]
 800330c:	687b      	ldr	r3, [r7, #4]
 800330e:	681b      	ldr	r3, [r3, #0]
 8003310:	4413      	add	r3, r2
 8003312:	60bb      	str	r3, [r7, #8]
    working_state[ 1] += initial_state[ 1];
 8003314:	68fa      	ldr	r2, [r7, #12]
 8003316:	687b      	ldr	r3, [r7, #4]
 8003318:	3304      	adds	r3, #4
 800331a:	681b      	ldr	r3, [r3, #0]
 800331c:	4413      	add	r3, r2
 800331e:	60fb      	str	r3, [r7, #12]
    working_state[ 2] += initial_state[ 2];
 8003320:	693a      	ldr	r2, [r7, #16]
 8003322:	687b      	ldr	r3, [r7, #4]
 8003324:	3308      	adds	r3, #8
 8003326:	681b      	ldr	r3, [r3, #0]
 8003328:	4413      	add	r3, r2
 800332a:	613b      	str	r3, [r7, #16]
    working_state[ 3] += initial_state[ 3];
 800332c:	697a      	ldr	r2, [r7, #20]
 800332e:	687b      	ldr	r3, [r7, #4]
 8003330:	330c      	adds	r3, #12
 8003332:	681b      	ldr	r3, [r3, #0]
 8003334:	4413      	add	r3, r2
 8003336:	617b      	str	r3, [r7, #20]
    working_state[ 4] += initial_state[ 4];
 8003338:	69ba      	ldr	r2, [r7, #24]
 800333a:	687b      	ldr	r3, [r7, #4]
 800333c:	3310      	adds	r3, #16
 800333e:	681b      	ldr	r3, [r3, #0]
 8003340:	4413      	add	r3, r2
 8003342:	61bb      	str	r3, [r7, #24]
    working_state[ 5] += initial_state[ 5];
 8003344:	69fa      	ldr	r2, [r7, #28]
 8003346:	687b      	ldr	r3, [r7, #4]
 8003348:	3314      	adds	r3, #20
 800334a:	681b      	ldr	r3, [r3, #0]
 800334c:	4413      	add	r3, r2
 800334e:	61fb      	str	r3, [r7, #28]
    working_state[ 6] += initial_state[ 6];
 8003350:	6a3a      	ldr	r2, [r7, #32]
 8003352:	687b      	ldr	r3, [r7, #4]
 8003354:	3318      	adds	r3, #24
 8003356:	681b      	ldr	r3, [r3, #0]
 8003358:	4413      	add	r3, r2
 800335a:	623b      	str	r3, [r7, #32]
    working_state[ 7] += initial_state[ 7];
 800335c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800335e:	687b      	ldr	r3, [r7, #4]
 8003360:	331c      	adds	r3, #28
 8003362:	681b      	ldr	r3, [r3, #0]
 8003364:	4413      	add	r3, r2
 8003366:	627b      	str	r3, [r7, #36]	@ 0x24
    working_state[ 8] += initial_state[ 8];
 8003368:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800336a:	687b      	ldr	r3, [r7, #4]
 800336c:	3320      	adds	r3, #32
 800336e:	681b      	ldr	r3, [r3, #0]
 8003370:	4413      	add	r3, r2
 8003372:	62bb      	str	r3, [r7, #40]	@ 0x28
    working_state[ 9] += initial_state[ 9];
 8003374:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8003376:	687b      	ldr	r3, [r7, #4]
 8003378:	3324      	adds	r3, #36	@ 0x24
 800337a:	681b      	ldr	r3, [r3, #0]
 800337c:	4413      	add	r3, r2
 800337e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    working_state[10] += initial_state[10];
 8003380:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8003382:	687b      	ldr	r3, [r7, #4]
 8003384:	3328      	adds	r3, #40	@ 0x28
 8003386:	681b      	ldr	r3, [r3, #0]
 8003388:	4413      	add	r3, r2
 800338a:	633b      	str	r3, [r7, #48]	@ 0x30
    working_state[11] += initial_state[11];
 800338c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800338e:	687b      	ldr	r3, [r7, #4]
 8003390:	332c      	adds	r3, #44	@ 0x2c
 8003392:	681b      	ldr	r3, [r3, #0]
 8003394:	4413      	add	r3, r2
 8003396:	637b      	str	r3, [r7, #52]	@ 0x34
    working_state[12] += initial_state[12];
 8003398:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800339a:	687b      	ldr	r3, [r7, #4]
 800339c:	3330      	adds	r3, #48	@ 0x30
 800339e:	681b      	ldr	r3, [r3, #0]
 80033a0:	4413      	add	r3, r2
 80033a2:	63bb      	str	r3, [r7, #56]	@ 0x38
    working_state[13] += initial_state[13];
 80033a4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80033a6:	687b      	ldr	r3, [r7, #4]
 80033a8:	3334      	adds	r3, #52	@ 0x34
 80033aa:	681b      	ldr	r3, [r3, #0]
 80033ac:	4413      	add	r3, r2
 80033ae:	63fb      	str	r3, [r7, #60]	@ 0x3c
    working_state[14] += initial_state[14];
 80033b0:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80033b2:	687b      	ldr	r3, [r7, #4]
 80033b4:	3338      	adds	r3, #56	@ 0x38
 80033b6:	681b      	ldr	r3, [r3, #0]
 80033b8:	4413      	add	r3, r2
 80033ba:	643b      	str	r3, [r7, #64]	@ 0x40
    working_state[15] += initial_state[15];
 80033bc:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80033be:	687b      	ldr	r3, [r7, #4]
 80033c0:	333c      	adds	r3, #60	@ 0x3c
 80033c2:	681b      	ldr	r3, [r3, #0]
 80033c4:	4413      	add	r3, r2
 80033c6:	647b      	str	r3, [r7, #68]	@ 0x44

    for( i = 0U; i < 16; i++ )
 80033c8:	2300      	movs	r3, #0
 80033ca:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80033cc:	e037      	b.n	800343e <chacha20_block+0x168>
    {
        size_t offset = i * 4U;
 80033ce:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80033d0:	009b      	lsls	r3, r3, #2
 80033d2:	64bb      	str	r3, [r7, #72]	@ 0x48

        keystream[offset     ] = (unsigned char)( working_state[i]       );
 80033d4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80033d6:	009b      	lsls	r3, r3, #2
 80033d8:	3350      	adds	r3, #80	@ 0x50
 80033da:	443b      	add	r3, r7
 80033dc:	f853 1c48 	ldr.w	r1, [r3, #-72]
 80033e0:	683a      	ldr	r2, [r7, #0]
 80033e2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80033e4:	4413      	add	r3, r2
 80033e6:	b2ca      	uxtb	r2, r1
 80033e8:	701a      	strb	r2, [r3, #0]
        keystream[offset + 1U] = (unsigned char)( working_state[i] >>  8 );
 80033ea:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80033ec:	009b      	lsls	r3, r3, #2
 80033ee:	3350      	adds	r3, #80	@ 0x50
 80033f0:	443b      	add	r3, r7
 80033f2:	f853 3c48 	ldr.w	r3, [r3, #-72]
 80033f6:	0a19      	lsrs	r1, r3, #8
 80033f8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80033fa:	3301      	adds	r3, #1
 80033fc:	683a      	ldr	r2, [r7, #0]
 80033fe:	4413      	add	r3, r2
 8003400:	b2ca      	uxtb	r2, r1
 8003402:	701a      	strb	r2, [r3, #0]
        keystream[offset + 2U] = (unsigned char)( working_state[i] >> 16 );
 8003404:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8003406:	009b      	lsls	r3, r3, #2
 8003408:	3350      	adds	r3, #80	@ 0x50
 800340a:	443b      	add	r3, r7
 800340c:	f853 3c48 	ldr.w	r3, [r3, #-72]
 8003410:	0c19      	lsrs	r1, r3, #16
 8003412:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8003414:	3302      	adds	r3, #2
 8003416:	683a      	ldr	r2, [r7, #0]
 8003418:	4413      	add	r3, r2
 800341a:	b2ca      	uxtb	r2, r1
 800341c:	701a      	strb	r2, [r3, #0]
        keystream[offset + 3U] = (unsigned char)( working_state[i] >> 24 );
 800341e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8003420:	009b      	lsls	r3, r3, #2
 8003422:	3350      	adds	r3, #80	@ 0x50
 8003424:	443b      	add	r3, r7
 8003426:	f853 3c48 	ldr.w	r3, [r3, #-72]
 800342a:	0e19      	lsrs	r1, r3, #24
 800342c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800342e:	3303      	adds	r3, #3
 8003430:	683a      	ldr	r2, [r7, #0]
 8003432:	4413      	add	r3, r2
 8003434:	b2ca      	uxtb	r2, r1
 8003436:	701a      	strb	r2, [r3, #0]
    for( i = 0U; i < 16; i++ )
 8003438:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800343a:	3301      	adds	r3, #1
 800343c:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800343e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8003440:	2b0f      	cmp	r3, #15
 8003442:	d9c4      	bls.n	80033ce <chacha20_block+0xf8>
    }

    mbedtls_platform_zeroize( working_state, sizeof( working_state ) );
 8003444:	f107 0308 	add.w	r3, r7, #8
 8003448:	2140      	movs	r1, #64	@ 0x40
 800344a:	4618      	mov	r0, r3
 800344c:	f002 fec8 	bl	80061e0 <mbedtls_platform_zeroize>
}
 8003450:	bf00      	nop
 8003452:	3750      	adds	r7, #80	@ 0x50
 8003454:	46bd      	mov	sp, r7
 8003456:	bd80      	pop	{r7, pc}

08003458 <mbedtls_chacha20_init>:

void mbedtls_chacha20_init( mbedtls_chacha20_context *ctx )
{
 8003458:	b580      	push	{r7, lr}
 800345a:	b082      	sub	sp, #8
 800345c:	af00      	add	r7, sp, #0
 800345e:	6078      	str	r0, [r7, #4]
    CHACHA20_VALIDATE( ctx != NULL );

    mbedtls_platform_zeroize( ctx->state, sizeof( ctx->state ) );
 8003460:	687b      	ldr	r3, [r7, #4]
 8003462:	2140      	movs	r1, #64	@ 0x40
 8003464:	4618      	mov	r0, r3
 8003466:	f002 febb 	bl	80061e0 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( ctx->keystream8, sizeof( ctx->keystream8 ) );
 800346a:	687b      	ldr	r3, [r7, #4]
 800346c:	3340      	adds	r3, #64	@ 0x40
 800346e:	2140      	movs	r1, #64	@ 0x40
 8003470:	4618      	mov	r0, r3
 8003472:	f002 feb5 	bl	80061e0 <mbedtls_platform_zeroize>

    /* Initially, there's no keystream bytes available */
    ctx->keystream_bytes_used = CHACHA20_BLOCK_SIZE_BYTES;
 8003476:	687b      	ldr	r3, [r7, #4]
 8003478:	2240      	movs	r2, #64	@ 0x40
 800347a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
}
 800347e:	bf00      	nop
 8003480:	3708      	adds	r7, #8
 8003482:	46bd      	mov	sp, r7
 8003484:	bd80      	pop	{r7, pc}

08003486 <mbedtls_chacha20_free>:

void mbedtls_chacha20_free( mbedtls_chacha20_context *ctx )
{
 8003486:	b580      	push	{r7, lr}
 8003488:	b082      	sub	sp, #8
 800348a:	af00      	add	r7, sp, #0
 800348c:	6078      	str	r0, [r7, #4]
    if( ctx != NULL )
 800348e:	687b      	ldr	r3, [r7, #4]
 8003490:	2b00      	cmp	r3, #0
 8003492:	d003      	beq.n	800349c <mbedtls_chacha20_free+0x16>
    {
        mbedtls_platform_zeroize( ctx, sizeof( mbedtls_chacha20_context ) );
 8003494:	2184      	movs	r1, #132	@ 0x84
 8003496:	6878      	ldr	r0, [r7, #4]
 8003498:	f002 fea2 	bl	80061e0 <mbedtls_platform_zeroize>
    }
}
 800349c:	bf00      	nop
 800349e:	3708      	adds	r7, #8
 80034a0:	46bd      	mov	sp, r7
 80034a2:	bd80      	pop	{r7, pc}

080034a4 <mbedtls_chacha20_setkey>:

int mbedtls_chacha20_setkey( mbedtls_chacha20_context *ctx,
                            const unsigned char key[32] )
{
 80034a4:	b480      	push	{r7}
 80034a6:	b083      	sub	sp, #12
 80034a8:	af00      	add	r7, sp, #0
 80034aa:	6078      	str	r0, [r7, #4]
 80034ac:	6039      	str	r1, [r7, #0]
    CHACHA20_VALIDATE_RET( ctx != NULL );
    CHACHA20_VALIDATE_RET( key != NULL );

    /* ChaCha20 constants - the string "expand 32-byte k" */
    ctx->state[0] = 0x61707865;
 80034ae:	687b      	ldr	r3, [r7, #4]
 80034b0:	4a5c      	ldr	r2, [pc, #368]	@ (8003624 <mbedtls_chacha20_setkey+0x180>)
 80034b2:	601a      	str	r2, [r3, #0]
    ctx->state[1] = 0x3320646e;
 80034b4:	687b      	ldr	r3, [r7, #4]
 80034b6:	4a5c      	ldr	r2, [pc, #368]	@ (8003628 <mbedtls_chacha20_setkey+0x184>)
 80034b8:	605a      	str	r2, [r3, #4]
    ctx->state[2] = 0x79622d32;
 80034ba:	687b      	ldr	r3, [r7, #4]
 80034bc:	4a5b      	ldr	r2, [pc, #364]	@ (800362c <mbedtls_chacha20_setkey+0x188>)
 80034be:	609a      	str	r2, [r3, #8]
    ctx->state[3] = 0x6b206574;
 80034c0:	687b      	ldr	r3, [r7, #4]
 80034c2:	4a5b      	ldr	r2, [pc, #364]	@ (8003630 <mbedtls_chacha20_setkey+0x18c>)
 80034c4:	60da      	str	r2, [r3, #12]

    /* Set key */
    ctx->state[4]  = BYTES_TO_U32_LE( key, 0 );
 80034c6:	683b      	ldr	r3, [r7, #0]
 80034c8:	781b      	ldrb	r3, [r3, #0]
 80034ca:	461a      	mov	r2, r3
 80034cc:	683b      	ldr	r3, [r7, #0]
 80034ce:	3301      	adds	r3, #1
 80034d0:	781b      	ldrb	r3, [r3, #0]
 80034d2:	021b      	lsls	r3, r3, #8
 80034d4:	431a      	orrs	r2, r3
 80034d6:	683b      	ldr	r3, [r7, #0]
 80034d8:	3302      	adds	r3, #2
 80034da:	781b      	ldrb	r3, [r3, #0]
 80034dc:	041b      	lsls	r3, r3, #16
 80034de:	431a      	orrs	r2, r3
 80034e0:	683b      	ldr	r3, [r7, #0]
 80034e2:	3303      	adds	r3, #3
 80034e4:	781b      	ldrb	r3, [r3, #0]
 80034e6:	061b      	lsls	r3, r3, #24
 80034e8:	431a      	orrs	r2, r3
 80034ea:	687b      	ldr	r3, [r7, #4]
 80034ec:	611a      	str	r2, [r3, #16]
    ctx->state[5]  = BYTES_TO_U32_LE( key, 4 );
 80034ee:	683b      	ldr	r3, [r7, #0]
 80034f0:	3304      	adds	r3, #4
 80034f2:	781b      	ldrb	r3, [r3, #0]
 80034f4:	461a      	mov	r2, r3
 80034f6:	683b      	ldr	r3, [r7, #0]
 80034f8:	3305      	adds	r3, #5
 80034fa:	781b      	ldrb	r3, [r3, #0]
 80034fc:	021b      	lsls	r3, r3, #8
 80034fe:	431a      	orrs	r2, r3
 8003500:	683b      	ldr	r3, [r7, #0]
 8003502:	3306      	adds	r3, #6
 8003504:	781b      	ldrb	r3, [r3, #0]
 8003506:	041b      	lsls	r3, r3, #16
 8003508:	431a      	orrs	r2, r3
 800350a:	683b      	ldr	r3, [r7, #0]
 800350c:	3307      	adds	r3, #7
 800350e:	781b      	ldrb	r3, [r3, #0]
 8003510:	061b      	lsls	r3, r3, #24
 8003512:	431a      	orrs	r2, r3
 8003514:	687b      	ldr	r3, [r7, #4]
 8003516:	615a      	str	r2, [r3, #20]
    ctx->state[6]  = BYTES_TO_U32_LE( key, 8 );
 8003518:	683b      	ldr	r3, [r7, #0]
 800351a:	3308      	adds	r3, #8
 800351c:	781b      	ldrb	r3, [r3, #0]
 800351e:	461a      	mov	r2, r3
 8003520:	683b      	ldr	r3, [r7, #0]
 8003522:	3309      	adds	r3, #9
 8003524:	781b      	ldrb	r3, [r3, #0]
 8003526:	021b      	lsls	r3, r3, #8
 8003528:	431a      	orrs	r2, r3
 800352a:	683b      	ldr	r3, [r7, #0]
 800352c:	330a      	adds	r3, #10
 800352e:	781b      	ldrb	r3, [r3, #0]
 8003530:	041b      	lsls	r3, r3, #16
 8003532:	431a      	orrs	r2, r3
 8003534:	683b      	ldr	r3, [r7, #0]
 8003536:	330b      	adds	r3, #11
 8003538:	781b      	ldrb	r3, [r3, #0]
 800353a:	061b      	lsls	r3, r3, #24
 800353c:	431a      	orrs	r2, r3
 800353e:	687b      	ldr	r3, [r7, #4]
 8003540:	619a      	str	r2, [r3, #24]
    ctx->state[7]  = BYTES_TO_U32_LE( key, 12 );
 8003542:	683b      	ldr	r3, [r7, #0]
 8003544:	330c      	adds	r3, #12
 8003546:	781b      	ldrb	r3, [r3, #0]
 8003548:	461a      	mov	r2, r3
 800354a:	683b      	ldr	r3, [r7, #0]
 800354c:	330d      	adds	r3, #13
 800354e:	781b      	ldrb	r3, [r3, #0]
 8003550:	021b      	lsls	r3, r3, #8
 8003552:	431a      	orrs	r2, r3
 8003554:	683b      	ldr	r3, [r7, #0]
 8003556:	330e      	adds	r3, #14
 8003558:	781b      	ldrb	r3, [r3, #0]
 800355a:	041b      	lsls	r3, r3, #16
 800355c:	431a      	orrs	r2, r3
 800355e:	683b      	ldr	r3, [r7, #0]
 8003560:	330f      	adds	r3, #15
 8003562:	781b      	ldrb	r3, [r3, #0]
 8003564:	061b      	lsls	r3, r3, #24
 8003566:	431a      	orrs	r2, r3
 8003568:	687b      	ldr	r3, [r7, #4]
 800356a:	61da      	str	r2, [r3, #28]
    ctx->state[8]  = BYTES_TO_U32_LE( key, 16 );
 800356c:	683b      	ldr	r3, [r7, #0]
 800356e:	3310      	adds	r3, #16
 8003570:	781b      	ldrb	r3, [r3, #0]
 8003572:	461a      	mov	r2, r3
 8003574:	683b      	ldr	r3, [r7, #0]
 8003576:	3311      	adds	r3, #17
 8003578:	781b      	ldrb	r3, [r3, #0]
 800357a:	021b      	lsls	r3, r3, #8
 800357c:	431a      	orrs	r2, r3
 800357e:	683b      	ldr	r3, [r7, #0]
 8003580:	3312      	adds	r3, #18
 8003582:	781b      	ldrb	r3, [r3, #0]
 8003584:	041b      	lsls	r3, r3, #16
 8003586:	431a      	orrs	r2, r3
 8003588:	683b      	ldr	r3, [r7, #0]
 800358a:	3313      	adds	r3, #19
 800358c:	781b      	ldrb	r3, [r3, #0]
 800358e:	061b      	lsls	r3, r3, #24
 8003590:	431a      	orrs	r2, r3
 8003592:	687b      	ldr	r3, [r7, #4]
 8003594:	621a      	str	r2, [r3, #32]
    ctx->state[9]  = BYTES_TO_U32_LE( key, 20 );
 8003596:	683b      	ldr	r3, [r7, #0]
 8003598:	3314      	adds	r3, #20
 800359a:	781b      	ldrb	r3, [r3, #0]
 800359c:	461a      	mov	r2, r3
 800359e:	683b      	ldr	r3, [r7, #0]
 80035a0:	3315      	adds	r3, #21
 80035a2:	781b      	ldrb	r3, [r3, #0]
 80035a4:	021b      	lsls	r3, r3, #8
 80035a6:	431a      	orrs	r2, r3
 80035a8:	683b      	ldr	r3, [r7, #0]
 80035aa:	3316      	adds	r3, #22
 80035ac:	781b      	ldrb	r3, [r3, #0]
 80035ae:	041b      	lsls	r3, r3, #16
 80035b0:	431a      	orrs	r2, r3
 80035b2:	683b      	ldr	r3, [r7, #0]
 80035b4:	3317      	adds	r3, #23
 80035b6:	781b      	ldrb	r3, [r3, #0]
 80035b8:	061b      	lsls	r3, r3, #24
 80035ba:	431a      	orrs	r2, r3
 80035bc:	687b      	ldr	r3, [r7, #4]
 80035be:	625a      	str	r2, [r3, #36]	@ 0x24
    ctx->state[10] = BYTES_TO_U32_LE( key, 24 );
 80035c0:	683b      	ldr	r3, [r7, #0]
 80035c2:	3318      	adds	r3, #24
 80035c4:	781b      	ldrb	r3, [r3, #0]
 80035c6:	461a      	mov	r2, r3
 80035c8:	683b      	ldr	r3, [r7, #0]
 80035ca:	3319      	adds	r3, #25
 80035cc:	781b      	ldrb	r3, [r3, #0]
 80035ce:	021b      	lsls	r3, r3, #8
 80035d0:	431a      	orrs	r2, r3
 80035d2:	683b      	ldr	r3, [r7, #0]
 80035d4:	331a      	adds	r3, #26
 80035d6:	781b      	ldrb	r3, [r3, #0]
 80035d8:	041b      	lsls	r3, r3, #16
 80035da:	431a      	orrs	r2, r3
 80035dc:	683b      	ldr	r3, [r7, #0]
 80035de:	331b      	adds	r3, #27
 80035e0:	781b      	ldrb	r3, [r3, #0]
 80035e2:	061b      	lsls	r3, r3, #24
 80035e4:	431a      	orrs	r2, r3
 80035e6:	687b      	ldr	r3, [r7, #4]
 80035e8:	629a      	str	r2, [r3, #40]	@ 0x28
    ctx->state[11] = BYTES_TO_U32_LE( key, 28 );
 80035ea:	683b      	ldr	r3, [r7, #0]
 80035ec:	331c      	adds	r3, #28
 80035ee:	781b      	ldrb	r3, [r3, #0]
 80035f0:	461a      	mov	r2, r3
 80035f2:	683b      	ldr	r3, [r7, #0]
 80035f4:	331d      	adds	r3, #29
 80035f6:	781b      	ldrb	r3, [r3, #0]
 80035f8:	021b      	lsls	r3, r3, #8
 80035fa:	431a      	orrs	r2, r3
 80035fc:	683b      	ldr	r3, [r7, #0]
 80035fe:	331e      	adds	r3, #30
 8003600:	781b      	ldrb	r3, [r3, #0]
 8003602:	041b      	lsls	r3, r3, #16
 8003604:	431a      	orrs	r2, r3
 8003606:	683b      	ldr	r3, [r7, #0]
 8003608:	331f      	adds	r3, #31
 800360a:	781b      	ldrb	r3, [r3, #0]
 800360c:	061b      	lsls	r3, r3, #24
 800360e:	431a      	orrs	r2, r3
 8003610:	687b      	ldr	r3, [r7, #4]
 8003612:	62da      	str	r2, [r3, #44]	@ 0x2c

    return( 0 );
 8003614:	2300      	movs	r3, #0
}
 8003616:	4618      	mov	r0, r3
 8003618:	370c      	adds	r7, #12
 800361a:	46bd      	mov	sp, r7
 800361c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003620:	4770      	bx	lr
 8003622:	bf00      	nop
 8003624:	61707865 	.word	0x61707865
 8003628:	3320646e 	.word	0x3320646e
 800362c:	79622d32 	.word	0x79622d32
 8003630:	6b206574 	.word	0x6b206574

08003634 <mbedtls_chacha20_starts>:

int mbedtls_chacha20_starts( mbedtls_chacha20_context* ctx,
                             const unsigned char nonce[12],
                             uint32_t counter )
{
 8003634:	b580      	push	{r7, lr}
 8003636:	b084      	sub	sp, #16
 8003638:	af00      	add	r7, sp, #0
 800363a:	60f8      	str	r0, [r7, #12]
 800363c:	60b9      	str	r1, [r7, #8]
 800363e:	607a      	str	r2, [r7, #4]
    CHACHA20_VALIDATE_RET( ctx != NULL );
    CHACHA20_VALIDATE_RET( nonce != NULL );

    /* Counter */
    ctx->state[12] = counter;
 8003640:	68fb      	ldr	r3, [r7, #12]
 8003642:	687a      	ldr	r2, [r7, #4]
 8003644:	631a      	str	r2, [r3, #48]	@ 0x30

    /* Nonce */
    ctx->state[13] = BYTES_TO_U32_LE( nonce, 0 );
 8003646:	68bb      	ldr	r3, [r7, #8]
 8003648:	781b      	ldrb	r3, [r3, #0]
 800364a:	461a      	mov	r2, r3
 800364c:	68bb      	ldr	r3, [r7, #8]
 800364e:	3301      	adds	r3, #1
 8003650:	781b      	ldrb	r3, [r3, #0]
 8003652:	021b      	lsls	r3, r3, #8
 8003654:	431a      	orrs	r2, r3
 8003656:	68bb      	ldr	r3, [r7, #8]
 8003658:	3302      	adds	r3, #2
 800365a:	781b      	ldrb	r3, [r3, #0]
 800365c:	041b      	lsls	r3, r3, #16
 800365e:	431a      	orrs	r2, r3
 8003660:	68bb      	ldr	r3, [r7, #8]
 8003662:	3303      	adds	r3, #3
 8003664:	781b      	ldrb	r3, [r3, #0]
 8003666:	061b      	lsls	r3, r3, #24
 8003668:	431a      	orrs	r2, r3
 800366a:	68fb      	ldr	r3, [r7, #12]
 800366c:	635a      	str	r2, [r3, #52]	@ 0x34
    ctx->state[14] = BYTES_TO_U32_LE( nonce, 4 );
 800366e:	68bb      	ldr	r3, [r7, #8]
 8003670:	3304      	adds	r3, #4
 8003672:	781b      	ldrb	r3, [r3, #0]
 8003674:	461a      	mov	r2, r3
 8003676:	68bb      	ldr	r3, [r7, #8]
 8003678:	3305      	adds	r3, #5
 800367a:	781b      	ldrb	r3, [r3, #0]
 800367c:	021b      	lsls	r3, r3, #8
 800367e:	431a      	orrs	r2, r3
 8003680:	68bb      	ldr	r3, [r7, #8]
 8003682:	3306      	adds	r3, #6
 8003684:	781b      	ldrb	r3, [r3, #0]
 8003686:	041b      	lsls	r3, r3, #16
 8003688:	431a      	orrs	r2, r3
 800368a:	68bb      	ldr	r3, [r7, #8]
 800368c:	3307      	adds	r3, #7
 800368e:	781b      	ldrb	r3, [r3, #0]
 8003690:	061b      	lsls	r3, r3, #24
 8003692:	431a      	orrs	r2, r3
 8003694:	68fb      	ldr	r3, [r7, #12]
 8003696:	639a      	str	r2, [r3, #56]	@ 0x38
    ctx->state[15] = BYTES_TO_U32_LE( nonce, 8 );
 8003698:	68bb      	ldr	r3, [r7, #8]
 800369a:	3308      	adds	r3, #8
 800369c:	781b      	ldrb	r3, [r3, #0]
 800369e:	461a      	mov	r2, r3
 80036a0:	68bb      	ldr	r3, [r7, #8]
 80036a2:	3309      	adds	r3, #9
 80036a4:	781b      	ldrb	r3, [r3, #0]
 80036a6:	021b      	lsls	r3, r3, #8
 80036a8:	431a      	orrs	r2, r3
 80036aa:	68bb      	ldr	r3, [r7, #8]
 80036ac:	330a      	adds	r3, #10
 80036ae:	781b      	ldrb	r3, [r3, #0]
 80036b0:	041b      	lsls	r3, r3, #16
 80036b2:	431a      	orrs	r2, r3
 80036b4:	68bb      	ldr	r3, [r7, #8]
 80036b6:	330b      	adds	r3, #11
 80036b8:	781b      	ldrb	r3, [r3, #0]
 80036ba:	061b      	lsls	r3, r3, #24
 80036bc:	431a      	orrs	r2, r3
 80036be:	68fb      	ldr	r3, [r7, #12]
 80036c0:	63da      	str	r2, [r3, #60]	@ 0x3c

    mbedtls_platform_zeroize( ctx->keystream8, sizeof( ctx->keystream8 ) );
 80036c2:	68fb      	ldr	r3, [r7, #12]
 80036c4:	3340      	adds	r3, #64	@ 0x40
 80036c6:	2140      	movs	r1, #64	@ 0x40
 80036c8:	4618      	mov	r0, r3
 80036ca:	f002 fd89 	bl	80061e0 <mbedtls_platform_zeroize>

    /* Initially, there's no keystream bytes available */
    ctx->keystream_bytes_used = CHACHA20_BLOCK_SIZE_BYTES;
 80036ce:	68fb      	ldr	r3, [r7, #12]
 80036d0:	2240      	movs	r2, #64	@ 0x40
 80036d2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

    return( 0 );
 80036d6:	2300      	movs	r3, #0
}
 80036d8:	4618      	mov	r0, r3
 80036da:	3710      	adds	r7, #16
 80036dc:	46bd      	mov	sp, r7
 80036de:	bd80      	pop	{r7, pc}

080036e0 <mbedtls_chacha20_update>:

int mbedtls_chacha20_update( mbedtls_chacha20_context *ctx,
                              size_t size,
                              const unsigned char *input,
                              unsigned char *output )
{
 80036e0:	b580      	push	{r7, lr}
 80036e2:	b086      	sub	sp, #24
 80036e4:	af00      	add	r7, sp, #0
 80036e6:	60f8      	str	r0, [r7, #12]
 80036e8:	60b9      	str	r1, [r7, #8]
 80036ea:	607a      	str	r2, [r7, #4]
 80036ec:	603b      	str	r3, [r7, #0]
    size_t offset = 0U;
 80036ee:	2300      	movs	r3, #0
 80036f0:	617b      	str	r3, [r7, #20]
    CHACHA20_VALIDATE_RET( ctx != NULL );
    CHACHA20_VALIDATE_RET( size == 0 || input  != NULL );
    CHACHA20_VALIDATE_RET( size == 0 || output != NULL );

    /* Use leftover keystream bytes, if available */
    while( size > 0U && ctx->keystream_bytes_used < CHACHA20_BLOCK_SIZE_BYTES )
 80036f2:	e01d      	b.n	8003730 <mbedtls_chacha20_update+0x50>
    {
        output[offset] = input[offset]
 80036f4:	687a      	ldr	r2, [r7, #4]
 80036f6:	697b      	ldr	r3, [r7, #20]
 80036f8:	4413      	add	r3, r2
 80036fa:	7819      	ldrb	r1, [r3, #0]
                       ^ ctx->keystream8[ctx->keystream_bytes_used];
 80036fc:	68fb      	ldr	r3, [r7, #12]
 80036fe:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 8003702:	68fa      	ldr	r2, [r7, #12]
 8003704:	4413      	add	r3, r2
 8003706:	f893 2040 	ldrb.w	r2, [r3, #64]	@ 0x40
        output[offset] = input[offset]
 800370a:	6838      	ldr	r0, [r7, #0]
 800370c:	697b      	ldr	r3, [r7, #20]
 800370e:	4403      	add	r3, r0
 8003710:	404a      	eors	r2, r1
 8003712:	b2d2      	uxtb	r2, r2
 8003714:	701a      	strb	r2, [r3, #0]

        ctx->keystream_bytes_used++;
 8003716:	68fb      	ldr	r3, [r7, #12]
 8003718:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800371c:	1c5a      	adds	r2, r3, #1
 800371e:	68fb      	ldr	r3, [r7, #12]
 8003720:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
        offset++;
 8003724:	697b      	ldr	r3, [r7, #20]
 8003726:	3301      	adds	r3, #1
 8003728:	617b      	str	r3, [r7, #20]
        size--;
 800372a:	68bb      	ldr	r3, [r7, #8]
 800372c:	3b01      	subs	r3, #1
 800372e:	60bb      	str	r3, [r7, #8]
    while( size > 0U && ctx->keystream_bytes_used < CHACHA20_BLOCK_SIZE_BYTES )
 8003730:	68bb      	ldr	r3, [r7, #8]
 8003732:	2b00      	cmp	r3, #0
 8003734:	f000 80cf 	beq.w	80038d6 <mbedtls_chacha20_update+0x1f6>
 8003738:	68fb      	ldr	r3, [r7, #12]
 800373a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800373e:	2b3f      	cmp	r3, #63	@ 0x3f
 8003740:	d9d8      	bls.n	80036f4 <mbedtls_chacha20_update+0x14>
    }

    /* Process full blocks */
    while( size >= CHACHA20_BLOCK_SIZE_BYTES )
 8003742:	e0c8      	b.n	80038d6 <mbedtls_chacha20_update+0x1f6>
    {
        /* Generate new keystream block and increment counter */
        chacha20_block( ctx->state, ctx->keystream8 );
 8003744:	68fa      	ldr	r2, [r7, #12]
 8003746:	68fb      	ldr	r3, [r7, #12]
 8003748:	3340      	adds	r3, #64	@ 0x40
 800374a:	4619      	mov	r1, r3
 800374c:	4610      	mov	r0, r2
 800374e:	f7ff fdc2 	bl	80032d6 <chacha20_block>
        ctx->state[CHACHA20_CTR_INDEX]++;
 8003752:	68fb      	ldr	r3, [r7, #12]
 8003754:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8003756:	1c5a      	adds	r2, r3, #1
 8003758:	68fb      	ldr	r3, [r7, #12]
 800375a:	631a      	str	r2, [r3, #48]	@ 0x30

        for( i = 0U; i < 64U; i += 8U )
 800375c:	2300      	movs	r3, #0
 800375e:	613b      	str	r3, [r7, #16]
 8003760:	e0af      	b.n	80038c2 <mbedtls_chacha20_update+0x1e2>
        {
            output[offset + i  ] = input[offset + i  ] ^ ctx->keystream8[i  ];
 8003762:	697a      	ldr	r2, [r7, #20]
 8003764:	693b      	ldr	r3, [r7, #16]
 8003766:	4413      	add	r3, r2
 8003768:	687a      	ldr	r2, [r7, #4]
 800376a:	4413      	add	r3, r2
 800376c:	7819      	ldrb	r1, [r3, #0]
 800376e:	68fa      	ldr	r2, [r7, #12]
 8003770:	693b      	ldr	r3, [r7, #16]
 8003772:	4413      	add	r3, r2
 8003774:	3340      	adds	r3, #64	@ 0x40
 8003776:	781a      	ldrb	r2, [r3, #0]
 8003778:	6978      	ldr	r0, [r7, #20]
 800377a:	693b      	ldr	r3, [r7, #16]
 800377c:	4403      	add	r3, r0
 800377e:	6838      	ldr	r0, [r7, #0]
 8003780:	4403      	add	r3, r0
 8003782:	404a      	eors	r2, r1
 8003784:	b2d2      	uxtb	r2, r2
 8003786:	701a      	strb	r2, [r3, #0]
            output[offset + i+1] = input[offset + i+1] ^ ctx->keystream8[i+1];
 8003788:	697a      	ldr	r2, [r7, #20]
 800378a:	693b      	ldr	r3, [r7, #16]
 800378c:	4413      	add	r3, r2
 800378e:	3301      	adds	r3, #1
 8003790:	687a      	ldr	r2, [r7, #4]
 8003792:	4413      	add	r3, r2
 8003794:	7819      	ldrb	r1, [r3, #0]
 8003796:	693b      	ldr	r3, [r7, #16]
 8003798:	3301      	adds	r3, #1
 800379a:	68fa      	ldr	r2, [r7, #12]
 800379c:	4413      	add	r3, r2
 800379e:	f893 2040 	ldrb.w	r2, [r3, #64]	@ 0x40
 80037a2:	6978      	ldr	r0, [r7, #20]
 80037a4:	693b      	ldr	r3, [r7, #16]
 80037a6:	4403      	add	r3, r0
 80037a8:	3301      	adds	r3, #1
 80037aa:	6838      	ldr	r0, [r7, #0]
 80037ac:	4403      	add	r3, r0
 80037ae:	404a      	eors	r2, r1
 80037b0:	b2d2      	uxtb	r2, r2
 80037b2:	701a      	strb	r2, [r3, #0]
            output[offset + i+2] = input[offset + i+2] ^ ctx->keystream8[i+2];
 80037b4:	697a      	ldr	r2, [r7, #20]
 80037b6:	693b      	ldr	r3, [r7, #16]
 80037b8:	4413      	add	r3, r2
 80037ba:	3302      	adds	r3, #2
 80037bc:	687a      	ldr	r2, [r7, #4]
 80037be:	4413      	add	r3, r2
 80037c0:	7819      	ldrb	r1, [r3, #0]
 80037c2:	693b      	ldr	r3, [r7, #16]
 80037c4:	3302      	adds	r3, #2
 80037c6:	68fa      	ldr	r2, [r7, #12]
 80037c8:	4413      	add	r3, r2
 80037ca:	f893 2040 	ldrb.w	r2, [r3, #64]	@ 0x40
 80037ce:	6978      	ldr	r0, [r7, #20]
 80037d0:	693b      	ldr	r3, [r7, #16]
 80037d2:	4403      	add	r3, r0
 80037d4:	3302      	adds	r3, #2
 80037d6:	6838      	ldr	r0, [r7, #0]
 80037d8:	4403      	add	r3, r0
 80037da:	404a      	eors	r2, r1
 80037dc:	b2d2      	uxtb	r2, r2
 80037de:	701a      	strb	r2, [r3, #0]
            output[offset + i+3] = input[offset + i+3] ^ ctx->keystream8[i+3];
 80037e0:	697a      	ldr	r2, [r7, #20]
 80037e2:	693b      	ldr	r3, [r7, #16]
 80037e4:	4413      	add	r3, r2
 80037e6:	3303      	adds	r3, #3
 80037e8:	687a      	ldr	r2, [r7, #4]
 80037ea:	4413      	add	r3, r2
 80037ec:	7819      	ldrb	r1, [r3, #0]
 80037ee:	693b      	ldr	r3, [r7, #16]
 80037f0:	3303      	adds	r3, #3
 80037f2:	68fa      	ldr	r2, [r7, #12]
 80037f4:	4413      	add	r3, r2
 80037f6:	f893 2040 	ldrb.w	r2, [r3, #64]	@ 0x40
 80037fa:	6978      	ldr	r0, [r7, #20]
 80037fc:	693b      	ldr	r3, [r7, #16]
 80037fe:	4403      	add	r3, r0
 8003800:	3303      	adds	r3, #3
 8003802:	6838      	ldr	r0, [r7, #0]
 8003804:	4403      	add	r3, r0
 8003806:	404a      	eors	r2, r1
 8003808:	b2d2      	uxtb	r2, r2
 800380a:	701a      	strb	r2, [r3, #0]
            output[offset + i+4] = input[offset + i+4] ^ ctx->keystream8[i+4];
 800380c:	697a      	ldr	r2, [r7, #20]
 800380e:	693b      	ldr	r3, [r7, #16]
 8003810:	4413      	add	r3, r2
 8003812:	3304      	adds	r3, #4
 8003814:	687a      	ldr	r2, [r7, #4]
 8003816:	4413      	add	r3, r2
 8003818:	7819      	ldrb	r1, [r3, #0]
 800381a:	693b      	ldr	r3, [r7, #16]
 800381c:	3304      	adds	r3, #4
 800381e:	68fa      	ldr	r2, [r7, #12]
 8003820:	4413      	add	r3, r2
 8003822:	f893 2040 	ldrb.w	r2, [r3, #64]	@ 0x40
 8003826:	6978      	ldr	r0, [r7, #20]
 8003828:	693b      	ldr	r3, [r7, #16]
 800382a:	4403      	add	r3, r0
 800382c:	3304      	adds	r3, #4
 800382e:	6838      	ldr	r0, [r7, #0]
 8003830:	4403      	add	r3, r0
 8003832:	404a      	eors	r2, r1
 8003834:	b2d2      	uxtb	r2, r2
 8003836:	701a      	strb	r2, [r3, #0]
            output[offset + i+5] = input[offset + i+5] ^ ctx->keystream8[i+5];
 8003838:	697a      	ldr	r2, [r7, #20]
 800383a:	693b      	ldr	r3, [r7, #16]
 800383c:	4413      	add	r3, r2
 800383e:	3305      	adds	r3, #5
 8003840:	687a      	ldr	r2, [r7, #4]
 8003842:	4413      	add	r3, r2
 8003844:	7819      	ldrb	r1, [r3, #0]
 8003846:	693b      	ldr	r3, [r7, #16]
 8003848:	3305      	adds	r3, #5
 800384a:	68fa      	ldr	r2, [r7, #12]
 800384c:	4413      	add	r3, r2
 800384e:	f893 2040 	ldrb.w	r2, [r3, #64]	@ 0x40
 8003852:	6978      	ldr	r0, [r7, #20]
 8003854:	693b      	ldr	r3, [r7, #16]
 8003856:	4403      	add	r3, r0
 8003858:	3305      	adds	r3, #5
 800385a:	6838      	ldr	r0, [r7, #0]
 800385c:	4403      	add	r3, r0
 800385e:	404a      	eors	r2, r1
 8003860:	b2d2      	uxtb	r2, r2
 8003862:	701a      	strb	r2, [r3, #0]
            output[offset + i+6] = input[offset + i+6] ^ ctx->keystream8[i+6];
 8003864:	697a      	ldr	r2, [r7, #20]
 8003866:	693b      	ldr	r3, [r7, #16]
 8003868:	4413      	add	r3, r2
 800386a:	3306      	adds	r3, #6
 800386c:	687a      	ldr	r2, [r7, #4]
 800386e:	4413      	add	r3, r2
 8003870:	7819      	ldrb	r1, [r3, #0]
 8003872:	693b      	ldr	r3, [r7, #16]
 8003874:	3306      	adds	r3, #6
 8003876:	68fa      	ldr	r2, [r7, #12]
 8003878:	4413      	add	r3, r2
 800387a:	f893 2040 	ldrb.w	r2, [r3, #64]	@ 0x40
 800387e:	6978      	ldr	r0, [r7, #20]
 8003880:	693b      	ldr	r3, [r7, #16]
 8003882:	4403      	add	r3, r0
 8003884:	3306      	adds	r3, #6
 8003886:	6838      	ldr	r0, [r7, #0]
 8003888:	4403      	add	r3, r0
 800388a:	404a      	eors	r2, r1
 800388c:	b2d2      	uxtb	r2, r2
 800388e:	701a      	strb	r2, [r3, #0]
            output[offset + i+7] = input[offset + i+7] ^ ctx->keystream8[i+7];
 8003890:	697a      	ldr	r2, [r7, #20]
 8003892:	693b      	ldr	r3, [r7, #16]
 8003894:	4413      	add	r3, r2
 8003896:	3307      	adds	r3, #7
 8003898:	687a      	ldr	r2, [r7, #4]
 800389a:	4413      	add	r3, r2
 800389c:	7819      	ldrb	r1, [r3, #0]
 800389e:	693b      	ldr	r3, [r7, #16]
 80038a0:	3307      	adds	r3, #7
 80038a2:	68fa      	ldr	r2, [r7, #12]
 80038a4:	4413      	add	r3, r2
 80038a6:	f893 2040 	ldrb.w	r2, [r3, #64]	@ 0x40
 80038aa:	6978      	ldr	r0, [r7, #20]
 80038ac:	693b      	ldr	r3, [r7, #16]
 80038ae:	4403      	add	r3, r0
 80038b0:	3307      	adds	r3, #7
 80038b2:	6838      	ldr	r0, [r7, #0]
 80038b4:	4403      	add	r3, r0
 80038b6:	404a      	eors	r2, r1
 80038b8:	b2d2      	uxtb	r2, r2
 80038ba:	701a      	strb	r2, [r3, #0]
        for( i = 0U; i < 64U; i += 8U )
 80038bc:	693b      	ldr	r3, [r7, #16]
 80038be:	3308      	adds	r3, #8
 80038c0:	613b      	str	r3, [r7, #16]
 80038c2:	693b      	ldr	r3, [r7, #16]
 80038c4:	2b3f      	cmp	r3, #63	@ 0x3f
 80038c6:	f67f af4c 	bls.w	8003762 <mbedtls_chacha20_update+0x82>
        }

        offset += CHACHA20_BLOCK_SIZE_BYTES;
 80038ca:	697b      	ldr	r3, [r7, #20]
 80038cc:	3340      	adds	r3, #64	@ 0x40
 80038ce:	617b      	str	r3, [r7, #20]
        size   -= CHACHA20_BLOCK_SIZE_BYTES;
 80038d0:	68bb      	ldr	r3, [r7, #8]
 80038d2:	3b40      	subs	r3, #64	@ 0x40
 80038d4:	60bb      	str	r3, [r7, #8]
    while( size >= CHACHA20_BLOCK_SIZE_BYTES )
 80038d6:	68bb      	ldr	r3, [r7, #8]
 80038d8:	2b3f      	cmp	r3, #63	@ 0x3f
 80038da:	f63f af33 	bhi.w	8003744 <mbedtls_chacha20_update+0x64>
    }

    /* Last (partial) block */
    if( size > 0U )
 80038de:	68bb      	ldr	r3, [r7, #8]
 80038e0:	2b00      	cmp	r3, #0
 80038e2:	d02c      	beq.n	800393e <mbedtls_chacha20_update+0x25e>
    {
        /* Generate new keystream block and increment counter */
        chacha20_block( ctx->state, ctx->keystream8 );
 80038e4:	68fa      	ldr	r2, [r7, #12]
 80038e6:	68fb      	ldr	r3, [r7, #12]
 80038e8:	3340      	adds	r3, #64	@ 0x40
 80038ea:	4619      	mov	r1, r3
 80038ec:	4610      	mov	r0, r2
 80038ee:	f7ff fcf2 	bl	80032d6 <chacha20_block>
        ctx->state[CHACHA20_CTR_INDEX]++;
 80038f2:	68fb      	ldr	r3, [r7, #12]
 80038f4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80038f6:	1c5a      	adds	r2, r3, #1
 80038f8:	68fb      	ldr	r3, [r7, #12]
 80038fa:	631a      	str	r2, [r3, #48]	@ 0x30

        for( i = 0U; i < size; i++)
 80038fc:	2300      	movs	r3, #0
 80038fe:	613b      	str	r3, [r7, #16]
 8003900:	e015      	b.n	800392e <mbedtls_chacha20_update+0x24e>
        {
            output[offset + i] = input[offset + i] ^ ctx->keystream8[i];
 8003902:	697a      	ldr	r2, [r7, #20]
 8003904:	693b      	ldr	r3, [r7, #16]
 8003906:	4413      	add	r3, r2
 8003908:	687a      	ldr	r2, [r7, #4]
 800390a:	4413      	add	r3, r2
 800390c:	7819      	ldrb	r1, [r3, #0]
 800390e:	68fa      	ldr	r2, [r7, #12]
 8003910:	693b      	ldr	r3, [r7, #16]
 8003912:	4413      	add	r3, r2
 8003914:	3340      	adds	r3, #64	@ 0x40
 8003916:	781a      	ldrb	r2, [r3, #0]
 8003918:	6978      	ldr	r0, [r7, #20]
 800391a:	693b      	ldr	r3, [r7, #16]
 800391c:	4403      	add	r3, r0
 800391e:	6838      	ldr	r0, [r7, #0]
 8003920:	4403      	add	r3, r0
 8003922:	404a      	eors	r2, r1
 8003924:	b2d2      	uxtb	r2, r2
 8003926:	701a      	strb	r2, [r3, #0]
        for( i = 0U; i < size; i++)
 8003928:	693b      	ldr	r3, [r7, #16]
 800392a:	3301      	adds	r3, #1
 800392c:	613b      	str	r3, [r7, #16]
 800392e:	693a      	ldr	r2, [r7, #16]
 8003930:	68bb      	ldr	r3, [r7, #8]
 8003932:	429a      	cmp	r2, r3
 8003934:	d3e5      	bcc.n	8003902 <mbedtls_chacha20_update+0x222>
        }

        ctx->keystream_bytes_used = size;
 8003936:	68fb      	ldr	r3, [r7, #12]
 8003938:	68ba      	ldr	r2, [r7, #8]
 800393a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

    }

    return( 0 );
 800393e:	2300      	movs	r3, #0
}
 8003940:	4618      	mov	r0, r3
 8003942:	3718      	adds	r7, #24
 8003944:	46bd      	mov	sp, r7
 8003946:	bd80      	pop	{r7, pc}

08003948 <chachapoly_pad_aad>:
 * \brief           Adds nul bytes to pad the AAD for Poly1305.
 *
 * \param ctx       The ChaCha20-Poly1305 context.
 */
static int chachapoly_pad_aad( mbedtls_chachapoly_context *ctx )
{
 8003948:	b580      	push	{r7, lr}
 800394a:	b088      	sub	sp, #32
 800394c:	af00      	add	r7, sp, #0
 800394e:	6078      	str	r0, [r7, #4]
    uint32_t partial_block_len = (uint32_t) ( ctx->aad_len % 16U );
 8003950:	687b      	ldr	r3, [r7, #4]
 8003952:	e9d3 2334 	ldrd	r2, r3, [r3, #208]	@ 0xd0
 8003956:	4613      	mov	r3, r2
 8003958:	f003 030f 	and.w	r3, r3, #15
 800395c:	61fb      	str	r3, [r7, #28]
    unsigned char zeroes[15];

    if( partial_block_len == 0U )
 800395e:	69fb      	ldr	r3, [r7, #28]
 8003960:	2b00      	cmp	r3, #0
 8003962:	d101      	bne.n	8003968 <chachapoly_pad_aad+0x20>
        return( 0 );
 8003964:	2300      	movs	r3, #0
 8003966:	e012      	b.n	800398e <chachapoly_pad_aad+0x46>

    memset( zeroes, 0, sizeof( zeroes ) );
 8003968:	f107 030c 	add.w	r3, r7, #12
 800396c:	220f      	movs	r2, #15
 800396e:	2100      	movs	r1, #0
 8003970:	4618      	mov	r0, r3
 8003972:	f011 fd69 	bl	8015448 <memset>

    return( mbedtls_poly1305_update( &ctx->poly1305_ctx,
 8003976:	687b      	ldr	r3, [r7, #4]
 8003978:	f103 0084 	add.w	r0, r3, #132	@ 0x84
                                     zeroes,
                                     16U - partial_block_len ) );
 800397c:	69fb      	ldr	r3, [r7, #28]
 800397e:	f1c3 0210 	rsb	r2, r3, #16
    return( mbedtls_poly1305_update( &ctx->poly1305_ctx,
 8003982:	f107 030c 	add.w	r3, r7, #12
 8003986:	4619      	mov	r1, r3
 8003988:	f003 fb70 	bl	800706c <mbedtls_poly1305_update>
 800398c:	4603      	mov	r3, r0
}
 800398e:	4618      	mov	r0, r3
 8003990:	3720      	adds	r7, #32
 8003992:	46bd      	mov	sp, r7
 8003994:	bd80      	pop	{r7, pc}

08003996 <chachapoly_pad_ciphertext>:
 * \brief           Adds nul bytes to pad the ciphertext for Poly1305.
 *
 * \param ctx       The ChaCha20-Poly1305 context.
 */
static int chachapoly_pad_ciphertext( mbedtls_chachapoly_context *ctx )
{
 8003996:	b580      	push	{r7, lr}
 8003998:	b088      	sub	sp, #32
 800399a:	af00      	add	r7, sp, #0
 800399c:	6078      	str	r0, [r7, #4]
    uint32_t partial_block_len = (uint32_t) ( ctx->ciphertext_len % 16U );
 800399e:	687b      	ldr	r3, [r7, #4]
 80039a0:	e9d3 2336 	ldrd	r2, r3, [r3, #216]	@ 0xd8
 80039a4:	4613      	mov	r3, r2
 80039a6:	f003 030f 	and.w	r3, r3, #15
 80039aa:	61fb      	str	r3, [r7, #28]
    unsigned char zeroes[15];

    if( partial_block_len == 0U )
 80039ac:	69fb      	ldr	r3, [r7, #28]
 80039ae:	2b00      	cmp	r3, #0
 80039b0:	d101      	bne.n	80039b6 <chachapoly_pad_ciphertext+0x20>
        return( 0 );
 80039b2:	2300      	movs	r3, #0
 80039b4:	e012      	b.n	80039dc <chachapoly_pad_ciphertext+0x46>

    memset( zeroes, 0, sizeof( zeroes ) );
 80039b6:	f107 030c 	add.w	r3, r7, #12
 80039ba:	220f      	movs	r2, #15
 80039bc:	2100      	movs	r1, #0
 80039be:	4618      	mov	r0, r3
 80039c0:	f011 fd42 	bl	8015448 <memset>
    return( mbedtls_poly1305_update( &ctx->poly1305_ctx,
 80039c4:	687b      	ldr	r3, [r7, #4]
 80039c6:	f103 0084 	add.w	r0, r3, #132	@ 0x84
                                     zeroes,
                                     16U - partial_block_len ) );
 80039ca:	69fb      	ldr	r3, [r7, #28]
 80039cc:	f1c3 0210 	rsb	r2, r3, #16
    return( mbedtls_poly1305_update( &ctx->poly1305_ctx,
 80039d0:	f107 030c 	add.w	r3, r7, #12
 80039d4:	4619      	mov	r1, r3
 80039d6:	f003 fb49 	bl	800706c <mbedtls_poly1305_update>
 80039da:	4603      	mov	r3, r0
}
 80039dc:	4618      	mov	r0, r3
 80039de:	3720      	adds	r7, #32
 80039e0:	46bd      	mov	sp, r7
 80039e2:	bd80      	pop	{r7, pc}

080039e4 <mbedtls_chachapoly_init>:

void mbedtls_chachapoly_init( mbedtls_chachapoly_context *ctx )
{
 80039e4:	b580      	push	{r7, lr}
 80039e6:	b082      	sub	sp, #8
 80039e8:	af00      	add	r7, sp, #0
 80039ea:	6078      	str	r0, [r7, #4]
    CHACHAPOLY_VALIDATE( ctx != NULL );

    mbedtls_chacha20_init( &ctx->chacha20_ctx );
 80039ec:	687b      	ldr	r3, [r7, #4]
 80039ee:	4618      	mov	r0, r3
 80039f0:	f7ff fd32 	bl	8003458 <mbedtls_chacha20_init>
    mbedtls_poly1305_init( &ctx->poly1305_ctx );
 80039f4:	687b      	ldr	r3, [r7, #4]
 80039f6:	3384      	adds	r3, #132	@ 0x84
 80039f8:	4618      	mov	r0, r3
 80039fa:	f003 fa44 	bl	8006e86 <mbedtls_poly1305_init>
    ctx->aad_len        = 0U;
 80039fe:	6879      	ldr	r1, [r7, #4]
 8003a00:	f04f 0200 	mov.w	r2, #0
 8003a04:	f04f 0300 	mov.w	r3, #0
 8003a08:	e9c1 2334 	strd	r2, r3, [r1, #208]	@ 0xd0
    ctx->ciphertext_len = 0U;
 8003a0c:	6879      	ldr	r1, [r7, #4]
 8003a0e:	f04f 0200 	mov.w	r2, #0
 8003a12:	f04f 0300 	mov.w	r3, #0
 8003a16:	e9c1 2336 	strd	r2, r3, [r1, #216]	@ 0xd8
    ctx->state          = CHACHAPOLY_STATE_INIT;
 8003a1a:	687b      	ldr	r3, [r7, #4]
 8003a1c:	2200      	movs	r2, #0
 8003a1e:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
    ctx->mode           = MBEDTLS_CHACHAPOLY_ENCRYPT;
 8003a22:	687b      	ldr	r3, [r7, #4]
 8003a24:	2200      	movs	r2, #0
 8003a26:	f883 20e4 	strb.w	r2, [r3, #228]	@ 0xe4
}
 8003a2a:	bf00      	nop
 8003a2c:	3708      	adds	r7, #8
 8003a2e:	46bd      	mov	sp, r7
 8003a30:	bd80      	pop	{r7, pc}

08003a32 <mbedtls_chachapoly_free>:

void mbedtls_chachapoly_free( mbedtls_chachapoly_context *ctx )
{
 8003a32:	b580      	push	{r7, lr}
 8003a34:	b082      	sub	sp, #8
 8003a36:	af00      	add	r7, sp, #0
 8003a38:	6078      	str	r0, [r7, #4]
    if( ctx == NULL )
 8003a3a:	687b      	ldr	r3, [r7, #4]
 8003a3c:	2b00      	cmp	r3, #0
 8003a3e:	d01f      	beq.n	8003a80 <mbedtls_chachapoly_free+0x4e>
        return;

    mbedtls_chacha20_free( &ctx->chacha20_ctx );
 8003a40:	687b      	ldr	r3, [r7, #4]
 8003a42:	4618      	mov	r0, r3
 8003a44:	f7ff fd1f 	bl	8003486 <mbedtls_chacha20_free>
    mbedtls_poly1305_free( &ctx->poly1305_ctx );
 8003a48:	687b      	ldr	r3, [r7, #4]
 8003a4a:	3384      	adds	r3, #132	@ 0x84
 8003a4c:	4618      	mov	r0, r3
 8003a4e:	f003 fa26 	bl	8006e9e <mbedtls_poly1305_free>
    ctx->aad_len        = 0U;
 8003a52:	6879      	ldr	r1, [r7, #4]
 8003a54:	f04f 0200 	mov.w	r2, #0
 8003a58:	f04f 0300 	mov.w	r3, #0
 8003a5c:	e9c1 2334 	strd	r2, r3, [r1, #208]	@ 0xd0
    ctx->ciphertext_len = 0U;
 8003a60:	6879      	ldr	r1, [r7, #4]
 8003a62:	f04f 0200 	mov.w	r2, #0
 8003a66:	f04f 0300 	mov.w	r3, #0
 8003a6a:	e9c1 2336 	strd	r2, r3, [r1, #216]	@ 0xd8
    ctx->state          = CHACHAPOLY_STATE_INIT;
 8003a6e:	687b      	ldr	r3, [r7, #4]
 8003a70:	2200      	movs	r2, #0
 8003a72:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
    ctx->mode           = MBEDTLS_CHACHAPOLY_ENCRYPT;
 8003a76:	687b      	ldr	r3, [r7, #4]
 8003a78:	2200      	movs	r2, #0
 8003a7a:	f883 20e4 	strb.w	r2, [r3, #228]	@ 0xe4
 8003a7e:	e000      	b.n	8003a82 <mbedtls_chachapoly_free+0x50>
        return;
 8003a80:	bf00      	nop
}
 8003a82:	3708      	adds	r7, #8
 8003a84:	46bd      	mov	sp, r7
 8003a86:	bd80      	pop	{r7, pc}

08003a88 <mbedtls_chachapoly_setkey>:

int mbedtls_chachapoly_setkey( mbedtls_chachapoly_context *ctx,
                               const unsigned char key[32] )
{
 8003a88:	b580      	push	{r7, lr}
 8003a8a:	b084      	sub	sp, #16
 8003a8c:	af00      	add	r7, sp, #0
 8003a8e:	6078      	str	r0, [r7, #4]
 8003a90:	6039      	str	r1, [r7, #0]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 8003a92:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8003a96:	60fb      	str	r3, [r7, #12]
    CHACHAPOLY_VALIDATE_RET( ctx != NULL );
    CHACHAPOLY_VALIDATE_RET( key != NULL );

    ret = mbedtls_chacha20_setkey( &ctx->chacha20_ctx, key );
 8003a98:	687b      	ldr	r3, [r7, #4]
 8003a9a:	6839      	ldr	r1, [r7, #0]
 8003a9c:	4618      	mov	r0, r3
 8003a9e:	f7ff fd01 	bl	80034a4 <mbedtls_chacha20_setkey>
 8003aa2:	60f8      	str	r0, [r7, #12]

    return( ret );
 8003aa4:	68fb      	ldr	r3, [r7, #12]
}
 8003aa6:	4618      	mov	r0, r3
 8003aa8:	3710      	adds	r7, #16
 8003aaa:	46bd      	mov	sp, r7
 8003aac:	bd80      	pop	{r7, pc}

08003aae <mbedtls_chachapoly_starts>:

int mbedtls_chachapoly_starts( mbedtls_chachapoly_context *ctx,
                               const unsigned char nonce[12],
                               mbedtls_chachapoly_mode_t mode  )
{
 8003aae:	b580      	push	{r7, lr}
 8003ab0:	b096      	sub	sp, #88	@ 0x58
 8003ab2:	af00      	add	r7, sp, #0
 8003ab4:	60f8      	str	r0, [r7, #12]
 8003ab6:	60b9      	str	r1, [r7, #8]
 8003ab8:	4613      	mov	r3, r2
 8003aba:	71fb      	strb	r3, [r7, #7]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 8003abc:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8003ac0:	657b      	str	r3, [r7, #84]	@ 0x54
    unsigned char poly1305_key[64];
    CHACHAPOLY_VALIDATE_RET( ctx != NULL );
    CHACHAPOLY_VALIDATE_RET( nonce != NULL );

    /* Set counter = 0, will be update to 1 when generating Poly1305 key */
    ret = mbedtls_chacha20_starts( &ctx->chacha20_ctx, nonce, 0U );
 8003ac2:	68fb      	ldr	r3, [r7, #12]
 8003ac4:	2200      	movs	r2, #0
 8003ac6:	68b9      	ldr	r1, [r7, #8]
 8003ac8:	4618      	mov	r0, r3
 8003aca:	f7ff fdb3 	bl	8003634 <mbedtls_chacha20_starts>
 8003ace:	6578      	str	r0, [r7, #84]	@ 0x54
    if( ret != 0 )
 8003ad0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8003ad2:	2b00      	cmp	r3, #0
 8003ad4:	d135      	bne.n	8003b42 <mbedtls_chachapoly_starts+0x94>
    /* Generate the Poly1305 key by getting the ChaCha20 keystream output with
     * counter = 0.  This is the same as encrypting a buffer of zeroes.
     * Only the first 256-bits (32 bytes) of the key is used for Poly1305.
     * The other 256 bits are discarded.
     */
    memset( poly1305_key, 0, sizeof( poly1305_key ) );
 8003ad6:	f107 0314 	add.w	r3, r7, #20
 8003ada:	2240      	movs	r2, #64	@ 0x40
 8003adc:	2100      	movs	r1, #0
 8003ade:	4618      	mov	r0, r3
 8003ae0:	f011 fcb2 	bl	8015448 <memset>
    ret = mbedtls_chacha20_update( &ctx->chacha20_ctx, sizeof( poly1305_key ),
 8003ae4:	68f8      	ldr	r0, [r7, #12]
 8003ae6:	f107 0314 	add.w	r3, r7, #20
 8003aea:	f107 0214 	add.w	r2, r7, #20
 8003aee:	2140      	movs	r1, #64	@ 0x40
 8003af0:	f7ff fdf6 	bl	80036e0 <mbedtls_chacha20_update>
 8003af4:	6578      	str	r0, [r7, #84]	@ 0x54
                                      poly1305_key, poly1305_key );
    if( ret != 0 )
 8003af6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8003af8:	2b00      	cmp	r3, #0
 8003afa:	d124      	bne.n	8003b46 <mbedtls_chachapoly_starts+0x98>
        goto cleanup;

    ret = mbedtls_poly1305_starts( &ctx->poly1305_ctx, poly1305_key );
 8003afc:	68fb      	ldr	r3, [r7, #12]
 8003afe:	3384      	adds	r3, #132	@ 0x84
 8003b00:	f107 0214 	add.w	r2, r7, #20
 8003b04:	4611      	mov	r1, r2
 8003b06:	4618      	mov	r0, r3
 8003b08:	f003 f9d9 	bl	8006ebe <mbedtls_poly1305_starts>
 8003b0c:	6578      	str	r0, [r7, #84]	@ 0x54

    if( ret == 0 )
 8003b0e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8003b10:	2b00      	cmp	r3, #0
 8003b12:	d11a      	bne.n	8003b4a <mbedtls_chachapoly_starts+0x9c>
    {
        ctx->aad_len        = 0U;
 8003b14:	68f9      	ldr	r1, [r7, #12]
 8003b16:	f04f 0200 	mov.w	r2, #0
 8003b1a:	f04f 0300 	mov.w	r3, #0
 8003b1e:	e9c1 2334 	strd	r2, r3, [r1, #208]	@ 0xd0
        ctx->ciphertext_len = 0U;
 8003b22:	68f9      	ldr	r1, [r7, #12]
 8003b24:	f04f 0200 	mov.w	r2, #0
 8003b28:	f04f 0300 	mov.w	r3, #0
 8003b2c:	e9c1 2336 	strd	r2, r3, [r1, #216]	@ 0xd8
        ctx->state          = CHACHAPOLY_STATE_AAD;
 8003b30:	68fb      	ldr	r3, [r7, #12]
 8003b32:	2201      	movs	r2, #1
 8003b34:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
        ctx->mode           = mode;
 8003b38:	68fb      	ldr	r3, [r7, #12]
 8003b3a:	79fa      	ldrb	r2, [r7, #7]
 8003b3c:	f883 20e4 	strb.w	r2, [r3, #228]	@ 0xe4
 8003b40:	e004      	b.n	8003b4c <mbedtls_chachapoly_starts+0x9e>
        goto cleanup;
 8003b42:	bf00      	nop
 8003b44:	e002      	b.n	8003b4c <mbedtls_chachapoly_starts+0x9e>
        goto cleanup;
 8003b46:	bf00      	nop
 8003b48:	e000      	b.n	8003b4c <mbedtls_chachapoly_starts+0x9e>
    }

cleanup:
 8003b4a:	bf00      	nop
    mbedtls_platform_zeroize( poly1305_key, 64U );
 8003b4c:	f107 0314 	add.w	r3, r7, #20
 8003b50:	2140      	movs	r1, #64	@ 0x40
 8003b52:	4618      	mov	r0, r3
 8003b54:	f002 fb44 	bl	80061e0 <mbedtls_platform_zeroize>
    return( ret );
 8003b58:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
}
 8003b5a:	4618      	mov	r0, r3
 8003b5c:	3758      	adds	r7, #88	@ 0x58
 8003b5e:	46bd      	mov	sp, r7
 8003b60:	bd80      	pop	{r7, pc}

08003b62 <mbedtls_chachapoly_update_aad>:

int mbedtls_chachapoly_update_aad( mbedtls_chachapoly_context *ctx,
                                   const unsigned char *aad,
                                   size_t aad_len )
{
 8003b62:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 8003b66:	b084      	sub	sp, #16
 8003b68:	af00      	add	r7, sp, #0
 8003b6a:	60f8      	str	r0, [r7, #12]
 8003b6c:	60b9      	str	r1, [r7, #8]
 8003b6e:	607a      	str	r2, [r7, #4]
    CHACHAPOLY_VALIDATE_RET( ctx != NULL );
    CHACHAPOLY_VALIDATE_RET( aad_len == 0 || aad != NULL );

    if( ctx->state != CHACHAPOLY_STATE_AAD )
 8003b70:	68fb      	ldr	r3, [r7, #12]
 8003b72:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8003b76:	2b01      	cmp	r3, #1
 8003b78:	d002      	beq.n	8003b80 <mbedtls_chachapoly_update_aad+0x1e>
        return( MBEDTLS_ERR_CHACHAPOLY_BAD_STATE );
 8003b7a:	f06f 0353 	mvn.w	r3, #83	@ 0x53
 8003b7e:	e015      	b.n	8003bac <mbedtls_chachapoly_update_aad+0x4a>

    ctx->aad_len += aad_len;
 8003b80:	68fb      	ldr	r3, [r7, #12]
 8003b82:	e9d3 2334 	ldrd	r2, r3, [r3, #208]	@ 0xd0
 8003b86:	6879      	ldr	r1, [r7, #4]
 8003b88:	2000      	movs	r0, #0
 8003b8a:	460c      	mov	r4, r1
 8003b8c:	4605      	mov	r5, r0
 8003b8e:	eb12 0804 	adds.w	r8, r2, r4
 8003b92:	eb43 0905 	adc.w	r9, r3, r5
 8003b96:	68fb      	ldr	r3, [r7, #12]
 8003b98:	e9c3 8934 	strd	r8, r9, [r3, #208]	@ 0xd0

    return( mbedtls_poly1305_update( &ctx->poly1305_ctx, aad, aad_len ) );
 8003b9c:	68fb      	ldr	r3, [r7, #12]
 8003b9e:	3384      	adds	r3, #132	@ 0x84
 8003ba0:	687a      	ldr	r2, [r7, #4]
 8003ba2:	68b9      	ldr	r1, [r7, #8]
 8003ba4:	4618      	mov	r0, r3
 8003ba6:	f003 fa61 	bl	800706c <mbedtls_poly1305_update>
 8003baa:	4603      	mov	r3, r0
}
 8003bac:	4618      	mov	r0, r3
 8003bae:	3710      	adds	r7, #16
 8003bb0:	46bd      	mov	sp, r7
 8003bb2:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}

08003bb6 <mbedtls_chachapoly_update>:

int mbedtls_chachapoly_update( mbedtls_chachapoly_context *ctx,
                               size_t len,
                               const unsigned char *input,
                               unsigned char *output )
{
 8003bb6:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 8003bba:	b086      	sub	sp, #24
 8003bbc:	af00      	add	r7, sp, #0
 8003bbe:	60f8      	str	r0, [r7, #12]
 8003bc0:	60b9      	str	r1, [r7, #8]
 8003bc2:	607a      	str	r2, [r7, #4]
 8003bc4:	603b      	str	r3, [r7, #0]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 8003bc6:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8003bca:	617b      	str	r3, [r7, #20]
    CHACHAPOLY_VALIDATE_RET( ctx != NULL );
    CHACHAPOLY_VALIDATE_RET( len == 0 || input != NULL );
    CHACHAPOLY_VALIDATE_RET( len == 0 || output != NULL );

    if( ( ctx->state != CHACHAPOLY_STATE_AAD ) &&
 8003bcc:	68fb      	ldr	r3, [r7, #12]
 8003bce:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8003bd2:	2b01      	cmp	r3, #1
 8003bd4:	d007      	beq.n	8003be6 <mbedtls_chachapoly_update+0x30>
        ( ctx->state != CHACHAPOLY_STATE_CIPHERTEXT ) )
 8003bd6:	68fb      	ldr	r3, [r7, #12]
 8003bd8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
    if( ( ctx->state != CHACHAPOLY_STATE_AAD ) &&
 8003bdc:	2b02      	cmp	r3, #2
 8003bde:	d002      	beq.n	8003be6 <mbedtls_chachapoly_update+0x30>
    {
        return( MBEDTLS_ERR_CHACHAPOLY_BAD_STATE );
 8003be0:	f06f 0353 	mvn.w	r3, #83	@ 0x53
 8003be4:	e057      	b.n	8003c96 <mbedtls_chachapoly_update+0xe0>
    }

    if( ctx->state == CHACHAPOLY_STATE_AAD )
 8003be6:	68fb      	ldr	r3, [r7, #12]
 8003be8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8003bec:	2b01      	cmp	r3, #1
 8003bee:	d10c      	bne.n	8003c0a <mbedtls_chachapoly_update+0x54>
    {
        ctx->state = CHACHAPOLY_STATE_CIPHERTEXT;
 8003bf0:	68fb      	ldr	r3, [r7, #12]
 8003bf2:	2202      	movs	r2, #2
 8003bf4:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0

        ret = chachapoly_pad_aad( ctx );
 8003bf8:	68f8      	ldr	r0, [r7, #12]
 8003bfa:	f7ff fea5 	bl	8003948 <chachapoly_pad_aad>
 8003bfe:	6178      	str	r0, [r7, #20]
        if( ret != 0 )
 8003c00:	697b      	ldr	r3, [r7, #20]
 8003c02:	2b00      	cmp	r3, #0
 8003c04:	d001      	beq.n	8003c0a <mbedtls_chachapoly_update+0x54>
            return( ret );
 8003c06:	697b      	ldr	r3, [r7, #20]
 8003c08:	e045      	b.n	8003c96 <mbedtls_chachapoly_update+0xe0>
    }

    ctx->ciphertext_len += len;
 8003c0a:	68fb      	ldr	r3, [r7, #12]
 8003c0c:	e9d3 2336 	ldrd	r2, r3, [r3, #216]	@ 0xd8
 8003c10:	68b9      	ldr	r1, [r7, #8]
 8003c12:	2000      	movs	r0, #0
 8003c14:	460c      	mov	r4, r1
 8003c16:	4605      	mov	r5, r0
 8003c18:	eb12 0804 	adds.w	r8, r2, r4
 8003c1c:	eb43 0905 	adc.w	r9, r3, r5
 8003c20:	68fb      	ldr	r3, [r7, #12]
 8003c22:	e9c3 8936 	strd	r8, r9, [r3, #216]	@ 0xd8

    if( ctx->mode == MBEDTLS_CHACHAPOLY_ENCRYPT )
 8003c26:	68fb      	ldr	r3, [r7, #12]
 8003c28:	f893 30e4 	ldrb.w	r3, [r3, #228]	@ 0xe4
 8003c2c:	2b00      	cmp	r3, #0
 8003c2e:	d118      	bne.n	8003c62 <mbedtls_chachapoly_update+0xac>
    {
        ret = mbedtls_chacha20_update( &ctx->chacha20_ctx, len, input, output );
 8003c30:	68f8      	ldr	r0, [r7, #12]
 8003c32:	683b      	ldr	r3, [r7, #0]
 8003c34:	687a      	ldr	r2, [r7, #4]
 8003c36:	68b9      	ldr	r1, [r7, #8]
 8003c38:	f7ff fd52 	bl	80036e0 <mbedtls_chacha20_update>
 8003c3c:	6178      	str	r0, [r7, #20]
        if( ret != 0 )
 8003c3e:	697b      	ldr	r3, [r7, #20]
 8003c40:	2b00      	cmp	r3, #0
 8003c42:	d001      	beq.n	8003c48 <mbedtls_chachapoly_update+0x92>
            return( ret );
 8003c44:	697b      	ldr	r3, [r7, #20]
 8003c46:	e026      	b.n	8003c96 <mbedtls_chachapoly_update+0xe0>

        ret = mbedtls_poly1305_update( &ctx->poly1305_ctx, output, len );
 8003c48:	68fb      	ldr	r3, [r7, #12]
 8003c4a:	3384      	adds	r3, #132	@ 0x84
 8003c4c:	68ba      	ldr	r2, [r7, #8]
 8003c4e:	6839      	ldr	r1, [r7, #0]
 8003c50:	4618      	mov	r0, r3
 8003c52:	f003 fa0b 	bl	800706c <mbedtls_poly1305_update>
 8003c56:	6178      	str	r0, [r7, #20]
        if( ret != 0 )
 8003c58:	697b      	ldr	r3, [r7, #20]
 8003c5a:	2b00      	cmp	r3, #0
 8003c5c:	d01a      	beq.n	8003c94 <mbedtls_chachapoly_update+0xde>
            return( ret );
 8003c5e:	697b      	ldr	r3, [r7, #20]
 8003c60:	e019      	b.n	8003c96 <mbedtls_chachapoly_update+0xe0>
    }
    else /* DECRYPT */
    {
        ret = mbedtls_poly1305_update( &ctx->poly1305_ctx, input, len );
 8003c62:	68fb      	ldr	r3, [r7, #12]
 8003c64:	3384      	adds	r3, #132	@ 0x84
 8003c66:	68ba      	ldr	r2, [r7, #8]
 8003c68:	6879      	ldr	r1, [r7, #4]
 8003c6a:	4618      	mov	r0, r3
 8003c6c:	f003 f9fe 	bl	800706c <mbedtls_poly1305_update>
 8003c70:	6178      	str	r0, [r7, #20]
        if( ret != 0 )
 8003c72:	697b      	ldr	r3, [r7, #20]
 8003c74:	2b00      	cmp	r3, #0
 8003c76:	d001      	beq.n	8003c7c <mbedtls_chachapoly_update+0xc6>
            return( ret );
 8003c78:	697b      	ldr	r3, [r7, #20]
 8003c7a:	e00c      	b.n	8003c96 <mbedtls_chachapoly_update+0xe0>

        ret = mbedtls_chacha20_update( &ctx->chacha20_ctx, len, input, output );
 8003c7c:	68f8      	ldr	r0, [r7, #12]
 8003c7e:	683b      	ldr	r3, [r7, #0]
 8003c80:	687a      	ldr	r2, [r7, #4]
 8003c82:	68b9      	ldr	r1, [r7, #8]
 8003c84:	f7ff fd2c 	bl	80036e0 <mbedtls_chacha20_update>
 8003c88:	6178      	str	r0, [r7, #20]
        if( ret != 0 )
 8003c8a:	697b      	ldr	r3, [r7, #20]
 8003c8c:	2b00      	cmp	r3, #0
 8003c8e:	d001      	beq.n	8003c94 <mbedtls_chachapoly_update+0xde>
            return( ret );
 8003c90:	697b      	ldr	r3, [r7, #20]
 8003c92:	e000      	b.n	8003c96 <mbedtls_chachapoly_update+0xe0>
    }

    return( 0 );
 8003c94:	2300      	movs	r3, #0
}
 8003c96:	4618      	mov	r0, r3
 8003c98:	3718      	adds	r7, #24
 8003c9a:	46bd      	mov	sp, r7
 8003c9c:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}

08003ca0 <mbedtls_chachapoly_finish>:

int mbedtls_chachapoly_finish( mbedtls_chachapoly_context *ctx,
                               unsigned char mac[16] )
{
 8003ca0:	b580      	push	{r7, lr}
 8003ca2:	b088      	sub	sp, #32
 8003ca4:	af00      	add	r7, sp, #0
 8003ca6:	6078      	str	r0, [r7, #4]
 8003ca8:	6039      	str	r1, [r7, #0]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 8003caa:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8003cae:	61fb      	str	r3, [r7, #28]
    unsigned char len_block[16];
    CHACHAPOLY_VALIDATE_RET( ctx != NULL );
    CHACHAPOLY_VALIDATE_RET( mac != NULL );

    if( ctx->state == CHACHAPOLY_STATE_INIT )
 8003cb0:	687b      	ldr	r3, [r7, #4]
 8003cb2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8003cb6:	2b00      	cmp	r3, #0
 8003cb8:	d102      	bne.n	8003cc0 <mbedtls_chachapoly_finish+0x20>
    {
        return( MBEDTLS_ERR_CHACHAPOLY_BAD_STATE );
 8003cba:	f06f 0353 	mvn.w	r3, #83	@ 0x53
 8003cbe:	e0e5      	b.n	8003e8c <mbedtls_chachapoly_finish+0x1ec>
    }

    if( ctx->state == CHACHAPOLY_STATE_AAD )
 8003cc0:	687b      	ldr	r3, [r7, #4]
 8003cc2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8003cc6:	2b01      	cmp	r3, #1
 8003cc8:	d108      	bne.n	8003cdc <mbedtls_chachapoly_finish+0x3c>
    {
        ret = chachapoly_pad_aad( ctx );
 8003cca:	6878      	ldr	r0, [r7, #4]
 8003ccc:	f7ff fe3c 	bl	8003948 <chachapoly_pad_aad>
 8003cd0:	61f8      	str	r0, [r7, #28]
        if( ret != 0 )
 8003cd2:	69fb      	ldr	r3, [r7, #28]
 8003cd4:	2b00      	cmp	r3, #0
 8003cd6:	d00f      	beq.n	8003cf8 <mbedtls_chachapoly_finish+0x58>
            return( ret );
 8003cd8:	69fb      	ldr	r3, [r7, #28]
 8003cda:	e0d7      	b.n	8003e8c <mbedtls_chachapoly_finish+0x1ec>
    }
    else if( ctx->state == CHACHAPOLY_STATE_CIPHERTEXT )
 8003cdc:	687b      	ldr	r3, [r7, #4]
 8003cde:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8003ce2:	2b02      	cmp	r3, #2
 8003ce4:	d108      	bne.n	8003cf8 <mbedtls_chachapoly_finish+0x58>
    {
        ret = chachapoly_pad_ciphertext( ctx );
 8003ce6:	6878      	ldr	r0, [r7, #4]
 8003ce8:	f7ff fe55 	bl	8003996 <chachapoly_pad_ciphertext>
 8003cec:	61f8      	str	r0, [r7, #28]
        if( ret != 0 )
 8003cee:	69fb      	ldr	r3, [r7, #28]
 8003cf0:	2b00      	cmp	r3, #0
 8003cf2:	d001      	beq.n	8003cf8 <mbedtls_chachapoly_finish+0x58>
            return( ret );
 8003cf4:	69fb      	ldr	r3, [r7, #28]
 8003cf6:	e0c9      	b.n	8003e8c <mbedtls_chachapoly_finish+0x1ec>
    }

    ctx->state = CHACHAPOLY_STATE_FINISHED;
 8003cf8:	687b      	ldr	r3, [r7, #4]
 8003cfa:	2203      	movs	r2, #3
 8003cfc:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0

    /* The lengths of the AAD and ciphertext are processed by
     * Poly1305 as the final 128-bit block, encoded as little-endian integers.
     */
    len_block[ 0] = (unsigned char)( ctx->aad_len       );
 8003d00:	687b      	ldr	r3, [r7, #4]
 8003d02:	e9d3 2334 	ldrd	r2, r3, [r3, #208]	@ 0xd0
 8003d06:	b2d3      	uxtb	r3, r2
 8003d08:	733b      	strb	r3, [r7, #12]
    len_block[ 1] = (unsigned char)( ctx->aad_len >>  8 );
 8003d0a:	687b      	ldr	r3, [r7, #4]
 8003d0c:	e9d3 0134 	ldrd	r0, r1, [r3, #208]	@ 0xd0
 8003d10:	f04f 0200 	mov.w	r2, #0
 8003d14:	f04f 0300 	mov.w	r3, #0
 8003d18:	0a02      	lsrs	r2, r0, #8
 8003d1a:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 8003d1e:	0a0b      	lsrs	r3, r1, #8
 8003d20:	b2d3      	uxtb	r3, r2
 8003d22:	737b      	strb	r3, [r7, #13]
    len_block[ 2] = (unsigned char)( ctx->aad_len >> 16 );
 8003d24:	687b      	ldr	r3, [r7, #4]
 8003d26:	e9d3 0134 	ldrd	r0, r1, [r3, #208]	@ 0xd0
 8003d2a:	f04f 0200 	mov.w	r2, #0
 8003d2e:	f04f 0300 	mov.w	r3, #0
 8003d32:	0c02      	lsrs	r2, r0, #16
 8003d34:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8003d38:	0c0b      	lsrs	r3, r1, #16
 8003d3a:	b2d3      	uxtb	r3, r2
 8003d3c:	73bb      	strb	r3, [r7, #14]
    len_block[ 3] = (unsigned char)( ctx->aad_len >> 24 );
 8003d3e:	687b      	ldr	r3, [r7, #4]
 8003d40:	e9d3 0134 	ldrd	r0, r1, [r3, #208]	@ 0xd0
 8003d44:	f04f 0200 	mov.w	r2, #0
 8003d48:	f04f 0300 	mov.w	r3, #0
 8003d4c:	0e02      	lsrs	r2, r0, #24
 8003d4e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8003d52:	0e0b      	lsrs	r3, r1, #24
 8003d54:	b2d3      	uxtb	r3, r2
 8003d56:	73fb      	strb	r3, [r7, #15]
    len_block[ 4] = (unsigned char)( ctx->aad_len >> 32 );
 8003d58:	687b      	ldr	r3, [r7, #4]
 8003d5a:	e9d3 0134 	ldrd	r0, r1, [r3, #208]	@ 0xd0
 8003d5e:	f04f 0200 	mov.w	r2, #0
 8003d62:	f04f 0300 	mov.w	r3, #0
 8003d66:	000a      	movs	r2, r1
 8003d68:	2300      	movs	r3, #0
 8003d6a:	b2d3      	uxtb	r3, r2
 8003d6c:	743b      	strb	r3, [r7, #16]
    len_block[ 5] = (unsigned char)( ctx->aad_len >> 40 );
 8003d6e:	687b      	ldr	r3, [r7, #4]
 8003d70:	e9d3 0134 	ldrd	r0, r1, [r3, #208]	@ 0xd0
 8003d74:	f04f 0200 	mov.w	r2, #0
 8003d78:	f04f 0300 	mov.w	r3, #0
 8003d7c:	0a0a      	lsrs	r2, r1, #8
 8003d7e:	2300      	movs	r3, #0
 8003d80:	b2d3      	uxtb	r3, r2
 8003d82:	747b      	strb	r3, [r7, #17]
    len_block[ 6] = (unsigned char)( ctx->aad_len >> 48 );
 8003d84:	687b      	ldr	r3, [r7, #4]
 8003d86:	e9d3 0134 	ldrd	r0, r1, [r3, #208]	@ 0xd0
 8003d8a:	f04f 0200 	mov.w	r2, #0
 8003d8e:	f04f 0300 	mov.w	r3, #0
 8003d92:	0c0a      	lsrs	r2, r1, #16
 8003d94:	2300      	movs	r3, #0
 8003d96:	b2d3      	uxtb	r3, r2
 8003d98:	74bb      	strb	r3, [r7, #18]
    len_block[ 7] = (unsigned char)( ctx->aad_len >> 56 );
 8003d9a:	687b      	ldr	r3, [r7, #4]
 8003d9c:	e9d3 0134 	ldrd	r0, r1, [r3, #208]	@ 0xd0
 8003da0:	f04f 0200 	mov.w	r2, #0
 8003da4:	f04f 0300 	mov.w	r3, #0
 8003da8:	0e0a      	lsrs	r2, r1, #24
 8003daa:	2300      	movs	r3, #0
 8003dac:	b2d3      	uxtb	r3, r2
 8003dae:	74fb      	strb	r3, [r7, #19]
    len_block[ 8] = (unsigned char)( ctx->ciphertext_len       );
 8003db0:	687b      	ldr	r3, [r7, #4]
 8003db2:	e9d3 2336 	ldrd	r2, r3, [r3, #216]	@ 0xd8
 8003db6:	b2d3      	uxtb	r3, r2
 8003db8:	753b      	strb	r3, [r7, #20]
    len_block[ 9] = (unsigned char)( ctx->ciphertext_len >>  8 );
 8003dba:	687b      	ldr	r3, [r7, #4]
 8003dbc:	e9d3 0136 	ldrd	r0, r1, [r3, #216]	@ 0xd8
 8003dc0:	f04f 0200 	mov.w	r2, #0
 8003dc4:	f04f 0300 	mov.w	r3, #0
 8003dc8:	0a02      	lsrs	r2, r0, #8
 8003dca:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 8003dce:	0a0b      	lsrs	r3, r1, #8
 8003dd0:	b2d3      	uxtb	r3, r2
 8003dd2:	757b      	strb	r3, [r7, #21]
    len_block[10] = (unsigned char)( ctx->ciphertext_len >> 16 );
 8003dd4:	687b      	ldr	r3, [r7, #4]
 8003dd6:	e9d3 0136 	ldrd	r0, r1, [r3, #216]	@ 0xd8
 8003dda:	f04f 0200 	mov.w	r2, #0
 8003dde:	f04f 0300 	mov.w	r3, #0
 8003de2:	0c02      	lsrs	r2, r0, #16
 8003de4:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8003de8:	0c0b      	lsrs	r3, r1, #16
 8003dea:	b2d3      	uxtb	r3, r2
 8003dec:	75bb      	strb	r3, [r7, #22]
    len_block[11] = (unsigned char)( ctx->ciphertext_len >> 24 );
 8003dee:	687b      	ldr	r3, [r7, #4]
 8003df0:	e9d3 0136 	ldrd	r0, r1, [r3, #216]	@ 0xd8
 8003df4:	f04f 0200 	mov.w	r2, #0
 8003df8:	f04f 0300 	mov.w	r3, #0
 8003dfc:	0e02      	lsrs	r2, r0, #24
 8003dfe:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8003e02:	0e0b      	lsrs	r3, r1, #24
 8003e04:	b2d3      	uxtb	r3, r2
 8003e06:	75fb      	strb	r3, [r7, #23]
    len_block[12] = (unsigned char)( ctx->ciphertext_len >> 32 );
 8003e08:	687b      	ldr	r3, [r7, #4]
 8003e0a:	e9d3 0136 	ldrd	r0, r1, [r3, #216]	@ 0xd8
 8003e0e:	f04f 0200 	mov.w	r2, #0
 8003e12:	f04f 0300 	mov.w	r3, #0
 8003e16:	000a      	movs	r2, r1
 8003e18:	2300      	movs	r3, #0
 8003e1a:	b2d3      	uxtb	r3, r2
 8003e1c:	763b      	strb	r3, [r7, #24]
    len_block[13] = (unsigned char)( ctx->ciphertext_len >> 40 );
 8003e1e:	687b      	ldr	r3, [r7, #4]
 8003e20:	e9d3 0136 	ldrd	r0, r1, [r3, #216]	@ 0xd8
 8003e24:	f04f 0200 	mov.w	r2, #0
 8003e28:	f04f 0300 	mov.w	r3, #0
 8003e2c:	0a0a      	lsrs	r2, r1, #8
 8003e2e:	2300      	movs	r3, #0
 8003e30:	b2d3      	uxtb	r3, r2
 8003e32:	767b      	strb	r3, [r7, #25]
    len_block[14] = (unsigned char)( ctx->ciphertext_len >> 48 );
 8003e34:	687b      	ldr	r3, [r7, #4]
 8003e36:	e9d3 0136 	ldrd	r0, r1, [r3, #216]	@ 0xd8
 8003e3a:	f04f 0200 	mov.w	r2, #0
 8003e3e:	f04f 0300 	mov.w	r3, #0
 8003e42:	0c0a      	lsrs	r2, r1, #16
 8003e44:	2300      	movs	r3, #0
 8003e46:	b2d3      	uxtb	r3, r2
 8003e48:	76bb      	strb	r3, [r7, #26]
    len_block[15] = (unsigned char)( ctx->ciphertext_len >> 56 );
 8003e4a:	687b      	ldr	r3, [r7, #4]
 8003e4c:	e9d3 0136 	ldrd	r0, r1, [r3, #216]	@ 0xd8
 8003e50:	f04f 0200 	mov.w	r2, #0
 8003e54:	f04f 0300 	mov.w	r3, #0
 8003e58:	0e0a      	lsrs	r2, r1, #24
 8003e5a:	2300      	movs	r3, #0
 8003e5c:	b2d3      	uxtb	r3, r2
 8003e5e:	76fb      	strb	r3, [r7, #27]

    ret = mbedtls_poly1305_update( &ctx->poly1305_ctx, len_block, 16U );
 8003e60:	687b      	ldr	r3, [r7, #4]
 8003e62:	3384      	adds	r3, #132	@ 0x84
 8003e64:	f107 010c 	add.w	r1, r7, #12
 8003e68:	2210      	movs	r2, #16
 8003e6a:	4618      	mov	r0, r3
 8003e6c:	f003 f8fe 	bl	800706c <mbedtls_poly1305_update>
 8003e70:	61f8      	str	r0, [r7, #28]
    if( ret != 0 )
 8003e72:	69fb      	ldr	r3, [r7, #28]
 8003e74:	2b00      	cmp	r3, #0
 8003e76:	d001      	beq.n	8003e7c <mbedtls_chachapoly_finish+0x1dc>
        return( ret );
 8003e78:	69fb      	ldr	r3, [r7, #28]
 8003e7a:	e007      	b.n	8003e8c <mbedtls_chachapoly_finish+0x1ec>

    ret = mbedtls_poly1305_finish( &ctx->poly1305_ctx, mac );
 8003e7c:	687b      	ldr	r3, [r7, #4]
 8003e7e:	3384      	adds	r3, #132	@ 0x84
 8003e80:	6839      	ldr	r1, [r7, #0]
 8003e82:	4618      	mov	r0, r3
 8003e84:	f003 f96a 	bl	800715c <mbedtls_poly1305_finish>
 8003e88:	61f8      	str	r0, [r7, #28]

    return( ret );
 8003e8a:	69fb      	ldr	r3, [r7, #28]
}
 8003e8c:	4618      	mov	r0, r3
 8003e8e:	3720      	adds	r7, #32
 8003e90:	46bd      	mov	sp, r7
 8003e92:	bd80      	pop	{r7, pc}

08003e94 <chachapoly_crypt_and_tag>:
                                     const unsigned char *aad,
                                     size_t aad_len,
                                     const unsigned char *input,
                                     unsigned char *output,
                                     unsigned char tag[16] )
{
 8003e94:	b580      	push	{r7, lr}
 8003e96:	b086      	sub	sp, #24
 8003e98:	af00      	add	r7, sp, #0
 8003e9a:	60f8      	str	r0, [r7, #12]
 8003e9c:	607a      	str	r2, [r7, #4]
 8003e9e:	603b      	str	r3, [r7, #0]
 8003ea0:	460b      	mov	r3, r1
 8003ea2:	72fb      	strb	r3, [r7, #11]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 8003ea4:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8003ea8:	617b      	str	r3, [r7, #20]

    ret = mbedtls_chachapoly_starts( ctx, nonce, mode );
 8003eaa:	7afb      	ldrb	r3, [r7, #11]
 8003eac:	461a      	mov	r2, r3
 8003eae:	6839      	ldr	r1, [r7, #0]
 8003eb0:	68f8      	ldr	r0, [r7, #12]
 8003eb2:	f7ff fdfc 	bl	8003aae <mbedtls_chachapoly_starts>
 8003eb6:	6178      	str	r0, [r7, #20]
    if( ret != 0 )
 8003eb8:	697b      	ldr	r3, [r7, #20]
 8003eba:	2b00      	cmp	r3, #0
 8003ebc:	d118      	bne.n	8003ef0 <chachapoly_crypt_and_tag+0x5c>
        goto cleanup;

    ret = mbedtls_chachapoly_update_aad( ctx, aad, aad_len );
 8003ebe:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003ec0:	6a39      	ldr	r1, [r7, #32]
 8003ec2:	68f8      	ldr	r0, [r7, #12]
 8003ec4:	f7ff fe4d 	bl	8003b62 <mbedtls_chachapoly_update_aad>
 8003ec8:	6178      	str	r0, [r7, #20]
    if( ret != 0 )
 8003eca:	697b      	ldr	r3, [r7, #20]
 8003ecc:	2b00      	cmp	r3, #0
 8003ece:	d111      	bne.n	8003ef4 <chachapoly_crypt_and_tag+0x60>
        goto cleanup;

    ret = mbedtls_chachapoly_update( ctx, length, input, output );
 8003ed0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003ed2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8003ed4:	6879      	ldr	r1, [r7, #4]
 8003ed6:	68f8      	ldr	r0, [r7, #12]
 8003ed8:	f7ff fe6d 	bl	8003bb6 <mbedtls_chachapoly_update>
 8003edc:	6178      	str	r0, [r7, #20]
    if( ret != 0 )
 8003ede:	697b      	ldr	r3, [r7, #20]
 8003ee0:	2b00      	cmp	r3, #0
 8003ee2:	d109      	bne.n	8003ef8 <chachapoly_crypt_and_tag+0x64>
        goto cleanup;

    ret = mbedtls_chachapoly_finish( ctx, tag );
 8003ee4:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8003ee6:	68f8      	ldr	r0, [r7, #12]
 8003ee8:	f7ff feda 	bl	8003ca0 <mbedtls_chachapoly_finish>
 8003eec:	6178      	str	r0, [r7, #20]
 8003eee:	e004      	b.n	8003efa <chachapoly_crypt_and_tag+0x66>
        goto cleanup;
 8003ef0:	bf00      	nop
 8003ef2:	e002      	b.n	8003efa <chachapoly_crypt_and_tag+0x66>
        goto cleanup;
 8003ef4:	bf00      	nop
 8003ef6:	e000      	b.n	8003efa <chachapoly_crypt_and_tag+0x66>
        goto cleanup;
 8003ef8:	bf00      	nop

cleanup:
    return( ret );
 8003efa:	697b      	ldr	r3, [r7, #20]
}
 8003efc:	4618      	mov	r0, r3
 8003efe:	3718      	adds	r7, #24
 8003f00:	46bd      	mov	sp, r7
 8003f02:	bd80      	pop	{r7, pc}

08003f04 <mbedtls_chachapoly_encrypt_and_tag>:
                                        const unsigned char *aad,
                                        size_t aad_len,
                                        const unsigned char *input,
                                        unsigned char *output,
                                        unsigned char tag[16] )
{
 8003f04:	b580      	push	{r7, lr}
 8003f06:	b08a      	sub	sp, #40	@ 0x28
 8003f08:	af06      	add	r7, sp, #24
 8003f0a:	60f8      	str	r0, [r7, #12]
 8003f0c:	60b9      	str	r1, [r7, #8]
 8003f0e:	607a      	str	r2, [r7, #4]
 8003f10:	603b      	str	r3, [r7, #0]
    CHACHAPOLY_VALIDATE_RET( tag   != NULL );
    CHACHAPOLY_VALIDATE_RET( aad_len == 0 || aad    != NULL );
    CHACHAPOLY_VALIDATE_RET( length  == 0 || input  != NULL );
    CHACHAPOLY_VALIDATE_RET( length  == 0 || output != NULL );

    return( chachapoly_crypt_and_tag( ctx, MBEDTLS_CHACHAPOLY_ENCRYPT,
 8003f12:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003f14:	9304      	str	r3, [sp, #16]
 8003f16:	6a3b      	ldr	r3, [r7, #32]
 8003f18:	9303      	str	r3, [sp, #12]
 8003f1a:	69fb      	ldr	r3, [r7, #28]
 8003f1c:	9302      	str	r3, [sp, #8]
 8003f1e:	69bb      	ldr	r3, [r7, #24]
 8003f20:	9301      	str	r3, [sp, #4]
 8003f22:	683b      	ldr	r3, [r7, #0]
 8003f24:	9300      	str	r3, [sp, #0]
 8003f26:	687b      	ldr	r3, [r7, #4]
 8003f28:	68ba      	ldr	r2, [r7, #8]
 8003f2a:	2100      	movs	r1, #0
 8003f2c:	68f8      	ldr	r0, [r7, #12]
 8003f2e:	f7ff ffb1 	bl	8003e94 <chachapoly_crypt_and_tag>
 8003f32:	4603      	mov	r3, r0
                                      length, nonce, aad, aad_len,
                                      input, output, tag ) );
}
 8003f34:	4618      	mov	r0, r3
 8003f36:	3710      	adds	r7, #16
 8003f38:	46bd      	mov	sp, r7
 8003f3a:	bd80      	pop	{r7, pc}

08003f3c <mbedtls_chachapoly_auth_decrypt>:
                                     const unsigned char *aad,
                                     size_t aad_len,
                                     const unsigned char tag[16],
                                     const unsigned char *input,
                                     unsigned char *output )
{
 8003f3c:	b580      	push	{r7, lr}
 8003f3e:	b092      	sub	sp, #72	@ 0x48
 8003f40:	af06      	add	r7, sp, #24
 8003f42:	60f8      	str	r0, [r7, #12]
 8003f44:	60b9      	str	r1, [r7, #8]
 8003f46:	607a      	str	r2, [r7, #4]
 8003f48:	603b      	str	r3, [r7, #0]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 8003f4a:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8003f4e:	627b      	str	r3, [r7, #36]	@ 0x24
    CHACHAPOLY_VALIDATE_RET( tag   != NULL );
    CHACHAPOLY_VALIDATE_RET( aad_len == 0 || aad    != NULL );
    CHACHAPOLY_VALIDATE_RET( length  == 0 || input  != NULL );
    CHACHAPOLY_VALIDATE_RET( length  == 0 || output != NULL );

    if( ( ret = chachapoly_crypt_and_tag( ctx,
 8003f50:	f107 0314 	add.w	r3, r7, #20
 8003f54:	9304      	str	r3, [sp, #16]
 8003f56:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8003f58:	9303      	str	r3, [sp, #12]
 8003f5a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8003f5c:	9302      	str	r3, [sp, #8]
 8003f5e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8003f60:	9301      	str	r3, [sp, #4]
 8003f62:	683b      	ldr	r3, [r7, #0]
 8003f64:	9300      	str	r3, [sp, #0]
 8003f66:	687b      	ldr	r3, [r7, #4]
 8003f68:	68ba      	ldr	r2, [r7, #8]
 8003f6a:	2101      	movs	r1, #1
 8003f6c:	68f8      	ldr	r0, [r7, #12]
 8003f6e:	f7ff ff91 	bl	8003e94 <chachapoly_crypt_and_tag>
 8003f72:	6278      	str	r0, [r7, #36]	@ 0x24
 8003f74:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003f76:	2b00      	cmp	r3, #0
 8003f78:	d001      	beq.n	8003f7e <mbedtls_chachapoly_auth_decrypt+0x42>
                        MBEDTLS_CHACHAPOLY_DECRYPT, length, nonce,
                        aad, aad_len, input, output, check_tag ) ) != 0 )
    {
        return( ret );
 8003f7a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003f7c:	e024      	b.n	8003fc8 <mbedtls_chachapoly_auth_decrypt+0x8c>
    }

    /* Check tag in "constant-time" */
    for( diff = 0, i = 0; i < sizeof( check_tag ); i++ )
 8003f7e:	2300      	movs	r3, #0
 8003f80:	62bb      	str	r3, [r7, #40]	@ 0x28
 8003f82:	2300      	movs	r3, #0
 8003f84:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8003f86:	e011      	b.n	8003fac <mbedtls_chachapoly_auth_decrypt+0x70>
        diff |= tag[i] ^ check_tag[i];
 8003f88:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8003f8a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003f8c:	4413      	add	r3, r2
 8003f8e:	781a      	ldrb	r2, [r3, #0]
 8003f90:	f107 0114 	add.w	r1, r7, #20
 8003f94:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003f96:	440b      	add	r3, r1
 8003f98:	781b      	ldrb	r3, [r3, #0]
 8003f9a:	4053      	eors	r3, r2
 8003f9c:	b2db      	uxtb	r3, r3
 8003f9e:	461a      	mov	r2, r3
 8003fa0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8003fa2:	4313      	orrs	r3, r2
 8003fa4:	62bb      	str	r3, [r7, #40]	@ 0x28
    for( diff = 0, i = 0; i < sizeof( check_tag ); i++ )
 8003fa6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003fa8:	3301      	adds	r3, #1
 8003faa:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8003fac:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003fae:	2b0f      	cmp	r3, #15
 8003fb0:	d9ea      	bls.n	8003f88 <mbedtls_chachapoly_auth_decrypt+0x4c>

    if( diff != 0 )
 8003fb2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8003fb4:	2b00      	cmp	r3, #0
 8003fb6:	d006      	beq.n	8003fc6 <mbedtls_chachapoly_auth_decrypt+0x8a>
    {
        mbedtls_platform_zeroize( output, length );
 8003fb8:	68b9      	ldr	r1, [r7, #8]
 8003fba:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 8003fbc:	f002 f910 	bl	80061e0 <mbedtls_platform_zeroize>
        return( MBEDTLS_ERR_CHACHAPOLY_AUTH_FAILED );
 8003fc0:	f06f 0355 	mvn.w	r3, #85	@ 0x55
 8003fc4:	e000      	b.n	8003fc8 <mbedtls_chachapoly_auth_decrypt+0x8c>
    }

    return( 0 );
 8003fc6:	2300      	movs	r3, #0
}
 8003fc8:	4618      	mov	r0, r3
 8003fca:	3730      	adds	r7, #48	@ 0x30
 8003fcc:	46bd      	mov	sp, r7
 8003fce:	bd80      	pop	{r7, pc}

08003fd0 <mbedtls_cipher_get_block_size>:
 * \return       The block size of the underlying cipher.
 * \return       \c 0 if \p ctx has not been initialized.
 */
static inline unsigned int mbedtls_cipher_get_block_size(
    const mbedtls_cipher_context_t *ctx )
{
 8003fd0:	b480      	push	{r7}
 8003fd2:	b083      	sub	sp, #12
 8003fd4:	af00      	add	r7, sp, #0
 8003fd6:	6078      	str	r0, [r7, #4]
    MBEDTLS_INTERNAL_VALIDATE_RET( ctx != NULL, 0 );
    if( ctx->MBEDTLS_PRIVATE(cipher_info) == NULL )
 8003fd8:	687b      	ldr	r3, [r7, #4]
 8003fda:	681b      	ldr	r3, [r3, #0]
 8003fdc:	2b00      	cmp	r3, #0
 8003fde:	d101      	bne.n	8003fe4 <mbedtls_cipher_get_block_size+0x14>
        return 0;
 8003fe0:	2300      	movs	r3, #0
 8003fe2:	e002      	b.n	8003fea <mbedtls_cipher_get_block_size+0x1a>

    return ctx->MBEDTLS_PRIVATE(cipher_info)->MBEDTLS_PRIVATE(block_size);
 8003fe4:	687b      	ldr	r3, [r7, #4]
 8003fe6:	681b      	ldr	r3, [r3, #0]
 8003fe8:	695b      	ldr	r3, [r3, #20]
}
 8003fea:	4618      	mov	r0, r3
 8003fec:	370c      	adds	r7, #12
 8003fee:	46bd      	mov	sp, r7
 8003ff0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003ff4:	4770      	bx	lr
	...

08003ff8 <mbedtls_cipher_info_from_values>:

const mbedtls_cipher_info_t *mbedtls_cipher_info_from_values(
    const mbedtls_cipher_id_t cipher_id,
    int key_bitlen,
    const mbedtls_cipher_mode_t mode )
{
 8003ff8:	b480      	push	{r7}
 8003ffa:	b085      	sub	sp, #20
 8003ffc:	af00      	add	r7, sp, #0
 8003ffe:	4603      	mov	r3, r0
 8004000:	6039      	str	r1, [r7, #0]
 8004002:	71fb      	strb	r3, [r7, #7]
 8004004:	4613      	mov	r3, r2
 8004006:	71bb      	strb	r3, [r7, #6]
    const mbedtls_cipher_definition_t *def;

    for( def = mbedtls_cipher_definitions; def->info != NULL; def++ )
 8004008:	4b13      	ldr	r3, [pc, #76]	@ (8004058 <mbedtls_cipher_info_from_values+0x60>)
 800400a:	60fb      	str	r3, [r7, #12]
 800400c:	e018      	b.n	8004040 <mbedtls_cipher_info_from_values+0x48>
        if( def->info->base->cipher == cipher_id &&
 800400e:	68fb      	ldr	r3, [r7, #12]
 8004010:	685b      	ldr	r3, [r3, #4]
 8004012:	699b      	ldr	r3, [r3, #24]
 8004014:	781b      	ldrb	r3, [r3, #0]
 8004016:	79fa      	ldrb	r2, [r7, #7]
 8004018:	429a      	cmp	r2, r3
 800401a:	d10e      	bne.n	800403a <mbedtls_cipher_info_from_values+0x42>
            def->info->key_bitlen == (unsigned) key_bitlen &&
 800401c:	68fb      	ldr	r3, [r7, #12]
 800401e:	685b      	ldr	r3, [r3, #4]
 8004020:	685a      	ldr	r2, [r3, #4]
 8004022:	683b      	ldr	r3, [r7, #0]
        if( def->info->base->cipher == cipher_id &&
 8004024:	429a      	cmp	r2, r3
 8004026:	d108      	bne.n	800403a <mbedtls_cipher_info_from_values+0x42>
            def->info->mode == mode )
 8004028:	68fb      	ldr	r3, [r7, #12]
 800402a:	685b      	ldr	r3, [r3, #4]
 800402c:	785b      	ldrb	r3, [r3, #1]
            def->info->key_bitlen == (unsigned) key_bitlen &&
 800402e:	79ba      	ldrb	r2, [r7, #6]
 8004030:	429a      	cmp	r2, r3
 8004032:	d102      	bne.n	800403a <mbedtls_cipher_info_from_values+0x42>
            return( def->info );
 8004034:	68fb      	ldr	r3, [r7, #12]
 8004036:	685b      	ldr	r3, [r3, #4]
 8004038:	e007      	b.n	800404a <mbedtls_cipher_info_from_values+0x52>
    for( def = mbedtls_cipher_definitions; def->info != NULL; def++ )
 800403a:	68fb      	ldr	r3, [r7, #12]
 800403c:	3308      	adds	r3, #8
 800403e:	60fb      	str	r3, [r7, #12]
 8004040:	68fb      	ldr	r3, [r7, #12]
 8004042:	685b      	ldr	r3, [r3, #4]
 8004044:	2b00      	cmp	r3, #0
 8004046:	d1e2      	bne.n	800400e <mbedtls_cipher_info_from_values+0x16>

    return( NULL );
 8004048:	2300      	movs	r3, #0
}
 800404a:	4618      	mov	r0, r3
 800404c:	3714      	adds	r7, #20
 800404e:	46bd      	mov	sp, r7
 8004050:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004054:	4770      	bx	lr
 8004056:	bf00      	nop
 8004058:	08016af4 	.word	0x08016af4

0800405c <mbedtls_cipher_free>:
    CIPHER_VALIDATE( ctx != NULL );
    memset( ctx, 0, sizeof( mbedtls_cipher_context_t ) );
}

void mbedtls_cipher_free( mbedtls_cipher_context_t *ctx )
{
 800405c:	b580      	push	{r7, lr}
 800405e:	b082      	sub	sp, #8
 8004060:	af00      	add	r7, sp, #0
 8004062:	6078      	str	r0, [r7, #4]
    if( ctx == NULL )
 8004064:	687b      	ldr	r3, [r7, #4]
 8004066:	2b00      	cmp	r3, #0
 8004068:	d01f      	beq.n	80040aa <mbedtls_cipher_free+0x4e>
        return;
    }
#endif /* MBEDTLS_USE_PSA_CRYPTO */

#if defined(MBEDTLS_CMAC_C)
    if( ctx->cmac_ctx )
 800406a:	687b      	ldr	r3, [r7, #4]
 800406c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800406e:	2b00      	cmp	r3, #0
 8004070:	d00a      	beq.n	8004088 <mbedtls_cipher_free+0x2c>
    {
       mbedtls_platform_zeroize( ctx->cmac_ctx,
 8004072:	687b      	ldr	r3, [r7, #4]
 8004074:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004076:	2124      	movs	r1, #36	@ 0x24
 8004078:	4618      	mov	r0, r3
 800407a:	f002 f8b1 	bl	80061e0 <mbedtls_platform_zeroize>
                                 sizeof( mbedtls_cmac_context_t ) );
       mbedtls_free( ctx->cmac_ctx );
 800407e:	687b      	ldr	r3, [r7, #4]
 8004080:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004082:	4618      	mov	r0, r3
 8004084:	f010 ff74 	bl	8014f70 <free>
    }
#endif

    if( ctx->cipher_ctx )
 8004088:	687b      	ldr	r3, [r7, #4]
 800408a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800408c:	2b00      	cmp	r3, #0
 800408e:	d007      	beq.n	80040a0 <mbedtls_cipher_free+0x44>
        ctx->cipher_info->base->ctx_free_func( ctx->cipher_ctx );
 8004090:	687b      	ldr	r3, [r7, #4]
 8004092:	681b      	ldr	r3, [r3, #0]
 8004094:	699b      	ldr	r3, [r3, #24]
 8004096:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8004098:	687a      	ldr	r2, [r7, #4]
 800409a:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 800409c:	4610      	mov	r0, r2
 800409e:	4798      	blx	r3

    mbedtls_platform_zeroize( ctx, sizeof(mbedtls_cipher_context_t) );
 80040a0:	2144      	movs	r1, #68	@ 0x44
 80040a2:	6878      	ldr	r0, [r7, #4]
 80040a4:	f002 f89c 	bl	80061e0 <mbedtls_platform_zeroize>
 80040a8:	e000      	b.n	80040ac <mbedtls_cipher_free+0x50>
        return;
 80040aa:	bf00      	nop
}
 80040ac:	3708      	adds	r7, #8
 80040ae:	46bd      	mov	sp, r7
 80040b0:	bd80      	pop	{r7, pc}
	...

080040b4 <mbedtls_cipher_setup>:

int mbedtls_cipher_setup( mbedtls_cipher_context_t *ctx,
                          const mbedtls_cipher_info_t *cipher_info )
{
 80040b4:	b580      	push	{r7, lr}
 80040b6:	b082      	sub	sp, #8
 80040b8:	af00      	add	r7, sp, #0
 80040ba:	6078      	str	r0, [r7, #4]
 80040bc:	6039      	str	r1, [r7, #0]
    CIPHER_VALIDATE_RET( ctx != NULL );
    if( cipher_info == NULL )
 80040be:	683b      	ldr	r3, [r7, #0]
 80040c0:	2b00      	cmp	r3, #0
 80040c2:	d101      	bne.n	80040c8 <mbedtls_cipher_setup+0x14>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 80040c4:	4b0f      	ldr	r3, [pc, #60]	@ (8004104 <mbedtls_cipher_setup+0x50>)
 80040c6:	e019      	b.n	80040fc <mbedtls_cipher_setup+0x48>

    memset( ctx, 0, sizeof( mbedtls_cipher_context_t ) );
 80040c8:	2244      	movs	r2, #68	@ 0x44
 80040ca:	2100      	movs	r1, #0
 80040cc:	6878      	ldr	r0, [r7, #4]
 80040ce:	f011 f9bb 	bl	8015448 <memset>

    if( NULL == ( ctx->cipher_ctx = cipher_info->base->ctx_alloc_func() ) )
 80040d2:	683b      	ldr	r3, [r7, #0]
 80040d4:	699b      	ldr	r3, [r3, #24]
 80040d6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80040d8:	4798      	blx	r3
 80040da:	4602      	mov	r2, r0
 80040dc:	687b      	ldr	r3, [r7, #4]
 80040de:	63da      	str	r2, [r3, #60]	@ 0x3c
 80040e0:	687b      	ldr	r3, [r7, #4]
 80040e2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80040e4:	2b00      	cmp	r3, #0
 80040e6:	d101      	bne.n	80040ec <mbedtls_cipher_setup+0x38>
        return( MBEDTLS_ERR_CIPHER_ALLOC_FAILED );
 80040e8:	4b07      	ldr	r3, [pc, #28]	@ (8004108 <mbedtls_cipher_setup+0x54>)
 80040ea:	e007      	b.n	80040fc <mbedtls_cipher_setup+0x48>

    ctx->cipher_info = cipher_info;
 80040ec:	687b      	ldr	r3, [r7, #4]
 80040ee:	683a      	ldr	r2, [r7, #0]
 80040f0:	601a      	str	r2, [r3, #0]
#if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)
    /*
     * Ignore possible errors caused by a cipher mode that doesn't use padding
     */
#if defined(MBEDTLS_CIPHER_PADDING_PKCS7)
    (void) mbedtls_cipher_set_padding_mode( ctx, MBEDTLS_PADDING_PKCS7 );
 80040f2:	2100      	movs	r1, #0
 80040f4:	6878      	ldr	r0, [r7, #4]
 80040f6:	f000 fca7 	bl	8004a48 <mbedtls_cipher_set_padding_mode>
#else
    (void) mbedtls_cipher_set_padding_mode( ctx, MBEDTLS_PADDING_NONE );
#endif
#endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */

    return( 0 );
 80040fa:	2300      	movs	r3, #0
}
 80040fc:	4618      	mov	r0, r3
 80040fe:	3708      	adds	r7, #8
 8004100:	46bd      	mov	sp, r7
 8004102:	bd80      	pop	{r7, pc}
 8004104:	ffff9f00 	.word	0xffff9f00
 8004108:	ffff9e80 	.word	0xffff9e80

0800410c <mbedtls_cipher_setkey>:

int mbedtls_cipher_setkey( mbedtls_cipher_context_t *ctx,
                           const unsigned char *key,
                           int key_bitlen,
                           const mbedtls_operation_t operation )
{
 800410c:	b580      	push	{r7, lr}
 800410e:	b084      	sub	sp, #16
 8004110:	af00      	add	r7, sp, #0
 8004112:	60f8      	str	r0, [r7, #12]
 8004114:	60b9      	str	r1, [r7, #8]
 8004116:	607a      	str	r2, [r7, #4]
 8004118:	70fb      	strb	r3, [r7, #3]
    CIPHER_VALIDATE_RET( ctx != NULL );
    CIPHER_VALIDATE_RET( key != NULL );
    CIPHER_VALIDATE_RET( operation == MBEDTLS_ENCRYPT ||
                         operation == MBEDTLS_DECRYPT );
    if( ctx->cipher_info == NULL )
 800411a:	68fb      	ldr	r3, [r7, #12]
 800411c:	681b      	ldr	r3, [r3, #0]
 800411e:	2b00      	cmp	r3, #0
 8004120:	d101      	bne.n	8004126 <mbedtls_cipher_setkey+0x1a>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 8004122:	4b26      	ldr	r3, [pc, #152]	@ (80041bc <mbedtls_cipher_setkey+0xb0>)
 8004124:	e045      	b.n	80041b2 <mbedtls_cipher_setkey+0xa6>
        ctx->operation = operation;
        return( 0 );
    }
#endif /* MBEDTLS_USE_PSA_CRYPTO */

    if( ( ctx->cipher_info->flags & MBEDTLS_CIPHER_VARIABLE_KEY_LEN ) == 0 &&
 8004126:	68fb      	ldr	r3, [r7, #12]
 8004128:	681b      	ldr	r3, [r3, #0]
 800412a:	691b      	ldr	r3, [r3, #16]
 800412c:	f003 0302 	and.w	r3, r3, #2
 8004130:	2b00      	cmp	r3, #0
 8004132:	d108      	bne.n	8004146 <mbedtls_cipher_setkey+0x3a>
        (int) ctx->cipher_info->key_bitlen != key_bitlen )
 8004134:	68fb      	ldr	r3, [r7, #12]
 8004136:	681b      	ldr	r3, [r3, #0]
 8004138:	685b      	ldr	r3, [r3, #4]
 800413a:	461a      	mov	r2, r3
    if( ( ctx->cipher_info->flags & MBEDTLS_CIPHER_VARIABLE_KEY_LEN ) == 0 &&
 800413c:	687b      	ldr	r3, [r7, #4]
 800413e:	4293      	cmp	r3, r2
 8004140:	d001      	beq.n	8004146 <mbedtls_cipher_setkey+0x3a>
    {
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 8004142:	4b1e      	ldr	r3, [pc, #120]	@ (80041bc <mbedtls_cipher_setkey+0xb0>)
 8004144:	e035      	b.n	80041b2 <mbedtls_cipher_setkey+0xa6>
    }

    ctx->key_bitlen = key_bitlen;
 8004146:	68fb      	ldr	r3, [r7, #12]
 8004148:	687a      	ldr	r2, [r7, #4]
 800414a:	605a      	str	r2, [r3, #4]
    ctx->operation = operation;
 800414c:	68fb      	ldr	r3, [r7, #12]
 800414e:	78fa      	ldrb	r2, [r7, #3]
 8004150:	721a      	strb	r2, [r3, #8]

    /*
     * For OFB, CFB and CTR mode always use the encryption key schedule
     */
    if( MBEDTLS_ENCRYPT == operation ||
 8004152:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8004156:	2b01      	cmp	r3, #1
 8004158:	d00e      	beq.n	8004178 <mbedtls_cipher_setkey+0x6c>
        MBEDTLS_MODE_CFB == ctx->cipher_info->mode ||
 800415a:	68fb      	ldr	r3, [r7, #12]
 800415c:	681b      	ldr	r3, [r3, #0]
 800415e:	785b      	ldrb	r3, [r3, #1]
    if( MBEDTLS_ENCRYPT == operation ||
 8004160:	2b03      	cmp	r3, #3
 8004162:	d009      	beq.n	8004178 <mbedtls_cipher_setkey+0x6c>
        MBEDTLS_MODE_OFB == ctx->cipher_info->mode ||
 8004164:	68fb      	ldr	r3, [r7, #12]
 8004166:	681b      	ldr	r3, [r3, #0]
 8004168:	785b      	ldrb	r3, [r3, #1]
        MBEDTLS_MODE_CFB == ctx->cipher_info->mode ||
 800416a:	2b04      	cmp	r3, #4
 800416c:	d004      	beq.n	8004178 <mbedtls_cipher_setkey+0x6c>
        MBEDTLS_MODE_CTR == ctx->cipher_info->mode )
 800416e:	68fb      	ldr	r3, [r7, #12]
 8004170:	681b      	ldr	r3, [r3, #0]
 8004172:	785b      	ldrb	r3, [r3, #1]
        MBEDTLS_MODE_OFB == ctx->cipher_info->mode ||
 8004174:	2b05      	cmp	r3, #5
 8004176:	d10b      	bne.n	8004190 <mbedtls_cipher_setkey+0x84>
    {
        return( ctx->cipher_info->base->setkey_enc_func( ctx->cipher_ctx, key,
 8004178:	68fb      	ldr	r3, [r7, #12]
 800417a:	681b      	ldr	r3, [r3, #0]
 800417c:	699b      	ldr	r3, [r3, #24]
 800417e:	6a1b      	ldr	r3, [r3, #32]
 8004180:	68fa      	ldr	r2, [r7, #12]
 8004182:	6bd0      	ldr	r0, [r2, #60]	@ 0x3c
                                                         ctx->key_bitlen ) );
 8004184:	68fa      	ldr	r2, [r7, #12]
 8004186:	6852      	ldr	r2, [r2, #4]
        return( ctx->cipher_info->base->setkey_enc_func( ctx->cipher_ctx, key,
 8004188:	68b9      	ldr	r1, [r7, #8]
 800418a:	4798      	blx	r3
 800418c:	4603      	mov	r3, r0
 800418e:	e010      	b.n	80041b2 <mbedtls_cipher_setkey+0xa6>
    }

    if( MBEDTLS_DECRYPT == operation )
 8004190:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8004194:	2b00      	cmp	r3, #0
 8004196:	d10b      	bne.n	80041b0 <mbedtls_cipher_setkey+0xa4>
        return( ctx->cipher_info->base->setkey_dec_func( ctx->cipher_ctx, key,
 8004198:	68fb      	ldr	r3, [r7, #12]
 800419a:	681b      	ldr	r3, [r3, #0]
 800419c:	699b      	ldr	r3, [r3, #24]
 800419e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80041a0:	68fa      	ldr	r2, [r7, #12]
 80041a2:	6bd0      	ldr	r0, [r2, #60]	@ 0x3c
                                                         ctx->key_bitlen ) );
 80041a4:	68fa      	ldr	r2, [r7, #12]
 80041a6:	6852      	ldr	r2, [r2, #4]
        return( ctx->cipher_info->base->setkey_dec_func( ctx->cipher_ctx, key,
 80041a8:	68b9      	ldr	r1, [r7, #8]
 80041aa:	4798      	blx	r3
 80041ac:	4603      	mov	r3, r0
 80041ae:	e000      	b.n	80041b2 <mbedtls_cipher_setkey+0xa6>

    return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 80041b0:	4b02      	ldr	r3, [pc, #8]	@ (80041bc <mbedtls_cipher_setkey+0xb0>)
}
 80041b2:	4618      	mov	r0, r3
 80041b4:	3710      	adds	r7, #16
 80041b6:	46bd      	mov	sp, r7
 80041b8:	bd80      	pop	{r7, pc}
 80041ba:	bf00      	nop
 80041bc:	ffff9f00 	.word	0xffff9f00

080041c0 <mbedtls_cipher_update>:
}
#endif /* MBEDTLS_GCM_C || MBEDTLS_CHACHAPOLY_C */

int mbedtls_cipher_update( mbedtls_cipher_context_t *ctx, const unsigned char *input,
                   size_t ilen, unsigned char *output, size_t *olen )
{
 80041c0:	b5b0      	push	{r4, r5, r7, lr}
 80041c2:	b08c      	sub	sp, #48	@ 0x30
 80041c4:	af04      	add	r7, sp, #16
 80041c6:	60f8      	str	r0, [r7, #12]
 80041c8:	60b9      	str	r1, [r7, #8]
 80041ca:	607a      	str	r2, [r7, #4]
 80041cc:	603b      	str	r3, [r7, #0]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 80041ce:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 80041d2:	61bb      	str	r3, [r7, #24]

    CIPHER_VALIDATE_RET( ctx != NULL );
    CIPHER_VALIDATE_RET( ilen == 0 || input != NULL );
    CIPHER_VALIDATE_RET( output != NULL );
    CIPHER_VALIDATE_RET( olen != NULL );
    if( ctx->cipher_info == NULL )
 80041d4:	68fb      	ldr	r3, [r7, #12]
 80041d6:	681b      	ldr	r3, [r3, #0]
 80041d8:	2b00      	cmp	r3, #0
 80041da:	d101      	bne.n	80041e0 <mbedtls_cipher_update+0x20>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 80041dc:	4b6d      	ldr	r3, [pc, #436]	@ (8004394 <mbedtls_cipher_update+0x1d4>)
 80041de:	e1fc      	b.n	80045da <mbedtls_cipher_update+0x41a>
         * accessible through the cipher layer. */
        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
    }
#endif /* MBEDTLS_USE_PSA_CRYPTO */

    *olen = 0;
 80041e0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80041e2:	2200      	movs	r2, #0
 80041e4:	601a      	str	r2, [r3, #0]
    block_size = mbedtls_cipher_get_block_size( ctx );
 80041e6:	68f8      	ldr	r0, [r7, #12]
 80041e8:	f7ff fef2 	bl	8003fd0 <mbedtls_cipher_get_block_size>
 80041ec:	6178      	str	r0, [r7, #20]
    if ( 0 == block_size )
 80041ee:	697b      	ldr	r3, [r7, #20]
 80041f0:	2b00      	cmp	r3, #0
 80041f2:	d101      	bne.n	80041f8 <mbedtls_cipher_update+0x38>
    {
        return( MBEDTLS_ERR_CIPHER_INVALID_CONTEXT );
 80041f4:	4b68      	ldr	r3, [pc, #416]	@ (8004398 <mbedtls_cipher_update+0x1d8>)
 80041f6:	e1f0      	b.n	80045da <mbedtls_cipher_update+0x41a>
    }

    if( ctx->cipher_info->mode == MBEDTLS_MODE_ECB )
 80041f8:	68fb      	ldr	r3, [r7, #12]
 80041fa:	681b      	ldr	r3, [r3, #0]
 80041fc:	785b      	ldrb	r3, [r3, #1]
 80041fe:	2b01      	cmp	r3, #1
 8004200:	d11c      	bne.n	800423c <mbedtls_cipher_update+0x7c>
    {
        if( ilen != block_size )
 8004202:	687a      	ldr	r2, [r7, #4]
 8004204:	697b      	ldr	r3, [r7, #20]
 8004206:	429a      	cmp	r2, r3
 8004208:	d001      	beq.n	800420e <mbedtls_cipher_update+0x4e>
            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );
 800420a:	4b64      	ldr	r3, [pc, #400]	@ (800439c <mbedtls_cipher_update+0x1dc>)
 800420c:	e1e5      	b.n	80045da <mbedtls_cipher_update+0x41a>

        *olen = ilen;
 800420e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004210:	687a      	ldr	r2, [r7, #4]
 8004212:	601a      	str	r2, [r3, #0]

        if( 0 != ( ret = ctx->cipher_info->base->ecb_func( ctx->cipher_ctx,
 8004214:	68fb      	ldr	r3, [r7, #12]
 8004216:	681b      	ldr	r3, [r3, #0]
 8004218:	699b      	ldr	r3, [r3, #24]
 800421a:	685c      	ldr	r4, [r3, #4]
 800421c:	68fb      	ldr	r3, [r7, #12]
 800421e:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 8004220:	68fb      	ldr	r3, [r7, #12]
 8004222:	f993 1008 	ldrsb.w	r1, [r3, #8]
 8004226:	683b      	ldr	r3, [r7, #0]
 8004228:	68ba      	ldr	r2, [r7, #8]
 800422a:	47a0      	blx	r4
 800422c:	61b8      	str	r0, [r7, #24]
 800422e:	69bb      	ldr	r3, [r7, #24]
 8004230:	2b00      	cmp	r3, #0
 8004232:	d001      	beq.n	8004238 <mbedtls_cipher_update+0x78>
                    ctx->operation, input, output ) ) )
        {
            return( ret );
 8004234:	69bb      	ldr	r3, [r7, #24]
 8004236:	e1d0      	b.n	80045da <mbedtls_cipher_update+0x41a>
        }

        return( 0 );
 8004238:	2300      	movs	r3, #0
 800423a:	e1ce      	b.n	80045da <mbedtls_cipher_update+0x41a>
    }

#if defined(MBEDTLS_GCM_C)
    if( ctx->cipher_info->mode == MBEDTLS_MODE_GCM )
 800423c:	68fb      	ldr	r3, [r7, #12]
 800423e:	681b      	ldr	r3, [r3, #0]
 8004240:	785b      	ldrb	r3, [r3, #1]
 8004242:	2b06      	cmp	r3, #6
 8004244:	d10c      	bne.n	8004260 <mbedtls_cipher_update+0xa0>
    {
        return( mbedtls_gcm_update( (mbedtls_gcm_context *) ctx->cipher_ctx,
 8004246:	68fb      	ldr	r3, [r7, #12]
 8004248:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 800424a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800424c:	9301      	str	r3, [sp, #4]
 800424e:	687b      	ldr	r3, [r7, #4]
 8004250:	9300      	str	r3, [sp, #0]
 8004252:	683b      	ldr	r3, [r7, #0]
 8004254:	687a      	ldr	r2, [r7, #4]
 8004256:	68b9      	ldr	r1, [r7, #8]
 8004258:	f001 fc8e 	bl	8005b78 <mbedtls_gcm_update>
 800425c:	4603      	mov	r3, r0
 800425e:	e1bc      	b.n	80045da <mbedtls_cipher_update+0x41a>
                                    output, ilen, olen ) );
    }
#endif

#if defined(MBEDTLS_CHACHAPOLY_C)
    if ( ctx->cipher_info->type == MBEDTLS_CIPHER_CHACHA20_POLY1305 )
 8004260:	68fb      	ldr	r3, [r7, #12]
 8004262:	681b      	ldr	r3, [r3, #0]
 8004264:	781b      	ldrb	r3, [r3, #0]
 8004266:	2b44      	cmp	r3, #68	@ 0x44
 8004268:	d10b      	bne.n	8004282 <mbedtls_cipher_update+0xc2>
    {
        *olen = ilen;
 800426a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800426c:	687a      	ldr	r2, [r7, #4]
 800426e:	601a      	str	r2, [r3, #0]
        return( mbedtls_chachapoly_update( (mbedtls_chachapoly_context*) ctx->cipher_ctx,
 8004270:	68fb      	ldr	r3, [r7, #12]
 8004272:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 8004274:	683b      	ldr	r3, [r7, #0]
 8004276:	68ba      	ldr	r2, [r7, #8]
 8004278:	6879      	ldr	r1, [r7, #4]
 800427a:	f7ff fc9c 	bl	8003bb6 <mbedtls_chachapoly_update>
 800427e:	4603      	mov	r3, r0
 8004280:	e1ab      	b.n	80045da <mbedtls_cipher_update+0x41a>
                                           ilen, input, output ) );
    }
#endif

    if( input == output &&
 8004282:	68ba      	ldr	r2, [r7, #8]
 8004284:	683b      	ldr	r3, [r7, #0]
 8004286:	429a      	cmp	r2, r3
 8004288:	d10f      	bne.n	80042aa <mbedtls_cipher_update+0xea>
       ( ctx->unprocessed_len != 0 || ilen % block_size ) )
 800428a:	68fb      	ldr	r3, [r7, #12]
 800428c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
    if( input == output &&
 800428e:	2b00      	cmp	r3, #0
 8004290:	d109      	bne.n	80042a6 <mbedtls_cipher_update+0xe6>
       ( ctx->unprocessed_len != 0 || ilen % block_size ) )
 8004292:	687b      	ldr	r3, [r7, #4]
 8004294:	697a      	ldr	r2, [r7, #20]
 8004296:	fbb3 f2f2 	udiv	r2, r3, r2
 800429a:	6979      	ldr	r1, [r7, #20]
 800429c:	fb01 f202 	mul.w	r2, r1, r2
 80042a0:	1a9b      	subs	r3, r3, r2
 80042a2:	2b00      	cmp	r3, #0
 80042a4:	d001      	beq.n	80042aa <mbedtls_cipher_update+0xea>
    {
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 80042a6:	4b3b      	ldr	r3, [pc, #236]	@ (8004394 <mbedtls_cipher_update+0x1d4>)
 80042a8:	e197      	b.n	80045da <mbedtls_cipher_update+0x41a>
    }

#if defined(MBEDTLS_CIPHER_MODE_CBC)
    if( ctx->cipher_info->mode == MBEDTLS_MODE_CBC )
 80042aa:	68fb      	ldr	r3, [r7, #12]
 80042ac:	681b      	ldr	r3, [r3, #0]
 80042ae:	785b      	ldrb	r3, [r3, #1]
 80042b0:	2b02      	cmp	r3, #2
 80042b2:	f040 80de 	bne.w	8004472 <mbedtls_cipher_update+0x2b2>
    {
        size_t copy_len = 0;
 80042b6:	2300      	movs	r3, #0
 80042b8:	61fb      	str	r3, [r7, #28]

        /*
         * If there is not enough data for a full block, cache it.
         */
        if( ( ctx->operation == MBEDTLS_DECRYPT && NULL != ctx->add_padding &&
 80042ba:	68fb      	ldr	r3, [r7, #12]
 80042bc:	f993 3008 	ldrsb.w	r3, [r3, #8]
 80042c0:	2b00      	cmp	r3, #0
 80042c2:	d10a      	bne.n	80042da <mbedtls_cipher_update+0x11a>
 80042c4:	68fb      	ldr	r3, [r7, #12]
 80042c6:	68db      	ldr	r3, [r3, #12]
 80042c8:	2b00      	cmp	r3, #0
 80042ca:	d006      	beq.n	80042da <mbedtls_cipher_update+0x11a>
                ilen <= block_size - ctx->unprocessed_len ) ||
 80042cc:	68fb      	ldr	r3, [r7, #12]
 80042ce:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80042d0:	697a      	ldr	r2, [r7, #20]
 80042d2:	1ad3      	subs	r3, r2, r3
        if( ( ctx->operation == MBEDTLS_DECRYPT && NULL != ctx->add_padding &&
 80042d4:	687a      	ldr	r2, [r7, #4]
 80042d6:	429a      	cmp	r2, r3
 80042d8:	d91b      	bls.n	8004312 <mbedtls_cipher_update+0x152>
            ( ctx->operation == MBEDTLS_DECRYPT && NULL == ctx->add_padding &&
 80042da:	68fb      	ldr	r3, [r7, #12]
 80042dc:	f993 3008 	ldrsb.w	r3, [r3, #8]
                ilen <= block_size - ctx->unprocessed_len ) ||
 80042e0:	2b00      	cmp	r3, #0
 80042e2:	d10a      	bne.n	80042fa <mbedtls_cipher_update+0x13a>
            ( ctx->operation == MBEDTLS_DECRYPT && NULL == ctx->add_padding &&
 80042e4:	68fb      	ldr	r3, [r7, #12]
 80042e6:	68db      	ldr	r3, [r3, #12]
 80042e8:	2b00      	cmp	r3, #0
 80042ea:	d106      	bne.n	80042fa <mbedtls_cipher_update+0x13a>
                ilen < block_size - ctx->unprocessed_len ) ||
 80042ec:	68fb      	ldr	r3, [r7, #12]
 80042ee:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80042f0:	697a      	ldr	r2, [r7, #20]
 80042f2:	1ad3      	subs	r3, r2, r3
            ( ctx->operation == MBEDTLS_DECRYPT && NULL == ctx->add_padding &&
 80042f4:	687a      	ldr	r2, [r7, #4]
 80042f6:	429a      	cmp	r2, r3
 80042f8:	d30b      	bcc.n	8004312 <mbedtls_cipher_update+0x152>
             ( ctx->operation == MBEDTLS_ENCRYPT &&
 80042fa:	68fb      	ldr	r3, [r7, #12]
 80042fc:	f993 3008 	ldrsb.w	r3, [r3, #8]
                ilen < block_size - ctx->unprocessed_len ) ||
 8004300:	2b01      	cmp	r3, #1
 8004302:	d119      	bne.n	8004338 <mbedtls_cipher_update+0x178>
                ilen < block_size - ctx->unprocessed_len ) )
 8004304:	68fb      	ldr	r3, [r7, #12]
 8004306:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8004308:	697a      	ldr	r2, [r7, #20]
 800430a:	1ad3      	subs	r3, r2, r3
             ( ctx->operation == MBEDTLS_ENCRYPT &&
 800430c:	687a      	ldr	r2, [r7, #4]
 800430e:	429a      	cmp	r2, r3
 8004310:	d212      	bcs.n	8004338 <mbedtls_cipher_update+0x178>
        {
            memcpy( &( ctx->unprocessed_data[ctx->unprocessed_len] ), input,
 8004312:	68fb      	ldr	r3, [r7, #12]
 8004314:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8004316:	3310      	adds	r3, #16
 8004318:	68fa      	ldr	r2, [r7, #12]
 800431a:	4413      	add	r3, r2
 800431c:	3304      	adds	r3, #4
 800431e:	687a      	ldr	r2, [r7, #4]
 8004320:	68b9      	ldr	r1, [r7, #8]
 8004322:	4618      	mov	r0, r3
 8004324:	f011 f91b 	bl	801555e <memcpy>
                    ilen );

            ctx->unprocessed_len += ilen;
 8004328:	68fb      	ldr	r3, [r7, #12]
 800432a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800432c:	687b      	ldr	r3, [r7, #4]
 800432e:	441a      	add	r2, r3
 8004330:	68fb      	ldr	r3, [r7, #12]
 8004332:	625a      	str	r2, [r3, #36]	@ 0x24
            return( 0 );
 8004334:	2300      	movs	r3, #0
 8004336:	e150      	b.n	80045da <mbedtls_cipher_update+0x41a>
        }

        /*
         * Process cached data first
         */
        if( 0 != ctx->unprocessed_len )
 8004338:	68fb      	ldr	r3, [r7, #12]
 800433a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800433c:	2b00      	cmp	r3, #0
 800433e:	d044      	beq.n	80043ca <mbedtls_cipher_update+0x20a>
        {
            copy_len = block_size - ctx->unprocessed_len;
 8004340:	68fb      	ldr	r3, [r7, #12]
 8004342:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8004344:	697a      	ldr	r2, [r7, #20]
 8004346:	1ad3      	subs	r3, r2, r3
 8004348:	61fb      	str	r3, [r7, #28]

            memcpy( &( ctx->unprocessed_data[ctx->unprocessed_len] ), input,
 800434a:	68fb      	ldr	r3, [r7, #12]
 800434c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800434e:	3310      	adds	r3, #16
 8004350:	68fa      	ldr	r2, [r7, #12]
 8004352:	4413      	add	r3, r2
 8004354:	3304      	adds	r3, #4
 8004356:	69fa      	ldr	r2, [r7, #28]
 8004358:	68b9      	ldr	r1, [r7, #8]
 800435a:	4618      	mov	r0, r3
 800435c:	f011 f8ff 	bl	801555e <memcpy>
                    copy_len );

            if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,
 8004360:	68fb      	ldr	r3, [r7, #12]
 8004362:	681b      	ldr	r3, [r3, #0]
 8004364:	699b      	ldr	r3, [r3, #24]
 8004366:	689c      	ldr	r4, [r3, #8]
 8004368:	68fb      	ldr	r3, [r7, #12]
 800436a:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 800436c:	68fb      	ldr	r3, [r7, #12]
 800436e:	f993 1008 	ldrsb.w	r1, [r3, #8]
                    ctx->operation, block_size, ctx->iv,
 8004372:	68fb      	ldr	r3, [r7, #12]
 8004374:	f103 0528 	add.w	r5, r3, #40	@ 0x28
                    ctx->unprocessed_data, output ) ) )
 8004378:	68fb      	ldr	r3, [r7, #12]
 800437a:	3314      	adds	r3, #20
            if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,
 800437c:	683a      	ldr	r2, [r7, #0]
 800437e:	9201      	str	r2, [sp, #4]
 8004380:	9300      	str	r3, [sp, #0]
 8004382:	462b      	mov	r3, r5
 8004384:	697a      	ldr	r2, [r7, #20]
 8004386:	47a0      	blx	r4
 8004388:	61b8      	str	r0, [r7, #24]
 800438a:	69bb      	ldr	r3, [r7, #24]
 800438c:	2b00      	cmp	r3, #0
 800438e:	d007      	beq.n	80043a0 <mbedtls_cipher_update+0x1e0>
            {
                return( ret );
 8004390:	69bb      	ldr	r3, [r7, #24]
 8004392:	e122      	b.n	80045da <mbedtls_cipher_update+0x41a>
 8004394:	ffff9f00 	.word	0xffff9f00
 8004398:	ffff9c80 	.word	0xffff9c80
 800439c:	ffff9d80 	.word	0xffff9d80
            }

            *olen += block_size;
 80043a0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80043a2:	681a      	ldr	r2, [r3, #0]
 80043a4:	697b      	ldr	r3, [r7, #20]
 80043a6:	441a      	add	r2, r3
 80043a8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80043aa:	601a      	str	r2, [r3, #0]
            output += block_size;
 80043ac:	683a      	ldr	r2, [r7, #0]
 80043ae:	697b      	ldr	r3, [r7, #20]
 80043b0:	4413      	add	r3, r2
 80043b2:	603b      	str	r3, [r7, #0]
            ctx->unprocessed_len = 0;
 80043b4:	68fb      	ldr	r3, [r7, #12]
 80043b6:	2200      	movs	r2, #0
 80043b8:	625a      	str	r2, [r3, #36]	@ 0x24

            input += copy_len;
 80043ba:	68ba      	ldr	r2, [r7, #8]
 80043bc:	69fb      	ldr	r3, [r7, #28]
 80043be:	4413      	add	r3, r2
 80043c0:	60bb      	str	r3, [r7, #8]
            ilen -= copy_len;
 80043c2:	687a      	ldr	r2, [r7, #4]
 80043c4:	69fb      	ldr	r3, [r7, #28]
 80043c6:	1ad3      	subs	r3, r2, r3
 80043c8:	607b      	str	r3, [r7, #4]
        }

        /*
         * Cache final, incomplete block
         */
        if( 0 != ilen )
 80043ca:	687b      	ldr	r3, [r7, #4]
 80043cc:	2b00      	cmp	r3, #0
 80043ce:	d02c      	beq.n	800442a <mbedtls_cipher_update+0x26a>
        {
            /* Encryption: only cache partial blocks
             * Decryption w/ padding: always keep at least one whole block
             * Decryption w/o padding: only cache partial blocks
             */
            copy_len = ilen % block_size;
 80043d0:	687b      	ldr	r3, [r7, #4]
 80043d2:	697a      	ldr	r2, [r7, #20]
 80043d4:	fbb3 f2f2 	udiv	r2, r3, r2
 80043d8:	6979      	ldr	r1, [r7, #20]
 80043da:	fb01 f202 	mul.w	r2, r1, r2
 80043de:	1a9b      	subs	r3, r3, r2
 80043e0:	61fb      	str	r3, [r7, #28]
            if( copy_len == 0 &&
 80043e2:	69fb      	ldr	r3, [r7, #28]
 80043e4:	2b00      	cmp	r3, #0
 80043e6:	d10a      	bne.n	80043fe <mbedtls_cipher_update+0x23e>
                ctx->operation == MBEDTLS_DECRYPT &&
 80043e8:	68fb      	ldr	r3, [r7, #12]
 80043ea:	f993 3008 	ldrsb.w	r3, [r3, #8]
            if( copy_len == 0 &&
 80043ee:	2b00      	cmp	r3, #0
 80043f0:	d105      	bne.n	80043fe <mbedtls_cipher_update+0x23e>
                NULL != ctx->add_padding)
 80043f2:	68fb      	ldr	r3, [r7, #12]
 80043f4:	68db      	ldr	r3, [r3, #12]
                ctx->operation == MBEDTLS_DECRYPT &&
 80043f6:	2b00      	cmp	r3, #0
 80043f8:	d001      	beq.n	80043fe <mbedtls_cipher_update+0x23e>
            {
                copy_len = block_size;
 80043fa:	697b      	ldr	r3, [r7, #20]
 80043fc:	61fb      	str	r3, [r7, #28]
            }

            memcpy( ctx->unprocessed_data, &( input[ilen - copy_len] ),
 80043fe:	68fb      	ldr	r3, [r7, #12]
 8004400:	f103 0014 	add.w	r0, r3, #20
 8004404:	687a      	ldr	r2, [r7, #4]
 8004406:	69fb      	ldr	r3, [r7, #28]
 8004408:	1ad3      	subs	r3, r2, r3
 800440a:	68ba      	ldr	r2, [r7, #8]
 800440c:	4413      	add	r3, r2
 800440e:	69fa      	ldr	r2, [r7, #28]
 8004410:	4619      	mov	r1, r3
 8004412:	f011 f8a4 	bl	801555e <memcpy>
                    copy_len );

            ctx->unprocessed_len += copy_len;
 8004416:	68fb      	ldr	r3, [r7, #12]
 8004418:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800441a:	69fb      	ldr	r3, [r7, #28]
 800441c:	441a      	add	r2, r3
 800441e:	68fb      	ldr	r3, [r7, #12]
 8004420:	625a      	str	r2, [r3, #36]	@ 0x24
            ilen -= copy_len;
 8004422:	687a      	ldr	r2, [r7, #4]
 8004424:	69fb      	ldr	r3, [r7, #28]
 8004426:	1ad3      	subs	r3, r2, r3
 8004428:	607b      	str	r3, [r7, #4]
        }

        /*
         * Process remaining full blocks
         */
        if( ilen )
 800442a:	687b      	ldr	r3, [r7, #4]
 800442c:	2b00      	cmp	r3, #0
 800442e:	d01e      	beq.n	800446e <mbedtls_cipher_update+0x2ae>
        {
            if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,
 8004430:	68fb      	ldr	r3, [r7, #12]
 8004432:	681b      	ldr	r3, [r3, #0]
 8004434:	699b      	ldr	r3, [r3, #24]
 8004436:	689c      	ldr	r4, [r3, #8]
 8004438:	68fb      	ldr	r3, [r7, #12]
 800443a:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 800443c:	68fb      	ldr	r3, [r7, #12]
 800443e:	f993 1008 	ldrsb.w	r1, [r3, #8]
                    ctx->operation, ilen, ctx->iv, input, output ) ) )
 8004442:	68fb      	ldr	r3, [r7, #12]
 8004444:	f103 0228 	add.w	r2, r3, #40	@ 0x28
            if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,
 8004448:	683b      	ldr	r3, [r7, #0]
 800444a:	9301      	str	r3, [sp, #4]
 800444c:	68bb      	ldr	r3, [r7, #8]
 800444e:	9300      	str	r3, [sp, #0]
 8004450:	4613      	mov	r3, r2
 8004452:	687a      	ldr	r2, [r7, #4]
 8004454:	47a0      	blx	r4
 8004456:	61b8      	str	r0, [r7, #24]
 8004458:	69bb      	ldr	r3, [r7, #24]
 800445a:	2b00      	cmp	r3, #0
 800445c:	d001      	beq.n	8004462 <mbedtls_cipher_update+0x2a2>
            {
                return( ret );
 800445e:	69bb      	ldr	r3, [r7, #24]
 8004460:	e0bb      	b.n	80045da <mbedtls_cipher_update+0x41a>
            }

            *olen += ilen;
 8004462:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004464:	681a      	ldr	r2, [r3, #0]
 8004466:	687b      	ldr	r3, [r7, #4]
 8004468:	441a      	add	r2, r3
 800446a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800446c:	601a      	str	r2, [r3, #0]
        }

        return( 0 );
 800446e:	2300      	movs	r3, #0
 8004470:	e0b3      	b.n	80045da <mbedtls_cipher_update+0x41a>
    }
#endif /* MBEDTLS_CIPHER_MODE_CBC */

#if defined(MBEDTLS_CIPHER_MODE_CFB)
    if( ctx->cipher_info->mode == MBEDTLS_MODE_CFB )
 8004472:	68fb      	ldr	r3, [r7, #12]
 8004474:	681b      	ldr	r3, [r3, #0]
 8004476:	785b      	ldrb	r3, [r3, #1]
 8004478:	2b03      	cmp	r3, #3
 800447a:	d120      	bne.n	80044be <mbedtls_cipher_update+0x2fe>
    {
        if( 0 != ( ret = ctx->cipher_info->base->cfb_func( ctx->cipher_ctx,
 800447c:	68fb      	ldr	r3, [r7, #12]
 800447e:	681b      	ldr	r3, [r3, #0]
 8004480:	699b      	ldr	r3, [r3, #24]
 8004482:	68dc      	ldr	r4, [r3, #12]
 8004484:	68fb      	ldr	r3, [r7, #12]
 8004486:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 8004488:	68fb      	ldr	r3, [r7, #12]
 800448a:	f993 1008 	ldrsb.w	r1, [r3, #8]
 800448e:	68fb      	ldr	r3, [r7, #12]
 8004490:	f103 0524 	add.w	r5, r3, #36	@ 0x24
                ctx->operation, ilen, &ctx->unprocessed_len, ctx->iv,
 8004494:	68fb      	ldr	r3, [r7, #12]
 8004496:	3328      	adds	r3, #40	@ 0x28
        if( 0 != ( ret = ctx->cipher_info->base->cfb_func( ctx->cipher_ctx,
 8004498:	683a      	ldr	r2, [r7, #0]
 800449a:	9202      	str	r2, [sp, #8]
 800449c:	68ba      	ldr	r2, [r7, #8]
 800449e:	9201      	str	r2, [sp, #4]
 80044a0:	9300      	str	r3, [sp, #0]
 80044a2:	462b      	mov	r3, r5
 80044a4:	687a      	ldr	r2, [r7, #4]
 80044a6:	47a0      	blx	r4
 80044a8:	61b8      	str	r0, [r7, #24]
 80044aa:	69bb      	ldr	r3, [r7, #24]
 80044ac:	2b00      	cmp	r3, #0
 80044ae:	d001      	beq.n	80044b4 <mbedtls_cipher_update+0x2f4>
                input, output ) ) )
        {
            return( ret );
 80044b0:	69bb      	ldr	r3, [r7, #24]
 80044b2:	e092      	b.n	80045da <mbedtls_cipher_update+0x41a>
        }

        *olen = ilen;
 80044b4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80044b6:	687a      	ldr	r2, [r7, #4]
 80044b8:	601a      	str	r2, [r3, #0]

        return( 0 );
 80044ba:	2300      	movs	r3, #0
 80044bc:	e08d      	b.n	80045da <mbedtls_cipher_update+0x41a>
    }
#endif /* MBEDTLS_CIPHER_MODE_CFB */

#if defined(MBEDTLS_CIPHER_MODE_OFB)
    if( ctx->cipher_info->mode == MBEDTLS_MODE_OFB )
 80044be:	68fb      	ldr	r3, [r7, #12]
 80044c0:	681b      	ldr	r3, [r3, #0]
 80044c2:	785b      	ldrb	r3, [r3, #1]
 80044c4:	2b04      	cmp	r3, #4
 80044c6:	d11d      	bne.n	8004504 <mbedtls_cipher_update+0x344>
    {
        if( 0 != ( ret = ctx->cipher_info->base->ofb_func( ctx->cipher_ctx,
 80044c8:	68fb      	ldr	r3, [r7, #12]
 80044ca:	681b      	ldr	r3, [r3, #0]
 80044cc:	699b      	ldr	r3, [r3, #24]
 80044ce:	691c      	ldr	r4, [r3, #16]
 80044d0:	68fb      	ldr	r3, [r7, #12]
 80044d2:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 80044d4:	68fb      	ldr	r3, [r7, #12]
 80044d6:	f103 0224 	add.w	r2, r3, #36	@ 0x24
                ilen, &ctx->unprocessed_len, ctx->iv, input, output ) ) )
 80044da:	68fb      	ldr	r3, [r7, #12]
 80044dc:	f103 0128 	add.w	r1, r3, #40	@ 0x28
        if( 0 != ( ret = ctx->cipher_info->base->ofb_func( ctx->cipher_ctx,
 80044e0:	683b      	ldr	r3, [r7, #0]
 80044e2:	9301      	str	r3, [sp, #4]
 80044e4:	68bb      	ldr	r3, [r7, #8]
 80044e6:	9300      	str	r3, [sp, #0]
 80044e8:	460b      	mov	r3, r1
 80044ea:	6879      	ldr	r1, [r7, #4]
 80044ec:	47a0      	blx	r4
 80044ee:	61b8      	str	r0, [r7, #24]
 80044f0:	69bb      	ldr	r3, [r7, #24]
 80044f2:	2b00      	cmp	r3, #0
 80044f4:	d001      	beq.n	80044fa <mbedtls_cipher_update+0x33a>
        {
            return( ret );
 80044f6:	69bb      	ldr	r3, [r7, #24]
 80044f8:	e06f      	b.n	80045da <mbedtls_cipher_update+0x41a>
        }

        *olen = ilen;
 80044fa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80044fc:	687a      	ldr	r2, [r7, #4]
 80044fe:	601a      	str	r2, [r3, #0]

        return( 0 );
 8004500:	2300      	movs	r3, #0
 8004502:	e06a      	b.n	80045da <mbedtls_cipher_update+0x41a>
    }
#endif /* MBEDTLS_CIPHER_MODE_OFB */

#if defined(MBEDTLS_CIPHER_MODE_CTR)
    if( ctx->cipher_info->mode == MBEDTLS_MODE_CTR )
 8004504:	68fb      	ldr	r3, [r7, #12]
 8004506:	681b      	ldr	r3, [r3, #0]
 8004508:	785b      	ldrb	r3, [r3, #1]
 800450a:	2b05      	cmp	r3, #5
 800450c:	d121      	bne.n	8004552 <mbedtls_cipher_update+0x392>
    {
        if( 0 != ( ret = ctx->cipher_info->base->ctr_func( ctx->cipher_ctx,
 800450e:	68fb      	ldr	r3, [r7, #12]
 8004510:	681b      	ldr	r3, [r3, #0]
 8004512:	699b      	ldr	r3, [r3, #24]
 8004514:	695c      	ldr	r4, [r3, #20]
 8004516:	68fb      	ldr	r3, [r7, #12]
 8004518:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 800451a:	68fb      	ldr	r3, [r7, #12]
 800451c:	f103 0124 	add.w	r1, r3, #36	@ 0x24
                ilen, &ctx->unprocessed_len, ctx->iv,
 8004520:	68fb      	ldr	r3, [r7, #12]
 8004522:	f103 0528 	add.w	r5, r3, #40	@ 0x28
                ctx->unprocessed_data, input, output ) ) )
 8004526:	68fb      	ldr	r3, [r7, #12]
 8004528:	3314      	adds	r3, #20
        if( 0 != ( ret = ctx->cipher_info->base->ctr_func( ctx->cipher_ctx,
 800452a:	683a      	ldr	r2, [r7, #0]
 800452c:	9202      	str	r2, [sp, #8]
 800452e:	68ba      	ldr	r2, [r7, #8]
 8004530:	9201      	str	r2, [sp, #4]
 8004532:	9300      	str	r3, [sp, #0]
 8004534:	462b      	mov	r3, r5
 8004536:	460a      	mov	r2, r1
 8004538:	6879      	ldr	r1, [r7, #4]
 800453a:	47a0      	blx	r4
 800453c:	61b8      	str	r0, [r7, #24]
 800453e:	69bb      	ldr	r3, [r7, #24]
 8004540:	2b00      	cmp	r3, #0
 8004542:	d001      	beq.n	8004548 <mbedtls_cipher_update+0x388>
        {
            return( ret );
 8004544:	69bb      	ldr	r3, [r7, #24]
 8004546:	e048      	b.n	80045da <mbedtls_cipher_update+0x41a>
        }

        *olen = ilen;
 8004548:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800454a:	687a      	ldr	r2, [r7, #4]
 800454c:	601a      	str	r2, [r3, #0]

        return( 0 );
 800454e:	2300      	movs	r3, #0
 8004550:	e043      	b.n	80045da <mbedtls_cipher_update+0x41a>
    }
#endif /* MBEDTLS_CIPHER_MODE_CTR */

#if defined(MBEDTLS_CIPHER_MODE_XTS)
    if( ctx->cipher_info->mode == MBEDTLS_MODE_XTS )
 8004552:	68fb      	ldr	r3, [r7, #12]
 8004554:	681b      	ldr	r3, [r3, #0]
 8004556:	785b      	ldrb	r3, [r3, #1]
 8004558:	2b09      	cmp	r3, #9
 800455a:	d123      	bne.n	80045a4 <mbedtls_cipher_update+0x3e4>
    {
        if( ctx->unprocessed_len > 0 ) {
 800455c:	68fb      	ldr	r3, [r7, #12]
 800455e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8004560:	2b00      	cmp	r3, #0
 8004562:	d001      	beq.n	8004568 <mbedtls_cipher_update+0x3a8>
            /* We can only process an entire data unit at a time. */
            return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
 8004564:	4b1f      	ldr	r3, [pc, #124]	@ (80045e4 <mbedtls_cipher_update+0x424>)
 8004566:	e038      	b.n	80045da <mbedtls_cipher_update+0x41a>
        }

        ret = ctx->cipher_info->base->xts_func( ctx->cipher_ctx,
 8004568:	68fb      	ldr	r3, [r7, #12]
 800456a:	681b      	ldr	r3, [r3, #0]
 800456c:	699b      	ldr	r3, [r3, #24]
 800456e:	699c      	ldr	r4, [r3, #24]
 8004570:	68fb      	ldr	r3, [r7, #12]
 8004572:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 8004574:	68fb      	ldr	r3, [r7, #12]
 8004576:	f993 1008 	ldrsb.w	r1, [r3, #8]
                ctx->operation, ilen, ctx->iv, input, output );
 800457a:	68fb      	ldr	r3, [r7, #12]
 800457c:	f103 0228 	add.w	r2, r3, #40	@ 0x28
        ret = ctx->cipher_info->base->xts_func( ctx->cipher_ctx,
 8004580:	683b      	ldr	r3, [r7, #0]
 8004582:	9301      	str	r3, [sp, #4]
 8004584:	68bb      	ldr	r3, [r7, #8]
 8004586:	9300      	str	r3, [sp, #0]
 8004588:	4613      	mov	r3, r2
 800458a:	687a      	ldr	r2, [r7, #4]
 800458c:	47a0      	blx	r4
 800458e:	61b8      	str	r0, [r7, #24]
        if( ret != 0 )
 8004590:	69bb      	ldr	r3, [r7, #24]
 8004592:	2b00      	cmp	r3, #0
 8004594:	d001      	beq.n	800459a <mbedtls_cipher_update+0x3da>
        {
            return( ret );
 8004596:	69bb      	ldr	r3, [r7, #24]
 8004598:	e01f      	b.n	80045da <mbedtls_cipher_update+0x41a>
        }

        *olen = ilen;
 800459a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800459c:	687a      	ldr	r2, [r7, #4]
 800459e:	601a      	str	r2, [r3, #0]

        return( 0 );
 80045a0:	2300      	movs	r3, #0
 80045a2:	e01a      	b.n	80045da <mbedtls_cipher_update+0x41a>
    }
#endif /* MBEDTLS_CIPHER_MODE_XTS */

#if defined(MBEDTLS_CIPHER_MODE_STREAM)
    if( ctx->cipher_info->mode == MBEDTLS_MODE_STREAM )
 80045a4:	68fb      	ldr	r3, [r7, #12]
 80045a6:	681b      	ldr	r3, [r3, #0]
 80045a8:	785b      	ldrb	r3, [r3, #1]
 80045aa:	2b07      	cmp	r3, #7
 80045ac:	d114      	bne.n	80045d8 <mbedtls_cipher_update+0x418>
    {
        if( 0 != ( ret = ctx->cipher_info->base->stream_func( ctx->cipher_ctx,
 80045ae:	68fb      	ldr	r3, [r7, #12]
 80045b0:	681b      	ldr	r3, [r3, #0]
 80045b2:	699b      	ldr	r3, [r3, #24]
 80045b4:	69dc      	ldr	r4, [r3, #28]
 80045b6:	68fb      	ldr	r3, [r7, #12]
 80045b8:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 80045ba:	683b      	ldr	r3, [r7, #0]
 80045bc:	68ba      	ldr	r2, [r7, #8]
 80045be:	6879      	ldr	r1, [r7, #4]
 80045c0:	47a0      	blx	r4
 80045c2:	61b8      	str	r0, [r7, #24]
 80045c4:	69bb      	ldr	r3, [r7, #24]
 80045c6:	2b00      	cmp	r3, #0
 80045c8:	d001      	beq.n	80045ce <mbedtls_cipher_update+0x40e>
                                                    ilen, input, output ) ) )
        {
            return( ret );
 80045ca:	69bb      	ldr	r3, [r7, #24]
 80045cc:	e005      	b.n	80045da <mbedtls_cipher_update+0x41a>
        }

        *olen = ilen;
 80045ce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80045d0:	687a      	ldr	r2, [r7, #4]
 80045d2:	601a      	str	r2, [r3, #0]

        return( 0 );
 80045d4:	2300      	movs	r3, #0
 80045d6:	e000      	b.n	80045da <mbedtls_cipher_update+0x41a>
    }
#endif /* MBEDTLS_CIPHER_MODE_STREAM */

    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
 80045d8:	4b02      	ldr	r3, [pc, #8]	@ (80045e4 <mbedtls_cipher_update+0x424>)
}
 80045da:	4618      	mov	r0, r3
 80045dc:	3720      	adds	r7, #32
 80045de:	46bd      	mov	sp, r7
 80045e0:	bdb0      	pop	{r4, r5, r7, pc}
 80045e2:	bf00      	nop
 80045e4:	ffff9f80 	.word	0xffff9f80

080045e8 <add_pkcs_padding>:
/*
 * PKCS7 (and PKCS5) padding: fill with ll bytes, with ll = padding_len
 */
static void add_pkcs_padding( unsigned char *output, size_t output_len,
        size_t data_len )
{
 80045e8:	b480      	push	{r7}
 80045ea:	b087      	sub	sp, #28
 80045ec:	af00      	add	r7, sp, #0
 80045ee:	60f8      	str	r0, [r7, #12]
 80045f0:	60b9      	str	r1, [r7, #8]
 80045f2:	607a      	str	r2, [r7, #4]
    size_t padding_len = output_len - data_len;
 80045f4:	68ba      	ldr	r2, [r7, #8]
 80045f6:	687b      	ldr	r3, [r7, #4]
 80045f8:	1ad3      	subs	r3, r2, r3
 80045fa:	613b      	str	r3, [r7, #16]
    unsigned char i;

    for( i = 0; i < padding_len; i++ )
 80045fc:	2300      	movs	r3, #0
 80045fe:	75fb      	strb	r3, [r7, #23]
 8004600:	e00a      	b.n	8004618 <add_pkcs_padding+0x30>
        output[data_len + i] = (unsigned char) padding_len;
 8004602:	7dfa      	ldrb	r2, [r7, #23]
 8004604:	687b      	ldr	r3, [r7, #4]
 8004606:	4413      	add	r3, r2
 8004608:	68fa      	ldr	r2, [r7, #12]
 800460a:	4413      	add	r3, r2
 800460c:	693a      	ldr	r2, [r7, #16]
 800460e:	b2d2      	uxtb	r2, r2
 8004610:	701a      	strb	r2, [r3, #0]
    for( i = 0; i < padding_len; i++ )
 8004612:	7dfb      	ldrb	r3, [r7, #23]
 8004614:	3301      	adds	r3, #1
 8004616:	75fb      	strb	r3, [r7, #23]
 8004618:	7dfb      	ldrb	r3, [r7, #23]
 800461a:	693a      	ldr	r2, [r7, #16]
 800461c:	429a      	cmp	r2, r3
 800461e:	d8f0      	bhi.n	8004602 <add_pkcs_padding+0x1a>
}
 8004620:	bf00      	nop
 8004622:	bf00      	nop
 8004624:	371c      	adds	r7, #28
 8004626:	46bd      	mov	sp, r7
 8004628:	f85d 7b04 	ldr.w	r7, [sp], #4
 800462c:	4770      	bx	lr
	...

08004630 <get_pkcs_padding>:

static int get_pkcs_padding( unsigned char *input, size_t input_len,
        size_t *data_len )
{
 8004630:	b480      	push	{r7}
 8004632:	b089      	sub	sp, #36	@ 0x24
 8004634:	af00      	add	r7, sp, #0
 8004636:	60f8      	str	r0, [r7, #12]
 8004638:	60b9      	str	r1, [r7, #8]
 800463a:	607a      	str	r2, [r7, #4]
    size_t i, pad_idx;
    unsigned char padding_len, bad = 0;
 800463c:	2300      	movs	r3, #0
 800463e:	76fb      	strb	r3, [r7, #27]

    if( NULL == input || NULL == data_len )
 8004640:	68fb      	ldr	r3, [r7, #12]
 8004642:	2b00      	cmp	r3, #0
 8004644:	d002      	beq.n	800464c <get_pkcs_padding+0x1c>
 8004646:	687b      	ldr	r3, [r7, #4]
 8004648:	2b00      	cmp	r3, #0
 800464a:	d101      	bne.n	8004650 <get_pkcs_padding+0x20>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 800464c:	4b2b      	ldr	r3, [pc, #172]	@ (80046fc <get_pkcs_padding+0xcc>)
 800464e:	e04f      	b.n	80046f0 <get_pkcs_padding+0xc0>

    padding_len = input[input_len - 1];
 8004650:	68bb      	ldr	r3, [r7, #8]
 8004652:	3b01      	subs	r3, #1
 8004654:	68fa      	ldr	r2, [r7, #12]
 8004656:	4413      	add	r3, r2
 8004658:	781b      	ldrb	r3, [r3, #0]
 800465a:	76bb      	strb	r3, [r7, #26]
    *data_len = input_len - padding_len;
 800465c:	7ebb      	ldrb	r3, [r7, #26]
 800465e:	68ba      	ldr	r2, [r7, #8]
 8004660:	1ad2      	subs	r2, r2, r3
 8004662:	687b      	ldr	r3, [r7, #4]
 8004664:	601a      	str	r2, [r3, #0]

    /* Avoid logical || since it results in a branch */
    bad |= padding_len > input_len;
 8004666:	7ebb      	ldrb	r3, [r7, #26]
 8004668:	68ba      	ldr	r2, [r7, #8]
 800466a:	429a      	cmp	r2, r3
 800466c:	bf34      	ite	cc
 800466e:	2301      	movcc	r3, #1
 8004670:	2300      	movcs	r3, #0
 8004672:	b2db      	uxtb	r3, r3
 8004674:	b25a      	sxtb	r2, r3
 8004676:	f997 301b 	ldrsb.w	r3, [r7, #27]
 800467a:	4313      	orrs	r3, r2
 800467c:	b25b      	sxtb	r3, r3
 800467e:	76fb      	strb	r3, [r7, #27]
    bad |= padding_len == 0;
 8004680:	7ebb      	ldrb	r3, [r7, #26]
 8004682:	2b00      	cmp	r3, #0
 8004684:	bf0c      	ite	eq
 8004686:	2301      	moveq	r3, #1
 8004688:	2300      	movne	r3, #0
 800468a:	b2db      	uxtb	r3, r3
 800468c:	b25a      	sxtb	r2, r3
 800468e:	f997 301b 	ldrsb.w	r3, [r7, #27]
 8004692:	4313      	orrs	r3, r2
 8004694:	b25b      	sxtb	r3, r3
 8004696:	76fb      	strb	r3, [r7, #27]

    /* The number of bytes checked must be independent of padding_len,
     * so pick input_len, which is usually 8 or 16 (one block) */
    pad_idx = input_len - padding_len;
 8004698:	7ebb      	ldrb	r3, [r7, #26]
 800469a:	68ba      	ldr	r2, [r7, #8]
 800469c:	1ad3      	subs	r3, r2, r3
 800469e:	617b      	str	r3, [r7, #20]
    for( i = 0; i < input_len; i++ )
 80046a0:	2300      	movs	r3, #0
 80046a2:	61fb      	str	r3, [r7, #28]
 80046a4:	e01a      	b.n	80046dc <get_pkcs_padding+0xac>
        bad |= ( input[i] ^ padding_len ) * ( i >= pad_idx );
 80046a6:	68fa      	ldr	r2, [r7, #12]
 80046a8:	69fb      	ldr	r3, [r7, #28]
 80046aa:	4413      	add	r3, r2
 80046ac:	781a      	ldrb	r2, [r3, #0]
 80046ae:	7ebb      	ldrb	r3, [r7, #26]
 80046b0:	4053      	eors	r3, r2
 80046b2:	b2da      	uxtb	r2, r3
 80046b4:	69f9      	ldr	r1, [r7, #28]
 80046b6:	697b      	ldr	r3, [r7, #20]
 80046b8:	4299      	cmp	r1, r3
 80046ba:	bf2c      	ite	cs
 80046bc:	2301      	movcs	r3, #1
 80046be:	2300      	movcc	r3, #0
 80046c0:	b2db      	uxtb	r3, r3
 80046c2:	b2db      	uxtb	r3, r3
 80046c4:	fb12 f303 	smulbb	r3, r2, r3
 80046c8:	b2db      	uxtb	r3, r3
 80046ca:	b25a      	sxtb	r2, r3
 80046cc:	f997 301b 	ldrsb.w	r3, [r7, #27]
 80046d0:	4313      	orrs	r3, r2
 80046d2:	b25b      	sxtb	r3, r3
 80046d4:	76fb      	strb	r3, [r7, #27]
    for( i = 0; i < input_len; i++ )
 80046d6:	69fb      	ldr	r3, [r7, #28]
 80046d8:	3301      	adds	r3, #1
 80046da:	61fb      	str	r3, [r7, #28]
 80046dc:	69fa      	ldr	r2, [r7, #28]
 80046de:	68bb      	ldr	r3, [r7, #8]
 80046e0:	429a      	cmp	r2, r3
 80046e2:	d3e0      	bcc.n	80046a6 <get_pkcs_padding+0x76>

    return( MBEDTLS_ERR_CIPHER_INVALID_PADDING * ( bad != 0 ) );
 80046e4:	7efb      	ldrb	r3, [r7, #27]
 80046e6:	2b00      	cmp	r3, #0
 80046e8:	d001      	beq.n	80046ee <get_pkcs_padding+0xbe>
 80046ea:	4b05      	ldr	r3, [pc, #20]	@ (8004700 <get_pkcs_padding+0xd0>)
 80046ec:	e000      	b.n	80046f0 <get_pkcs_padding+0xc0>
 80046ee:	2300      	movs	r3, #0
}
 80046f0:	4618      	mov	r0, r3
 80046f2:	3724      	adds	r7, #36	@ 0x24
 80046f4:	46bd      	mov	sp, r7
 80046f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80046fa:	4770      	bx	lr
 80046fc:	ffff9f00 	.word	0xffff9f00
 8004700:	ffff9e00 	.word	0xffff9e00

08004704 <add_one_and_zeros_padding>:
/*
 * One and zeros padding: fill with 80 00 ... 00
 */
static void add_one_and_zeros_padding( unsigned char *output,
                                       size_t output_len, size_t data_len )
{
 8004704:	b480      	push	{r7}
 8004706:	b087      	sub	sp, #28
 8004708:	af00      	add	r7, sp, #0
 800470a:	60f8      	str	r0, [r7, #12]
 800470c:	60b9      	str	r1, [r7, #8]
 800470e:	607a      	str	r2, [r7, #4]
    size_t padding_len = output_len - data_len;
 8004710:	68ba      	ldr	r2, [r7, #8]
 8004712:	687b      	ldr	r3, [r7, #4]
 8004714:	1ad3      	subs	r3, r2, r3
 8004716:	613b      	str	r3, [r7, #16]
    unsigned char i = 0;
 8004718:	2300      	movs	r3, #0
 800471a:	75fb      	strb	r3, [r7, #23]

    output[data_len] = 0x80;
 800471c:	68fa      	ldr	r2, [r7, #12]
 800471e:	687b      	ldr	r3, [r7, #4]
 8004720:	4413      	add	r3, r2
 8004722:	2280      	movs	r2, #128	@ 0x80
 8004724:	701a      	strb	r2, [r3, #0]
    for( i = 1; i < padding_len; i++ )
 8004726:	2301      	movs	r3, #1
 8004728:	75fb      	strb	r3, [r7, #23]
 800472a:	e009      	b.n	8004740 <add_one_and_zeros_padding+0x3c>
        output[data_len + i] = 0x00;
 800472c:	7dfa      	ldrb	r2, [r7, #23]
 800472e:	687b      	ldr	r3, [r7, #4]
 8004730:	4413      	add	r3, r2
 8004732:	68fa      	ldr	r2, [r7, #12]
 8004734:	4413      	add	r3, r2
 8004736:	2200      	movs	r2, #0
 8004738:	701a      	strb	r2, [r3, #0]
    for( i = 1; i < padding_len; i++ )
 800473a:	7dfb      	ldrb	r3, [r7, #23]
 800473c:	3301      	adds	r3, #1
 800473e:	75fb      	strb	r3, [r7, #23]
 8004740:	7dfb      	ldrb	r3, [r7, #23]
 8004742:	693a      	ldr	r2, [r7, #16]
 8004744:	429a      	cmp	r2, r3
 8004746:	d8f1      	bhi.n	800472c <add_one_and_zeros_padding+0x28>
}
 8004748:	bf00      	nop
 800474a:	bf00      	nop
 800474c:	371c      	adds	r7, #28
 800474e:	46bd      	mov	sp, r7
 8004750:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004754:	4770      	bx	lr
	...

08004758 <get_one_and_zeros_padding>:

static int get_one_and_zeros_padding( unsigned char *input, size_t input_len,
                                      size_t *data_len )
{
 8004758:	b480      	push	{r7}
 800475a:	b087      	sub	sp, #28
 800475c:	af00      	add	r7, sp, #0
 800475e:	60f8      	str	r0, [r7, #12]
 8004760:	60b9      	str	r1, [r7, #8]
 8004762:	607a      	str	r2, [r7, #4]
    size_t i;
    unsigned char done = 0, prev_done, bad;
 8004764:	2300      	movs	r3, #0
 8004766:	74fb      	strb	r3, [r7, #19]

    if( NULL == input || NULL == data_len )
 8004768:	68fb      	ldr	r3, [r7, #12]
 800476a:	2b00      	cmp	r3, #0
 800476c:	d002      	beq.n	8004774 <get_one_and_zeros_padding+0x1c>
 800476e:	687b      	ldr	r3, [r7, #4]
 8004770:	2b00      	cmp	r3, #0
 8004772:	d101      	bne.n	8004778 <get_one_and_zeros_padding+0x20>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 8004774:	4b29      	ldr	r3, [pc, #164]	@ (800481c <get_one_and_zeros_padding+0xc4>)
 8004776:	e04b      	b.n	8004810 <get_one_and_zeros_padding+0xb8>

    bad = 0x80;
 8004778:	2380      	movs	r3, #128	@ 0x80
 800477a:	74bb      	strb	r3, [r7, #18]
    *data_len = 0;
 800477c:	687b      	ldr	r3, [r7, #4]
 800477e:	2200      	movs	r2, #0
 8004780:	601a      	str	r2, [r3, #0]
    for( i = input_len; i > 0; i-- )
 8004782:	68bb      	ldr	r3, [r7, #8]
 8004784:	617b      	str	r3, [r7, #20]
 8004786:	e03a      	b.n	80047fe <get_one_and_zeros_padding+0xa6>
    {
        prev_done = done;
 8004788:	7cfb      	ldrb	r3, [r7, #19]
 800478a:	747b      	strb	r3, [r7, #17]
        done |= ( input[i - 1] != 0 );
 800478c:	697b      	ldr	r3, [r7, #20]
 800478e:	3b01      	subs	r3, #1
 8004790:	68fa      	ldr	r2, [r7, #12]
 8004792:	4413      	add	r3, r2
 8004794:	781b      	ldrb	r3, [r3, #0]
 8004796:	2b00      	cmp	r3, #0
 8004798:	bf14      	ite	ne
 800479a:	2301      	movne	r3, #1
 800479c:	2300      	moveq	r3, #0
 800479e:	b2db      	uxtb	r3, r3
 80047a0:	b25a      	sxtb	r2, r3
 80047a2:	f997 3013 	ldrsb.w	r3, [r7, #19]
 80047a6:	4313      	orrs	r3, r2
 80047a8:	b25b      	sxtb	r3, r3
 80047aa:	74fb      	strb	r3, [r7, #19]
        *data_len |= ( i - 1 ) * ( done != prev_done );
 80047ac:	687b      	ldr	r3, [r7, #4]
 80047ae:	681a      	ldr	r2, [r3, #0]
 80047b0:	697b      	ldr	r3, [r7, #20]
 80047b2:	3b01      	subs	r3, #1
 80047b4:	7cf8      	ldrb	r0, [r7, #19]
 80047b6:	7c79      	ldrb	r1, [r7, #17]
 80047b8:	4288      	cmp	r0, r1
 80047ba:	bf14      	ite	ne
 80047bc:	2101      	movne	r1, #1
 80047be:	2100      	moveq	r1, #0
 80047c0:	b2c9      	uxtb	r1, r1
 80047c2:	fb01 f303 	mul.w	r3, r1, r3
 80047c6:	431a      	orrs	r2, r3
 80047c8:	687b      	ldr	r3, [r7, #4]
 80047ca:	601a      	str	r2, [r3, #0]
        bad ^= input[i - 1] * ( done != prev_done );
 80047cc:	697b      	ldr	r3, [r7, #20]
 80047ce:	3b01      	subs	r3, #1
 80047d0:	68fa      	ldr	r2, [r7, #12]
 80047d2:	4413      	add	r3, r2
 80047d4:	781a      	ldrb	r2, [r3, #0]
 80047d6:	7cf9      	ldrb	r1, [r7, #19]
 80047d8:	7c7b      	ldrb	r3, [r7, #17]
 80047da:	4299      	cmp	r1, r3
 80047dc:	bf14      	ite	ne
 80047de:	2301      	movne	r3, #1
 80047e0:	2300      	moveq	r3, #0
 80047e2:	b2db      	uxtb	r3, r3
 80047e4:	b2db      	uxtb	r3, r3
 80047e6:	fb12 f303 	smulbb	r3, r2, r3
 80047ea:	b2db      	uxtb	r3, r3
 80047ec:	b25a      	sxtb	r2, r3
 80047ee:	f997 3012 	ldrsb.w	r3, [r7, #18]
 80047f2:	4053      	eors	r3, r2
 80047f4:	b25b      	sxtb	r3, r3
 80047f6:	74bb      	strb	r3, [r7, #18]
    for( i = input_len; i > 0; i-- )
 80047f8:	697b      	ldr	r3, [r7, #20]
 80047fa:	3b01      	subs	r3, #1
 80047fc:	617b      	str	r3, [r7, #20]
 80047fe:	697b      	ldr	r3, [r7, #20]
 8004800:	2b00      	cmp	r3, #0
 8004802:	d1c1      	bne.n	8004788 <get_one_and_zeros_padding+0x30>
    }

    return( MBEDTLS_ERR_CIPHER_INVALID_PADDING * ( bad != 0 ) );
 8004804:	7cbb      	ldrb	r3, [r7, #18]
 8004806:	2b00      	cmp	r3, #0
 8004808:	d001      	beq.n	800480e <get_one_and_zeros_padding+0xb6>
 800480a:	4b05      	ldr	r3, [pc, #20]	@ (8004820 <get_one_and_zeros_padding+0xc8>)
 800480c:	e000      	b.n	8004810 <get_one_and_zeros_padding+0xb8>
 800480e:	2300      	movs	r3, #0

}
 8004810:	4618      	mov	r0, r3
 8004812:	371c      	adds	r7, #28
 8004814:	46bd      	mov	sp, r7
 8004816:	f85d 7b04 	ldr.w	r7, [sp], #4
 800481a:	4770      	bx	lr
 800481c:	ffff9f00 	.word	0xffff9f00
 8004820:	ffff9e00 	.word	0xffff9e00

08004824 <add_zeros_and_len_padding>:
/*
 * Zeros and len padding: fill with 00 ... 00 ll, where ll is padding length
 */
static void add_zeros_and_len_padding( unsigned char *output,
                                       size_t output_len, size_t data_len )
{
 8004824:	b480      	push	{r7}
 8004826:	b087      	sub	sp, #28
 8004828:	af00      	add	r7, sp, #0
 800482a:	60f8      	str	r0, [r7, #12]
 800482c:	60b9      	str	r1, [r7, #8]
 800482e:	607a      	str	r2, [r7, #4]
    size_t padding_len = output_len - data_len;
 8004830:	68ba      	ldr	r2, [r7, #8]
 8004832:	687b      	ldr	r3, [r7, #4]
 8004834:	1ad3      	subs	r3, r2, r3
 8004836:	613b      	str	r3, [r7, #16]
    unsigned char i = 0;
 8004838:	2300      	movs	r3, #0
 800483a:	75fb      	strb	r3, [r7, #23]

    for( i = 1; i < padding_len; i++ )
 800483c:	2301      	movs	r3, #1
 800483e:	75fb      	strb	r3, [r7, #23]
 8004840:	e00a      	b.n	8004858 <add_zeros_and_len_padding+0x34>
        output[data_len + i - 1] = 0x00;
 8004842:	7dfa      	ldrb	r2, [r7, #23]
 8004844:	687b      	ldr	r3, [r7, #4]
 8004846:	4413      	add	r3, r2
 8004848:	3b01      	subs	r3, #1
 800484a:	68fa      	ldr	r2, [r7, #12]
 800484c:	4413      	add	r3, r2
 800484e:	2200      	movs	r2, #0
 8004850:	701a      	strb	r2, [r3, #0]
    for( i = 1; i < padding_len; i++ )
 8004852:	7dfb      	ldrb	r3, [r7, #23]
 8004854:	3301      	adds	r3, #1
 8004856:	75fb      	strb	r3, [r7, #23]
 8004858:	7dfb      	ldrb	r3, [r7, #23]
 800485a:	693a      	ldr	r2, [r7, #16]
 800485c:	429a      	cmp	r2, r3
 800485e:	d8f0      	bhi.n	8004842 <add_zeros_and_len_padding+0x1e>
    output[output_len - 1] = (unsigned char) padding_len;
 8004860:	68bb      	ldr	r3, [r7, #8]
 8004862:	3b01      	subs	r3, #1
 8004864:	68fa      	ldr	r2, [r7, #12]
 8004866:	4413      	add	r3, r2
 8004868:	693a      	ldr	r2, [r7, #16]
 800486a:	b2d2      	uxtb	r2, r2
 800486c:	701a      	strb	r2, [r3, #0]
}
 800486e:	bf00      	nop
 8004870:	371c      	adds	r7, #28
 8004872:	46bd      	mov	sp, r7
 8004874:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004878:	4770      	bx	lr
	...

0800487c <get_zeros_and_len_padding>:

static int get_zeros_and_len_padding( unsigned char *input, size_t input_len,
                                      size_t *data_len )
{
 800487c:	b480      	push	{r7}
 800487e:	b089      	sub	sp, #36	@ 0x24
 8004880:	af00      	add	r7, sp, #0
 8004882:	60f8      	str	r0, [r7, #12]
 8004884:	60b9      	str	r1, [r7, #8]
 8004886:	607a      	str	r2, [r7, #4]
    size_t i, pad_idx;
    unsigned char padding_len, bad = 0;
 8004888:	2300      	movs	r3, #0
 800488a:	76fb      	strb	r3, [r7, #27]

    if( NULL == input || NULL == data_len )
 800488c:	68fb      	ldr	r3, [r7, #12]
 800488e:	2b00      	cmp	r3, #0
 8004890:	d002      	beq.n	8004898 <get_zeros_and_len_padding+0x1c>
 8004892:	687b      	ldr	r3, [r7, #4]
 8004894:	2b00      	cmp	r3, #0
 8004896:	d101      	bne.n	800489c <get_zeros_and_len_padding+0x20>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 8004898:	4b2a      	ldr	r3, [pc, #168]	@ (8004944 <get_zeros_and_len_padding+0xc8>)
 800489a:	e04d      	b.n	8004938 <get_zeros_and_len_padding+0xbc>

    padding_len = input[input_len - 1];
 800489c:	68bb      	ldr	r3, [r7, #8]
 800489e:	3b01      	subs	r3, #1
 80048a0:	68fa      	ldr	r2, [r7, #12]
 80048a2:	4413      	add	r3, r2
 80048a4:	781b      	ldrb	r3, [r3, #0]
 80048a6:	76bb      	strb	r3, [r7, #26]
    *data_len = input_len - padding_len;
 80048a8:	7ebb      	ldrb	r3, [r7, #26]
 80048aa:	68ba      	ldr	r2, [r7, #8]
 80048ac:	1ad2      	subs	r2, r2, r3
 80048ae:	687b      	ldr	r3, [r7, #4]
 80048b0:	601a      	str	r2, [r3, #0]

    /* Avoid logical || since it results in a branch */
    bad |= padding_len > input_len;
 80048b2:	7ebb      	ldrb	r3, [r7, #26]
 80048b4:	68ba      	ldr	r2, [r7, #8]
 80048b6:	429a      	cmp	r2, r3
 80048b8:	bf34      	ite	cc
 80048ba:	2301      	movcc	r3, #1
 80048bc:	2300      	movcs	r3, #0
 80048be:	b2db      	uxtb	r3, r3
 80048c0:	b25a      	sxtb	r2, r3
 80048c2:	f997 301b 	ldrsb.w	r3, [r7, #27]
 80048c6:	4313      	orrs	r3, r2
 80048c8:	b25b      	sxtb	r3, r3
 80048ca:	76fb      	strb	r3, [r7, #27]
    bad |= padding_len == 0;
 80048cc:	7ebb      	ldrb	r3, [r7, #26]
 80048ce:	2b00      	cmp	r3, #0
 80048d0:	bf0c      	ite	eq
 80048d2:	2301      	moveq	r3, #1
 80048d4:	2300      	movne	r3, #0
 80048d6:	b2db      	uxtb	r3, r3
 80048d8:	b25a      	sxtb	r2, r3
 80048da:	f997 301b 	ldrsb.w	r3, [r7, #27]
 80048de:	4313      	orrs	r3, r2
 80048e0:	b25b      	sxtb	r3, r3
 80048e2:	76fb      	strb	r3, [r7, #27]

    /* The number of bytes checked must be independent of padding_len */
    pad_idx = input_len - padding_len;
 80048e4:	7ebb      	ldrb	r3, [r7, #26]
 80048e6:	68ba      	ldr	r2, [r7, #8]
 80048e8:	1ad3      	subs	r3, r2, r3
 80048ea:	617b      	str	r3, [r7, #20]
    for( i = 0; i < input_len - 1; i++ )
 80048ec:	2300      	movs	r3, #0
 80048ee:	61fb      	str	r3, [r7, #28]
 80048f0:	e017      	b.n	8004922 <get_zeros_and_len_padding+0xa6>
        bad |= input[i] * ( i >= pad_idx );
 80048f2:	68fa      	ldr	r2, [r7, #12]
 80048f4:	69fb      	ldr	r3, [r7, #28]
 80048f6:	4413      	add	r3, r2
 80048f8:	781a      	ldrb	r2, [r3, #0]
 80048fa:	69f9      	ldr	r1, [r7, #28]
 80048fc:	697b      	ldr	r3, [r7, #20]
 80048fe:	4299      	cmp	r1, r3
 8004900:	bf2c      	ite	cs
 8004902:	2301      	movcs	r3, #1
 8004904:	2300      	movcc	r3, #0
 8004906:	b2db      	uxtb	r3, r3
 8004908:	b2db      	uxtb	r3, r3
 800490a:	fb12 f303 	smulbb	r3, r2, r3
 800490e:	b2db      	uxtb	r3, r3
 8004910:	b25a      	sxtb	r2, r3
 8004912:	f997 301b 	ldrsb.w	r3, [r7, #27]
 8004916:	4313      	orrs	r3, r2
 8004918:	b25b      	sxtb	r3, r3
 800491a:	76fb      	strb	r3, [r7, #27]
    for( i = 0; i < input_len - 1; i++ )
 800491c:	69fb      	ldr	r3, [r7, #28]
 800491e:	3301      	adds	r3, #1
 8004920:	61fb      	str	r3, [r7, #28]
 8004922:	68bb      	ldr	r3, [r7, #8]
 8004924:	3b01      	subs	r3, #1
 8004926:	69fa      	ldr	r2, [r7, #28]
 8004928:	429a      	cmp	r2, r3
 800492a:	d3e2      	bcc.n	80048f2 <get_zeros_and_len_padding+0x76>

    return( MBEDTLS_ERR_CIPHER_INVALID_PADDING * ( bad != 0 ) );
 800492c:	7efb      	ldrb	r3, [r7, #27]
 800492e:	2b00      	cmp	r3, #0
 8004930:	d001      	beq.n	8004936 <get_zeros_and_len_padding+0xba>
 8004932:	4b05      	ldr	r3, [pc, #20]	@ (8004948 <get_zeros_and_len_padding+0xcc>)
 8004934:	e000      	b.n	8004938 <get_zeros_and_len_padding+0xbc>
 8004936:	2300      	movs	r3, #0
}
 8004938:	4618      	mov	r0, r3
 800493a:	3724      	adds	r7, #36	@ 0x24
 800493c:	46bd      	mov	sp, r7
 800493e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004942:	4770      	bx	lr
 8004944:	ffff9f00 	.word	0xffff9f00
 8004948:	ffff9e00 	.word	0xffff9e00

0800494c <add_zeros_padding>:
/*
 * Zero padding: fill with 00 ... 00
 */
static void add_zeros_padding( unsigned char *output,
                               size_t output_len, size_t data_len )
{
 800494c:	b480      	push	{r7}
 800494e:	b087      	sub	sp, #28
 8004950:	af00      	add	r7, sp, #0
 8004952:	60f8      	str	r0, [r7, #12]
 8004954:	60b9      	str	r1, [r7, #8]
 8004956:	607a      	str	r2, [r7, #4]
    size_t i;

    for( i = data_len; i < output_len; i++ )
 8004958:	687b      	ldr	r3, [r7, #4]
 800495a:	617b      	str	r3, [r7, #20]
 800495c:	e007      	b.n	800496e <add_zeros_padding+0x22>
        output[i] = 0x00;
 800495e:	68fa      	ldr	r2, [r7, #12]
 8004960:	697b      	ldr	r3, [r7, #20]
 8004962:	4413      	add	r3, r2
 8004964:	2200      	movs	r2, #0
 8004966:	701a      	strb	r2, [r3, #0]
    for( i = data_len; i < output_len; i++ )
 8004968:	697b      	ldr	r3, [r7, #20]
 800496a:	3301      	adds	r3, #1
 800496c:	617b      	str	r3, [r7, #20]
 800496e:	697a      	ldr	r2, [r7, #20]
 8004970:	68bb      	ldr	r3, [r7, #8]
 8004972:	429a      	cmp	r2, r3
 8004974:	d3f3      	bcc.n	800495e <add_zeros_padding+0x12>
}
 8004976:	bf00      	nop
 8004978:	bf00      	nop
 800497a:	371c      	adds	r7, #28
 800497c:	46bd      	mov	sp, r7
 800497e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004982:	4770      	bx	lr

08004984 <get_zeros_padding>:

static int get_zeros_padding( unsigned char *input, size_t input_len,
                              size_t *data_len )
{
 8004984:	b480      	push	{r7}
 8004986:	b087      	sub	sp, #28
 8004988:	af00      	add	r7, sp, #0
 800498a:	60f8      	str	r0, [r7, #12]
 800498c:	60b9      	str	r1, [r7, #8]
 800498e:	607a      	str	r2, [r7, #4]
    size_t i;
    unsigned char done = 0, prev_done;
 8004990:	2300      	movs	r3, #0
 8004992:	74fb      	strb	r3, [r7, #19]

    if( NULL == input || NULL == data_len )
 8004994:	68fb      	ldr	r3, [r7, #12]
 8004996:	2b00      	cmp	r3, #0
 8004998:	d002      	beq.n	80049a0 <get_zeros_padding+0x1c>
 800499a:	687b      	ldr	r3, [r7, #4]
 800499c:	2b00      	cmp	r3, #0
 800499e:	d101      	bne.n	80049a4 <get_zeros_padding+0x20>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 80049a0:	4b1b      	ldr	r3, [pc, #108]	@ (8004a10 <get_zeros_padding+0x8c>)
 80049a2:	e02e      	b.n	8004a02 <get_zeros_padding+0x7e>

    *data_len = 0;
 80049a4:	687b      	ldr	r3, [r7, #4]
 80049a6:	2200      	movs	r2, #0
 80049a8:	601a      	str	r2, [r3, #0]
    for( i = input_len; i > 0; i-- )
 80049aa:	68bb      	ldr	r3, [r7, #8]
 80049ac:	617b      	str	r3, [r7, #20]
 80049ae:	e024      	b.n	80049fa <get_zeros_padding+0x76>
    {
        prev_done = done;
 80049b0:	7cfb      	ldrb	r3, [r7, #19]
 80049b2:	74bb      	strb	r3, [r7, #18]
        done |= ( input[i-1] != 0 );
 80049b4:	697b      	ldr	r3, [r7, #20]
 80049b6:	3b01      	subs	r3, #1
 80049b8:	68fa      	ldr	r2, [r7, #12]
 80049ba:	4413      	add	r3, r2
 80049bc:	781b      	ldrb	r3, [r3, #0]
 80049be:	2b00      	cmp	r3, #0
 80049c0:	bf14      	ite	ne
 80049c2:	2301      	movne	r3, #1
 80049c4:	2300      	moveq	r3, #0
 80049c6:	b2db      	uxtb	r3, r3
 80049c8:	b25a      	sxtb	r2, r3
 80049ca:	f997 3013 	ldrsb.w	r3, [r7, #19]
 80049ce:	4313      	orrs	r3, r2
 80049d0:	b25b      	sxtb	r3, r3
 80049d2:	74fb      	strb	r3, [r7, #19]
        *data_len |= i * ( done != prev_done );
 80049d4:	687b      	ldr	r3, [r7, #4]
 80049d6:	681a      	ldr	r2, [r3, #0]
 80049d8:	7cf9      	ldrb	r1, [r7, #19]
 80049da:	7cbb      	ldrb	r3, [r7, #18]
 80049dc:	4299      	cmp	r1, r3
 80049de:	bf14      	ite	ne
 80049e0:	2301      	movne	r3, #1
 80049e2:	2300      	moveq	r3, #0
 80049e4:	b2db      	uxtb	r3, r3
 80049e6:	4619      	mov	r1, r3
 80049e8:	697b      	ldr	r3, [r7, #20]
 80049ea:	fb01 f303 	mul.w	r3, r1, r3
 80049ee:	431a      	orrs	r2, r3
 80049f0:	687b      	ldr	r3, [r7, #4]
 80049f2:	601a      	str	r2, [r3, #0]
    for( i = input_len; i > 0; i-- )
 80049f4:	697b      	ldr	r3, [r7, #20]
 80049f6:	3b01      	subs	r3, #1
 80049f8:	617b      	str	r3, [r7, #20]
 80049fa:	697b      	ldr	r3, [r7, #20]
 80049fc:	2b00      	cmp	r3, #0
 80049fe:	d1d7      	bne.n	80049b0 <get_zeros_padding+0x2c>
    }

    return( 0 );
 8004a00:	2300      	movs	r3, #0
}
 8004a02:	4618      	mov	r0, r3
 8004a04:	371c      	adds	r7, #28
 8004a06:	46bd      	mov	sp, r7
 8004a08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004a0c:	4770      	bx	lr
 8004a0e:	bf00      	nop
 8004a10:	ffff9f00 	.word	0xffff9f00

08004a14 <get_no_padding>:
 * There is no add_padding function (check for NULL in mbedtls_cipher_finish)
 * but a trivial get_padding function
 */
static int get_no_padding( unsigned char *input, size_t input_len,
                              size_t *data_len )
{
 8004a14:	b480      	push	{r7}
 8004a16:	b085      	sub	sp, #20
 8004a18:	af00      	add	r7, sp, #0
 8004a1a:	60f8      	str	r0, [r7, #12]
 8004a1c:	60b9      	str	r1, [r7, #8]
 8004a1e:	607a      	str	r2, [r7, #4]
    if( NULL == input || NULL == data_len )
 8004a20:	68fb      	ldr	r3, [r7, #12]
 8004a22:	2b00      	cmp	r3, #0
 8004a24:	d002      	beq.n	8004a2c <get_no_padding+0x18>
 8004a26:	687b      	ldr	r3, [r7, #4]
 8004a28:	2b00      	cmp	r3, #0
 8004a2a:	d101      	bne.n	8004a30 <get_no_padding+0x1c>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 8004a2c:	4b05      	ldr	r3, [pc, #20]	@ (8004a44 <get_no_padding+0x30>)
 8004a2e:	e003      	b.n	8004a38 <get_no_padding+0x24>

    *data_len = input_len;
 8004a30:	687b      	ldr	r3, [r7, #4]
 8004a32:	68ba      	ldr	r2, [r7, #8]
 8004a34:	601a      	str	r2, [r3, #0]

    return( 0 );
 8004a36:	2300      	movs	r3, #0
}
 8004a38:	4618      	mov	r0, r3
 8004a3a:	3714      	adds	r7, #20
 8004a3c:	46bd      	mov	sp, r7
 8004a3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004a42:	4770      	bx	lr
 8004a44:	ffff9f00 	.word	0xffff9f00

08004a48 <mbedtls_cipher_set_padding_mode>:
}

#if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)
int mbedtls_cipher_set_padding_mode( mbedtls_cipher_context_t *ctx,
                                     mbedtls_cipher_padding_t mode )
{
 8004a48:	b480      	push	{r7}
 8004a4a:	b083      	sub	sp, #12
 8004a4c:	af00      	add	r7, sp, #0
 8004a4e:	6078      	str	r0, [r7, #4]
 8004a50:	460b      	mov	r3, r1
 8004a52:	70fb      	strb	r3, [r7, #3]
    CIPHER_VALIDATE_RET( ctx != NULL );

    if( NULL == ctx->cipher_info || MBEDTLS_MODE_CBC != ctx->cipher_info->mode )
 8004a54:	687b      	ldr	r3, [r7, #4]
 8004a56:	681b      	ldr	r3, [r3, #0]
 8004a58:	2b00      	cmp	r3, #0
 8004a5a:	d004      	beq.n	8004a66 <mbedtls_cipher_set_padding_mode+0x1e>
 8004a5c:	687b      	ldr	r3, [r7, #4]
 8004a5e:	681b      	ldr	r3, [r3, #0]
 8004a60:	785b      	ldrb	r3, [r3, #1]
 8004a62:	2b02      	cmp	r3, #2
 8004a64:	d001      	beq.n	8004a6a <mbedtls_cipher_set_padding_mode+0x22>
    {
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 8004a66:	4b1f      	ldr	r3, [pc, #124]	@ (8004ae4 <mbedtls_cipher_set_padding_mode+0x9c>)
 8004a68:	e036      	b.n	8004ad8 <mbedtls_cipher_set_padding_mode+0x90>

        return( 0 );
    }
#endif /* MBEDTLS_USE_PSA_CRYPTO */

    switch( mode )
 8004a6a:	78fb      	ldrb	r3, [r7, #3]
 8004a6c:	2b04      	cmp	r3, #4
 8004a6e:	d830      	bhi.n	8004ad2 <mbedtls_cipher_set_padding_mode+0x8a>
 8004a70:	a201      	add	r2, pc, #4	@ (adr r2, 8004a78 <mbedtls_cipher_set_padding_mode+0x30>)
 8004a72:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004a76:	bf00      	nop
 8004a78:	08004a8d 	.word	0x08004a8d
 8004a7c:	08004a9b 	.word	0x08004a9b
 8004a80:	08004aa9 	.word	0x08004aa9
 8004a84:	08004ab7 	.word	0x08004ab7
 8004a88:	08004ac5 	.word	0x08004ac5
    {
#if defined(MBEDTLS_CIPHER_PADDING_PKCS7)
    case MBEDTLS_PADDING_PKCS7:
        ctx->add_padding = add_pkcs_padding;
 8004a8c:	687b      	ldr	r3, [r7, #4]
 8004a8e:	4a16      	ldr	r2, [pc, #88]	@ (8004ae8 <mbedtls_cipher_set_padding_mode+0xa0>)
 8004a90:	60da      	str	r2, [r3, #12]
        ctx->get_padding = get_pkcs_padding;
 8004a92:	687b      	ldr	r3, [r7, #4]
 8004a94:	4a15      	ldr	r2, [pc, #84]	@ (8004aec <mbedtls_cipher_set_padding_mode+0xa4>)
 8004a96:	611a      	str	r2, [r3, #16]
        break;
 8004a98:	e01d      	b.n	8004ad6 <mbedtls_cipher_set_padding_mode+0x8e>
#endif
#if defined(MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS)
    case MBEDTLS_PADDING_ONE_AND_ZEROS:
        ctx->add_padding = add_one_and_zeros_padding;
 8004a9a:	687b      	ldr	r3, [r7, #4]
 8004a9c:	4a14      	ldr	r2, [pc, #80]	@ (8004af0 <mbedtls_cipher_set_padding_mode+0xa8>)
 8004a9e:	60da      	str	r2, [r3, #12]
        ctx->get_padding = get_one_and_zeros_padding;
 8004aa0:	687b      	ldr	r3, [r7, #4]
 8004aa2:	4a14      	ldr	r2, [pc, #80]	@ (8004af4 <mbedtls_cipher_set_padding_mode+0xac>)
 8004aa4:	611a      	str	r2, [r3, #16]
        break;
 8004aa6:	e016      	b.n	8004ad6 <mbedtls_cipher_set_padding_mode+0x8e>
#endif
#if defined(MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN)
    case MBEDTLS_PADDING_ZEROS_AND_LEN:
        ctx->add_padding = add_zeros_and_len_padding;
 8004aa8:	687b      	ldr	r3, [r7, #4]
 8004aaa:	4a13      	ldr	r2, [pc, #76]	@ (8004af8 <mbedtls_cipher_set_padding_mode+0xb0>)
 8004aac:	60da      	str	r2, [r3, #12]
        ctx->get_padding = get_zeros_and_len_padding;
 8004aae:	687b      	ldr	r3, [r7, #4]
 8004ab0:	4a12      	ldr	r2, [pc, #72]	@ (8004afc <mbedtls_cipher_set_padding_mode+0xb4>)
 8004ab2:	611a      	str	r2, [r3, #16]
        break;
 8004ab4:	e00f      	b.n	8004ad6 <mbedtls_cipher_set_padding_mode+0x8e>
#endif
#if defined(MBEDTLS_CIPHER_PADDING_ZEROS)
    case MBEDTLS_PADDING_ZEROS:
        ctx->add_padding = add_zeros_padding;
 8004ab6:	687b      	ldr	r3, [r7, #4]
 8004ab8:	4a11      	ldr	r2, [pc, #68]	@ (8004b00 <mbedtls_cipher_set_padding_mode+0xb8>)
 8004aba:	60da      	str	r2, [r3, #12]
        ctx->get_padding = get_zeros_padding;
 8004abc:	687b      	ldr	r3, [r7, #4]
 8004abe:	4a11      	ldr	r2, [pc, #68]	@ (8004b04 <mbedtls_cipher_set_padding_mode+0xbc>)
 8004ac0:	611a      	str	r2, [r3, #16]
        break;
 8004ac2:	e008      	b.n	8004ad6 <mbedtls_cipher_set_padding_mode+0x8e>
#endif
    case MBEDTLS_PADDING_NONE:
        ctx->add_padding = NULL;
 8004ac4:	687b      	ldr	r3, [r7, #4]
 8004ac6:	2200      	movs	r2, #0
 8004ac8:	60da      	str	r2, [r3, #12]
        ctx->get_padding = get_no_padding;
 8004aca:	687b      	ldr	r3, [r7, #4]
 8004acc:	4a0e      	ldr	r2, [pc, #56]	@ (8004b08 <mbedtls_cipher_set_padding_mode+0xc0>)
 8004ace:	611a      	str	r2, [r3, #16]
        break;
 8004ad0:	e001      	b.n	8004ad6 <mbedtls_cipher_set_padding_mode+0x8e>

    default:
        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
 8004ad2:	4b0e      	ldr	r3, [pc, #56]	@ (8004b0c <mbedtls_cipher_set_padding_mode+0xc4>)
 8004ad4:	e000      	b.n	8004ad8 <mbedtls_cipher_set_padding_mode+0x90>
    }

    return( 0 );
 8004ad6:	2300      	movs	r3, #0
}
 8004ad8:	4618      	mov	r0, r3
 8004ada:	370c      	adds	r7, #12
 8004adc:	46bd      	mov	sp, r7
 8004ade:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004ae2:	4770      	bx	lr
 8004ae4:	ffff9f00 	.word	0xffff9f00
 8004ae8:	080045e9 	.word	0x080045e9
 8004aec:	08004631 	.word	0x08004631
 8004af0:	08004705 	.word	0x08004705
 8004af4:	08004759 	.word	0x08004759
 8004af8:	08004825 	.word	0x08004825
 8004afc:	0800487d 	.word	0x0800487d
 8004b00:	0800494d 	.word	0x0800494d
 8004b04:	08004985 	.word	0x08004985
 8004b08:	08004a15 	.word	0x08004a15
 8004b0c:	ffff9f80 	.word	0xffff9f80

08004b10 <gcm_ctx_alloc>:
#endif

#if defined(MBEDTLS_GCM_C)
/* shared by all GCM ciphers */
static void *gcm_ctx_alloc( void )
{
 8004b10:	b580      	push	{r7, lr}
 8004b12:	b082      	sub	sp, #8
 8004b14:	af00      	add	r7, sp, #0
    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_gcm_context ) );
 8004b16:	f44f 71c8 	mov.w	r1, #400	@ 0x190
 8004b1a:	2001      	movs	r0, #1
 8004b1c:	f010 fa04 	bl	8014f28 <calloc>
 8004b20:	4603      	mov	r3, r0
 8004b22:	607b      	str	r3, [r7, #4]

    if( ctx != NULL )
 8004b24:	687b      	ldr	r3, [r7, #4]
 8004b26:	2b00      	cmp	r3, #0
 8004b28:	d002      	beq.n	8004b30 <gcm_ctx_alloc+0x20>
        mbedtls_gcm_init( (mbedtls_gcm_context *) ctx );
 8004b2a:	6878      	ldr	r0, [r7, #4]
 8004b2c:	f000 fa26 	bl	8004f7c <mbedtls_gcm_init>

    return( ctx );
 8004b30:	687b      	ldr	r3, [r7, #4]
}
 8004b32:	4618      	mov	r0, r3
 8004b34:	3708      	adds	r7, #8
 8004b36:	46bd      	mov	sp, r7
 8004b38:	bd80      	pop	{r7, pc}

08004b3a <gcm_ctx_free>:

static void gcm_ctx_free( void *ctx )
{
 8004b3a:	b580      	push	{r7, lr}
 8004b3c:	b082      	sub	sp, #8
 8004b3e:	af00      	add	r7, sp, #0
 8004b40:	6078      	str	r0, [r7, #4]
    mbedtls_gcm_free( ctx );
 8004b42:	6878      	ldr	r0, [r7, #4]
 8004b44:	f001 fb37 	bl	80061b6 <mbedtls_gcm_free>
    mbedtls_free( ctx );
 8004b48:	6878      	ldr	r0, [r7, #4]
 8004b4a:	f010 fa11 	bl	8014f70 <free>
}
 8004b4e:	bf00      	nop
 8004b50:	3708      	adds	r7, #8
 8004b52:	46bd      	mov	sp, r7
 8004b54:	bd80      	pop	{r7, pc}

08004b56 <ccm_ctx_alloc>:
#endif /* MBEDTLS_GCM_C */

#if defined(MBEDTLS_CCM_C)
/* shared by all CCM ciphers */
static void *ccm_ctx_alloc( void )
{
 8004b56:	b580      	push	{r7, lr}
 8004b58:	b082      	sub	sp, #8
 8004b5a:	af00      	add	r7, sp, #0
    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_ccm_context ) );
 8004b5c:	2144      	movs	r1, #68	@ 0x44
 8004b5e:	2001      	movs	r0, #1
 8004b60:	f010 f9e2 	bl	8014f28 <calloc>
 8004b64:	4603      	mov	r3, r0
 8004b66:	607b      	str	r3, [r7, #4]

    if( ctx != NULL )
 8004b68:	687b      	ldr	r3, [r7, #4]
 8004b6a:	2b00      	cmp	r3, #0
 8004b6c:	d002      	beq.n	8004b74 <ccm_ctx_alloc+0x1e>
        mbedtls_ccm_init( (mbedtls_ccm_context *) ctx );
 8004b6e:	6878      	ldr	r0, [r7, #4]
 8004b70:	f7fd feaa 	bl	80028c8 <mbedtls_ccm_init>

    return( ctx );
 8004b74:	687b      	ldr	r3, [r7, #4]
}
 8004b76:	4618      	mov	r0, r3
 8004b78:	3708      	adds	r7, #8
 8004b7a:	46bd      	mov	sp, r7
 8004b7c:	bd80      	pop	{r7, pc}

08004b7e <ccm_ctx_free>:

static void ccm_ctx_free( void *ctx )
{
 8004b7e:	b580      	push	{r7, lr}
 8004b80:	b082      	sub	sp, #8
 8004b82:	af00      	add	r7, sp, #0
 8004b84:	6078      	str	r0, [r7, #4]
    mbedtls_ccm_free( ctx );
 8004b86:	6878      	ldr	r0, [r7, #4]
 8004b88:	f7fd feea 	bl	8002960 <mbedtls_ccm_free>
    mbedtls_free( ctx );
 8004b8c:	6878      	ldr	r0, [r7, #4]
 8004b8e:	f010 f9ef 	bl	8014f70 <free>
}
 8004b92:	bf00      	nop
 8004b94:	3708      	adds	r7, #8
 8004b96:	46bd      	mov	sp, r7
 8004b98:	bd80      	pop	{r7, pc}

08004b9a <aes_crypt_ecb_wrap>:

#if defined(MBEDTLS_AES_C)

static int aes_crypt_ecb_wrap( void *ctx, mbedtls_operation_t operation,
        const unsigned char *input, unsigned char *output )
{
 8004b9a:	b580      	push	{r7, lr}
 8004b9c:	b084      	sub	sp, #16
 8004b9e:	af00      	add	r7, sp, #0
 8004ba0:	60f8      	str	r0, [r7, #12]
 8004ba2:	607a      	str	r2, [r7, #4]
 8004ba4:	603b      	str	r3, [r7, #0]
 8004ba6:	460b      	mov	r3, r1
 8004ba8:	72fb      	strb	r3, [r7, #11]
    return mbedtls_aes_crypt_ecb( (mbedtls_aes_context *) ctx, operation, input, output );
 8004baa:	f997 100b 	ldrsb.w	r1, [r7, #11]
 8004bae:	683b      	ldr	r3, [r7, #0]
 8004bb0:	687a      	ldr	r2, [r7, #4]
 8004bb2:	68f8      	ldr	r0, [r7, #12]
 8004bb4:	f7fd f920 	bl	8001df8 <mbedtls_aes_crypt_ecb>
 8004bb8:	4603      	mov	r3, r0
}
 8004bba:	4618      	mov	r0, r3
 8004bbc:	3710      	adds	r7, #16
 8004bbe:	46bd      	mov	sp, r7
 8004bc0:	bd80      	pop	{r7, pc}

08004bc2 <aes_crypt_cbc_wrap>:

#if defined(MBEDTLS_CIPHER_MODE_CBC)
static int aes_crypt_cbc_wrap( void *ctx, mbedtls_operation_t operation, size_t length,
        unsigned char *iv, const unsigned char *input, unsigned char *output )
{
 8004bc2:	b580      	push	{r7, lr}
 8004bc4:	b086      	sub	sp, #24
 8004bc6:	af02      	add	r7, sp, #8
 8004bc8:	60f8      	str	r0, [r7, #12]
 8004bca:	607a      	str	r2, [r7, #4]
 8004bcc:	603b      	str	r3, [r7, #0]
 8004bce:	460b      	mov	r3, r1
 8004bd0:	72fb      	strb	r3, [r7, #11]
    return mbedtls_aes_crypt_cbc( (mbedtls_aes_context *) ctx, operation, length, iv, input,
 8004bd2:	f997 100b 	ldrsb.w	r1, [r7, #11]
 8004bd6:	69fb      	ldr	r3, [r7, #28]
 8004bd8:	9301      	str	r3, [sp, #4]
 8004bda:	69bb      	ldr	r3, [r7, #24]
 8004bdc:	9300      	str	r3, [sp, #0]
 8004bde:	683b      	ldr	r3, [r7, #0]
 8004be0:	687a      	ldr	r2, [r7, #4]
 8004be2:	68f8      	ldr	r0, [r7, #12]
 8004be4:	f7fd f923 	bl	8001e2e <mbedtls_aes_crypt_cbc>
 8004be8:	4603      	mov	r3, r0
                          output );
}
 8004bea:	4618      	mov	r0, r3
 8004bec:	3710      	adds	r7, #16
 8004bee:	46bd      	mov	sp, r7
 8004bf0:	bd80      	pop	{r7, pc}

08004bf2 <aes_crypt_cfb128_wrap>:

#if defined(MBEDTLS_CIPHER_MODE_CFB)
static int aes_crypt_cfb128_wrap( void *ctx, mbedtls_operation_t operation,
        size_t length, size_t *iv_off, unsigned char *iv,
        const unsigned char *input, unsigned char *output )
{
 8004bf2:	b580      	push	{r7, lr}
 8004bf4:	b088      	sub	sp, #32
 8004bf6:	af04      	add	r7, sp, #16
 8004bf8:	60f8      	str	r0, [r7, #12]
 8004bfa:	607a      	str	r2, [r7, #4]
 8004bfc:	603b      	str	r3, [r7, #0]
 8004bfe:	460b      	mov	r3, r1
 8004c00:	72fb      	strb	r3, [r7, #11]
    return mbedtls_aes_crypt_cfb128( (mbedtls_aes_context *) ctx, operation, length, iv_off, iv,
 8004c02:	f997 100b 	ldrsb.w	r1, [r7, #11]
 8004c06:	6a3b      	ldr	r3, [r7, #32]
 8004c08:	9302      	str	r3, [sp, #8]
 8004c0a:	69fb      	ldr	r3, [r7, #28]
 8004c0c:	9301      	str	r3, [sp, #4]
 8004c0e:	69bb      	ldr	r3, [r7, #24]
 8004c10:	9300      	str	r3, [sp, #0]
 8004c12:	683b      	ldr	r3, [r7, #0]
 8004c14:	687a      	ldr	r2, [r7, #4]
 8004c16:	68f8      	ldr	r0, [r7, #12]
 8004c18:	f7fd fd52 	bl	80026c0 <mbedtls_aes_crypt_cfb128>
 8004c1c:	4603      	mov	r3, r0
                             input, output );
}
 8004c1e:	4618      	mov	r0, r3
 8004c20:	3710      	adds	r7, #16
 8004c22:	46bd      	mov	sp, r7
 8004c24:	bd80      	pop	{r7, pc}

08004c26 <aes_crypt_ofb_wrap>:
#endif /* MBEDTLS_CIPHER_MODE_CFB */

#if defined(MBEDTLS_CIPHER_MODE_OFB)
static int aes_crypt_ofb_wrap( void *ctx, size_t length, size_t *iv_off,
        unsigned char *iv, const unsigned char *input, unsigned char *output )
{
 8004c26:	b580      	push	{r7, lr}
 8004c28:	b086      	sub	sp, #24
 8004c2a:	af02      	add	r7, sp, #8
 8004c2c:	60f8      	str	r0, [r7, #12]
 8004c2e:	60b9      	str	r1, [r7, #8]
 8004c30:	607a      	str	r2, [r7, #4]
 8004c32:	603b      	str	r3, [r7, #0]
    return mbedtls_aes_crypt_ofb( (mbedtls_aes_context *) ctx, length, iv_off,
 8004c34:	69fb      	ldr	r3, [r7, #28]
 8004c36:	9301      	str	r3, [sp, #4]
 8004c38:	69bb      	ldr	r3, [r7, #24]
 8004c3a:	9300      	str	r3, [sp, #0]
 8004c3c:	683b      	ldr	r3, [r7, #0]
 8004c3e:	687a      	ldr	r2, [r7, #4]
 8004c40:	68b9      	ldr	r1, [r7, #8]
 8004c42:	68f8      	ldr	r0, [r7, #12]
 8004c44:	f7fd fdab 	bl	800279e <mbedtls_aes_crypt_ofb>
 8004c48:	4603      	mov	r3, r0
                                    iv, input, output );
}
 8004c4a:	4618      	mov	r0, r3
 8004c4c:	3710      	adds	r7, #16
 8004c4e:	46bd      	mov	sp, r7
 8004c50:	bd80      	pop	{r7, pc}

08004c52 <aes_crypt_ctr_wrap>:

#if defined(MBEDTLS_CIPHER_MODE_CTR)
static int aes_crypt_ctr_wrap( void *ctx, size_t length, size_t *nc_off,
        unsigned char *nonce_counter, unsigned char *stream_block,
        const unsigned char *input, unsigned char *output )
{
 8004c52:	b580      	push	{r7, lr}
 8004c54:	b088      	sub	sp, #32
 8004c56:	af04      	add	r7, sp, #16
 8004c58:	60f8      	str	r0, [r7, #12]
 8004c5a:	60b9      	str	r1, [r7, #8]
 8004c5c:	607a      	str	r2, [r7, #4]
 8004c5e:	603b      	str	r3, [r7, #0]
    return mbedtls_aes_crypt_ctr( (mbedtls_aes_context *) ctx, length, nc_off, nonce_counter,
 8004c60:	6a3b      	ldr	r3, [r7, #32]
 8004c62:	9302      	str	r3, [sp, #8]
 8004c64:	69fb      	ldr	r3, [r7, #28]
 8004c66:	9301      	str	r3, [sp, #4]
 8004c68:	69bb      	ldr	r3, [r7, #24]
 8004c6a:	9300      	str	r3, [sp, #0]
 8004c6c:	683b      	ldr	r3, [r7, #0]
 8004c6e:	687a      	ldr	r2, [r7, #4]
 8004c70:	68b9      	ldr	r1, [r7, #8]
 8004c72:	68f8      	ldr	r0, [r7, #12]
 8004c74:	f7fd fdd4 	bl	8002820 <mbedtls_aes_crypt_ctr>
 8004c78:	4603      	mov	r3, r0
                          stream_block, input, output );
}
 8004c7a:	4618      	mov	r0, r3
 8004c7c:	3710      	adds	r7, #16
 8004c7e:	46bd      	mov	sp, r7
 8004c80:	bd80      	pop	{r7, pc}
	...

08004c84 <aes_crypt_xts_wrap>:
static int aes_crypt_xts_wrap( void *ctx, mbedtls_operation_t operation,
                               size_t length,
                               const unsigned char data_unit[16],
                               const unsigned char *input,
                               unsigned char *output )
{
 8004c84:	b580      	push	{r7, lr}
 8004c86:	b088      	sub	sp, #32
 8004c88:	af02      	add	r7, sp, #8
 8004c8a:	60f8      	str	r0, [r7, #12]
 8004c8c:	607a      	str	r2, [r7, #4]
 8004c8e:	603b      	str	r3, [r7, #0]
 8004c90:	460b      	mov	r3, r1
 8004c92:	72fb      	strb	r3, [r7, #11]
    mbedtls_aes_xts_context *xts_ctx = ctx;
 8004c94:	68fb      	ldr	r3, [r7, #12]
 8004c96:	613b      	str	r3, [r7, #16]
    int mode;

    switch( operation )
 8004c98:	f997 300b 	ldrsb.w	r3, [r7, #11]
 8004c9c:	2b00      	cmp	r3, #0
 8004c9e:	d004      	beq.n	8004caa <aes_crypt_xts_wrap+0x26>
 8004ca0:	2b01      	cmp	r3, #1
 8004ca2:	d105      	bne.n	8004cb0 <aes_crypt_xts_wrap+0x2c>
    {
        case MBEDTLS_ENCRYPT:
            mode = MBEDTLS_AES_ENCRYPT;
 8004ca4:	2301      	movs	r3, #1
 8004ca6:	617b      	str	r3, [r7, #20]
            break;
 8004ca8:	e004      	b.n	8004cb4 <aes_crypt_xts_wrap+0x30>
        case MBEDTLS_DECRYPT:
            mode = MBEDTLS_AES_DECRYPT;
 8004caa:	2300      	movs	r3, #0
 8004cac:	617b      	str	r3, [r7, #20]
            break;
 8004cae:	e001      	b.n	8004cb4 <aes_crypt_xts_wrap+0x30>
        default:
            return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
 8004cb0:	4b08      	ldr	r3, [pc, #32]	@ (8004cd4 <aes_crypt_xts_wrap+0x50>)
 8004cb2:	e00a      	b.n	8004cca <aes_crypt_xts_wrap+0x46>
    }

    return mbedtls_aes_crypt_xts( xts_ctx, mode, length,
 8004cb4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8004cb6:	9301      	str	r3, [sp, #4]
 8004cb8:	6a3b      	ldr	r3, [r7, #32]
 8004cba:	9300      	str	r3, [sp, #0]
 8004cbc:	683b      	ldr	r3, [r7, #0]
 8004cbe:	687a      	ldr	r2, [r7, #4]
 8004cc0:	6979      	ldr	r1, [r7, #20]
 8004cc2:	6938      	ldr	r0, [r7, #16]
 8004cc4:	f7fd fbf0 	bl	80024a8 <mbedtls_aes_crypt_xts>
 8004cc8:	4603      	mov	r3, r0
                                  data_unit, input, output );
}
 8004cca:	4618      	mov	r0, r3
 8004ccc:	3718      	adds	r7, #24
 8004cce:	46bd      	mov	sp, r7
 8004cd0:	bd80      	pop	{r7, pc}
 8004cd2:	bf00      	nop
 8004cd4:	ffff9f00 	.word	0xffff9f00

08004cd8 <aes_setkey_dec_wrap>:
#endif /* MBEDTLS_CIPHER_MODE_XTS */

static int aes_setkey_dec_wrap( void *ctx, const unsigned char *key,
                                unsigned int key_bitlen )
{
 8004cd8:	b580      	push	{r7, lr}
 8004cda:	b084      	sub	sp, #16
 8004cdc:	af00      	add	r7, sp, #0
 8004cde:	60f8      	str	r0, [r7, #12]
 8004ce0:	60b9      	str	r1, [r7, #8]
 8004ce2:	607a      	str	r2, [r7, #4]
    return mbedtls_aes_setkey_dec( (mbedtls_aes_context *) ctx, key, key_bitlen );
 8004ce4:	687a      	ldr	r2, [r7, #4]
 8004ce6:	68b9      	ldr	r1, [r7, #8]
 8004ce8:	68f8      	ldr	r0, [r7, #12]
 8004cea:	f7fc f8eb 	bl	8000ec4 <mbedtls_aes_setkey_dec>
 8004cee:	4603      	mov	r3, r0
}
 8004cf0:	4618      	mov	r0, r3
 8004cf2:	3710      	adds	r7, #16
 8004cf4:	46bd      	mov	sp, r7
 8004cf6:	bd80      	pop	{r7, pc}

08004cf8 <aes_setkey_enc_wrap>:

static int aes_setkey_enc_wrap( void *ctx, const unsigned char *key,
                                unsigned int key_bitlen )
{
 8004cf8:	b580      	push	{r7, lr}
 8004cfa:	b084      	sub	sp, #16
 8004cfc:	af00      	add	r7, sp, #0
 8004cfe:	60f8      	str	r0, [r7, #12]
 8004d00:	60b9      	str	r1, [r7, #8]
 8004d02:	607a      	str	r2, [r7, #4]
    return mbedtls_aes_setkey_enc( (mbedtls_aes_context *) ctx, key, key_bitlen );
 8004d04:	687a      	ldr	r2, [r7, #4]
 8004d06:	68b9      	ldr	r1, [r7, #8]
 8004d08:	68f8      	ldr	r0, [r7, #12]
 8004d0a:	f7fb fefb 	bl	8000b04 <mbedtls_aes_setkey_enc>
 8004d0e:	4603      	mov	r3, r0
}
 8004d10:	4618      	mov	r0, r3
 8004d12:	3710      	adds	r7, #16
 8004d14:	46bd      	mov	sp, r7
 8004d16:	bd80      	pop	{r7, pc}

08004d18 <aes_ctx_alloc>:

static void * aes_ctx_alloc( void )
{
 8004d18:	b580      	push	{r7, lr}
 8004d1a:	b082      	sub	sp, #8
 8004d1c:	af00      	add	r7, sp, #0
    mbedtls_aes_context *aes = mbedtls_calloc( 1, sizeof( mbedtls_aes_context ) );
 8004d1e:	f44f 718c 	mov.w	r1, #280	@ 0x118
 8004d22:	2001      	movs	r0, #1
 8004d24:	f010 f900 	bl	8014f28 <calloc>
 8004d28:	4603      	mov	r3, r0
 8004d2a:	607b      	str	r3, [r7, #4]

    if( aes == NULL )
 8004d2c:	687b      	ldr	r3, [r7, #4]
 8004d2e:	2b00      	cmp	r3, #0
 8004d30:	d101      	bne.n	8004d36 <aes_ctx_alloc+0x1e>
        return( NULL );
 8004d32:	2300      	movs	r3, #0
 8004d34:	e003      	b.n	8004d3e <aes_ctx_alloc+0x26>

    mbedtls_aes_init( aes );
 8004d36:	6878      	ldr	r0, [r7, #4]
 8004d38:	f7fb fe9c 	bl	8000a74 <mbedtls_aes_init>

    return( aes );
 8004d3c:	687b      	ldr	r3, [r7, #4]
}
 8004d3e:	4618      	mov	r0, r3
 8004d40:	3708      	adds	r7, #8
 8004d42:	46bd      	mov	sp, r7
 8004d44:	bd80      	pop	{r7, pc}

08004d46 <aes_ctx_free>:

static void aes_ctx_free( void *ctx )
{
 8004d46:	b580      	push	{r7, lr}
 8004d48:	b082      	sub	sp, #8
 8004d4a:	af00      	add	r7, sp, #0
 8004d4c:	6078      	str	r0, [r7, #4]
    mbedtls_aes_free( (mbedtls_aes_context *) ctx );
 8004d4e:	6878      	ldr	r0, [r7, #4]
 8004d50:	f7fb fe9e 	bl	8000a90 <mbedtls_aes_free>
    mbedtls_free( ctx );
 8004d54:	6878      	ldr	r0, [r7, #4]
 8004d56:	f010 f90b 	bl	8014f70 <free>
}
 8004d5a:	bf00      	nop
 8004d5c:	3708      	adds	r7, #8
 8004d5e:	46bd      	mov	sp, r7
 8004d60:	bd80      	pop	{r7, pc}

08004d62 <xts_aes_setkey_enc_wrap>:
#endif /* MBEDTLS_CIPHER_MODE_CTR */

#if defined(MBEDTLS_CIPHER_MODE_XTS)
static int xts_aes_setkey_enc_wrap( void *ctx, const unsigned char *key,
                                    unsigned int key_bitlen )
{
 8004d62:	b580      	push	{r7, lr}
 8004d64:	b086      	sub	sp, #24
 8004d66:	af00      	add	r7, sp, #0
 8004d68:	60f8      	str	r0, [r7, #12]
 8004d6a:	60b9      	str	r1, [r7, #8]
 8004d6c:	607a      	str	r2, [r7, #4]
    mbedtls_aes_xts_context *xts_ctx = ctx;
 8004d6e:	68fb      	ldr	r3, [r7, #12]
 8004d70:	617b      	str	r3, [r7, #20]
    return( mbedtls_aes_xts_setkey_enc( xts_ctx, key, key_bitlen ) );
 8004d72:	687a      	ldr	r2, [r7, #4]
 8004d74:	68b9      	ldr	r1, [r7, #8]
 8004d76:	6978      	ldr	r0, [r7, #20]
 8004d78:	f7fc fa04 	bl	8001184 <mbedtls_aes_xts_setkey_enc>
 8004d7c:	4603      	mov	r3, r0
}
 8004d7e:	4618      	mov	r0, r3
 8004d80:	3718      	adds	r7, #24
 8004d82:	46bd      	mov	sp, r7
 8004d84:	bd80      	pop	{r7, pc}

08004d86 <xts_aes_setkey_dec_wrap>:

static int xts_aes_setkey_dec_wrap( void *ctx, const unsigned char *key,
                                    unsigned int key_bitlen )
{
 8004d86:	b580      	push	{r7, lr}
 8004d88:	b086      	sub	sp, #24
 8004d8a:	af00      	add	r7, sp, #0
 8004d8c:	60f8      	str	r0, [r7, #12]
 8004d8e:	60b9      	str	r1, [r7, #8]
 8004d90:	607a      	str	r2, [r7, #4]
    mbedtls_aes_xts_context *xts_ctx = ctx;
 8004d92:	68fb      	ldr	r3, [r7, #12]
 8004d94:	617b      	str	r3, [r7, #20]
    return( mbedtls_aes_xts_setkey_dec( xts_ctx, key, key_bitlen ) );
 8004d96:	687a      	ldr	r2, [r7, #4]
 8004d98:	68b9      	ldr	r1, [r7, #8]
 8004d9a:	6978      	ldr	r0, [r7, #20]
 8004d9c:	f7fc fa29 	bl	80011f2 <mbedtls_aes_xts_setkey_dec>
 8004da0:	4603      	mov	r3, r0
}
 8004da2:	4618      	mov	r0, r3
 8004da4:	3718      	adds	r7, #24
 8004da6:	46bd      	mov	sp, r7
 8004da8:	bd80      	pop	{r7, pc}

08004daa <xts_aes_ctx_alloc>:

static void *xts_aes_ctx_alloc( void )
{
 8004daa:	b580      	push	{r7, lr}
 8004dac:	b082      	sub	sp, #8
 8004dae:	af00      	add	r7, sp, #0
    mbedtls_aes_xts_context *xts_ctx = mbedtls_calloc( 1, sizeof( *xts_ctx ) );
 8004db0:	f44f 710c 	mov.w	r1, #560	@ 0x230
 8004db4:	2001      	movs	r0, #1
 8004db6:	f010 f8b7 	bl	8014f28 <calloc>
 8004dba:	4603      	mov	r3, r0
 8004dbc:	607b      	str	r3, [r7, #4]

    if( xts_ctx != NULL )
 8004dbe:	687b      	ldr	r3, [r7, #4]
 8004dc0:	2b00      	cmp	r3, #0
 8004dc2:	d002      	beq.n	8004dca <xts_aes_ctx_alloc+0x20>
        mbedtls_aes_xts_init( xts_ctx );
 8004dc4:	6878      	ldr	r0, [r7, #4]
 8004dc6:	f7fb fe74 	bl	8000ab2 <mbedtls_aes_xts_init>

    return( xts_ctx );
 8004dca:	687b      	ldr	r3, [r7, #4]
}
 8004dcc:	4618      	mov	r0, r3
 8004dce:	3708      	adds	r7, #8
 8004dd0:	46bd      	mov	sp, r7
 8004dd2:	bd80      	pop	{r7, pc}

08004dd4 <xts_aes_ctx_free>:

static void xts_aes_ctx_free( void *ctx )
{
 8004dd4:	b580      	push	{r7, lr}
 8004dd6:	b084      	sub	sp, #16
 8004dd8:	af00      	add	r7, sp, #0
 8004dda:	6078      	str	r0, [r7, #4]
    mbedtls_aes_xts_context *xts_ctx = ctx;
 8004ddc:	687b      	ldr	r3, [r7, #4]
 8004dde:	60fb      	str	r3, [r7, #12]

    if( xts_ctx == NULL )
 8004de0:	68fb      	ldr	r3, [r7, #12]
 8004de2:	2b00      	cmp	r3, #0
 8004de4:	d006      	beq.n	8004df4 <xts_aes_ctx_free+0x20>
        return;

    mbedtls_aes_xts_free( xts_ctx );
 8004de6:	68f8      	ldr	r0, [r7, #12]
 8004de8:	f7fb fe75 	bl	8000ad6 <mbedtls_aes_xts_free>
    mbedtls_free( xts_ctx );
 8004dec:	68f8      	ldr	r0, [r7, #12]
 8004dee:	f010 f8bf 	bl	8014f70 <free>
 8004df2:	e000      	b.n	8004df6 <xts_aes_ctx_free+0x22>
        return;
 8004df4:	bf00      	nop
}
 8004df6:	3710      	adds	r7, #16
 8004df8:	46bd      	mov	sp, r7
 8004dfa:	bd80      	pop	{r7, pc}

08004dfc <gcm_aes_setkey_wrap>:
#endif /* MBEDTLS_CIPHER_MODE_XTS */

#if defined(MBEDTLS_GCM_C)
static int gcm_aes_setkey_wrap( void *ctx, const unsigned char *key,
                                unsigned int key_bitlen )
{
 8004dfc:	b580      	push	{r7, lr}
 8004dfe:	b084      	sub	sp, #16
 8004e00:	af00      	add	r7, sp, #0
 8004e02:	60f8      	str	r0, [r7, #12]
 8004e04:	60b9      	str	r1, [r7, #8]
 8004e06:	607a      	str	r2, [r7, #4]
    return mbedtls_gcm_setkey( (mbedtls_gcm_context *) ctx, MBEDTLS_CIPHER_ID_AES,
 8004e08:	687b      	ldr	r3, [r7, #4]
 8004e0a:	68ba      	ldr	r2, [r7, #8]
 8004e0c:	2102      	movs	r1, #2
 8004e0e:	68f8      	ldr	r0, [r7, #12]
 8004e10:	f000 fa3c 	bl	800528c <mbedtls_gcm_setkey>
 8004e14:	4603      	mov	r3, r0
                     key, key_bitlen );
}
 8004e16:	4618      	mov	r0, r3
 8004e18:	3710      	adds	r7, #16
 8004e1a:	46bd      	mov	sp, r7
 8004e1c:	bd80      	pop	{r7, pc}

08004e1e <ccm_aes_setkey_wrap>:
#endif /* MBEDTLS_GCM_C */

#if defined(MBEDTLS_CCM_C)
static int ccm_aes_setkey_wrap( void *ctx, const unsigned char *key,
                                unsigned int key_bitlen )
{
 8004e1e:	b580      	push	{r7, lr}
 8004e20:	b084      	sub	sp, #16
 8004e22:	af00      	add	r7, sp, #0
 8004e24:	60f8      	str	r0, [r7, #12]
 8004e26:	60b9      	str	r1, [r7, #8]
 8004e28:	607a      	str	r2, [r7, #4]
    return mbedtls_ccm_setkey( (mbedtls_ccm_context *) ctx, MBEDTLS_CIPHER_ID_AES,
 8004e2a:	687b      	ldr	r3, [r7, #4]
 8004e2c:	68ba      	ldr	r2, [r7, #8]
 8004e2e:	2102      	movs	r1, #2
 8004e30:	68f8      	ldr	r0, [r7, #12]
 8004e32:	f7fd fd56 	bl	80028e2 <mbedtls_ccm_setkey>
 8004e36:	4603      	mov	r3, r0
                     key, key_bitlen );
}
 8004e38:	4618      	mov	r0, r3
 8004e3a:	3710      	adds	r7, #16
 8004e3c:	46bd      	mov	sp, r7
 8004e3e:	bd80      	pop	{r7, pc}

08004e40 <chacha20_setkey_wrap>:

#if defined(MBEDTLS_CHACHA20_C)

static int chacha20_setkey_wrap( void *ctx, const unsigned char *key,
                                 unsigned int key_bitlen )
{
 8004e40:	b580      	push	{r7, lr}
 8004e42:	b084      	sub	sp, #16
 8004e44:	af00      	add	r7, sp, #0
 8004e46:	60f8      	str	r0, [r7, #12]
 8004e48:	60b9      	str	r1, [r7, #8]
 8004e4a:	607a      	str	r2, [r7, #4]
    if( key_bitlen != 256U )
 8004e4c:	687b      	ldr	r3, [r7, #4]
 8004e4e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8004e52:	d001      	beq.n	8004e58 <chacha20_setkey_wrap+0x18>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 8004e54:	4b07      	ldr	r3, [pc, #28]	@ (8004e74 <chacha20_setkey_wrap+0x34>)
 8004e56:	e009      	b.n	8004e6c <chacha20_setkey_wrap+0x2c>

    if ( 0 != mbedtls_chacha20_setkey( (mbedtls_chacha20_context*)ctx, key ) )
 8004e58:	68b9      	ldr	r1, [r7, #8]
 8004e5a:	68f8      	ldr	r0, [r7, #12]
 8004e5c:	f7fe fb22 	bl	80034a4 <mbedtls_chacha20_setkey>
 8004e60:	4603      	mov	r3, r0
 8004e62:	2b00      	cmp	r3, #0
 8004e64:	d001      	beq.n	8004e6a <chacha20_setkey_wrap+0x2a>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 8004e66:	4b03      	ldr	r3, [pc, #12]	@ (8004e74 <chacha20_setkey_wrap+0x34>)
 8004e68:	e000      	b.n	8004e6c <chacha20_setkey_wrap+0x2c>

    return( 0 );
 8004e6a:	2300      	movs	r3, #0
}
 8004e6c:	4618      	mov	r0, r3
 8004e6e:	3710      	adds	r7, #16
 8004e70:	46bd      	mov	sp, r7
 8004e72:	bd80      	pop	{r7, pc}
 8004e74:	ffff9f00 	.word	0xffff9f00

08004e78 <chacha20_stream_wrap>:

static int chacha20_stream_wrap( void *ctx,  size_t length,
                                 const unsigned char *input,
                                 unsigned char *output )
{
 8004e78:	b580      	push	{r7, lr}
 8004e7a:	b086      	sub	sp, #24
 8004e7c:	af00      	add	r7, sp, #0
 8004e7e:	60f8      	str	r0, [r7, #12]
 8004e80:	60b9      	str	r1, [r7, #8]
 8004e82:	607a      	str	r2, [r7, #4]
 8004e84:	603b      	str	r3, [r7, #0]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 8004e86:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8004e8a:	617b      	str	r3, [r7, #20]

    ret = mbedtls_chacha20_update( ctx, length, input, output );
 8004e8c:	683b      	ldr	r3, [r7, #0]
 8004e8e:	687a      	ldr	r2, [r7, #4]
 8004e90:	68b9      	ldr	r1, [r7, #8]
 8004e92:	68f8      	ldr	r0, [r7, #12]
 8004e94:	f7fe fc24 	bl	80036e0 <mbedtls_chacha20_update>
 8004e98:	6178      	str	r0, [r7, #20]
    if( ret == MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA )
 8004e9a:	697b      	ldr	r3, [r7, #20]
 8004e9c:	f113 0f51 	cmn.w	r3, #81	@ 0x51
 8004ea0:	d101      	bne.n	8004ea6 <chacha20_stream_wrap+0x2e>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 8004ea2:	4b03      	ldr	r3, [pc, #12]	@ (8004eb0 <chacha20_stream_wrap+0x38>)
 8004ea4:	e000      	b.n	8004ea8 <chacha20_stream_wrap+0x30>

    return( ret );
 8004ea6:	697b      	ldr	r3, [r7, #20]
}
 8004ea8:	4618      	mov	r0, r3
 8004eaa:	3718      	adds	r7, #24
 8004eac:	46bd      	mov	sp, r7
 8004eae:	bd80      	pop	{r7, pc}
 8004eb0:	ffff9f00 	.word	0xffff9f00

08004eb4 <chacha20_ctx_alloc>:

static void * chacha20_ctx_alloc( void )
{
 8004eb4:	b580      	push	{r7, lr}
 8004eb6:	b082      	sub	sp, #8
 8004eb8:	af00      	add	r7, sp, #0
    mbedtls_chacha20_context *ctx;
    ctx = mbedtls_calloc( 1, sizeof( mbedtls_chacha20_context ) );
 8004eba:	2184      	movs	r1, #132	@ 0x84
 8004ebc:	2001      	movs	r0, #1
 8004ebe:	f010 f833 	bl	8014f28 <calloc>
 8004ec2:	4603      	mov	r3, r0
 8004ec4:	607b      	str	r3, [r7, #4]

    if( ctx == NULL )
 8004ec6:	687b      	ldr	r3, [r7, #4]
 8004ec8:	2b00      	cmp	r3, #0
 8004eca:	d101      	bne.n	8004ed0 <chacha20_ctx_alloc+0x1c>
        return( NULL );
 8004ecc:	2300      	movs	r3, #0
 8004ece:	e003      	b.n	8004ed8 <chacha20_ctx_alloc+0x24>

    mbedtls_chacha20_init( ctx );
 8004ed0:	6878      	ldr	r0, [r7, #4]
 8004ed2:	f7fe fac1 	bl	8003458 <mbedtls_chacha20_init>

    return( ctx );
 8004ed6:	687b      	ldr	r3, [r7, #4]
}
 8004ed8:	4618      	mov	r0, r3
 8004eda:	3708      	adds	r7, #8
 8004edc:	46bd      	mov	sp, r7
 8004ede:	bd80      	pop	{r7, pc}

08004ee0 <chacha20_ctx_free>:

static void chacha20_ctx_free( void *ctx )
{
 8004ee0:	b580      	push	{r7, lr}
 8004ee2:	b082      	sub	sp, #8
 8004ee4:	af00      	add	r7, sp, #0
 8004ee6:	6078      	str	r0, [r7, #4]
    mbedtls_chacha20_free( (mbedtls_chacha20_context *) ctx );
 8004ee8:	6878      	ldr	r0, [r7, #4]
 8004eea:	f7fe facc 	bl	8003486 <mbedtls_chacha20_free>
    mbedtls_free( ctx );
 8004eee:	6878      	ldr	r0, [r7, #4]
 8004ef0:	f010 f83e 	bl	8014f70 <free>
}
 8004ef4:	bf00      	nop
 8004ef6:	3708      	adds	r7, #8
 8004ef8:	46bd      	mov	sp, r7
 8004efa:	bd80      	pop	{r7, pc}

08004efc <chachapoly_setkey_wrap>:
#if defined(MBEDTLS_CHACHAPOLY_C)

static int chachapoly_setkey_wrap( void *ctx,
                                   const unsigned char *key,
                                   unsigned int key_bitlen )
{
 8004efc:	b580      	push	{r7, lr}
 8004efe:	b084      	sub	sp, #16
 8004f00:	af00      	add	r7, sp, #0
 8004f02:	60f8      	str	r0, [r7, #12]
 8004f04:	60b9      	str	r1, [r7, #8]
 8004f06:	607a      	str	r2, [r7, #4]
    if( key_bitlen != 256U )
 8004f08:	687b      	ldr	r3, [r7, #4]
 8004f0a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8004f0e:	d001      	beq.n	8004f14 <chachapoly_setkey_wrap+0x18>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 8004f10:	4b07      	ldr	r3, [pc, #28]	@ (8004f30 <chachapoly_setkey_wrap+0x34>)
 8004f12:	e009      	b.n	8004f28 <chachapoly_setkey_wrap+0x2c>

    if ( 0 != mbedtls_chachapoly_setkey( (mbedtls_chachapoly_context*)ctx, key ) )
 8004f14:	68b9      	ldr	r1, [r7, #8]
 8004f16:	68f8      	ldr	r0, [r7, #12]
 8004f18:	f7fe fdb6 	bl	8003a88 <mbedtls_chachapoly_setkey>
 8004f1c:	4603      	mov	r3, r0
 8004f1e:	2b00      	cmp	r3, #0
 8004f20:	d001      	beq.n	8004f26 <chachapoly_setkey_wrap+0x2a>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 8004f22:	4b03      	ldr	r3, [pc, #12]	@ (8004f30 <chachapoly_setkey_wrap+0x34>)
 8004f24:	e000      	b.n	8004f28 <chachapoly_setkey_wrap+0x2c>

    return( 0 );
 8004f26:	2300      	movs	r3, #0
}
 8004f28:	4618      	mov	r0, r3
 8004f2a:	3710      	adds	r7, #16
 8004f2c:	46bd      	mov	sp, r7
 8004f2e:	bd80      	pop	{r7, pc}
 8004f30:	ffff9f00 	.word	0xffff9f00

08004f34 <chachapoly_ctx_alloc>:

static void * chachapoly_ctx_alloc( void )
{
 8004f34:	b580      	push	{r7, lr}
 8004f36:	b082      	sub	sp, #8
 8004f38:	af00      	add	r7, sp, #0
    mbedtls_chachapoly_context *ctx;
    ctx = mbedtls_calloc( 1, sizeof( mbedtls_chachapoly_context ) );
 8004f3a:	21e8      	movs	r1, #232	@ 0xe8
 8004f3c:	2001      	movs	r0, #1
 8004f3e:	f00f fff3 	bl	8014f28 <calloc>
 8004f42:	4603      	mov	r3, r0
 8004f44:	607b      	str	r3, [r7, #4]

    if( ctx == NULL )
 8004f46:	687b      	ldr	r3, [r7, #4]
 8004f48:	2b00      	cmp	r3, #0
 8004f4a:	d101      	bne.n	8004f50 <chachapoly_ctx_alloc+0x1c>
        return( NULL );
 8004f4c:	2300      	movs	r3, #0
 8004f4e:	e003      	b.n	8004f58 <chachapoly_ctx_alloc+0x24>

    mbedtls_chachapoly_init( ctx );
 8004f50:	6878      	ldr	r0, [r7, #4]
 8004f52:	f7fe fd47 	bl	80039e4 <mbedtls_chachapoly_init>

    return( ctx );
 8004f56:	687b      	ldr	r3, [r7, #4]
}
 8004f58:	4618      	mov	r0, r3
 8004f5a:	3708      	adds	r7, #8
 8004f5c:	46bd      	mov	sp, r7
 8004f5e:	bd80      	pop	{r7, pc}

08004f60 <chachapoly_ctx_free>:

static void chachapoly_ctx_free( void *ctx )
{
 8004f60:	b580      	push	{r7, lr}
 8004f62:	b082      	sub	sp, #8
 8004f64:	af00      	add	r7, sp, #0
 8004f66:	6078      	str	r0, [r7, #4]
    mbedtls_chachapoly_free( (mbedtls_chachapoly_context *) ctx );
 8004f68:	6878      	ldr	r0, [r7, #4]
 8004f6a:	f7fe fd62 	bl	8003a32 <mbedtls_chachapoly_free>
    mbedtls_free( ctx );
 8004f6e:	6878      	ldr	r0, [r7, #4]
 8004f70:	f00f fffe 	bl	8014f70 <free>
}
 8004f74:	bf00      	nop
 8004f76:	3708      	adds	r7, #8
 8004f78:	46bd      	mov	sp, r7
 8004f7a:	bd80      	pop	{r7, pc}

08004f7c <mbedtls_gcm_init>:

/*
 * Initialize a context
 */
void mbedtls_gcm_init( mbedtls_gcm_context *ctx )
{
 8004f7c:	b580      	push	{r7, lr}
 8004f7e:	b082      	sub	sp, #8
 8004f80:	af00      	add	r7, sp, #0
 8004f82:	6078      	str	r0, [r7, #4]
    GCM_VALIDATE( ctx != NULL );
    memset( ctx, 0, sizeof( mbedtls_gcm_context ) );
 8004f84:	f44f 72c8 	mov.w	r2, #400	@ 0x190
 8004f88:	2100      	movs	r1, #0
 8004f8a:	6878      	ldr	r0, [r7, #4]
 8004f8c:	f010 fa5c 	bl	8015448 <memset>
}
 8004f90:	bf00      	nop
 8004f92:	3708      	adds	r7, #8
 8004f94:	46bd      	mov	sp, r7
 8004f96:	bd80      	pop	{r7, pc}

08004f98 <gcm_gen_table>:
 * correspond to low powers of P. The result is stored in the same way, that
 * is the high-order bit of HH corresponds to P^0 and the low-order bit of HL
 * corresponds to P^127.
 */
static int gcm_gen_table( mbedtls_gcm_context *ctx )
{
 8004f98:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8004f9c:	b0a8      	sub	sp, #160	@ 0xa0
 8004f9e:	af02      	add	r7, sp, #8
 8004fa0:	6478      	str	r0, [r7, #68]	@ 0x44
    int ret, i, j;
    uint64_t hi, lo;
    uint64_t vl, vh;
    unsigned char h[16];
    size_t olen = 0;
 8004fa2:	2300      	movs	r3, #0
 8004fa4:	64bb      	str	r3, [r7, #72]	@ 0x48

    memset( h, 0, 16 );
 8004fa6:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
 8004faa:	2210      	movs	r2, #16
 8004fac:	2100      	movs	r1, #0
 8004fae:	4618      	mov	r0, r3
 8004fb0:	f010 fa4a 	bl	8015448 <memset>
    if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, h, 16, h, &olen ) ) != 0 )
 8004fb4:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 8004fb6:	f107 024c 	add.w	r2, r7, #76	@ 0x4c
 8004fba:	f107 014c 	add.w	r1, r7, #76	@ 0x4c
 8004fbe:	f107 0348 	add.w	r3, r7, #72	@ 0x48
 8004fc2:	9300      	str	r3, [sp, #0]
 8004fc4:	4613      	mov	r3, r2
 8004fc6:	2210      	movs	r2, #16
 8004fc8:	f7ff f8fa 	bl	80041c0 <mbedtls_cipher_update>
 8004fcc:	67f8      	str	r0, [r7, #124]	@ 0x7c
 8004fce:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8004fd0:	2b00      	cmp	r3, #0
 8004fd2:	d001      	beq.n	8004fd8 <gcm_gen_table+0x40>
        return( ret );
 8004fd4:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8004fd6:	e154      	b.n	8005282 <gcm_gen_table+0x2ea>

    /* pack h as two 64-bits ints, big-endian */
    GET_UINT32_BE( hi, h,  0  );
 8004fd8:	f897 304c 	ldrb.w	r3, [r7, #76]	@ 0x4c
 8004fdc:	061a      	lsls	r2, r3, #24
 8004fde:	f897 304d 	ldrb.w	r3, [r7, #77]	@ 0x4d
 8004fe2:	041b      	lsls	r3, r3, #16
 8004fe4:	431a      	orrs	r2, r3
 8004fe6:	f897 304e 	ldrb.w	r3, [r7, #78]	@ 0x4e
 8004fea:	021b      	lsls	r3, r3, #8
 8004fec:	431a      	orrs	r2, r3
 8004fee:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 8004ff2:	4313      	orrs	r3, r2
 8004ff4:	2200      	movs	r2, #0
 8004ff6:	4698      	mov	r8, r3
 8004ff8:	4691      	mov	r9, r2
 8004ffa:	e9c7 891c 	strd	r8, r9, [r7, #112]	@ 0x70
    GET_UINT32_BE( lo, h,  4  );
 8004ffe:	f897 3050 	ldrb.w	r3, [r7, #80]	@ 0x50
 8005002:	061a      	lsls	r2, r3, #24
 8005004:	f897 3051 	ldrb.w	r3, [r7, #81]	@ 0x51
 8005008:	041b      	lsls	r3, r3, #16
 800500a:	431a      	orrs	r2, r3
 800500c:	f897 3052 	ldrb.w	r3, [r7, #82]	@ 0x52
 8005010:	021b      	lsls	r3, r3, #8
 8005012:	431a      	orrs	r2, r3
 8005014:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 8005018:	4313      	orrs	r3, r2
 800501a:	2200      	movs	r2, #0
 800501c:	623b      	str	r3, [r7, #32]
 800501e:	627a      	str	r2, [r7, #36]	@ 0x24
 8005020:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8005024:	e9c7 231a 	strd	r2, r3, [r7, #104]	@ 0x68
    vh = (uint64_t) hi << 32 | lo;
 8005028:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	@ 0x70
 800502c:	f04f 0000 	mov.w	r0, #0
 8005030:	f04f 0100 	mov.w	r1, #0
 8005034:	0011      	movs	r1, r2
 8005036:	2000      	movs	r0, #0
 8005038:	e9d7 231a 	ldrd	r2, r3, [r7, #104]	@ 0x68
 800503c:	ea42 0400 	orr.w	r4, r2, r0
 8005040:	ea43 0501 	orr.w	r5, r3, r1
 8005044:	e9c7 4520 	strd	r4, r5, [r7, #128]	@ 0x80

    GET_UINT32_BE( hi, h,  8  );
 8005048:	f897 3054 	ldrb.w	r3, [r7, #84]	@ 0x54
 800504c:	061a      	lsls	r2, r3, #24
 800504e:	f897 3055 	ldrb.w	r3, [r7, #85]	@ 0x55
 8005052:	041b      	lsls	r3, r3, #16
 8005054:	431a      	orrs	r2, r3
 8005056:	f897 3056 	ldrb.w	r3, [r7, #86]	@ 0x56
 800505a:	021b      	lsls	r3, r3, #8
 800505c:	431a      	orrs	r2, r3
 800505e:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 8005062:	4313      	orrs	r3, r2
 8005064:	2200      	movs	r2, #0
 8005066:	61bb      	str	r3, [r7, #24]
 8005068:	61fa      	str	r2, [r7, #28]
 800506a:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 800506e:	e9c7 341c 	strd	r3, r4, [r7, #112]	@ 0x70
    GET_UINT32_BE( lo, h,  12 );
 8005072:	f897 3058 	ldrb.w	r3, [r7, #88]	@ 0x58
 8005076:	061a      	lsls	r2, r3, #24
 8005078:	f897 3059 	ldrb.w	r3, [r7, #89]	@ 0x59
 800507c:	041b      	lsls	r3, r3, #16
 800507e:	431a      	orrs	r2, r3
 8005080:	f897 305a 	ldrb.w	r3, [r7, #90]	@ 0x5a
 8005084:	021b      	lsls	r3, r3, #8
 8005086:	431a      	orrs	r2, r3
 8005088:	f897 305b 	ldrb.w	r3, [r7, #91]	@ 0x5b
 800508c:	4313      	orrs	r3, r2
 800508e:	2200      	movs	r2, #0
 8005090:	613b      	str	r3, [r7, #16]
 8005092:	617a      	str	r2, [r7, #20]
 8005094:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 8005098:	e9c7 341a 	strd	r3, r4, [r7, #104]	@ 0x68
    vl = (uint64_t) hi << 32 | lo;
 800509c:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	@ 0x70
 80050a0:	f04f 0000 	mov.w	r0, #0
 80050a4:	f04f 0100 	mov.w	r1, #0
 80050a8:	0011      	movs	r1, r2
 80050aa:	2000      	movs	r0, #0
 80050ac:	e9d7 231a 	ldrd	r2, r3, [r7, #104]	@ 0x68
 80050b0:	ea42 0a00 	orr.w	sl, r2, r0
 80050b4:	ea43 0b01 	orr.w	fp, r3, r1
 80050b8:	e9c7 ab22 	strd	sl, fp, [r7, #136]	@ 0x88

    /* 8 = 1000 corresponds to 1 in GF(2^128) */
    ctx->HL[8] = vl;
 80050bc:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 80050be:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 80050c2:	e9c1 2322 	strd	r2, r3, [r1, #136]	@ 0x88
    ctx->HH[8] = vh;
 80050c6:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 80050c8:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 80050cc:	e9c1 2342 	strd	r2, r3, [r1, #264]	@ 0x108
    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_CLMUL ) )
        return( 0 );
#endif

    /* 0 corresponds to 0 in GF(2^128) */
    ctx->HH[0] = 0;
 80050d0:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 80050d2:	f04f 0200 	mov.w	r2, #0
 80050d6:	f04f 0300 	mov.w	r3, #0
 80050da:	e9c1 2332 	strd	r2, r3, [r1, #200]	@ 0xc8
    ctx->HL[0] = 0;
 80050de:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 80050e0:	f04f 0200 	mov.w	r2, #0
 80050e4:	f04f 0300 	mov.w	r3, #0
 80050e8:	e9c1 2312 	strd	r2, r3, [r1, #72]	@ 0x48

    for( i = 4; i > 0; i >>= 1 )
 80050ec:	2304      	movs	r3, #4
 80050ee:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
 80050f2:	e05b      	b.n	80051ac <gcm_gen_table+0x214>
    {
        uint32_t T = ( vl & 1 ) * 0xe1000000U;
 80050f4:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 80050f8:	f003 0201 	and.w	r2, r3, #1
 80050fc:	4613      	mov	r3, r2
 80050fe:	0152      	lsls	r2, r2, #5
 8005100:	1a9b      	subs	r3, r3, r2
 8005102:	061b      	lsls	r3, r3, #24
 8005104:	65fb      	str	r3, [r7, #92]	@ 0x5c
        vl  = ( vh << 63 ) | ( vl >> 1 );
 8005106:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 800510a:	f04f 0400 	mov.w	r4, #0
 800510e:	f04f 0500 	mov.w	r5, #0
 8005112:	07d5      	lsls	r5, r2, #31
 8005114:	2400      	movs	r4, #0
 8005116:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 800511a:	f04f 0000 	mov.w	r0, #0
 800511e:	f04f 0100 	mov.w	r1, #0
 8005122:	0850      	lsrs	r0, r2, #1
 8005124:	ea40 70c3 	orr.w	r0, r0, r3, lsl #31
 8005128:	0859      	lsrs	r1, r3, #1
 800512a:	ea44 0300 	orr.w	r3, r4, r0
 800512e:	60bb      	str	r3, [r7, #8]
 8005130:	ea45 0301 	orr.w	r3, r5, r1
 8005134:	60fb      	str	r3, [r7, #12]
 8005136:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 800513a:	e9c7 3422 	strd	r3, r4, [r7, #136]	@ 0x88
        vh  = ( vh >> 1 ) ^ ( (uint64_t) T << 32);
 800513e:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 8005142:	f04f 0000 	mov.w	r0, #0
 8005146:	f04f 0100 	mov.w	r1, #0
 800514a:	0850      	lsrs	r0, r2, #1
 800514c:	ea40 70c3 	orr.w	r0, r0, r3, lsl #31
 8005150:	0859      	lsrs	r1, r3, #1
 8005152:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8005154:	2200      	movs	r2, #0
 8005156:	63bb      	str	r3, [r7, #56]	@ 0x38
 8005158:	63fa      	str	r2, [r7, #60]	@ 0x3c
 800515a:	f04f 0200 	mov.w	r2, #0
 800515e:	f04f 0300 	mov.w	r3, #0
 8005162:	6bbc      	ldr	r4, [r7, #56]	@ 0x38
 8005164:	0023      	movs	r3, r4
 8005166:	2200      	movs	r2, #0
 8005168:	ea80 0402 	eor.w	r4, r0, r2
 800516c:	603c      	str	r4, [r7, #0]
 800516e:	404b      	eors	r3, r1
 8005170:	607b      	str	r3, [r7, #4]
 8005172:	e9d7 3400 	ldrd	r3, r4, [r7]
 8005176:	e9c7 3420 	strd	r3, r4, [r7, #128]	@ 0x80

        ctx->HL[i] = vl;
 800517a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800517c:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8005180:	3309      	adds	r3, #9
 8005182:	00db      	lsls	r3, r3, #3
 8005184:	18d1      	adds	r1, r2, r3
 8005186:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 800518a:	e9c1 2300 	strd	r2, r3, [r1]
        ctx->HH[i] = vh;
 800518e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8005190:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8005194:	3319      	adds	r3, #25
 8005196:	00db      	lsls	r3, r3, #3
 8005198:	18d1      	adds	r1, r2, r3
 800519a:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 800519e:	e9c1 2300 	strd	r2, r3, [r1]
    for( i = 4; i > 0; i >>= 1 )
 80051a2:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 80051a6:	105b      	asrs	r3, r3, #1
 80051a8:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
 80051ac:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 80051b0:	2b00      	cmp	r3, #0
 80051b2:	dc9f      	bgt.n	80050f4 <gcm_gen_table+0x15c>
    }

    for( i = 2; i <= 8; i *= 2 )
 80051b4:	2302      	movs	r3, #2
 80051b6:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
 80051ba:	e05d      	b.n	8005278 <gcm_gen_table+0x2e0>
    {
        uint64_t *HiL = ctx->HL + i, *HiH = ctx->HH + i;
 80051bc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80051be:	f103 0248 	add.w	r2, r3, #72	@ 0x48
 80051c2:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 80051c6:	00db      	lsls	r3, r3, #3
 80051c8:	4413      	add	r3, r2
 80051ca:	667b      	str	r3, [r7, #100]	@ 0x64
 80051cc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80051ce:	f103 02c8 	add.w	r2, r3, #200	@ 0xc8
 80051d2:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 80051d6:	00db      	lsls	r3, r3, #3
 80051d8:	4413      	add	r3, r2
 80051da:	663b      	str	r3, [r7, #96]	@ 0x60
        vh = *HiH;
 80051dc:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80051de:	e9d3 2300 	ldrd	r2, r3, [r3]
 80051e2:	e9c7 2320 	strd	r2, r3, [r7, #128]	@ 0x80
        vl = *HiL;
 80051e6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80051e8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80051ec:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
        for( j = 1; j < i; j++ )
 80051f0:	2301      	movs	r3, #1
 80051f2:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 80051f6:	e034      	b.n	8005262 <gcm_gen_table+0x2ca>
        {
            HiH[j] = vh ^ ctx->HH[j];
 80051f8:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80051fa:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80051fe:	3319      	adds	r3, #25
 8005200:	00db      	lsls	r3, r3, #3
 8005202:	4413      	add	r3, r2
 8005204:	e9d3 0100 	ldrd	r0, r1, [r3]
 8005208:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 800520c:	00db      	lsls	r3, r3, #3
 800520e:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8005210:	18d4      	adds	r4, r2, r3
 8005212:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 8005216:	ea80 0502 	eor.w	r5, r0, r2
 800521a:	633d      	str	r5, [r7, #48]	@ 0x30
 800521c:	404b      	eors	r3, r1
 800521e:	637b      	str	r3, [r7, #52]	@ 0x34
 8005220:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 8005224:	e9c4 2300 	strd	r2, r3, [r4]
            HiL[j] = vl ^ ctx->HL[j];
 8005228:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800522a:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 800522e:	3309      	adds	r3, #9
 8005230:	00db      	lsls	r3, r3, #3
 8005232:	4413      	add	r3, r2
 8005234:	e9d3 0100 	ldrd	r0, r1, [r3]
 8005238:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 800523c:	00db      	lsls	r3, r3, #3
 800523e:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8005240:	18d4      	adds	r4, r2, r3
 8005242:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 8005246:	ea80 0502 	eor.w	r5, r0, r2
 800524a:	62bd      	str	r5, [r7, #40]	@ 0x28
 800524c:	404b      	eors	r3, r1
 800524e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8005250:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 8005254:	e9c4 2300 	strd	r2, r3, [r4]
        for( j = 1; j < i; j++ )
 8005258:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 800525c:	3301      	adds	r3, #1
 800525e:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 8005262:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
 8005266:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 800526a:	429a      	cmp	r2, r3
 800526c:	dbc4      	blt.n	80051f8 <gcm_gen_table+0x260>
    for( i = 2; i <= 8; i *= 2 )
 800526e:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8005272:	005b      	lsls	r3, r3, #1
 8005274:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
 8005278:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 800527c:	2b08      	cmp	r3, #8
 800527e:	dd9d      	ble.n	80051bc <gcm_gen_table+0x224>
        }
    }

    return( 0 );
 8005280:	2300      	movs	r3, #0
}
 8005282:	4618      	mov	r0, r3
 8005284:	3798      	adds	r7, #152	@ 0x98
 8005286:	46bd      	mov	sp, r7
 8005288:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0800528c <mbedtls_gcm_setkey>:

int mbedtls_gcm_setkey( mbedtls_gcm_context *ctx,
                        mbedtls_cipher_id_t cipher,
                        const unsigned char *key,
                        unsigned int keybits )
{
 800528c:	b580      	push	{r7, lr}
 800528e:	b086      	sub	sp, #24
 8005290:	af00      	add	r7, sp, #0
 8005292:	60f8      	str	r0, [r7, #12]
 8005294:	607a      	str	r2, [r7, #4]
 8005296:	603b      	str	r3, [r7, #0]
 8005298:	460b      	mov	r3, r1
 800529a:	72fb      	strb	r3, [r7, #11]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 800529c:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 80052a0:	617b      	str	r3, [r7, #20]

    GCM_VALIDATE_RET( ctx != NULL );
    GCM_VALIDATE_RET( key != NULL );
    GCM_VALIDATE_RET( keybits == 128 || keybits == 192 || keybits == 256 );

    cipher_info = mbedtls_cipher_info_from_values( cipher, keybits,
 80052a2:	6839      	ldr	r1, [r7, #0]
 80052a4:	7afb      	ldrb	r3, [r7, #11]
 80052a6:	2201      	movs	r2, #1
 80052a8:	4618      	mov	r0, r3
 80052aa:	f7fe fea5 	bl	8003ff8 <mbedtls_cipher_info_from_values>
 80052ae:	6138      	str	r0, [r7, #16]
                                                   MBEDTLS_MODE_ECB );
    if( cipher_info == NULL )
 80052b0:	693b      	ldr	r3, [r7, #16]
 80052b2:	2b00      	cmp	r3, #0
 80052b4:	d102      	bne.n	80052bc <mbedtls_gcm_setkey+0x30>
        return( MBEDTLS_ERR_GCM_BAD_INPUT );
 80052b6:	f06f 0313 	mvn.w	r3, #19
 80052ba:	e02b      	b.n	8005314 <mbedtls_gcm_setkey+0x88>

    if( cipher_info->block_size != 16 )
 80052bc:	693b      	ldr	r3, [r7, #16]
 80052be:	695b      	ldr	r3, [r3, #20]
 80052c0:	2b10      	cmp	r3, #16
 80052c2:	d002      	beq.n	80052ca <mbedtls_gcm_setkey+0x3e>
        return( MBEDTLS_ERR_GCM_BAD_INPUT );
 80052c4:	f06f 0313 	mvn.w	r3, #19
 80052c8:	e024      	b.n	8005314 <mbedtls_gcm_setkey+0x88>

    mbedtls_cipher_free( &ctx->cipher_ctx );
 80052ca:	68fb      	ldr	r3, [r7, #12]
 80052cc:	4618      	mov	r0, r3
 80052ce:	f7fe fec5 	bl	800405c <mbedtls_cipher_free>

    if( ( ret = mbedtls_cipher_setup( &ctx->cipher_ctx, cipher_info ) ) != 0 )
 80052d2:	68fb      	ldr	r3, [r7, #12]
 80052d4:	6939      	ldr	r1, [r7, #16]
 80052d6:	4618      	mov	r0, r3
 80052d8:	f7fe feec 	bl	80040b4 <mbedtls_cipher_setup>
 80052dc:	6178      	str	r0, [r7, #20]
 80052de:	697b      	ldr	r3, [r7, #20]
 80052e0:	2b00      	cmp	r3, #0
 80052e2:	d001      	beq.n	80052e8 <mbedtls_gcm_setkey+0x5c>
        return( ret );
 80052e4:	697b      	ldr	r3, [r7, #20]
 80052e6:	e015      	b.n	8005314 <mbedtls_gcm_setkey+0x88>

    if( ( ret = mbedtls_cipher_setkey( &ctx->cipher_ctx, key, keybits,
 80052e8:	68f8      	ldr	r0, [r7, #12]
 80052ea:	683a      	ldr	r2, [r7, #0]
 80052ec:	2301      	movs	r3, #1
 80052ee:	6879      	ldr	r1, [r7, #4]
 80052f0:	f7fe ff0c 	bl	800410c <mbedtls_cipher_setkey>
 80052f4:	6178      	str	r0, [r7, #20]
 80052f6:	697b      	ldr	r3, [r7, #20]
 80052f8:	2b00      	cmp	r3, #0
 80052fa:	d001      	beq.n	8005300 <mbedtls_gcm_setkey+0x74>
                               MBEDTLS_ENCRYPT ) ) != 0 )
    {
        return( ret );
 80052fc:	697b      	ldr	r3, [r7, #20]
 80052fe:	e009      	b.n	8005314 <mbedtls_gcm_setkey+0x88>
    }

    if( ( ret = gcm_gen_table( ctx ) ) != 0 )
 8005300:	68f8      	ldr	r0, [r7, #12]
 8005302:	f7ff fe49 	bl	8004f98 <gcm_gen_table>
 8005306:	6178      	str	r0, [r7, #20]
 8005308:	697b      	ldr	r3, [r7, #20]
 800530a:	2b00      	cmp	r3, #0
 800530c:	d001      	beq.n	8005312 <mbedtls_gcm_setkey+0x86>
        return( ret );
 800530e:	697b      	ldr	r3, [r7, #20]
 8005310:	e000      	b.n	8005314 <mbedtls_gcm_setkey+0x88>

    return( 0 );
 8005312:	2300      	movs	r3, #0
}
 8005314:	4618      	mov	r0, r3
 8005316:	3718      	adds	r7, #24
 8005318:	46bd      	mov	sp, r7
 800531a:	bd80      	pop	{r7, pc}

0800531c <gcm_mult>:
 * Sets output to x times H using the precomputed tables.
 * x and output are seen as elements of GF(2^128) as in [MGV].
 */
static void gcm_mult( mbedtls_gcm_context *ctx, const unsigned char x[16],
                      unsigned char output[16] )
{
 800531c:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8005320:	b099      	sub	sp, #100	@ 0x64
 8005322:	af00      	add	r7, sp, #0
 8005324:	63f8      	str	r0, [r7, #60]	@ 0x3c
 8005326:	63b9      	str	r1, [r7, #56]	@ 0x38
 8005328:	637a      	str	r2, [r7, #52]	@ 0x34
    int i = 0;
 800532a:	2300      	movs	r3, #0
 800532c:	65fb      	str	r3, [r7, #92]	@ 0x5c
        mbedtls_aesni_gcm_mult( output, x, h );
        return;
    }
#endif /* MBEDTLS_AESNI_C && MBEDTLS_HAVE_X86_64 */

    lo = x[15] & 0xf;
 800532e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8005330:	330f      	adds	r3, #15
 8005332:	781b      	ldrb	r3, [r3, #0]
 8005334:	f003 030f 	and.w	r3, r3, #15
 8005338:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47

    zh = ctx->HH[lo];
 800533c:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 8005340:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8005342:	3319      	adds	r3, #25
 8005344:	00db      	lsls	r3, r3, #3
 8005346:	4413      	add	r3, r2
 8005348:	e9d3 2300 	ldrd	r2, r3, [r3]
 800534c:	e9c7 2314 	strd	r2, r3, [r7, #80]	@ 0x50
    zl = ctx->HL[lo];
 8005350:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 8005354:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8005356:	3309      	adds	r3, #9
 8005358:	00db      	lsls	r3, r3, #3
 800535a:	4413      	add	r3, r2
 800535c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005360:	e9c7 2312 	strd	r2, r3, [r7, #72]	@ 0x48

    for( i = 15; i >= 0; i-- )
 8005364:	230f      	movs	r3, #15
 8005366:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8005368:	e0e6      	b.n	8005538 <gcm_mult+0x21c>
    {
        lo = x[i] & 0xf;
 800536a:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 800536c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800536e:	4413      	add	r3, r2
 8005370:	781b      	ldrb	r3, [r3, #0]
 8005372:	f003 030f 	and.w	r3, r3, #15
 8005376:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
        hi = ( x[i] >> 4 ) & 0xf;
 800537a:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 800537c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800537e:	4413      	add	r3, r2
 8005380:	781b      	ldrb	r3, [r3, #0]
 8005382:	091b      	lsrs	r3, r3, #4
 8005384:	f887 3046 	strb.w	r3, [r7, #70]	@ 0x46

        if( i != 15 )
 8005388:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800538a:	2b0f      	cmp	r3, #15
 800538c:	d068      	beq.n	8005460 <gcm_mult+0x144>
        {
            rem = (unsigned char) zl & 0xf;
 800538e:	f897 3048 	ldrb.w	r3, [r7, #72]	@ 0x48
 8005392:	f003 030f 	and.w	r3, r3, #15
 8005396:	f887 3045 	strb.w	r3, [r7, #69]	@ 0x45
            zl = ( zh << 60 ) | ( zl >> 4 );
 800539a:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	@ 0x50
 800539e:	f04f 0400 	mov.w	r4, #0
 80053a2:	f04f 0500 	mov.w	r5, #0
 80053a6:	0715      	lsls	r5, r2, #28
 80053a8:	2400      	movs	r4, #0
 80053aa:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	@ 0x48
 80053ae:	f04f 0000 	mov.w	r0, #0
 80053b2:	f04f 0100 	mov.w	r1, #0
 80053b6:	0910      	lsrs	r0, r2, #4
 80053b8:	ea40 7003 	orr.w	r0, r0, r3, lsl #28
 80053bc:	0919      	lsrs	r1, r3, #4
 80053be:	ea44 0300 	orr.w	r3, r4, r0
 80053c2:	62bb      	str	r3, [r7, #40]	@ 0x28
 80053c4:	ea45 0301 	orr.w	r3, r5, r1
 80053c8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80053ca:	e9d7 340a 	ldrd	r3, r4, [r7, #40]	@ 0x28
 80053ce:	e9c7 3412 	strd	r3, r4, [r7, #72]	@ 0x48
            zh = ( zh >> 4 );
 80053d2:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	@ 0x50
 80053d6:	f04f 0000 	mov.w	r0, #0
 80053da:	f04f 0100 	mov.w	r1, #0
 80053de:	0910      	lsrs	r0, r2, #4
 80053e0:	ea40 7003 	orr.w	r0, r0, r3, lsl #28
 80053e4:	0919      	lsrs	r1, r3, #4
 80053e6:	e9c7 0114 	strd	r0, r1, [r7, #80]	@ 0x50
            zh ^= (uint64_t) last4[rem] << 48;
 80053ea:	f897 3045 	ldrb.w	r3, [r7, #69]	@ 0x45
 80053ee:	4ab6      	ldr	r2, [pc, #728]	@ (80056c8 <gcm_mult+0x3ac>)
 80053f0:	00db      	lsls	r3, r3, #3
 80053f2:	4413      	add	r3, r2
 80053f4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80053f8:	f04f 0000 	mov.w	r0, #0
 80053fc:	f04f 0100 	mov.w	r1, #0
 8005400:	0411      	lsls	r1, r2, #16
 8005402:	2000      	movs	r0, #0
 8005404:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	@ 0x50
 8005408:	ea82 0400 	eor.w	r4, r2, r0
 800540c:	623c      	str	r4, [r7, #32]
 800540e:	404b      	eors	r3, r1
 8005410:	627b      	str	r3, [r7, #36]	@ 0x24
 8005412:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
 8005416:	e9c7 3414 	strd	r3, r4, [r7, #80]	@ 0x50
            zh ^= ctx->HH[lo];
 800541a:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 800541e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8005420:	3319      	adds	r3, #25
 8005422:	00db      	lsls	r3, r3, #3
 8005424:	4413      	add	r3, r2
 8005426:	e9d3 0100 	ldrd	r0, r1, [r3]
 800542a:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	@ 0x50
 800542e:	ea82 0400 	eor.w	r4, r2, r0
 8005432:	61bc      	str	r4, [r7, #24]
 8005434:	404b      	eors	r3, r1
 8005436:	61fb      	str	r3, [r7, #28]
 8005438:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 800543c:	e9c7 3414 	strd	r3, r4, [r7, #80]	@ 0x50
            zl ^= ctx->HL[lo];
 8005440:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 8005444:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8005446:	3309      	adds	r3, #9
 8005448:	00db      	lsls	r3, r3, #3
 800544a:	4413      	add	r3, r2
 800544c:	e9d3 0100 	ldrd	r0, r1, [r3]
 8005450:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	@ 0x48
 8005454:	ea82 0800 	eor.w	r8, r2, r0
 8005458:	ea83 0901 	eor.w	r9, r3, r1
 800545c:	e9c7 8912 	strd	r8, r9, [r7, #72]	@ 0x48

        }

        rem = (unsigned char) zl & 0xf;
 8005460:	f897 3048 	ldrb.w	r3, [r7, #72]	@ 0x48
 8005464:	f003 030f 	and.w	r3, r3, #15
 8005468:	f887 3045 	strb.w	r3, [r7, #69]	@ 0x45
        zl = ( zh << 60 ) | ( zl >> 4 );
 800546c:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	@ 0x50
 8005470:	f04f 0400 	mov.w	r4, #0
 8005474:	f04f 0500 	mov.w	r5, #0
 8005478:	0715      	lsls	r5, r2, #28
 800547a:	2400      	movs	r4, #0
 800547c:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	@ 0x48
 8005480:	f04f 0000 	mov.w	r0, #0
 8005484:	f04f 0100 	mov.w	r1, #0
 8005488:	0910      	lsrs	r0, r2, #4
 800548a:	ea40 7003 	orr.w	r0, r0, r3, lsl #28
 800548e:	0919      	lsrs	r1, r3, #4
 8005490:	ea44 0300 	orr.w	r3, r4, r0
 8005494:	613b      	str	r3, [r7, #16]
 8005496:	ea45 0301 	orr.w	r3, r5, r1
 800549a:	617b      	str	r3, [r7, #20]
 800549c:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 80054a0:	e9c7 3412 	strd	r3, r4, [r7, #72]	@ 0x48
        zh = ( zh >> 4 );
 80054a4:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	@ 0x50
 80054a8:	f04f 0000 	mov.w	r0, #0
 80054ac:	f04f 0100 	mov.w	r1, #0
 80054b0:	0910      	lsrs	r0, r2, #4
 80054b2:	ea40 7003 	orr.w	r0, r0, r3, lsl #28
 80054b6:	0919      	lsrs	r1, r3, #4
 80054b8:	e9c7 0114 	strd	r0, r1, [r7, #80]	@ 0x50
        zh ^= (uint64_t) last4[rem] << 48;
 80054bc:	f897 3045 	ldrb.w	r3, [r7, #69]	@ 0x45
 80054c0:	4a81      	ldr	r2, [pc, #516]	@ (80056c8 <gcm_mult+0x3ac>)
 80054c2:	00db      	lsls	r3, r3, #3
 80054c4:	4413      	add	r3, r2
 80054c6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80054ca:	f04f 0000 	mov.w	r0, #0
 80054ce:	f04f 0100 	mov.w	r1, #0
 80054d2:	0411      	lsls	r1, r2, #16
 80054d4:	2000      	movs	r0, #0
 80054d6:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	@ 0x50
 80054da:	ea82 0400 	eor.w	r4, r2, r0
 80054de:	60bc      	str	r4, [r7, #8]
 80054e0:	404b      	eors	r3, r1
 80054e2:	60fb      	str	r3, [r7, #12]
 80054e4:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 80054e8:	e9c7 3414 	strd	r3, r4, [r7, #80]	@ 0x50
        zh ^= ctx->HH[hi];
 80054ec:	f897 3046 	ldrb.w	r3, [r7, #70]	@ 0x46
 80054f0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80054f2:	3319      	adds	r3, #25
 80054f4:	00db      	lsls	r3, r3, #3
 80054f6:	4413      	add	r3, r2
 80054f8:	e9d3 0100 	ldrd	r0, r1, [r3]
 80054fc:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	@ 0x50
 8005500:	ea82 0400 	eor.w	r4, r2, r0
 8005504:	603c      	str	r4, [r7, #0]
 8005506:	404b      	eors	r3, r1
 8005508:	607b      	str	r3, [r7, #4]
 800550a:	e9d7 3400 	ldrd	r3, r4, [r7]
 800550e:	e9c7 3414 	strd	r3, r4, [r7, #80]	@ 0x50
        zl ^= ctx->HL[hi];
 8005512:	f897 3046 	ldrb.w	r3, [r7, #70]	@ 0x46
 8005516:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8005518:	3309      	adds	r3, #9
 800551a:	00db      	lsls	r3, r3, #3
 800551c:	4413      	add	r3, r2
 800551e:	e9d3 0100 	ldrd	r0, r1, [r3]
 8005522:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	@ 0x48
 8005526:	ea82 0a00 	eor.w	sl, r2, r0
 800552a:	ea83 0b01 	eor.w	fp, r3, r1
 800552e:	e9c7 ab12 	strd	sl, fp, [r7, #72]	@ 0x48
    for( i = 15; i >= 0; i-- )
 8005532:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8005534:	3b01      	subs	r3, #1
 8005536:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8005538:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800553a:	2b00      	cmp	r3, #0
 800553c:	f6bf af15 	bge.w	800536a <gcm_mult+0x4e>
    }

    PUT_UINT32_BE( zh >> 32, output, 0 );
 8005540:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
 8005544:	f04f 0200 	mov.w	r2, #0
 8005548:	f04f 0300 	mov.w	r3, #0
 800554c:	0e0a      	lsrs	r2, r1, #24
 800554e:	2300      	movs	r3, #0
 8005550:	b2d2      	uxtb	r2, r2
 8005552:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8005554:	701a      	strb	r2, [r3, #0]
 8005556:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
 800555a:	f04f 0200 	mov.w	r2, #0
 800555e:	f04f 0300 	mov.w	r3, #0
 8005562:	0c0a      	lsrs	r2, r1, #16
 8005564:	2300      	movs	r3, #0
 8005566:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8005568:	3101      	adds	r1, #1
 800556a:	b2d3      	uxtb	r3, r2
 800556c:	700b      	strb	r3, [r1, #0]
 800556e:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
 8005572:	f04f 0200 	mov.w	r2, #0
 8005576:	f04f 0300 	mov.w	r3, #0
 800557a:	0a0a      	lsrs	r2, r1, #8
 800557c:	2300      	movs	r3, #0
 800557e:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8005580:	3102      	adds	r1, #2
 8005582:	b2d3      	uxtb	r3, r2
 8005584:	700b      	strb	r3, [r1, #0]
 8005586:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
 800558a:	f04f 0200 	mov.w	r2, #0
 800558e:	f04f 0300 	mov.w	r3, #0
 8005592:	000a      	movs	r2, r1
 8005594:	2300      	movs	r3, #0
 8005596:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8005598:	3103      	adds	r1, #3
 800559a:	b2d3      	uxtb	r3, r2
 800559c:	700b      	strb	r3, [r1, #0]
    PUT_UINT32_BE( zh, output, 4 );
 800559e:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
 80055a2:	f04f 0200 	mov.w	r2, #0
 80055a6:	f04f 0300 	mov.w	r3, #0
 80055aa:	0e02      	lsrs	r2, r0, #24
 80055ac:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80055b0:	0e0b      	lsrs	r3, r1, #24
 80055b2:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 80055b4:	3104      	adds	r1, #4
 80055b6:	b2d3      	uxtb	r3, r2
 80055b8:	700b      	strb	r3, [r1, #0]
 80055ba:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
 80055be:	f04f 0200 	mov.w	r2, #0
 80055c2:	f04f 0300 	mov.w	r3, #0
 80055c6:	0c02      	lsrs	r2, r0, #16
 80055c8:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 80055cc:	0c0b      	lsrs	r3, r1, #16
 80055ce:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 80055d0:	3105      	adds	r1, #5
 80055d2:	b2d3      	uxtb	r3, r2
 80055d4:	700b      	strb	r3, [r1, #0]
 80055d6:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
 80055da:	f04f 0200 	mov.w	r2, #0
 80055de:	f04f 0300 	mov.w	r3, #0
 80055e2:	0a02      	lsrs	r2, r0, #8
 80055e4:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 80055e8:	0a0b      	lsrs	r3, r1, #8
 80055ea:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 80055ec:	3106      	adds	r1, #6
 80055ee:	b2d3      	uxtb	r3, r2
 80055f0:	700b      	strb	r3, [r1, #0]
 80055f2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80055f4:	3307      	adds	r3, #7
 80055f6:	f897 2050 	ldrb.w	r2, [r7, #80]	@ 0x50
 80055fa:	701a      	strb	r2, [r3, #0]
    PUT_UINT32_BE( zl >> 32, output, 8 );
 80055fc:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
 8005600:	f04f 0200 	mov.w	r2, #0
 8005604:	f04f 0300 	mov.w	r3, #0
 8005608:	0e0a      	lsrs	r2, r1, #24
 800560a:	2300      	movs	r3, #0
 800560c:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 800560e:	3108      	adds	r1, #8
 8005610:	b2d3      	uxtb	r3, r2
 8005612:	700b      	strb	r3, [r1, #0]
 8005614:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
 8005618:	f04f 0200 	mov.w	r2, #0
 800561c:	f04f 0300 	mov.w	r3, #0
 8005620:	0c0a      	lsrs	r2, r1, #16
 8005622:	2300      	movs	r3, #0
 8005624:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8005626:	3109      	adds	r1, #9
 8005628:	b2d3      	uxtb	r3, r2
 800562a:	700b      	strb	r3, [r1, #0]
 800562c:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
 8005630:	f04f 0200 	mov.w	r2, #0
 8005634:	f04f 0300 	mov.w	r3, #0
 8005638:	0a0a      	lsrs	r2, r1, #8
 800563a:	2300      	movs	r3, #0
 800563c:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 800563e:	310a      	adds	r1, #10
 8005640:	b2d3      	uxtb	r3, r2
 8005642:	700b      	strb	r3, [r1, #0]
 8005644:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
 8005648:	f04f 0200 	mov.w	r2, #0
 800564c:	f04f 0300 	mov.w	r3, #0
 8005650:	000a      	movs	r2, r1
 8005652:	2300      	movs	r3, #0
 8005654:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8005656:	310b      	adds	r1, #11
 8005658:	b2d3      	uxtb	r3, r2
 800565a:	700b      	strb	r3, [r1, #0]
    PUT_UINT32_BE( zl, output, 12 );
 800565c:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
 8005660:	f04f 0200 	mov.w	r2, #0
 8005664:	f04f 0300 	mov.w	r3, #0
 8005668:	0e02      	lsrs	r2, r0, #24
 800566a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800566e:	0e0b      	lsrs	r3, r1, #24
 8005670:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8005672:	310c      	adds	r1, #12
 8005674:	b2d3      	uxtb	r3, r2
 8005676:	700b      	strb	r3, [r1, #0]
 8005678:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
 800567c:	f04f 0200 	mov.w	r2, #0
 8005680:	f04f 0300 	mov.w	r3, #0
 8005684:	0c02      	lsrs	r2, r0, #16
 8005686:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800568a:	0c0b      	lsrs	r3, r1, #16
 800568c:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 800568e:	310d      	adds	r1, #13
 8005690:	b2d3      	uxtb	r3, r2
 8005692:	700b      	strb	r3, [r1, #0]
 8005694:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
 8005698:	f04f 0200 	mov.w	r2, #0
 800569c:	f04f 0300 	mov.w	r3, #0
 80056a0:	0a02      	lsrs	r2, r0, #8
 80056a2:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 80056a6:	0a0b      	lsrs	r3, r1, #8
 80056a8:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 80056aa:	310e      	adds	r1, #14
 80056ac:	b2d3      	uxtb	r3, r2
 80056ae:	700b      	strb	r3, [r1, #0]
 80056b0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80056b2:	330f      	adds	r3, #15
 80056b4:	f897 2048 	ldrb.w	r2, [r7, #72]	@ 0x48
 80056b8:	701a      	strb	r2, [r3, #0]
}
 80056ba:	bf00      	nop
 80056bc:	3764      	adds	r7, #100	@ 0x64
 80056be:	46bd      	mov	sp, r7
 80056c0:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 80056c4:	4770      	bx	lr
 80056c6:	bf00      	nop
 80056c8:	08016bc8 	.word	0x08016bc8

080056cc <mbedtls_gcm_starts>:

int mbedtls_gcm_starts( mbedtls_gcm_context *ctx,
                        int mode,
                        const unsigned char *iv, size_t iv_len )
{
 80056cc:	b5b0      	push	{r4, r5, r7, lr}
 80056ce:	b090      	sub	sp, #64	@ 0x40
 80056d0:	af02      	add	r7, sp, #8
 80056d2:	60f8      	str	r0, [r7, #12]
 80056d4:	60b9      	str	r1, [r7, #8]
 80056d6:	607a      	str	r2, [r7, #4]
 80056d8:	603b      	str	r3, [r7, #0]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 80056da:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 80056de:	62fb      	str	r3, [r7, #44]	@ 0x2c
    unsigned char work_buf[16];
    size_t i;
    const unsigned char *p;
    size_t use_len, olen = 0;
 80056e0:	2300      	movs	r3, #0
 80056e2:	617b      	str	r3, [r7, #20]
    GCM_VALIDATE_RET( ctx != NULL );
    GCM_VALIDATE_RET( iv != NULL );

    /* IV is limited to 2^64 bits, so 2^61 bytes */
    /* IV is not allowed to be zero length */
    if( iv_len == 0 || (uint64_t) iv_len >> 61 != 0 )
 80056e4:	683b      	ldr	r3, [r7, #0]
 80056e6:	2b00      	cmp	r3, #0
 80056e8:	d00b      	beq.n	8005702 <mbedtls_gcm_starts+0x36>
 80056ea:	683b      	ldr	r3, [r7, #0]
 80056ec:	2200      	movs	r2, #0
 80056ee:	461c      	mov	r4, r3
 80056f0:	4615      	mov	r5, r2
 80056f2:	f04f 0200 	mov.w	r2, #0
 80056f6:	f04f 0300 	mov.w	r3, #0
 80056fa:	0f6a      	lsrs	r2, r5, #29
 80056fc:	2300      	movs	r3, #0
 80056fe:	4313      	orrs	r3, r2
 8005700:	d002      	beq.n	8005708 <mbedtls_gcm_starts+0x3c>
        return( MBEDTLS_ERR_GCM_BAD_INPUT );
 8005702:	f06f 0313 	mvn.w	r3, #19
 8005706:	e0c6      	b.n	8005896 <mbedtls_gcm_starts+0x1ca>

    memset( ctx->y, 0x00, sizeof(ctx->y) );
 8005708:	68fb      	ldr	r3, [r7, #12]
 800570a:	f503 73b4 	add.w	r3, r3, #360	@ 0x168
 800570e:	2210      	movs	r2, #16
 8005710:	2100      	movs	r1, #0
 8005712:	4618      	mov	r0, r3
 8005714:	f00f fe98 	bl	8015448 <memset>
    memset( ctx->buf, 0x00, sizeof(ctx->buf) );
 8005718:	68fb      	ldr	r3, [r7, #12]
 800571a:	f503 73bc 	add.w	r3, r3, #376	@ 0x178
 800571e:	2210      	movs	r2, #16
 8005720:	2100      	movs	r1, #0
 8005722:	4618      	mov	r0, r3
 8005724:	f00f fe90 	bl	8015448 <memset>

    ctx->mode = mode;
 8005728:	68fb      	ldr	r3, [r7, #12]
 800572a:	68ba      	ldr	r2, [r7, #8]
 800572c:	f8c3 2188 	str.w	r2, [r3, #392]	@ 0x188
    ctx->len = 0;
 8005730:	68f9      	ldr	r1, [r7, #12]
 8005732:	f04f 0200 	mov.w	r2, #0
 8005736:	f04f 0300 	mov.w	r3, #0
 800573a:	e9c1 2352 	strd	r2, r3, [r1, #328]	@ 0x148
    ctx->add_len = 0;
 800573e:	68f9      	ldr	r1, [r7, #12]
 8005740:	f04f 0200 	mov.w	r2, #0
 8005744:	f04f 0300 	mov.w	r3, #0
 8005748:	e9c1 2354 	strd	r2, r3, [r1, #336]	@ 0x150

    if( iv_len == 12 )
 800574c:	683b      	ldr	r3, [r7, #0]
 800574e:	2b0c      	cmp	r3, #12
 8005750:	d10c      	bne.n	800576c <mbedtls_gcm_starts+0xa0>
    {
        memcpy( ctx->y, iv, iv_len );
 8005752:	68fb      	ldr	r3, [r7, #12]
 8005754:	f503 73b4 	add.w	r3, r3, #360	@ 0x168
 8005758:	683a      	ldr	r2, [r7, #0]
 800575a:	6879      	ldr	r1, [r7, #4]
 800575c:	4618      	mov	r0, r3
 800575e:	f00f fefe 	bl	801555e <memcpy>
        ctx->y[15] = 1;
 8005762:	68fb      	ldr	r3, [r7, #12]
 8005764:	2201      	movs	r2, #1
 8005766:	f883 2177 	strb.w	r2, [r3, #375]	@ 0x177
 800576a:	e07f      	b.n	800586c <mbedtls_gcm_starts+0x1a0>
    }
    else
    {
        memset( work_buf, 0x00, 16 );
 800576c:	f107 0318 	add.w	r3, r7, #24
 8005770:	2210      	movs	r2, #16
 8005772:	2100      	movs	r1, #0
 8005774:	4618      	mov	r0, r3
 8005776:	f00f fe67 	bl	8015448 <memset>
        PUT_UINT32_BE( iv_len * 8, work_buf, 12 );
 800577a:	683b      	ldr	r3, [r7, #0]
 800577c:	00db      	lsls	r3, r3, #3
 800577e:	0e1b      	lsrs	r3, r3, #24
 8005780:	b2db      	uxtb	r3, r3
 8005782:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
 8005786:	683b      	ldr	r3, [r7, #0]
 8005788:	00db      	lsls	r3, r3, #3
 800578a:	0c1b      	lsrs	r3, r3, #16
 800578c:	b2db      	uxtb	r3, r3
 800578e:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
 8005792:	683b      	ldr	r3, [r7, #0]
 8005794:	00db      	lsls	r3, r3, #3
 8005796:	0a1b      	lsrs	r3, r3, #8
 8005798:	b2db      	uxtb	r3, r3
 800579a:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
 800579e:	683b      	ldr	r3, [r7, #0]
 80057a0:	b2db      	uxtb	r3, r3
 80057a2:	00db      	lsls	r3, r3, #3
 80057a4:	b2db      	uxtb	r3, r3
 80057a6:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        p = iv;
 80057aa:	687b      	ldr	r3, [r7, #4]
 80057ac:	633b      	str	r3, [r7, #48]	@ 0x30
        while( iv_len > 0 )
 80057ae:	e033      	b.n	8005818 <mbedtls_gcm_starts+0x14c>
        {
            use_len = ( iv_len < 16 ) ? iv_len : 16;
 80057b0:	683b      	ldr	r3, [r7, #0]
 80057b2:	2b10      	cmp	r3, #16
 80057b4:	bf28      	it	cs
 80057b6:	2310      	movcs	r3, #16
 80057b8:	62bb      	str	r3, [r7, #40]	@ 0x28

            for( i = 0; i < use_len; i++ )
 80057ba:	2300      	movs	r3, #0
 80057bc:	637b      	str	r3, [r7, #52]	@ 0x34
 80057be:	e015      	b.n	80057ec <mbedtls_gcm_starts+0x120>
                ctx->y[i] ^= p[i];
 80057c0:	68fa      	ldr	r2, [r7, #12]
 80057c2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80057c4:	4413      	add	r3, r2
 80057c6:	f503 73b4 	add.w	r3, r3, #360	@ 0x168
 80057ca:	781a      	ldrb	r2, [r3, #0]
 80057cc:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 80057ce:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80057d0:	440b      	add	r3, r1
 80057d2:	781b      	ldrb	r3, [r3, #0]
 80057d4:	4053      	eors	r3, r2
 80057d6:	b2d9      	uxtb	r1, r3
 80057d8:	68fa      	ldr	r2, [r7, #12]
 80057da:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80057dc:	4413      	add	r3, r2
 80057de:	f503 73b4 	add.w	r3, r3, #360	@ 0x168
 80057e2:	460a      	mov	r2, r1
 80057e4:	701a      	strb	r2, [r3, #0]
            for( i = 0; i < use_len; i++ )
 80057e6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80057e8:	3301      	adds	r3, #1
 80057ea:	637b      	str	r3, [r7, #52]	@ 0x34
 80057ec:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80057ee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80057f0:	429a      	cmp	r2, r3
 80057f2:	d3e5      	bcc.n	80057c0 <mbedtls_gcm_starts+0xf4>

            gcm_mult( ctx, ctx->y, ctx->y );
 80057f4:	68fb      	ldr	r3, [r7, #12]
 80057f6:	f503 71b4 	add.w	r1, r3, #360	@ 0x168
 80057fa:	68fb      	ldr	r3, [r7, #12]
 80057fc:	f503 73b4 	add.w	r3, r3, #360	@ 0x168
 8005800:	461a      	mov	r2, r3
 8005802:	68f8      	ldr	r0, [r7, #12]
 8005804:	f7ff fd8a 	bl	800531c <gcm_mult>

            iv_len -= use_len;
 8005808:	683a      	ldr	r2, [r7, #0]
 800580a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800580c:	1ad3      	subs	r3, r2, r3
 800580e:	603b      	str	r3, [r7, #0]
            p += use_len;
 8005810:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8005812:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8005814:	4413      	add	r3, r2
 8005816:	633b      	str	r3, [r7, #48]	@ 0x30
        while( iv_len > 0 )
 8005818:	683b      	ldr	r3, [r7, #0]
 800581a:	2b00      	cmp	r3, #0
 800581c:	d1c8      	bne.n	80057b0 <mbedtls_gcm_starts+0xe4>
        }

        for( i = 0; i < 16; i++ )
 800581e:	2300      	movs	r3, #0
 8005820:	637b      	str	r3, [r7, #52]	@ 0x34
 8005822:	e016      	b.n	8005852 <mbedtls_gcm_starts+0x186>
            ctx->y[i] ^= work_buf[i];
 8005824:	68fa      	ldr	r2, [r7, #12]
 8005826:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8005828:	4413      	add	r3, r2
 800582a:	f503 73b4 	add.w	r3, r3, #360	@ 0x168
 800582e:	781a      	ldrb	r2, [r3, #0]
 8005830:	f107 0118 	add.w	r1, r7, #24
 8005834:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8005836:	440b      	add	r3, r1
 8005838:	781b      	ldrb	r3, [r3, #0]
 800583a:	4053      	eors	r3, r2
 800583c:	b2d9      	uxtb	r1, r3
 800583e:	68fa      	ldr	r2, [r7, #12]
 8005840:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8005842:	4413      	add	r3, r2
 8005844:	f503 73b4 	add.w	r3, r3, #360	@ 0x168
 8005848:	460a      	mov	r2, r1
 800584a:	701a      	strb	r2, [r3, #0]
        for( i = 0; i < 16; i++ )
 800584c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800584e:	3301      	adds	r3, #1
 8005850:	637b      	str	r3, [r7, #52]	@ 0x34
 8005852:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8005854:	2b0f      	cmp	r3, #15
 8005856:	d9e5      	bls.n	8005824 <mbedtls_gcm_starts+0x158>

        gcm_mult( ctx, ctx->y, ctx->y );
 8005858:	68fb      	ldr	r3, [r7, #12]
 800585a:	f503 71b4 	add.w	r1, r3, #360	@ 0x168
 800585e:	68fb      	ldr	r3, [r7, #12]
 8005860:	f503 73b4 	add.w	r3, r3, #360	@ 0x168
 8005864:	461a      	mov	r2, r3
 8005866:	68f8      	ldr	r0, [r7, #12]
 8005868:	f7ff fd58 	bl	800531c <gcm_mult>
    }

    if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, ctx->y, 16,
 800586c:	68f8      	ldr	r0, [r7, #12]
 800586e:	68fb      	ldr	r3, [r7, #12]
 8005870:	f503 71b4 	add.w	r1, r3, #360	@ 0x168
                                       ctx->base_ectr, &olen ) ) != 0 )
 8005874:	68fb      	ldr	r3, [r7, #12]
 8005876:	f503 72ac 	add.w	r2, r3, #344	@ 0x158
    if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, ctx->y, 16,
 800587a:	f107 0314 	add.w	r3, r7, #20
 800587e:	9300      	str	r3, [sp, #0]
 8005880:	4613      	mov	r3, r2
 8005882:	2210      	movs	r2, #16
 8005884:	f7fe fc9c 	bl	80041c0 <mbedtls_cipher_update>
 8005888:	62f8      	str	r0, [r7, #44]	@ 0x2c
 800588a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800588c:	2b00      	cmp	r3, #0
 800588e:	d001      	beq.n	8005894 <mbedtls_gcm_starts+0x1c8>
    {
        return( ret );
 8005890:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8005892:	e000      	b.n	8005896 <mbedtls_gcm_starts+0x1ca>
    }

    return( 0 );
 8005894:	2300      	movs	r3, #0
}
 8005896:	4618      	mov	r0, r3
 8005898:	3738      	adds	r7, #56	@ 0x38
 800589a:	46bd      	mov	sp, r7
 800589c:	bdb0      	pop	{r4, r5, r7, pc}

0800589e <mbedtls_gcm_update_ad>:
 *     * len > 0 && len % 16 == 0:      the authentication tag is correct if
 *                                      the data ends now.
 */
int mbedtls_gcm_update_ad( mbedtls_gcm_context *ctx,
                           const unsigned char *add, size_t add_len )
{
 800589e:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80058a2:	b08c      	sub	sp, #48	@ 0x30
 80058a4:	af00      	add	r7, sp, #0
 80058a6:	61f8      	str	r0, [r7, #28]
 80058a8:	61b9      	str	r1, [r7, #24]
 80058aa:	617a      	str	r2, [r7, #20]
    size_t use_len, i, offset;

    GCM_VALIDATE_RET( add_len == 0 || add != NULL );

    /* IV is limited to 2^64 bits, so 2^61 bytes */
    if( (uint64_t) add_len >> 61 != 0 )
 80058ac:	697b      	ldr	r3, [r7, #20]
 80058ae:	2200      	movs	r2, #0
 80058b0:	60bb      	str	r3, [r7, #8]
 80058b2:	60fa      	str	r2, [r7, #12]
 80058b4:	f04f 0200 	mov.w	r2, #0
 80058b8:	f04f 0300 	mov.w	r3, #0
 80058bc:	68f9      	ldr	r1, [r7, #12]
 80058be:	0f4a      	lsrs	r2, r1, #29
 80058c0:	2300      	movs	r3, #0
 80058c2:	4313      	orrs	r3, r2
 80058c4:	d002      	beq.n	80058cc <mbedtls_gcm_update_ad+0x2e>
        return( MBEDTLS_ERR_GCM_BAD_INPUT );
 80058c6:	f06f 0313 	mvn.w	r3, #19
 80058ca:	e0bc      	b.n	8005a46 <mbedtls_gcm_update_ad+0x1a8>

    offset = ctx->add_len % 16;
 80058cc:	69fb      	ldr	r3, [r7, #28]
 80058ce:	e9d3 2354 	ldrd	r2, r3, [r3, #336]	@ 0x150
 80058d2:	4613      	mov	r3, r2
 80058d4:	f003 030f 	and.w	r3, r3, #15
 80058d8:	623b      	str	r3, [r7, #32]
    p = add;
 80058da:	69bb      	ldr	r3, [r7, #24]
 80058dc:	62fb      	str	r3, [r7, #44]	@ 0x2c

    if( offset != 0 )
 80058de:	6a3b      	ldr	r3, [r7, #32]
 80058e0:	2b00      	cmp	r3, #0
 80058e2:	d051      	beq.n	8005988 <mbedtls_gcm_update_ad+0xea>
    {
        use_len = 16 - offset;
 80058e4:	6a3b      	ldr	r3, [r7, #32]
 80058e6:	f1c3 0310 	rsb	r3, r3, #16
 80058ea:	62bb      	str	r3, [r7, #40]	@ 0x28
        if( use_len > add_len )
 80058ec:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80058ee:	697b      	ldr	r3, [r7, #20]
 80058f0:	429a      	cmp	r2, r3
 80058f2:	d901      	bls.n	80058f8 <mbedtls_gcm_update_ad+0x5a>
            use_len = add_len;
 80058f4:	697b      	ldr	r3, [r7, #20]
 80058f6:	62bb      	str	r3, [r7, #40]	@ 0x28

        for( i = 0; i < use_len; i++ )
 80058f8:	2300      	movs	r3, #0
 80058fa:	627b      	str	r3, [r7, #36]	@ 0x24
 80058fc:	e017      	b.n	800592e <mbedtls_gcm_update_ad+0x90>
            ctx->buf[i+offset] ^= p[i];
 80058fe:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8005900:	6a3b      	ldr	r3, [r7, #32]
 8005902:	4413      	add	r3, r2
 8005904:	69fa      	ldr	r2, [r7, #28]
 8005906:	4413      	add	r3, r2
 8005908:	f893 1178 	ldrb.w	r1, [r3, #376]	@ 0x178
 800590c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800590e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8005910:	4413      	add	r3, r2
 8005912:	781a      	ldrb	r2, [r3, #0]
 8005914:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8005916:	6a3b      	ldr	r3, [r7, #32]
 8005918:	4403      	add	r3, r0
 800591a:	404a      	eors	r2, r1
 800591c:	b2d1      	uxtb	r1, r2
 800591e:	69fa      	ldr	r2, [r7, #28]
 8005920:	4413      	add	r3, r2
 8005922:	460a      	mov	r2, r1
 8005924:	f883 2178 	strb.w	r2, [r3, #376]	@ 0x178
        for( i = 0; i < use_len; i++ )
 8005928:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800592a:	3301      	adds	r3, #1
 800592c:	627b      	str	r3, [r7, #36]	@ 0x24
 800592e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8005930:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8005932:	429a      	cmp	r2, r3
 8005934:	d3e3      	bcc.n	80058fe <mbedtls_gcm_update_ad+0x60>

        if( offset + use_len == 16 )
 8005936:	6a3a      	ldr	r2, [r7, #32]
 8005938:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800593a:	4413      	add	r3, r2
 800593c:	2b10      	cmp	r3, #16
 800593e:	d109      	bne.n	8005954 <mbedtls_gcm_update_ad+0xb6>
            gcm_mult( ctx, ctx->buf, ctx->buf );
 8005940:	69fb      	ldr	r3, [r7, #28]
 8005942:	f503 71bc 	add.w	r1, r3, #376	@ 0x178
 8005946:	69fb      	ldr	r3, [r7, #28]
 8005948:	f503 73bc 	add.w	r3, r3, #376	@ 0x178
 800594c:	461a      	mov	r2, r3
 800594e:	69f8      	ldr	r0, [r7, #28]
 8005950:	f7ff fce4 	bl	800531c <gcm_mult>

        ctx->add_len += use_len;
 8005954:	69fb      	ldr	r3, [r7, #28]
 8005956:	e9d3 2354 	ldrd	r2, r3, [r3, #336]	@ 0x150
 800595a:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800595c:	2000      	movs	r0, #0
 800595e:	4688      	mov	r8, r1
 8005960:	4681      	mov	r9, r0
 8005962:	eb12 0108 	adds.w	r1, r2, r8
 8005966:	6039      	str	r1, [r7, #0]
 8005968:	eb43 0309 	adc.w	r3, r3, r9
 800596c:	607b      	str	r3, [r7, #4]
 800596e:	69fb      	ldr	r3, [r7, #28]
 8005970:	e9d7 1200 	ldrd	r1, r2, [r7]
 8005974:	e9c3 1254 	strd	r1, r2, [r3, #336]	@ 0x150
        add_len -= use_len;
 8005978:	697a      	ldr	r2, [r7, #20]
 800597a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800597c:	1ad3      	subs	r3, r2, r3
 800597e:	617b      	str	r3, [r7, #20]
        p += use_len;
 8005980:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8005982:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8005984:	4413      	add	r3, r2
 8005986:	62fb      	str	r3, [r7, #44]	@ 0x2c
    }

    ctx->add_len += add_len;
 8005988:	69fb      	ldr	r3, [r7, #28]
 800598a:	e9d3 2354 	ldrd	r2, r3, [r3, #336]	@ 0x150
 800598e:	6979      	ldr	r1, [r7, #20]
 8005990:	2000      	movs	r0, #0
 8005992:	460c      	mov	r4, r1
 8005994:	4605      	mov	r5, r0
 8005996:	eb12 0a04 	adds.w	sl, r2, r4
 800599a:	eb43 0b05 	adc.w	fp, r3, r5
 800599e:	69fb      	ldr	r3, [r7, #28]
 80059a0:	e9c3 ab54 	strd	sl, fp, [r3, #336]	@ 0x150

    while( add_len >= 16 )
 80059a4:	e02b      	b.n	80059fe <mbedtls_gcm_update_ad+0x160>
    {
        for( i = 0; i < 16; i++ )
 80059a6:	2300      	movs	r3, #0
 80059a8:	627b      	str	r3, [r7, #36]	@ 0x24
 80059aa:	e015      	b.n	80059d8 <mbedtls_gcm_update_ad+0x13a>
            ctx->buf[i] ^= p[i];
 80059ac:	69fa      	ldr	r2, [r7, #28]
 80059ae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80059b0:	4413      	add	r3, r2
 80059b2:	f503 73bc 	add.w	r3, r3, #376	@ 0x178
 80059b6:	781a      	ldrb	r2, [r3, #0]
 80059b8:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 80059ba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80059bc:	440b      	add	r3, r1
 80059be:	781b      	ldrb	r3, [r3, #0]
 80059c0:	4053      	eors	r3, r2
 80059c2:	b2d9      	uxtb	r1, r3
 80059c4:	69fa      	ldr	r2, [r7, #28]
 80059c6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80059c8:	4413      	add	r3, r2
 80059ca:	f503 73bc 	add.w	r3, r3, #376	@ 0x178
 80059ce:	460a      	mov	r2, r1
 80059d0:	701a      	strb	r2, [r3, #0]
        for( i = 0; i < 16; i++ )
 80059d2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80059d4:	3301      	adds	r3, #1
 80059d6:	627b      	str	r3, [r7, #36]	@ 0x24
 80059d8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80059da:	2b0f      	cmp	r3, #15
 80059dc:	d9e6      	bls.n	80059ac <mbedtls_gcm_update_ad+0x10e>

        gcm_mult( ctx, ctx->buf, ctx->buf );
 80059de:	69fb      	ldr	r3, [r7, #28]
 80059e0:	f503 71bc 	add.w	r1, r3, #376	@ 0x178
 80059e4:	69fb      	ldr	r3, [r7, #28]
 80059e6:	f503 73bc 	add.w	r3, r3, #376	@ 0x178
 80059ea:	461a      	mov	r2, r3
 80059ec:	69f8      	ldr	r0, [r7, #28]
 80059ee:	f7ff fc95 	bl	800531c <gcm_mult>

        add_len -= 16;
 80059f2:	697b      	ldr	r3, [r7, #20]
 80059f4:	3b10      	subs	r3, #16
 80059f6:	617b      	str	r3, [r7, #20]
        p += 16;
 80059f8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80059fa:	3310      	adds	r3, #16
 80059fc:	62fb      	str	r3, [r7, #44]	@ 0x2c
    while( add_len >= 16 )
 80059fe:	697b      	ldr	r3, [r7, #20]
 8005a00:	2b0f      	cmp	r3, #15
 8005a02:	d8d0      	bhi.n	80059a6 <mbedtls_gcm_update_ad+0x108>
    }

    if( add_len > 0 )
 8005a04:	697b      	ldr	r3, [r7, #20]
 8005a06:	2b00      	cmp	r3, #0
 8005a08:	d01c      	beq.n	8005a44 <mbedtls_gcm_update_ad+0x1a6>
    {
        for( i = 0; i < add_len; i++ )
 8005a0a:	2300      	movs	r3, #0
 8005a0c:	627b      	str	r3, [r7, #36]	@ 0x24
 8005a0e:	e015      	b.n	8005a3c <mbedtls_gcm_update_ad+0x19e>
            ctx->buf[i] ^= p[i];
 8005a10:	69fa      	ldr	r2, [r7, #28]
 8005a12:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8005a14:	4413      	add	r3, r2
 8005a16:	f503 73bc 	add.w	r3, r3, #376	@ 0x178
 8005a1a:	781a      	ldrb	r2, [r3, #0]
 8005a1c:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8005a1e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8005a20:	440b      	add	r3, r1
 8005a22:	781b      	ldrb	r3, [r3, #0]
 8005a24:	4053      	eors	r3, r2
 8005a26:	b2d9      	uxtb	r1, r3
 8005a28:	69fa      	ldr	r2, [r7, #28]
 8005a2a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8005a2c:	4413      	add	r3, r2
 8005a2e:	f503 73bc 	add.w	r3, r3, #376	@ 0x178
 8005a32:	460a      	mov	r2, r1
 8005a34:	701a      	strb	r2, [r3, #0]
        for( i = 0; i < add_len; i++ )
 8005a36:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8005a38:	3301      	adds	r3, #1
 8005a3a:	627b      	str	r3, [r7, #36]	@ 0x24
 8005a3c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8005a3e:	697b      	ldr	r3, [r7, #20]
 8005a40:	429a      	cmp	r2, r3
 8005a42:	d3e5      	bcc.n	8005a10 <mbedtls_gcm_update_ad+0x172>
    }

    return( 0 );
 8005a44:	2300      	movs	r3, #0
}
 8005a46:	4618      	mov	r0, r3
 8005a48:	3730      	adds	r7, #48	@ 0x30
 8005a4a:	46bd      	mov	sp, r7
 8005a4c:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08005a50 <gcm_incr>:

/* Increment the counter. */
static void gcm_incr( unsigned char y[16] )
{
 8005a50:	b480      	push	{r7}
 8005a52:	b085      	sub	sp, #20
 8005a54:	af00      	add	r7, sp, #0
 8005a56:	6078      	str	r0, [r7, #4]
    size_t i;
    for( i = 16; i > 12; i-- )
 8005a58:	2310      	movs	r3, #16
 8005a5a:	60fb      	str	r3, [r7, #12]
 8005a5c:	e00d      	b.n	8005a7a <gcm_incr+0x2a>
        if( ++y[i - 1] != 0 )
 8005a5e:	68fb      	ldr	r3, [r7, #12]
 8005a60:	3b01      	subs	r3, #1
 8005a62:	687a      	ldr	r2, [r7, #4]
 8005a64:	4413      	add	r3, r2
 8005a66:	781a      	ldrb	r2, [r3, #0]
 8005a68:	3201      	adds	r2, #1
 8005a6a:	b2d2      	uxtb	r2, r2
 8005a6c:	701a      	strb	r2, [r3, #0]
 8005a6e:	781b      	ldrb	r3, [r3, #0]
 8005a70:	2b00      	cmp	r3, #0
 8005a72:	d106      	bne.n	8005a82 <gcm_incr+0x32>
    for( i = 16; i > 12; i-- )
 8005a74:	68fb      	ldr	r3, [r7, #12]
 8005a76:	3b01      	subs	r3, #1
 8005a78:	60fb      	str	r3, [r7, #12]
 8005a7a:	68fb      	ldr	r3, [r7, #12]
 8005a7c:	2b0c      	cmp	r3, #12
 8005a7e:	d8ee      	bhi.n	8005a5e <gcm_incr+0xe>
            break;
}
 8005a80:	e000      	b.n	8005a84 <gcm_incr+0x34>
            break;
 8005a82:	bf00      	nop
}
 8005a84:	bf00      	nop
 8005a86:	3714      	adds	r7, #20
 8005a88:	46bd      	mov	sp, r7
 8005a8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005a8e:	4770      	bx	lr

08005a90 <gcm_mask>:
static int gcm_mask( mbedtls_gcm_context *ctx,
                     unsigned char ectr[16],
                     size_t offset, size_t use_len,
                     const unsigned char *input,
                     unsigned char *output )
{
 8005a90:	b580      	push	{r7, lr}
 8005a92:	b08a      	sub	sp, #40	@ 0x28
 8005a94:	af02      	add	r7, sp, #8
 8005a96:	60f8      	str	r0, [r7, #12]
 8005a98:	60b9      	str	r1, [r7, #8]
 8005a9a:	607a      	str	r2, [r7, #4]
 8005a9c:	603b      	str	r3, [r7, #0]
    size_t i;
    size_t olen = 0;
 8005a9e:	2300      	movs	r3, #0
 8005aa0:	617b      	str	r3, [r7, #20]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 8005aa2:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8005aa6:	61bb      	str	r3, [r7, #24]

    if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, ctx->y, 16, ectr,
 8005aa8:	68f8      	ldr	r0, [r7, #12]
 8005aaa:	68fb      	ldr	r3, [r7, #12]
 8005aac:	f503 71b4 	add.w	r1, r3, #360	@ 0x168
 8005ab0:	f107 0314 	add.w	r3, r7, #20
 8005ab4:	9300      	str	r3, [sp, #0]
 8005ab6:	68bb      	ldr	r3, [r7, #8]
 8005ab8:	2210      	movs	r2, #16
 8005aba:	f7fe fb81 	bl	80041c0 <mbedtls_cipher_update>
 8005abe:	61b8      	str	r0, [r7, #24]
 8005ac0:	69bb      	ldr	r3, [r7, #24]
 8005ac2:	2b00      	cmp	r3, #0
 8005ac4:	d005      	beq.n	8005ad2 <gcm_mask+0x42>
                                       &olen ) ) != 0 )
    {
        mbedtls_platform_zeroize( ectr, 16 );
 8005ac6:	2110      	movs	r1, #16
 8005ac8:	68b8      	ldr	r0, [r7, #8]
 8005aca:	f000 fb89 	bl	80061e0 <mbedtls_platform_zeroize>
        return( ret );
 8005ace:	69bb      	ldr	r3, [r7, #24]
 8005ad0:	e04e      	b.n	8005b70 <gcm_mask+0xe0>
    }

    for( i = 0; i < use_len; i++ )
 8005ad2:	2300      	movs	r3, #0
 8005ad4:	61fb      	str	r3, [r7, #28]
 8005ad6:	e046      	b.n	8005b66 <gcm_mask+0xd6>
    {
        if( ctx->mode == MBEDTLS_GCM_DECRYPT )
 8005ad8:	68fb      	ldr	r3, [r7, #12]
 8005ada:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
 8005ade:	2b00      	cmp	r3, #0
 8005ae0:	d114      	bne.n	8005b0c <gcm_mask+0x7c>
            ctx->buf[offset + i] ^= input[i];
 8005ae2:	687a      	ldr	r2, [r7, #4]
 8005ae4:	69fb      	ldr	r3, [r7, #28]
 8005ae6:	4413      	add	r3, r2
 8005ae8:	68fa      	ldr	r2, [r7, #12]
 8005aea:	4413      	add	r3, r2
 8005aec:	f893 1178 	ldrb.w	r1, [r3, #376]	@ 0x178
 8005af0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8005af2:	69fb      	ldr	r3, [r7, #28]
 8005af4:	4413      	add	r3, r2
 8005af6:	781a      	ldrb	r2, [r3, #0]
 8005af8:	6878      	ldr	r0, [r7, #4]
 8005afa:	69fb      	ldr	r3, [r7, #28]
 8005afc:	4403      	add	r3, r0
 8005afe:	404a      	eors	r2, r1
 8005b00:	b2d1      	uxtb	r1, r2
 8005b02:	68fa      	ldr	r2, [r7, #12]
 8005b04:	4413      	add	r3, r2
 8005b06:	460a      	mov	r2, r1
 8005b08:	f883 2178 	strb.w	r2, [r3, #376]	@ 0x178
        output[i] = ectr[offset + i] ^ input[i];
 8005b0c:	687a      	ldr	r2, [r7, #4]
 8005b0e:	69fb      	ldr	r3, [r7, #28]
 8005b10:	4413      	add	r3, r2
 8005b12:	68ba      	ldr	r2, [r7, #8]
 8005b14:	4413      	add	r3, r2
 8005b16:	7819      	ldrb	r1, [r3, #0]
 8005b18:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8005b1a:	69fb      	ldr	r3, [r7, #28]
 8005b1c:	4413      	add	r3, r2
 8005b1e:	781a      	ldrb	r2, [r3, #0]
 8005b20:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8005b22:	69fb      	ldr	r3, [r7, #28]
 8005b24:	4403      	add	r3, r0
 8005b26:	404a      	eors	r2, r1
 8005b28:	b2d2      	uxtb	r2, r2
 8005b2a:	701a      	strb	r2, [r3, #0]
        if( ctx->mode == MBEDTLS_GCM_ENCRYPT )
 8005b2c:	68fb      	ldr	r3, [r7, #12]
 8005b2e:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
 8005b32:	2b01      	cmp	r3, #1
 8005b34:	d114      	bne.n	8005b60 <gcm_mask+0xd0>
            ctx->buf[offset + i] ^= output[i];
 8005b36:	687a      	ldr	r2, [r7, #4]
 8005b38:	69fb      	ldr	r3, [r7, #28]
 8005b3a:	4413      	add	r3, r2
 8005b3c:	68fa      	ldr	r2, [r7, #12]
 8005b3e:	4413      	add	r3, r2
 8005b40:	f893 1178 	ldrb.w	r1, [r3, #376]	@ 0x178
 8005b44:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8005b46:	69fb      	ldr	r3, [r7, #28]
 8005b48:	4413      	add	r3, r2
 8005b4a:	781a      	ldrb	r2, [r3, #0]
 8005b4c:	6878      	ldr	r0, [r7, #4]
 8005b4e:	69fb      	ldr	r3, [r7, #28]
 8005b50:	4403      	add	r3, r0
 8005b52:	404a      	eors	r2, r1
 8005b54:	b2d1      	uxtb	r1, r2
 8005b56:	68fa      	ldr	r2, [r7, #12]
 8005b58:	4413      	add	r3, r2
 8005b5a:	460a      	mov	r2, r1
 8005b5c:	f883 2178 	strb.w	r2, [r3, #376]	@ 0x178
    for( i = 0; i < use_len; i++ )
 8005b60:	69fb      	ldr	r3, [r7, #28]
 8005b62:	3301      	adds	r3, #1
 8005b64:	61fb      	str	r3, [r7, #28]
 8005b66:	69fa      	ldr	r2, [r7, #28]
 8005b68:	683b      	ldr	r3, [r7, #0]
 8005b6a:	429a      	cmp	r2, r3
 8005b6c:	d3b4      	bcc.n	8005ad8 <gcm_mask+0x48>
    }
    return( 0 );
 8005b6e:	2300      	movs	r3, #0
}
 8005b70:	4618      	mov	r0, r3
 8005b72:	3720      	adds	r7, #32
 8005b74:	46bd      	mov	sp, r7
 8005b76:	bd80      	pop	{r7, pc}

08005b78 <mbedtls_gcm_update>:

int mbedtls_gcm_update( mbedtls_gcm_context *ctx,
                        const unsigned char *input, size_t input_length,
                        unsigned char *output, size_t output_size,
                        size_t *output_length )
{
 8005b78:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8005b7c:	b09c      	sub	sp, #112	@ 0x70
 8005b7e:	af02      	add	r7, sp, #8
 8005b80:	63f8      	str	r0, [r7, #60]	@ 0x3c
 8005b82:	63b9      	str	r1, [r7, #56]	@ 0x38
 8005b84:	637a      	str	r2, [r7, #52]	@ 0x34
 8005b86:	633b      	str	r3, [r7, #48]	@ 0x30
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 8005b88:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8005b8c:	65bb      	str	r3, [r7, #88]	@ 0x58
    const unsigned char *p = input;
 8005b8e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8005b90:	667b      	str	r3, [r7, #100]	@ 0x64
    unsigned char *out_p = output;
 8005b92:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8005b94:	663b      	str	r3, [r7, #96]	@ 0x60
    size_t offset;
    unsigned char ectr[16];

    if( output_size < input_length )
 8005b96:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 8005b9a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8005b9c:	429a      	cmp	r2, r3
 8005b9e:	d202      	bcs.n	8005ba6 <mbedtls_gcm_update+0x2e>
        return( MBEDTLS_ERR_GCM_BAD_INPUT );
 8005ba0:	f06f 0313 	mvn.w	r3, #19
 8005ba4:	e113      	b.n	8005dce <mbedtls_gcm_update+0x256>
    GCM_VALIDATE_RET( output_length != NULL );
    *output_length = input_length;
 8005ba6:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 8005baa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8005bac:	6013      	str	r3, [r2, #0]

    /* Exit early if input_length==0 so that we don't do any pointer arithmetic
     * on a potentially null pointer.
     * Returning early also means that the last partial block of AD remains
     * untouched for mbedtls_gcm_finish */
    if( input_length == 0 )
 8005bae:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8005bb0:	2b00      	cmp	r3, #0
 8005bb2:	d101      	bne.n	8005bb8 <mbedtls_gcm_update+0x40>
        return( 0 );
 8005bb4:	2300      	movs	r3, #0
 8005bb6:	e10a      	b.n	8005dce <mbedtls_gcm_update+0x256>

    GCM_VALIDATE_RET( ctx != NULL );
    GCM_VALIDATE_RET( input != NULL );
    GCM_VALIDATE_RET( output != NULL );

    if( output > input && (size_t) ( output - input ) < input_length )
 8005bb8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8005bba:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8005bbc:	429a      	cmp	r2, r3
 8005bbe:	d909      	bls.n	8005bd4 <mbedtls_gcm_update+0x5c>
 8005bc0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8005bc2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8005bc4:	1ad3      	subs	r3, r2, r3
 8005bc6:	461a      	mov	r2, r3
 8005bc8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8005bca:	4293      	cmp	r3, r2
 8005bcc:	d902      	bls.n	8005bd4 <mbedtls_gcm_update+0x5c>
        return( MBEDTLS_ERR_GCM_BAD_INPUT );
 8005bce:	f06f 0313 	mvn.w	r3, #19
 8005bd2:	e0fc      	b.n	8005dce <mbedtls_gcm_update+0x256>

    /* Total length is restricted to 2^39 - 256 bits, ie 2^36 - 2^5 bytes
     * Also check for possible overflow */
    if( ctx->len + input_length < ctx->len ||
 8005bd4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8005bd6:	e9d3 2352 	ldrd	r2, r3, [r3, #328]	@ 0x148
 8005bda:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8005bdc:	2000      	movs	r0, #0
 8005bde:	62b9      	str	r1, [r7, #40]	@ 0x28
 8005be0:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8005be2:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8005be4:	1854      	adds	r4, r2, r1
 8005be6:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8005be8:	eb43 0101 	adc.w	r1, r3, r1
 8005bec:	460d      	mov	r5, r1
 8005bee:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8005bf0:	e9d3 2352 	ldrd	r2, r3, [r3, #328]	@ 0x148
 8005bf4:	4294      	cmp	r4, r2
 8005bf6:	eb75 0303 	sbcs.w	r3, r5, r3
 8005bfa:	d313      	bcc.n	8005c24 <mbedtls_gcm_update+0xac>
        (uint64_t) ctx->len + input_length > 0xFFFFFFFE0ull )
 8005bfc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8005bfe:	e9d3 2352 	ldrd	r2, r3, [r3, #328]	@ 0x148
 8005c02:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8005c04:	2000      	movs	r0, #0
 8005c06:	6239      	str	r1, [r7, #32]
 8005c08:	6278      	str	r0, [r7, #36]	@ 0x24
 8005c0a:	e9d7 4508 	ldrd	r4, r5, [r7, #32]
 8005c0e:	4621      	mov	r1, r4
 8005c10:	eb12 0801 	adds.w	r8, r2, r1
 8005c14:	4629      	mov	r1, r5
 8005c16:	eb43 0901 	adc.w	r9, r3, r1
    if( ctx->len + input_length < ctx->len ||
 8005c1a:	f118 0f1f 	cmn.w	r8, #31
 8005c1e:	f179 030f 	sbcs.w	r3, r9, #15
 8005c22:	d302      	bcc.n	8005c2a <mbedtls_gcm_update+0xb2>
    {
        return( MBEDTLS_ERR_GCM_BAD_INPUT );
 8005c24:	f06f 0313 	mvn.w	r3, #19
 8005c28:	e0d1      	b.n	8005dce <mbedtls_gcm_update+0x256>
    }

    if( ctx->len == 0 && ctx->add_len % 16 != 0 )
 8005c2a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8005c2c:	e9d3 2352 	ldrd	r2, r3, [r3, #328]	@ 0x148
 8005c30:	4313      	orrs	r3, r2
 8005c32:	d113      	bne.n	8005c5c <mbedtls_gcm_update+0xe4>
 8005c34:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8005c36:	e9d3 2354 	ldrd	r2, r3, [r3, #336]	@ 0x150
 8005c3a:	f002 0a0f 	and.w	sl, r2, #15
 8005c3e:	f04f 0b00 	mov.w	fp, #0
 8005c42:	ea5a 030b 	orrs.w	r3, sl, fp
 8005c46:	d009      	beq.n	8005c5c <mbedtls_gcm_update+0xe4>
    {
        gcm_mult( ctx, ctx->buf, ctx->buf );
 8005c48:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8005c4a:	f503 71bc 	add.w	r1, r3, #376	@ 0x178
 8005c4e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8005c50:	f503 73bc 	add.w	r3, r3, #376	@ 0x178
 8005c54:	461a      	mov	r2, r3
 8005c56:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8005c58:	f7ff fb60 	bl	800531c <gcm_mult>
    }

    offset = ctx->len % 16;
 8005c5c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8005c5e:	e9d3 2352 	ldrd	r2, r3, [r3, #328]	@ 0x148
 8005c62:	4613      	mov	r3, r2
 8005c64:	f003 030f 	and.w	r3, r3, #15
 8005c68:	657b      	str	r3, [r7, #84]	@ 0x54
    if( offset != 0 )
 8005c6a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8005c6c:	2b00      	cmp	r3, #0
 8005c6e:	d04a      	beq.n	8005d06 <mbedtls_gcm_update+0x18e>
    {
        size_t use_len = 16 - offset;
 8005c70:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8005c72:	f1c3 0310 	rsb	r3, r3, #16
 8005c76:	65fb      	str	r3, [r7, #92]	@ 0x5c
        if( use_len > input_length )
 8005c78:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8005c7a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8005c7c:	429a      	cmp	r2, r3
 8005c7e:	d901      	bls.n	8005c84 <mbedtls_gcm_update+0x10c>
            use_len = input_length;
 8005c80:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8005c82:	65fb      	str	r3, [r7, #92]	@ 0x5c

        if( ( ret = gcm_mask( ctx, ectr, offset, use_len, p, out_p ) ) != 0 )
 8005c84:	f107 0144 	add.w	r1, r7, #68	@ 0x44
 8005c88:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8005c8a:	9301      	str	r3, [sp, #4]
 8005c8c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8005c8e:	9300      	str	r3, [sp, #0]
 8005c90:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8005c92:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8005c94:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8005c96:	f7ff fefb 	bl	8005a90 <gcm_mask>
 8005c9a:	65b8      	str	r0, [r7, #88]	@ 0x58
 8005c9c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8005c9e:	2b00      	cmp	r3, #0
 8005ca0:	d001      	beq.n	8005ca6 <mbedtls_gcm_update+0x12e>
            return( ret );
 8005ca2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8005ca4:	e093      	b.n	8005dce <mbedtls_gcm_update+0x256>

        if( offset + use_len == 16 )
 8005ca6:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8005ca8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8005caa:	4413      	add	r3, r2
 8005cac:	2b10      	cmp	r3, #16
 8005cae:	d109      	bne.n	8005cc4 <mbedtls_gcm_update+0x14c>
            gcm_mult( ctx, ctx->buf, ctx->buf );
 8005cb0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8005cb2:	f503 71bc 	add.w	r1, r3, #376	@ 0x178
 8005cb6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8005cb8:	f503 73bc 	add.w	r3, r3, #376	@ 0x178
 8005cbc:	461a      	mov	r2, r3
 8005cbe:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8005cc0:	f7ff fb2c 	bl	800531c <gcm_mult>

        ctx->len += use_len;
 8005cc4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8005cc6:	e9d3 2352 	ldrd	r2, r3, [r3, #328]	@ 0x148
 8005cca:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8005ccc:	2000      	movs	r0, #0
 8005cce:	61b9      	str	r1, [r7, #24]
 8005cd0:	61f8      	str	r0, [r7, #28]
 8005cd2:	e9d7 4506 	ldrd	r4, r5, [r7, #24]
 8005cd6:	4621      	mov	r1, r4
 8005cd8:	1851      	adds	r1, r2, r1
 8005cda:	6139      	str	r1, [r7, #16]
 8005cdc:	4629      	mov	r1, r5
 8005cde:	eb43 0101 	adc.w	r1, r3, r1
 8005ce2:	6179      	str	r1, [r7, #20]
 8005ce4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8005ce6:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 8005cea:	e9c3 1252 	strd	r1, r2, [r3, #328]	@ 0x148
        input_length -= use_len;
 8005cee:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8005cf0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8005cf2:	1ad3      	subs	r3, r2, r3
 8005cf4:	637b      	str	r3, [r7, #52]	@ 0x34
        p += use_len;
 8005cf6:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8005cf8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8005cfa:	4413      	add	r3, r2
 8005cfc:	667b      	str	r3, [r7, #100]	@ 0x64
        out_p += use_len;
 8005cfe:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8005d00:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8005d02:	4413      	add	r3, r2
 8005d04:	663b      	str	r3, [r7, #96]	@ 0x60
    }

    ctx->len += input_length;
 8005d06:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8005d08:	e9d3 2352 	ldrd	r2, r3, [r3, #328]	@ 0x148
 8005d0c:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8005d0e:	2000      	movs	r0, #0
 8005d10:	60b9      	str	r1, [r7, #8]
 8005d12:	60f8      	str	r0, [r7, #12]
 8005d14:	e9d7 4502 	ldrd	r4, r5, [r7, #8]
 8005d18:	4621      	mov	r1, r4
 8005d1a:	1851      	adds	r1, r2, r1
 8005d1c:	6039      	str	r1, [r7, #0]
 8005d1e:	4629      	mov	r1, r5
 8005d20:	eb43 0101 	adc.w	r1, r3, r1
 8005d24:	6079      	str	r1, [r7, #4]
 8005d26:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8005d28:	e9d7 1200 	ldrd	r1, r2, [r7]
 8005d2c:	e9c3 1252 	strd	r1, r2, [r3, #328]	@ 0x148

    while( input_length >= 16 )
 8005d30:	e029      	b.n	8005d86 <mbedtls_gcm_update+0x20e>
    {
        gcm_incr( ctx->y );
 8005d32:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8005d34:	f503 73b4 	add.w	r3, r3, #360	@ 0x168
 8005d38:	4618      	mov	r0, r3
 8005d3a:	f7ff fe89 	bl	8005a50 <gcm_incr>
        if( ( ret = gcm_mask( ctx, ectr, 0, 16, p, out_p ) ) != 0 )
 8005d3e:	f107 0144 	add.w	r1, r7, #68	@ 0x44
 8005d42:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8005d44:	9301      	str	r3, [sp, #4]
 8005d46:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8005d48:	9300      	str	r3, [sp, #0]
 8005d4a:	2310      	movs	r3, #16
 8005d4c:	2200      	movs	r2, #0
 8005d4e:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8005d50:	f7ff fe9e 	bl	8005a90 <gcm_mask>
 8005d54:	65b8      	str	r0, [r7, #88]	@ 0x58
 8005d56:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8005d58:	2b00      	cmp	r3, #0
 8005d5a:	d001      	beq.n	8005d60 <mbedtls_gcm_update+0x1e8>
            return( ret );
 8005d5c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8005d5e:	e036      	b.n	8005dce <mbedtls_gcm_update+0x256>

        gcm_mult( ctx, ctx->buf, ctx->buf );
 8005d60:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8005d62:	f503 71bc 	add.w	r1, r3, #376	@ 0x178
 8005d66:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8005d68:	f503 73bc 	add.w	r3, r3, #376	@ 0x178
 8005d6c:	461a      	mov	r2, r3
 8005d6e:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8005d70:	f7ff fad4 	bl	800531c <gcm_mult>

        input_length -= 16;
 8005d74:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8005d76:	3b10      	subs	r3, #16
 8005d78:	637b      	str	r3, [r7, #52]	@ 0x34
        p += 16;
 8005d7a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8005d7c:	3310      	adds	r3, #16
 8005d7e:	667b      	str	r3, [r7, #100]	@ 0x64
        out_p += 16;
 8005d80:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8005d82:	3310      	adds	r3, #16
 8005d84:	663b      	str	r3, [r7, #96]	@ 0x60
    while( input_length >= 16 )
 8005d86:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8005d88:	2b0f      	cmp	r3, #15
 8005d8a:	d8d2      	bhi.n	8005d32 <mbedtls_gcm_update+0x1ba>
    }

    if( input_length > 0 )
 8005d8c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8005d8e:	2b00      	cmp	r3, #0
 8005d90:	d016      	beq.n	8005dc0 <mbedtls_gcm_update+0x248>
    {
        gcm_incr( ctx->y );
 8005d92:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8005d94:	f503 73b4 	add.w	r3, r3, #360	@ 0x168
 8005d98:	4618      	mov	r0, r3
 8005d9a:	f7ff fe59 	bl	8005a50 <gcm_incr>
        if( ( ret = gcm_mask( ctx, ectr, 0, input_length, p, out_p ) ) != 0 )
 8005d9e:	f107 0144 	add.w	r1, r7, #68	@ 0x44
 8005da2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8005da4:	9301      	str	r3, [sp, #4]
 8005da6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8005da8:	9300      	str	r3, [sp, #0]
 8005daa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8005dac:	2200      	movs	r2, #0
 8005dae:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8005db0:	f7ff fe6e 	bl	8005a90 <gcm_mask>
 8005db4:	65b8      	str	r0, [r7, #88]	@ 0x58
 8005db6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8005db8:	2b00      	cmp	r3, #0
 8005dba:	d001      	beq.n	8005dc0 <mbedtls_gcm_update+0x248>
            return( ret );
 8005dbc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8005dbe:	e006      	b.n	8005dce <mbedtls_gcm_update+0x256>
    }

    mbedtls_platform_zeroize( ectr, sizeof( ectr ) );
 8005dc0:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 8005dc4:	2110      	movs	r1, #16
 8005dc6:	4618      	mov	r0, r3
 8005dc8:	f000 fa0a 	bl	80061e0 <mbedtls_platform_zeroize>
    return( 0 );
 8005dcc:	2300      	movs	r3, #0
}
 8005dce:	4618      	mov	r0, r3
 8005dd0:	3768      	adds	r7, #104	@ 0x68
 8005dd2:	46bd      	mov	sp, r7
 8005dd4:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08005dd8 <mbedtls_gcm_finish>:

int mbedtls_gcm_finish( mbedtls_gcm_context *ctx,
                        unsigned char *output, size_t output_size,
                        size_t *output_length,
                        unsigned char *tag, size_t tag_len )
{
 8005dd8:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 8005ddc:	b08e      	sub	sp, #56	@ 0x38
 8005dde:	af00      	add	r7, sp, #0
 8005de0:	60f8      	str	r0, [r7, #12]
 8005de2:	60b9      	str	r1, [r7, #8]
 8005de4:	607a      	str	r2, [r7, #4]
 8005de6:	603b      	str	r3, [r7, #0]

    /* We never pass any output in finish(). The output parameter exists only
     * for the sake of alternative implementations. */
    (void) output;
    (void) output_size;
    *output_length = 0;
 8005de8:	683b      	ldr	r3, [r7, #0]
 8005dea:	2200      	movs	r2, #0
 8005dec:	601a      	str	r2, [r3, #0]

    orig_len = ctx->len * 8;
 8005dee:	68fb      	ldr	r3, [r7, #12]
 8005df0:	e9d3 0152 	ldrd	r0, r1, [r3, #328]	@ 0x148
 8005df4:	f04f 0200 	mov.w	r2, #0
 8005df8:	f04f 0300 	mov.w	r3, #0
 8005dfc:	00cb      	lsls	r3, r1, #3
 8005dfe:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 8005e02:	00c2      	lsls	r2, r0, #3
 8005e04:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
    orig_add_len = ctx->add_len * 8;
 8005e08:	68fb      	ldr	r3, [r7, #12]
 8005e0a:	e9d3 0154 	ldrd	r0, r1, [r3, #336]	@ 0x150
 8005e0e:	f04f 0200 	mov.w	r2, #0
 8005e12:	f04f 0300 	mov.w	r3, #0
 8005e16:	00cb      	lsls	r3, r1, #3
 8005e18:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 8005e1c:	00c2      	lsls	r2, r0, #3
 8005e1e:	e9c7 2308 	strd	r2, r3, [r7, #32]

    if( ctx->len == 0 && ctx->add_len % 16 != 0 )
 8005e22:	68fb      	ldr	r3, [r7, #12]
 8005e24:	e9d3 2352 	ldrd	r2, r3, [r3, #328]	@ 0x148
 8005e28:	4313      	orrs	r3, r2
 8005e2a:	d113      	bne.n	8005e54 <mbedtls_gcm_finish+0x7c>
 8005e2c:	68fb      	ldr	r3, [r7, #12]
 8005e2e:	e9d3 2354 	ldrd	r2, r3, [r3, #336]	@ 0x150
 8005e32:	f002 080f 	and.w	r8, r2, #15
 8005e36:	f04f 0900 	mov.w	r9, #0
 8005e3a:	ea58 0309 	orrs.w	r3, r8, r9
 8005e3e:	d009      	beq.n	8005e54 <mbedtls_gcm_finish+0x7c>
    {
        gcm_mult( ctx, ctx->buf, ctx->buf );
 8005e40:	68fb      	ldr	r3, [r7, #12]
 8005e42:	f503 71bc 	add.w	r1, r3, #376	@ 0x178
 8005e46:	68fb      	ldr	r3, [r7, #12]
 8005e48:	f503 73bc 	add.w	r3, r3, #376	@ 0x178
 8005e4c:	461a      	mov	r2, r3
 8005e4e:	68f8      	ldr	r0, [r7, #12]
 8005e50:	f7ff fa64 	bl	800531c <gcm_mult>
    }

    if( tag_len > 16 || tag_len < 4 )
 8005e54:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8005e56:	2b10      	cmp	r3, #16
 8005e58:	d802      	bhi.n	8005e60 <mbedtls_gcm_finish+0x88>
 8005e5a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8005e5c:	2b03      	cmp	r3, #3
 8005e5e:	d802      	bhi.n	8005e66 <mbedtls_gcm_finish+0x8e>
        return( MBEDTLS_ERR_GCM_BAD_INPUT );
 8005e60:	f06f 0313 	mvn.w	r3, #19
 8005e64:	e10a      	b.n	800607c <mbedtls_gcm_finish+0x2a4>

    if( ctx->len % 16 != 0 )
 8005e66:	68fb      	ldr	r3, [r7, #12]
 8005e68:	e9d3 2352 	ldrd	r2, r3, [r3, #328]	@ 0x148
 8005e6c:	f002 040f 	and.w	r4, r2, #15
 8005e70:	2500      	movs	r5, #0
 8005e72:	ea54 0305 	orrs.w	r3, r4, r5
 8005e76:	d009      	beq.n	8005e8c <mbedtls_gcm_finish+0xb4>
        gcm_mult( ctx, ctx->buf, ctx->buf );
 8005e78:	68fb      	ldr	r3, [r7, #12]
 8005e7a:	f503 71bc 	add.w	r1, r3, #376	@ 0x178
 8005e7e:	68fb      	ldr	r3, [r7, #12]
 8005e80:	f503 73bc 	add.w	r3, r3, #376	@ 0x178
 8005e84:	461a      	mov	r2, r3
 8005e86:	68f8      	ldr	r0, [r7, #12]
 8005e88:	f7ff fa48 	bl	800531c <gcm_mult>

    memcpy( tag, ctx->base_ectr, tag_len );
 8005e8c:	68fb      	ldr	r3, [r7, #12]
 8005e8e:	f503 73ac 	add.w	r3, r3, #344	@ 0x158
 8005e92:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8005e94:	4619      	mov	r1, r3
 8005e96:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8005e98:	f00f fb61 	bl	801555e <memcpy>

    if( orig_len || orig_add_len )
 8005e9c:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 8005ea0:	4313      	orrs	r3, r2
 8005ea2:	d104      	bne.n	8005eae <mbedtls_gcm_finish+0xd6>
 8005ea4:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8005ea8:	4313      	orrs	r3, r2
 8005eaa:	f000 80e6 	beq.w	800607a <mbedtls_gcm_finish+0x2a2>
    {
        memset( work_buf, 0x00, 16 );
 8005eae:	f107 0310 	add.w	r3, r7, #16
 8005eb2:	2210      	movs	r2, #16
 8005eb4:	2100      	movs	r1, #0
 8005eb6:	4618      	mov	r0, r3
 8005eb8:	f00f fac6 	bl	8015448 <memset>

        PUT_UINT32_BE( ( orig_add_len >> 32 ), work_buf, 0  );
 8005ebc:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8005ec0:	f04f 0200 	mov.w	r2, #0
 8005ec4:	f04f 0300 	mov.w	r3, #0
 8005ec8:	0e0a      	lsrs	r2, r1, #24
 8005eca:	2300      	movs	r3, #0
 8005ecc:	b2d3      	uxtb	r3, r2
 8005ece:	743b      	strb	r3, [r7, #16]
 8005ed0:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8005ed4:	f04f 0200 	mov.w	r2, #0
 8005ed8:	f04f 0300 	mov.w	r3, #0
 8005edc:	0c0a      	lsrs	r2, r1, #16
 8005ede:	2300      	movs	r3, #0
 8005ee0:	b2d3      	uxtb	r3, r2
 8005ee2:	747b      	strb	r3, [r7, #17]
 8005ee4:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8005ee8:	f04f 0200 	mov.w	r2, #0
 8005eec:	f04f 0300 	mov.w	r3, #0
 8005ef0:	0a0a      	lsrs	r2, r1, #8
 8005ef2:	2300      	movs	r3, #0
 8005ef4:	b2d3      	uxtb	r3, r2
 8005ef6:	74bb      	strb	r3, [r7, #18]
 8005ef8:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8005efc:	f04f 0200 	mov.w	r2, #0
 8005f00:	f04f 0300 	mov.w	r3, #0
 8005f04:	000a      	movs	r2, r1
 8005f06:	2300      	movs	r3, #0
 8005f08:	b2d3      	uxtb	r3, r2
 8005f0a:	74fb      	strb	r3, [r7, #19]
        PUT_UINT32_BE( ( orig_add_len       ), work_buf, 4  );
 8005f0c:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8005f10:	f04f 0200 	mov.w	r2, #0
 8005f14:	f04f 0300 	mov.w	r3, #0
 8005f18:	0e02      	lsrs	r2, r0, #24
 8005f1a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8005f1e:	0e0b      	lsrs	r3, r1, #24
 8005f20:	b2d3      	uxtb	r3, r2
 8005f22:	753b      	strb	r3, [r7, #20]
 8005f24:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8005f28:	f04f 0200 	mov.w	r2, #0
 8005f2c:	f04f 0300 	mov.w	r3, #0
 8005f30:	0c02      	lsrs	r2, r0, #16
 8005f32:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8005f36:	0c0b      	lsrs	r3, r1, #16
 8005f38:	b2d3      	uxtb	r3, r2
 8005f3a:	757b      	strb	r3, [r7, #21]
 8005f3c:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8005f40:	f04f 0200 	mov.w	r2, #0
 8005f44:	f04f 0300 	mov.w	r3, #0
 8005f48:	0a02      	lsrs	r2, r0, #8
 8005f4a:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 8005f4e:	0a0b      	lsrs	r3, r1, #8
 8005f50:	b2d3      	uxtb	r3, r2
 8005f52:	75bb      	strb	r3, [r7, #22]
 8005f54:	f897 3020 	ldrb.w	r3, [r7, #32]
 8005f58:	75fb      	strb	r3, [r7, #23]
        PUT_UINT32_BE( ( orig_len     >> 32 ), work_buf, 8  );
 8005f5a:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
 8005f5e:	f04f 0200 	mov.w	r2, #0
 8005f62:	f04f 0300 	mov.w	r3, #0
 8005f66:	0e0a      	lsrs	r2, r1, #24
 8005f68:	2300      	movs	r3, #0
 8005f6a:	b2d3      	uxtb	r3, r2
 8005f6c:	763b      	strb	r3, [r7, #24]
 8005f6e:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
 8005f72:	f04f 0200 	mov.w	r2, #0
 8005f76:	f04f 0300 	mov.w	r3, #0
 8005f7a:	0c0a      	lsrs	r2, r1, #16
 8005f7c:	2300      	movs	r3, #0
 8005f7e:	b2d3      	uxtb	r3, r2
 8005f80:	767b      	strb	r3, [r7, #25]
 8005f82:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
 8005f86:	f04f 0200 	mov.w	r2, #0
 8005f8a:	f04f 0300 	mov.w	r3, #0
 8005f8e:	0a0a      	lsrs	r2, r1, #8
 8005f90:	2300      	movs	r3, #0
 8005f92:	b2d3      	uxtb	r3, r2
 8005f94:	76bb      	strb	r3, [r7, #26]
 8005f96:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
 8005f9a:	f04f 0200 	mov.w	r2, #0
 8005f9e:	f04f 0300 	mov.w	r3, #0
 8005fa2:	000a      	movs	r2, r1
 8005fa4:	2300      	movs	r3, #0
 8005fa6:	b2d3      	uxtb	r3, r2
 8005fa8:	76fb      	strb	r3, [r7, #27]
        PUT_UINT32_BE( ( orig_len           ), work_buf, 12 );
 8005faa:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
 8005fae:	f04f 0200 	mov.w	r2, #0
 8005fb2:	f04f 0300 	mov.w	r3, #0
 8005fb6:	0e02      	lsrs	r2, r0, #24
 8005fb8:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8005fbc:	0e0b      	lsrs	r3, r1, #24
 8005fbe:	b2d3      	uxtb	r3, r2
 8005fc0:	773b      	strb	r3, [r7, #28]
 8005fc2:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
 8005fc6:	f04f 0200 	mov.w	r2, #0
 8005fca:	f04f 0300 	mov.w	r3, #0
 8005fce:	0c02      	lsrs	r2, r0, #16
 8005fd0:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8005fd4:	0c0b      	lsrs	r3, r1, #16
 8005fd6:	b2d3      	uxtb	r3, r2
 8005fd8:	777b      	strb	r3, [r7, #29]
 8005fda:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
 8005fde:	f04f 0200 	mov.w	r2, #0
 8005fe2:	f04f 0300 	mov.w	r3, #0
 8005fe6:	0a02      	lsrs	r2, r0, #8
 8005fe8:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 8005fec:	0a0b      	lsrs	r3, r1, #8
 8005fee:	b2d3      	uxtb	r3, r2
 8005ff0:	77bb      	strb	r3, [r7, #30]
 8005ff2:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 8005ff6:	77fb      	strb	r3, [r7, #31]

        for( i = 0; i < 16; i++ )
 8005ff8:	2300      	movs	r3, #0
 8005ffa:	637b      	str	r3, [r7, #52]	@ 0x34
 8005ffc:	e016      	b.n	800602c <mbedtls_gcm_finish+0x254>
            ctx->buf[i] ^= work_buf[i];
 8005ffe:	68fa      	ldr	r2, [r7, #12]
 8006000:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8006002:	4413      	add	r3, r2
 8006004:	f503 73bc 	add.w	r3, r3, #376	@ 0x178
 8006008:	781a      	ldrb	r2, [r3, #0]
 800600a:	f107 0110 	add.w	r1, r7, #16
 800600e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8006010:	440b      	add	r3, r1
 8006012:	781b      	ldrb	r3, [r3, #0]
 8006014:	4053      	eors	r3, r2
 8006016:	b2d9      	uxtb	r1, r3
 8006018:	68fa      	ldr	r2, [r7, #12]
 800601a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800601c:	4413      	add	r3, r2
 800601e:	f503 73bc 	add.w	r3, r3, #376	@ 0x178
 8006022:	460a      	mov	r2, r1
 8006024:	701a      	strb	r2, [r3, #0]
        for( i = 0; i < 16; i++ )
 8006026:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8006028:	3301      	adds	r3, #1
 800602a:	637b      	str	r3, [r7, #52]	@ 0x34
 800602c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800602e:	2b0f      	cmp	r3, #15
 8006030:	d9e5      	bls.n	8005ffe <mbedtls_gcm_finish+0x226>

        gcm_mult( ctx, ctx->buf, ctx->buf );
 8006032:	68fb      	ldr	r3, [r7, #12]
 8006034:	f503 71bc 	add.w	r1, r3, #376	@ 0x178
 8006038:	68fb      	ldr	r3, [r7, #12]
 800603a:	f503 73bc 	add.w	r3, r3, #376	@ 0x178
 800603e:	461a      	mov	r2, r3
 8006040:	68f8      	ldr	r0, [r7, #12]
 8006042:	f7ff f96b 	bl	800531c <gcm_mult>

        for( i = 0; i < tag_len; i++ )
 8006046:	2300      	movs	r3, #0
 8006048:	637b      	str	r3, [r7, #52]	@ 0x34
 800604a:	e012      	b.n	8006072 <mbedtls_gcm_finish+0x29a>
            tag[i] ^= ctx->buf[i];
 800604c:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800604e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8006050:	4413      	add	r3, r2
 8006052:	7819      	ldrb	r1, [r3, #0]
 8006054:	68fa      	ldr	r2, [r7, #12]
 8006056:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8006058:	4413      	add	r3, r2
 800605a:	f503 73bc 	add.w	r3, r3, #376	@ 0x178
 800605e:	781a      	ldrb	r2, [r3, #0]
 8006060:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8006062:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8006064:	4403      	add	r3, r0
 8006066:	404a      	eors	r2, r1
 8006068:	b2d2      	uxtb	r2, r2
 800606a:	701a      	strb	r2, [r3, #0]
        for( i = 0; i < tag_len; i++ )
 800606c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800606e:	3301      	adds	r3, #1
 8006070:	637b      	str	r3, [r7, #52]	@ 0x34
 8006072:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8006074:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8006076:	429a      	cmp	r2, r3
 8006078:	d3e8      	bcc.n	800604c <mbedtls_gcm_finish+0x274>
    }

    return( 0 );
 800607a:	2300      	movs	r3, #0
}
 800607c:	4618      	mov	r0, r3
 800607e:	3738      	adds	r7, #56	@ 0x38
 8006080:	46bd      	mov	sp, r7
 8006082:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}

08006086 <mbedtls_gcm_crypt_and_tag>:
                       size_t add_len,
                       const unsigned char *input,
                       unsigned char *output,
                       size_t tag_len,
                       unsigned char *tag )
{
 8006086:	b580      	push	{r7, lr}
 8006088:	b088      	sub	sp, #32
 800608a:	af02      	add	r7, sp, #8
 800608c:	60f8      	str	r0, [r7, #12]
 800608e:	60b9      	str	r1, [r7, #8]
 8006090:	607a      	str	r2, [r7, #4]
 8006092:	603b      	str	r3, [r7, #0]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 8006094:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8006098:	617b      	str	r3, [r7, #20]
    GCM_VALIDATE_RET( add_len == 0 || add != NULL );
    GCM_VALIDATE_RET( length == 0 || input != NULL );
    GCM_VALIDATE_RET( length == 0 || output != NULL );
    GCM_VALIDATE_RET( tag != NULL );

    if( ( ret = mbedtls_gcm_starts( ctx, mode, iv, iv_len ) ) != 0 )
 800609a:	6a3b      	ldr	r3, [r7, #32]
 800609c:	683a      	ldr	r2, [r7, #0]
 800609e:	68b9      	ldr	r1, [r7, #8]
 80060a0:	68f8      	ldr	r0, [r7, #12]
 80060a2:	f7ff fb13 	bl	80056cc <mbedtls_gcm_starts>
 80060a6:	6178      	str	r0, [r7, #20]
 80060a8:	697b      	ldr	r3, [r7, #20]
 80060aa:	2b00      	cmp	r3, #0
 80060ac:	d001      	beq.n	80060b2 <mbedtls_gcm_crypt_and_tag+0x2c>
        return( ret );
 80060ae:	697b      	ldr	r3, [r7, #20]
 80060b0:	e02e      	b.n	8006110 <mbedtls_gcm_crypt_and_tag+0x8a>

    if( ( ret = mbedtls_gcm_update_ad( ctx, add, add_len ) ) != 0 )
 80060b2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80060b4:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 80060b6:	68f8      	ldr	r0, [r7, #12]
 80060b8:	f7ff fbf1 	bl	800589e <mbedtls_gcm_update_ad>
 80060bc:	6178      	str	r0, [r7, #20]
 80060be:	697b      	ldr	r3, [r7, #20]
 80060c0:	2b00      	cmp	r3, #0
 80060c2:	d001      	beq.n	80060c8 <mbedtls_gcm_crypt_and_tag+0x42>
        return( ret );
 80060c4:	697b      	ldr	r3, [r7, #20]
 80060c6:	e023      	b.n	8006110 <mbedtls_gcm_crypt_and_tag+0x8a>

    if( ( ret = mbedtls_gcm_update( ctx, input, length,
 80060c8:	f107 0310 	add.w	r3, r7, #16
 80060cc:	9301      	str	r3, [sp, #4]
 80060ce:	687b      	ldr	r3, [r7, #4]
 80060d0:	9300      	str	r3, [sp, #0]
 80060d2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80060d4:	687a      	ldr	r2, [r7, #4]
 80060d6:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 80060d8:	68f8      	ldr	r0, [r7, #12]
 80060da:	f7ff fd4d 	bl	8005b78 <mbedtls_gcm_update>
 80060de:	6178      	str	r0, [r7, #20]
 80060e0:	697b      	ldr	r3, [r7, #20]
 80060e2:	2b00      	cmp	r3, #0
 80060e4:	d001      	beq.n	80060ea <mbedtls_gcm_crypt_and_tag+0x64>
                                    output, length, &olen ) ) != 0 )
        return( ret );
 80060e6:	697b      	ldr	r3, [r7, #20]
 80060e8:	e012      	b.n	8006110 <mbedtls_gcm_crypt_and_tag+0x8a>

    if( ( ret = mbedtls_gcm_finish( ctx, NULL, 0, &olen, tag, tag_len ) ) != 0 )
 80060ea:	f107 0210 	add.w	r2, r7, #16
 80060ee:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80060f0:	9301      	str	r3, [sp, #4]
 80060f2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80060f4:	9300      	str	r3, [sp, #0]
 80060f6:	4613      	mov	r3, r2
 80060f8:	2200      	movs	r2, #0
 80060fa:	2100      	movs	r1, #0
 80060fc:	68f8      	ldr	r0, [r7, #12]
 80060fe:	f7ff fe6b 	bl	8005dd8 <mbedtls_gcm_finish>
 8006102:	6178      	str	r0, [r7, #20]
 8006104:	697b      	ldr	r3, [r7, #20]
 8006106:	2b00      	cmp	r3, #0
 8006108:	d001      	beq.n	800610e <mbedtls_gcm_crypt_and_tag+0x88>
        return( ret );
 800610a:	697b      	ldr	r3, [r7, #20]
 800610c:	e000      	b.n	8006110 <mbedtls_gcm_crypt_and_tag+0x8a>

    return( 0 );
 800610e:	2300      	movs	r3, #0
}
 8006110:	4618      	mov	r0, r3
 8006112:	3718      	adds	r7, #24
 8006114:	46bd      	mov	sp, r7
 8006116:	bd80      	pop	{r7, pc}

08006118 <mbedtls_gcm_auth_decrypt>:
                      size_t add_len,
                      const unsigned char *tag,
                      size_t tag_len,
                      const unsigned char *input,
                      unsigned char *output )
{
 8006118:	b580      	push	{r7, lr}
 800611a:	b094      	sub	sp, #80	@ 0x50
 800611c:	af08      	add	r7, sp, #32
 800611e:	60f8      	str	r0, [r7, #12]
 8006120:	60b9      	str	r1, [r7, #8]
 8006122:	607a      	str	r2, [r7, #4]
 8006124:	603b      	str	r3, [r7, #0]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 8006126:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 800612a:	627b      	str	r3, [r7, #36]	@ 0x24
    GCM_VALIDATE_RET( add_len == 0 || add != NULL );
    GCM_VALIDATE_RET( tag != NULL );
    GCM_VALIDATE_RET( length == 0 || input != NULL );
    GCM_VALIDATE_RET( length == 0 || output != NULL );

    if( ( ret = mbedtls_gcm_crypt_and_tag( ctx, MBEDTLS_GCM_DECRYPT, length,
 800612c:	f107 0314 	add.w	r3, r7, #20
 8006130:	9306      	str	r3, [sp, #24]
 8006132:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8006134:	9305      	str	r3, [sp, #20]
 8006136:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8006138:	9304      	str	r3, [sp, #16]
 800613a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800613c:	9303      	str	r3, [sp, #12]
 800613e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8006140:	9302      	str	r3, [sp, #8]
 8006142:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8006144:	9301      	str	r3, [sp, #4]
 8006146:	683b      	ldr	r3, [r7, #0]
 8006148:	9300      	str	r3, [sp, #0]
 800614a:	687b      	ldr	r3, [r7, #4]
 800614c:	68ba      	ldr	r2, [r7, #8]
 800614e:	2100      	movs	r1, #0
 8006150:	68f8      	ldr	r0, [r7, #12]
 8006152:	f7ff ff98 	bl	8006086 <mbedtls_gcm_crypt_and_tag>
 8006156:	6278      	str	r0, [r7, #36]	@ 0x24
 8006158:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800615a:	2b00      	cmp	r3, #0
 800615c:	d001      	beq.n	8006162 <mbedtls_gcm_auth_decrypt+0x4a>
                                   iv, iv_len, add, add_len,
                                   input, output, tag_len, check_tag ) ) != 0 )
    {
        return( ret );
 800615e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006160:	e025      	b.n	80061ae <mbedtls_gcm_auth_decrypt+0x96>
    }

    /* Check tag in "constant-time" */
    for( diff = 0, i = 0; i < tag_len; i++ )
 8006162:	2300      	movs	r3, #0
 8006164:	62bb      	str	r3, [r7, #40]	@ 0x28
 8006166:	2300      	movs	r3, #0
 8006168:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800616a:	e011      	b.n	8006190 <mbedtls_gcm_auth_decrypt+0x78>
        diff |= tag[i] ^ check_tag[i];
 800616c:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800616e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8006170:	4413      	add	r3, r2
 8006172:	781a      	ldrb	r2, [r3, #0]
 8006174:	f107 0114 	add.w	r1, r7, #20
 8006178:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800617a:	440b      	add	r3, r1
 800617c:	781b      	ldrb	r3, [r3, #0]
 800617e:	4053      	eors	r3, r2
 8006180:	b2db      	uxtb	r3, r3
 8006182:	461a      	mov	r2, r3
 8006184:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8006186:	4313      	orrs	r3, r2
 8006188:	62bb      	str	r3, [r7, #40]	@ 0x28
    for( diff = 0, i = 0; i < tag_len; i++ )
 800618a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800618c:	3301      	adds	r3, #1
 800618e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8006190:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8006192:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8006194:	429a      	cmp	r2, r3
 8006196:	d3e9      	bcc.n	800616c <mbedtls_gcm_auth_decrypt+0x54>

    if( diff != 0 )
 8006198:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800619a:	2b00      	cmp	r3, #0
 800619c:	d006      	beq.n	80061ac <mbedtls_gcm_auth_decrypt+0x94>
    {
        mbedtls_platform_zeroize( output, length );
 800619e:	68b9      	ldr	r1, [r7, #8]
 80061a0:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 80061a2:	f000 f81d 	bl	80061e0 <mbedtls_platform_zeroize>
        return( MBEDTLS_ERR_GCM_AUTH_FAILED );
 80061a6:	f06f 0311 	mvn.w	r3, #17
 80061aa:	e000      	b.n	80061ae <mbedtls_gcm_auth_decrypt+0x96>
    }

    return( 0 );
 80061ac:	2300      	movs	r3, #0
}
 80061ae:	4618      	mov	r0, r3
 80061b0:	3730      	adds	r7, #48	@ 0x30
 80061b2:	46bd      	mov	sp, r7
 80061b4:	bd80      	pop	{r7, pc}

080061b6 <mbedtls_gcm_free>:

void mbedtls_gcm_free( mbedtls_gcm_context *ctx )
{
 80061b6:	b580      	push	{r7, lr}
 80061b8:	b082      	sub	sp, #8
 80061ba:	af00      	add	r7, sp, #0
 80061bc:	6078      	str	r0, [r7, #4]
    if( ctx == NULL )
 80061be:	687b      	ldr	r3, [r7, #4]
 80061c0:	2b00      	cmp	r3, #0
 80061c2:	d009      	beq.n	80061d8 <mbedtls_gcm_free+0x22>
        return;
    mbedtls_cipher_free( &ctx->cipher_ctx );
 80061c4:	687b      	ldr	r3, [r7, #4]
 80061c6:	4618      	mov	r0, r3
 80061c8:	f7fd ff48 	bl	800405c <mbedtls_cipher_free>
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_gcm_context ) );
 80061cc:	f44f 71c8 	mov.w	r1, #400	@ 0x190
 80061d0:	6878      	ldr	r0, [r7, #4]
 80061d2:	f000 f805 	bl	80061e0 <mbedtls_platform_zeroize>
 80061d6:	e000      	b.n	80061da <mbedtls_gcm_free+0x24>
        return;
 80061d8:	bf00      	nop
}
 80061da:	3708      	adds	r7, #8
 80061dc:	46bd      	mov	sp, r7
 80061de:	bd80      	pop	{r7, pc}

080061e0 <mbedtls_platform_zeroize>:
 * platform and needs.
 */
static void * (* const volatile memset_func)( void *, int, size_t ) = memset;

void mbedtls_platform_zeroize( void *buf, size_t len )
{
 80061e0:	b580      	push	{r7, lr}
 80061e2:	b082      	sub	sp, #8
 80061e4:	af00      	add	r7, sp, #0
 80061e6:	6078      	str	r0, [r7, #4]
 80061e8:	6039      	str	r1, [r7, #0]
    MBEDTLS_INTERNAL_VALIDATE( len == 0 || buf != NULL );

    if( len > 0 )
 80061ea:	683b      	ldr	r3, [r7, #0]
 80061ec:	2b00      	cmp	r3, #0
 80061ee:	d005      	beq.n	80061fc <mbedtls_platform_zeroize+0x1c>
        memset_func( buf, 0, len );
 80061f0:	4b04      	ldr	r3, [pc, #16]	@ (8006204 <mbedtls_platform_zeroize+0x24>)
 80061f2:	681b      	ldr	r3, [r3, #0]
 80061f4:	683a      	ldr	r2, [r7, #0]
 80061f6:	2100      	movs	r1, #0
 80061f8:	6878      	ldr	r0, [r7, #4]
 80061fa:	4798      	blx	r3
}
 80061fc:	bf00      	nop
 80061fe:	3708      	adds	r7, #8
 8006200:	46bd      	mov	sp, r7
 8006202:	bd80      	pop	{r7, pc}
 8006204:	08016c48 	.word	0x08016c48

08006208 <mul64>:

    return( lo + ( me << 16 ) + ( (uint64_t) hi << 32 ) );
}
#else
static inline uint64_t mul64( uint32_t a, uint32_t b )
{
 8006208:	e92d 03b0 	stmdb	sp!, {r4, r5, r7, r8, r9}
 800620c:	b083      	sub	sp, #12
 800620e:	af00      	add	r7, sp, #0
 8006210:	6078      	str	r0, [r7, #4]
 8006212:	6039      	str	r1, [r7, #0]
    return( (uint64_t) a * b );
 8006214:	6879      	ldr	r1, [r7, #4]
 8006216:	2000      	movs	r0, #0
 8006218:	4688      	mov	r8, r1
 800621a:	4681      	mov	r9, r0
 800621c:	6839      	ldr	r1, [r7, #0]
 800621e:	2000      	movs	r0, #0
 8006220:	460c      	mov	r4, r1
 8006222:	4605      	mov	r5, r0
 8006224:	fb04 f009 	mul.w	r0, r4, r9
 8006228:	fb08 f105 	mul.w	r1, r8, r5
 800622c:	4401      	add	r1, r0
 800622e:	fba8 2304 	umull	r2, r3, r8, r4
 8006232:	4419      	add	r1, r3
 8006234:	460b      	mov	r3, r1
}
 8006236:	4610      	mov	r0, r2
 8006238:	4619      	mov	r1, r3
 800623a:	370c      	adds	r7, #12
 800623c:	46bd      	mov	sp, r7
 800623e:	e8bd 03b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9}
 8006242:	4770      	bx	lr

08006244 <poly1305_process>:
 */
static void poly1305_process( mbedtls_poly1305_context *ctx,
                              size_t nblocks,
                              const unsigned char *input,
                              uint32_t needs_padding )
{
 8006244:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8006248:	b0f4      	sub	sp, #464	@ 0x1d0
 800624a:	af00      	add	r7, sp, #0
 800624c:	f8c7 0174 	str.w	r0, [r7, #372]	@ 0x174
 8006250:	f8c7 1170 	str.w	r1, [r7, #368]	@ 0x170
 8006254:	f8c7 216c 	str.w	r2, [r7, #364]	@ 0x16c
 8006258:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
    uint64_t d0, d1, d2, d3;
    uint32_t acc0, acc1, acc2, acc3, acc4;
    uint32_t r0, r1, r2, r3;
    uint32_t rs1, rs2, rs3;
    size_t offset  = 0U;
 800625c:	2300      	movs	r3, #0
 800625e:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    size_t i;

    r0 = ctx->r[0];
 8006262:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8006266:	681b      	ldr	r3, [r3, #0]
 8006268:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0
    r1 = ctx->r[1];
 800626c:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8006270:	685b      	ldr	r3, [r3, #4]
 8006272:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    r2 = ctx->r[2];
 8006276:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 800627a:	689b      	ldr	r3, [r3, #8]
 800627c:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    r3 = ctx->r[3];
 8006280:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8006284:	68db      	ldr	r3, [r3, #12]
 8006286:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4

    rs1 = r1 + ( r1 >> 2U );
 800628a:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800628e:	089a      	lsrs	r2, r3, #2
 8006290:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 8006294:	4413      	add	r3, r2
 8006296:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    rs2 = r2 + ( r2 >> 2U );
 800629a:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 800629e:	089a      	lsrs	r2, r3, #2
 80062a0:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 80062a4:	4413      	add	r3, r2
 80062a6:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    rs3 = r3 + ( r3 >> 2U );
 80062aa:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 80062ae:	089a      	lsrs	r2, r3, #2
 80062b0:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 80062b4:	4413      	add	r3, r2
 80062b6:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198

    acc0 = ctx->acc[0];
 80062ba:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80062be:	6a1b      	ldr	r3, [r3, #32]
 80062c0:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    acc1 = ctx->acc[1];
 80062c4:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80062c8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80062ca:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
    acc2 = ctx->acc[2];
 80062ce:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80062d2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80062d4:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    acc3 = ctx->acc[3];
 80062d8:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80062dc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80062de:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    acc4 = ctx->acc[4];
 80062e2:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80062e6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80062e8:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc

    /* Process full blocks */
    for( i = 0U; i < nblocks; i++ )
 80062ec:	2300      	movs	r3, #0
 80062ee:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
 80062f2:	e3b5      	b.n	8006a60 <poly1305_process+0x81c>
    {
        /* The input block is treated as a 128-bit little-endian integer */
        d0   = BYTES_TO_U32_LE( input, offset + 0  );
 80062f4:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 80062f8:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80062fc:	4413      	add	r3, r2
 80062fe:	781b      	ldrb	r3, [r3, #0]
 8006300:	4619      	mov	r1, r3
 8006302:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8006306:	1c5a      	adds	r2, r3, #1
 8006308:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 800630c:	4413      	add	r3, r2
 800630e:	781b      	ldrb	r3, [r3, #0]
 8006310:	021b      	lsls	r3, r3, #8
 8006312:	4319      	orrs	r1, r3
 8006314:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8006318:	1c9a      	adds	r2, r3, #2
 800631a:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 800631e:	4413      	add	r3, r2
 8006320:	781b      	ldrb	r3, [r3, #0]
 8006322:	041b      	lsls	r3, r3, #16
 8006324:	4319      	orrs	r1, r3
 8006326:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 800632a:	1cda      	adds	r2, r3, #3
 800632c:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8006330:	4413      	add	r3, r2
 8006332:	781b      	ldrb	r3, [r3, #0]
 8006334:	061b      	lsls	r3, r3, #24
 8006336:	430b      	orrs	r3, r1
 8006338:	2200      	movs	r2, #0
 800633a:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
 800633e:	f8c7 209c 	str.w	r2, [r7, #156]	@ 0x9c
 8006342:	e9d7 3426 	ldrd	r3, r4, [r7, #152]	@ 0x98
 8006346:	e9c7 3464 	strd	r3, r4, [r7, #400]	@ 0x190
        d1   = BYTES_TO_U32_LE( input, offset + 4  );
 800634a:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 800634e:	1d1a      	adds	r2, r3, #4
 8006350:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8006354:	4413      	add	r3, r2
 8006356:	781b      	ldrb	r3, [r3, #0]
 8006358:	4619      	mov	r1, r3
 800635a:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 800635e:	1d5a      	adds	r2, r3, #5
 8006360:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8006364:	4413      	add	r3, r2
 8006366:	781b      	ldrb	r3, [r3, #0]
 8006368:	021b      	lsls	r3, r3, #8
 800636a:	4319      	orrs	r1, r3
 800636c:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8006370:	1d9a      	adds	r2, r3, #6
 8006372:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8006376:	4413      	add	r3, r2
 8006378:	781b      	ldrb	r3, [r3, #0]
 800637a:	041b      	lsls	r3, r3, #16
 800637c:	4319      	orrs	r1, r3
 800637e:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8006382:	1dda      	adds	r2, r3, #7
 8006384:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8006388:	4413      	add	r3, r2
 800638a:	781b      	ldrb	r3, [r3, #0]
 800638c:	061b      	lsls	r3, r3, #24
 800638e:	430b      	orrs	r3, r1
 8006390:	2200      	movs	r2, #0
 8006392:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 8006396:	f8c7 2094 	str.w	r2, [r7, #148]	@ 0x94
 800639a:	e9d7 3424 	ldrd	r3, r4, [r7, #144]	@ 0x90
 800639e:	e9c7 3462 	strd	r3, r4, [r7, #392]	@ 0x188
        d2   = BYTES_TO_U32_LE( input, offset + 8  );
 80063a2:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80063a6:	f103 0208 	add.w	r2, r3, #8
 80063aa:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 80063ae:	4413      	add	r3, r2
 80063b0:	781b      	ldrb	r3, [r3, #0]
 80063b2:	4619      	mov	r1, r3
 80063b4:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80063b8:	f103 0209 	add.w	r2, r3, #9
 80063bc:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 80063c0:	4413      	add	r3, r2
 80063c2:	781b      	ldrb	r3, [r3, #0]
 80063c4:	021b      	lsls	r3, r3, #8
 80063c6:	4319      	orrs	r1, r3
 80063c8:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80063cc:	f103 020a 	add.w	r2, r3, #10
 80063d0:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 80063d4:	4413      	add	r3, r2
 80063d6:	781b      	ldrb	r3, [r3, #0]
 80063d8:	041b      	lsls	r3, r3, #16
 80063da:	4319      	orrs	r1, r3
 80063dc:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80063e0:	f103 020b 	add.w	r2, r3, #11
 80063e4:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 80063e8:	4413      	add	r3, r2
 80063ea:	781b      	ldrb	r3, [r3, #0]
 80063ec:	061b      	lsls	r3, r3, #24
 80063ee:	430b      	orrs	r3, r1
 80063f0:	2200      	movs	r2, #0
 80063f2:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 80063f6:	f8c7 208c 	str.w	r2, [r7, #140]	@ 0x8c
 80063fa:	e9d7 3422 	ldrd	r3, r4, [r7, #136]	@ 0x88
 80063fe:	e9c7 3460 	strd	r3, r4, [r7, #384]	@ 0x180
        d3   = BYTES_TO_U32_LE( input, offset + 12 );
 8006402:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8006406:	f103 020c 	add.w	r2, r3, #12
 800640a:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 800640e:	4413      	add	r3, r2
 8006410:	781b      	ldrb	r3, [r3, #0]
 8006412:	4619      	mov	r1, r3
 8006414:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8006418:	f103 020d 	add.w	r2, r3, #13
 800641c:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8006420:	4413      	add	r3, r2
 8006422:	781b      	ldrb	r3, [r3, #0]
 8006424:	021b      	lsls	r3, r3, #8
 8006426:	4319      	orrs	r1, r3
 8006428:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 800642c:	f103 020e 	add.w	r2, r3, #14
 8006430:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8006434:	4413      	add	r3, r2
 8006436:	781b      	ldrb	r3, [r3, #0]
 8006438:	041b      	lsls	r3, r3, #16
 800643a:	4319      	orrs	r1, r3
 800643c:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8006440:	f103 020f 	add.w	r2, r3, #15
 8006444:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8006448:	4413      	add	r3, r2
 800644a:	781b      	ldrb	r3, [r3, #0]
 800644c:	061b      	lsls	r3, r3, #24
 800644e:	430b      	orrs	r3, r1
 8006450:	2200      	movs	r2, #0
 8006452:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 8006456:	f8c7 2084 	str.w	r2, [r7, #132]	@ 0x84
 800645a:	e9d7 3420 	ldrd	r3, r4, [r7, #128]	@ 0x80
 800645e:	e9c7 345e 	strd	r3, r4, [r7, #376]	@ 0x178

        /* Compute: acc += (padded) block as a 130-bit integer */
        d0  += (uint64_t) acc0;
 8006462:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 8006466:	2200      	movs	r2, #0
 8006468:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
 800646c:	f8c7 2164 	str.w	r2, [r7, #356]	@ 0x164
 8006470:	e9d7 2364 	ldrd	r2, r3, [r7, #400]	@ 0x190
 8006474:	e9d7 4558 	ldrd	r4, r5, [r7, #352]	@ 0x160
 8006478:	4621      	mov	r1, r4
 800647a:	1851      	adds	r1, r2, r1
 800647c:	67b9      	str	r1, [r7, #120]	@ 0x78
 800647e:	4629      	mov	r1, r5
 8006480:	414b      	adcs	r3, r1
 8006482:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8006484:	e9d7 341e 	ldrd	r3, r4, [r7, #120]	@ 0x78
 8006488:	e9c7 3464 	strd	r3, r4, [r7, #400]	@ 0x190
        d1  += (uint64_t) acc1 + ( d0 >> 32U );
 800648c:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8006490:	2200      	movs	r2, #0
 8006492:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
 8006496:	f8c7 215c 	str.w	r2, [r7, #348]	@ 0x15c
 800649a:	e9d7 2364 	ldrd	r2, r3, [r7, #400]	@ 0x190
 800649e:	f04f 0000 	mov.w	r0, #0
 80064a2:	f04f 0100 	mov.w	r1, #0
 80064a6:	0018      	movs	r0, r3
 80064a8:	2100      	movs	r1, #0
 80064aa:	e9d7 4556 	ldrd	r4, r5, [r7, #344]	@ 0x158
 80064ae:	4623      	mov	r3, r4
 80064b0:	181b      	adds	r3, r3, r0
 80064b2:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
 80064b6:	462b      	mov	r3, r5
 80064b8:	414b      	adcs	r3, r1
 80064ba:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
 80064be:	e9d7 2362 	ldrd	r2, r3, [r7, #392]	@ 0x188
 80064c2:	e9d7 4554 	ldrd	r4, r5, [r7, #336]	@ 0x150
 80064c6:	4621      	mov	r1, r4
 80064c8:	1851      	adds	r1, r2, r1
 80064ca:	6739      	str	r1, [r7, #112]	@ 0x70
 80064cc:	4629      	mov	r1, r5
 80064ce:	414b      	adcs	r3, r1
 80064d0:	677b      	str	r3, [r7, #116]	@ 0x74
 80064d2:	e9d7 341c 	ldrd	r3, r4, [r7, #112]	@ 0x70
 80064d6:	e9c7 3462 	strd	r3, r4, [r7, #392]	@ 0x188
        d2  += (uint64_t) acc2 + ( d1 >> 32U );
 80064da:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 80064de:	2200      	movs	r2, #0
 80064e0:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
 80064e4:	f8c7 214c 	str.w	r2, [r7, #332]	@ 0x14c
 80064e8:	e9d7 2362 	ldrd	r2, r3, [r7, #392]	@ 0x188
 80064ec:	f04f 0000 	mov.w	r0, #0
 80064f0:	f04f 0100 	mov.w	r1, #0
 80064f4:	0018      	movs	r0, r3
 80064f6:	2100      	movs	r1, #0
 80064f8:	e9d7 4552 	ldrd	r4, r5, [r7, #328]	@ 0x148
 80064fc:	4623      	mov	r3, r4
 80064fe:	181b      	adds	r3, r3, r0
 8006500:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 8006504:	462b      	mov	r3, r5
 8006506:	414b      	adcs	r3, r1
 8006508:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
 800650c:	e9d7 2360 	ldrd	r2, r3, [r7, #384]	@ 0x180
 8006510:	e9d7 4550 	ldrd	r4, r5, [r7, #320]	@ 0x140
 8006514:	4621      	mov	r1, r4
 8006516:	1851      	adds	r1, r2, r1
 8006518:	66b9      	str	r1, [r7, #104]	@ 0x68
 800651a:	4629      	mov	r1, r5
 800651c:	414b      	adcs	r3, r1
 800651e:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8006520:	e9d7 341a 	ldrd	r3, r4, [r7, #104]	@ 0x68
 8006524:	e9c7 3460 	strd	r3, r4, [r7, #384]	@ 0x180
        d3  += (uint64_t) acc3 + ( d2 >> 32U );
 8006528:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 800652c:	2200      	movs	r2, #0
 800652e:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
 8006532:	f8c7 213c 	str.w	r2, [r7, #316]	@ 0x13c
 8006536:	e9d7 2360 	ldrd	r2, r3, [r7, #384]	@ 0x180
 800653a:	f04f 0000 	mov.w	r0, #0
 800653e:	f04f 0100 	mov.w	r1, #0
 8006542:	0018      	movs	r0, r3
 8006544:	2100      	movs	r1, #0
 8006546:	e9d7 454e 	ldrd	r4, r5, [r7, #312]	@ 0x138
 800654a:	4623      	mov	r3, r4
 800654c:	181b      	adds	r3, r3, r0
 800654e:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 8006552:	462b      	mov	r3, r5
 8006554:	414b      	adcs	r3, r1
 8006556:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
 800655a:	e9d7 235e 	ldrd	r2, r3, [r7, #376]	@ 0x178
 800655e:	e9d7 454c 	ldrd	r4, r5, [r7, #304]	@ 0x130
 8006562:	4621      	mov	r1, r4
 8006564:	1851      	adds	r1, r2, r1
 8006566:	6639      	str	r1, [r7, #96]	@ 0x60
 8006568:	4629      	mov	r1, r5
 800656a:	414b      	adcs	r3, r1
 800656c:	667b      	str	r3, [r7, #100]	@ 0x64
 800656e:	e9d7 3418 	ldrd	r3, r4, [r7, #96]	@ 0x60
 8006572:	e9c7 345e 	strd	r3, r4, [r7, #376]	@ 0x178
        acc0 = (uint32_t) d0;
 8006576:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 800657a:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
        acc1 = (uint32_t) d1;
 800657e:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 8006582:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
        acc2 = (uint32_t) d2;
 8006586:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 800658a:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
        acc3 = (uint32_t) d3;
 800658e:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8006592:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
        acc4 += (uint32_t) ( d3 >> 32U ) + needs_padding;
 8006596:	e9d7 235e 	ldrd	r2, r3, [r7, #376]	@ 0x178
 800659a:	f04f 0000 	mov.w	r0, #0
 800659e:	f04f 0100 	mov.w	r1, #0
 80065a2:	0018      	movs	r0, r3
 80065a4:	2100      	movs	r1, #0
 80065a6:	4602      	mov	r2, r0
 80065a8:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 80065ac:	441a      	add	r2, r3
 80065ae:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 80065b2:	4413      	add	r3, r2
 80065b4:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc

        /* Compute: acc *= r */
        d0 = mul64( acc0, r0  ) +
 80065b8:	f8d7 11b0 	ldr.w	r1, [r7, #432]	@ 0x1b0
 80065bc:	f8d7 01cc 	ldr.w	r0, [r7, #460]	@ 0x1cc
 80065c0:	f7ff fe22 	bl	8006208 <mul64>
 80065c4:	4604      	mov	r4, r0
 80065c6:	460d      	mov	r5, r1
             mul64( acc1, rs3 ) +
 80065c8:	f8d7 1198 	ldr.w	r1, [r7, #408]	@ 0x198
 80065cc:	f8d7 01c8 	ldr.w	r0, [r7, #456]	@ 0x1c8
 80065d0:	f7ff fe1a 	bl	8006208 <mul64>
 80065d4:	4602      	mov	r2, r0
 80065d6:	460b      	mov	r3, r1
        d0 = mul64( acc0, r0  ) +
 80065d8:	18a1      	adds	r1, r4, r2
 80065da:	f8c7 1128 	str.w	r1, [r7, #296]	@ 0x128
 80065de:	eb45 0303 	adc.w	r3, r5, r3
 80065e2:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
             mul64( acc2, rs2 ) +
 80065e6:	f8d7 119c 	ldr.w	r1, [r7, #412]	@ 0x19c
 80065ea:	f8d7 01c4 	ldr.w	r0, [r7, #452]	@ 0x1c4
 80065ee:	f7ff fe0b 	bl	8006208 <mul64>
 80065f2:	4602      	mov	r2, r0
 80065f4:	460b      	mov	r3, r1
             mul64( acc1, rs3 ) +
 80065f6:	e9d7 454a 	ldrd	r4, r5, [r7, #296]	@ 0x128
 80065fa:	4621      	mov	r1, r4
 80065fc:	1889      	adds	r1, r1, r2
 80065fe:	f8c7 1120 	str.w	r1, [r7, #288]	@ 0x120
 8006602:	4629      	mov	r1, r5
 8006604:	eb41 0303 	adc.w	r3, r1, r3
 8006608:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
             mul64( acc3, rs1 );
 800660c:	f8d7 11a0 	ldr.w	r1, [r7, #416]	@ 0x1a0
 8006610:	f8d7 01c0 	ldr.w	r0, [r7, #448]	@ 0x1c0
 8006614:	f7ff fdf8 	bl	8006208 <mul64>
 8006618:	4602      	mov	r2, r0
 800661a:	460b      	mov	r3, r1
        d0 = mul64( acc0, r0  ) +
 800661c:	e9d7 4548 	ldrd	r4, r5, [r7, #288]	@ 0x120
 8006620:	4621      	mov	r1, r4
 8006622:	1889      	adds	r1, r1, r2
 8006624:	65b9      	str	r1, [r7, #88]	@ 0x58
 8006626:	4629      	mov	r1, r5
 8006628:	eb41 0303 	adc.w	r3, r1, r3
 800662c:	65fb      	str	r3, [r7, #92]	@ 0x5c
 800662e:	e9d7 3416 	ldrd	r3, r4, [r7, #88]	@ 0x58
 8006632:	e9c7 3464 	strd	r3, r4, [r7, #400]	@ 0x190
        d1 = mul64( acc0, r1  ) +
 8006636:	f8d7 11ac 	ldr.w	r1, [r7, #428]	@ 0x1ac
 800663a:	f8d7 01cc 	ldr.w	r0, [r7, #460]	@ 0x1cc
 800663e:	f7ff fde3 	bl	8006208 <mul64>
 8006642:	4604      	mov	r4, r0
 8006644:	460d      	mov	r5, r1
             mul64( acc1, r0  ) +
 8006646:	f8d7 11b0 	ldr.w	r1, [r7, #432]	@ 0x1b0
 800664a:	f8d7 01c8 	ldr.w	r0, [r7, #456]	@ 0x1c8
 800664e:	f7ff fddb 	bl	8006208 <mul64>
 8006652:	4602      	mov	r2, r0
 8006654:	460b      	mov	r3, r1
        d1 = mul64( acc0, r1  ) +
 8006656:	18a1      	adds	r1, r4, r2
 8006658:	f8c7 1118 	str.w	r1, [r7, #280]	@ 0x118
 800665c:	eb45 0303 	adc.w	r3, r5, r3
 8006660:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
             mul64( acc2, rs3 ) +
 8006664:	f8d7 1198 	ldr.w	r1, [r7, #408]	@ 0x198
 8006668:	f8d7 01c4 	ldr.w	r0, [r7, #452]	@ 0x1c4
 800666c:	f7ff fdcc 	bl	8006208 <mul64>
 8006670:	4602      	mov	r2, r0
 8006672:	460b      	mov	r3, r1
             mul64( acc1, r0  ) +
 8006674:	e9d7 4546 	ldrd	r4, r5, [r7, #280]	@ 0x118
 8006678:	4621      	mov	r1, r4
 800667a:	1889      	adds	r1, r1, r2
 800667c:	f8c7 1110 	str.w	r1, [r7, #272]	@ 0x110
 8006680:	4629      	mov	r1, r5
 8006682:	eb41 0303 	adc.w	r3, r1, r3
 8006686:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
             mul64( acc3, rs2 ) +
 800668a:	f8d7 119c 	ldr.w	r1, [r7, #412]	@ 0x19c
 800668e:	f8d7 01c0 	ldr.w	r0, [r7, #448]	@ 0x1c0
 8006692:	f7ff fdb9 	bl	8006208 <mul64>
 8006696:	4602      	mov	r2, r0
 8006698:	460b      	mov	r3, r1
             mul64( acc2, rs3 ) +
 800669a:	e9d7 4544 	ldrd	r4, r5, [r7, #272]	@ 0x110
 800669e:	4621      	mov	r1, r4
 80066a0:	1889      	adds	r1, r1, r2
 80066a2:	f8c7 1108 	str.w	r1, [r7, #264]	@ 0x108
 80066a6:	4629      	mov	r1, r5
 80066a8:	eb41 0303 	adc.w	r3, r1, r3
 80066ac:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
             mul64( acc4, rs1 );
 80066b0:	f8d7 11a0 	ldr.w	r1, [r7, #416]	@ 0x1a0
 80066b4:	f8d7 01bc 	ldr.w	r0, [r7, #444]	@ 0x1bc
 80066b8:	f7ff fda6 	bl	8006208 <mul64>
 80066bc:	4602      	mov	r2, r0
 80066be:	460b      	mov	r3, r1
        d1 = mul64( acc0, r1  ) +
 80066c0:	e9d7 4542 	ldrd	r4, r5, [r7, #264]	@ 0x108
 80066c4:	4621      	mov	r1, r4
 80066c6:	1889      	adds	r1, r1, r2
 80066c8:	6539      	str	r1, [r7, #80]	@ 0x50
 80066ca:	4629      	mov	r1, r5
 80066cc:	eb41 0303 	adc.w	r3, r1, r3
 80066d0:	657b      	str	r3, [r7, #84]	@ 0x54
 80066d2:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	@ 0x50
 80066d6:	e9c7 3462 	strd	r3, r4, [r7, #392]	@ 0x188
        d2 = mul64( acc0, r2  ) +
 80066da:	f8d7 11a8 	ldr.w	r1, [r7, #424]	@ 0x1a8
 80066de:	f8d7 01cc 	ldr.w	r0, [r7, #460]	@ 0x1cc
 80066e2:	f7ff fd91 	bl	8006208 <mul64>
 80066e6:	4604      	mov	r4, r0
 80066e8:	460d      	mov	r5, r1
             mul64( acc1, r1  ) +
 80066ea:	f8d7 11ac 	ldr.w	r1, [r7, #428]	@ 0x1ac
 80066ee:	f8d7 01c8 	ldr.w	r0, [r7, #456]	@ 0x1c8
 80066f2:	f7ff fd89 	bl	8006208 <mul64>
 80066f6:	4602      	mov	r2, r0
 80066f8:	460b      	mov	r3, r1
        d2 = mul64( acc0, r2  ) +
 80066fa:	18a1      	adds	r1, r4, r2
 80066fc:	f8c7 1100 	str.w	r1, [r7, #256]	@ 0x100
 8006700:	eb45 0303 	adc.w	r3, r5, r3
 8006704:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
             mul64( acc2, r0  ) +
 8006708:	f8d7 11b0 	ldr.w	r1, [r7, #432]	@ 0x1b0
 800670c:	f8d7 01c4 	ldr.w	r0, [r7, #452]	@ 0x1c4
 8006710:	f7ff fd7a 	bl	8006208 <mul64>
 8006714:	4602      	mov	r2, r0
 8006716:	460b      	mov	r3, r1
             mul64( acc1, r1  ) +
 8006718:	e9d7 4540 	ldrd	r4, r5, [r7, #256]	@ 0x100
 800671c:	4621      	mov	r1, r4
 800671e:	1889      	adds	r1, r1, r2
 8006720:	f8c7 10f8 	str.w	r1, [r7, #248]	@ 0xf8
 8006724:	4629      	mov	r1, r5
 8006726:	eb41 0303 	adc.w	r3, r1, r3
 800672a:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
             mul64( acc3, rs3 ) +
 800672e:	f8d7 1198 	ldr.w	r1, [r7, #408]	@ 0x198
 8006732:	f8d7 01c0 	ldr.w	r0, [r7, #448]	@ 0x1c0
 8006736:	f7ff fd67 	bl	8006208 <mul64>
 800673a:	4602      	mov	r2, r0
 800673c:	460b      	mov	r3, r1
             mul64( acc2, r0  ) +
 800673e:	e9d7 453e 	ldrd	r4, r5, [r7, #248]	@ 0xf8
 8006742:	4621      	mov	r1, r4
 8006744:	1889      	adds	r1, r1, r2
 8006746:	f8c7 10f0 	str.w	r1, [r7, #240]	@ 0xf0
 800674a:	4629      	mov	r1, r5
 800674c:	eb41 0303 	adc.w	r3, r1, r3
 8006750:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
             mul64( acc4, rs2 );
 8006754:	f8d7 119c 	ldr.w	r1, [r7, #412]	@ 0x19c
 8006758:	f8d7 01bc 	ldr.w	r0, [r7, #444]	@ 0x1bc
 800675c:	f7ff fd54 	bl	8006208 <mul64>
 8006760:	4602      	mov	r2, r0
 8006762:	460b      	mov	r3, r1
        d2 = mul64( acc0, r2  ) +
 8006764:	e9d7 453c 	ldrd	r4, r5, [r7, #240]	@ 0xf0
 8006768:	4621      	mov	r1, r4
 800676a:	1889      	adds	r1, r1, r2
 800676c:	64b9      	str	r1, [r7, #72]	@ 0x48
 800676e:	4629      	mov	r1, r5
 8006770:	eb41 0303 	adc.w	r3, r1, r3
 8006774:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8006776:	e9d7 3412 	ldrd	r3, r4, [r7, #72]	@ 0x48
 800677a:	e9c7 3460 	strd	r3, r4, [r7, #384]	@ 0x180
        d3 = mul64( acc0, r3  ) +
 800677e:	f8d7 11a4 	ldr.w	r1, [r7, #420]	@ 0x1a4
 8006782:	f8d7 01cc 	ldr.w	r0, [r7, #460]	@ 0x1cc
 8006786:	f7ff fd3f 	bl	8006208 <mul64>
 800678a:	4604      	mov	r4, r0
 800678c:	460d      	mov	r5, r1
             mul64( acc1, r2  ) +
 800678e:	f8d7 11a8 	ldr.w	r1, [r7, #424]	@ 0x1a8
 8006792:	f8d7 01c8 	ldr.w	r0, [r7, #456]	@ 0x1c8
 8006796:	f7ff fd37 	bl	8006208 <mul64>
 800679a:	4602      	mov	r2, r0
 800679c:	460b      	mov	r3, r1
        d3 = mul64( acc0, r3  ) +
 800679e:	18a1      	adds	r1, r4, r2
 80067a0:	f8c7 10e8 	str.w	r1, [r7, #232]	@ 0xe8
 80067a4:	eb45 0303 	adc.w	r3, r5, r3
 80067a8:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
             mul64( acc2, r1  ) +
 80067ac:	f8d7 11ac 	ldr.w	r1, [r7, #428]	@ 0x1ac
 80067b0:	f8d7 01c4 	ldr.w	r0, [r7, #452]	@ 0x1c4
 80067b4:	f7ff fd28 	bl	8006208 <mul64>
 80067b8:	4602      	mov	r2, r0
 80067ba:	460b      	mov	r3, r1
             mul64( acc1, r2  ) +
 80067bc:	e9d7 453a 	ldrd	r4, r5, [r7, #232]	@ 0xe8
 80067c0:	4621      	mov	r1, r4
 80067c2:	1889      	adds	r1, r1, r2
 80067c4:	f8c7 10e0 	str.w	r1, [r7, #224]	@ 0xe0
 80067c8:	4629      	mov	r1, r5
 80067ca:	eb41 0303 	adc.w	r3, r1, r3
 80067ce:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
             mul64( acc3, r0  ) +
 80067d2:	f8d7 11b0 	ldr.w	r1, [r7, #432]	@ 0x1b0
 80067d6:	f8d7 01c0 	ldr.w	r0, [r7, #448]	@ 0x1c0
 80067da:	f7ff fd15 	bl	8006208 <mul64>
 80067de:	4602      	mov	r2, r0
 80067e0:	460b      	mov	r3, r1
             mul64( acc2, r1  ) +
 80067e2:	e9d7 4538 	ldrd	r4, r5, [r7, #224]	@ 0xe0
 80067e6:	4621      	mov	r1, r4
 80067e8:	eb11 0a02 	adds.w	sl, r1, r2
 80067ec:	4629      	mov	r1, r5
 80067ee:	eb41 0b03 	adc.w	fp, r1, r3
             mul64( acc4, rs3 );
 80067f2:	f8d7 1198 	ldr.w	r1, [r7, #408]	@ 0x198
 80067f6:	f8d7 01bc 	ldr.w	r0, [r7, #444]	@ 0x1bc
 80067fa:	f7ff fd05 	bl	8006208 <mul64>
 80067fe:	4602      	mov	r2, r0
 8006800:	460b      	mov	r3, r1
        d3 = mul64( acc0, r3  ) +
 8006802:	eb1a 0102 	adds.w	r1, sl, r2
 8006806:	6439      	str	r1, [r7, #64]	@ 0x40
 8006808:	eb4b 0303 	adc.w	r3, fp, r3
 800680c:	647b      	str	r3, [r7, #68]	@ 0x44
 800680e:	e9d7 3410 	ldrd	r3, r4, [r7, #64]	@ 0x40
 8006812:	e9c7 345e 	strd	r3, r4, [r7, #376]	@ 0x178
        acc4 *= r0;
 8006816:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 800681a:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 800681e:	fb02 f303 	mul.w	r3, r2, r3
 8006822:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc

        /* Compute: acc %= (2^130 - 5) (partial remainder) */
        d1 += ( d0 >> 32 );
 8006826:	e9d7 2364 	ldrd	r2, r3, [r7, #400]	@ 0x190
 800682a:	f04f 0000 	mov.w	r0, #0
 800682e:	f04f 0100 	mov.w	r1, #0
 8006832:	0018      	movs	r0, r3
 8006834:	2100      	movs	r1, #0
 8006836:	e9d7 2362 	ldrd	r2, r3, [r7, #392]	@ 0x188
 800683a:	1814      	adds	r4, r2, r0
 800683c:	63bc      	str	r4, [r7, #56]	@ 0x38
 800683e:	414b      	adcs	r3, r1
 8006840:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8006842:	e9d7 340e 	ldrd	r3, r4, [r7, #56]	@ 0x38
 8006846:	e9c7 3462 	strd	r3, r4, [r7, #392]	@ 0x188
        d2 += ( d1 >> 32 );
 800684a:	e9d7 2362 	ldrd	r2, r3, [r7, #392]	@ 0x188
 800684e:	f04f 0000 	mov.w	r0, #0
 8006852:	f04f 0100 	mov.w	r1, #0
 8006856:	0018      	movs	r0, r3
 8006858:	2100      	movs	r1, #0
 800685a:	e9d7 2360 	ldrd	r2, r3, [r7, #384]	@ 0x180
 800685e:	1814      	adds	r4, r2, r0
 8006860:	633c      	str	r4, [r7, #48]	@ 0x30
 8006862:	414b      	adcs	r3, r1
 8006864:	637b      	str	r3, [r7, #52]	@ 0x34
 8006866:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	@ 0x30
 800686a:	e9c7 3460 	strd	r3, r4, [r7, #384]	@ 0x180
        d3 += ( d2 >> 32 );
 800686e:	e9d7 2360 	ldrd	r2, r3, [r7, #384]	@ 0x180
 8006872:	f04f 0000 	mov.w	r0, #0
 8006876:	f04f 0100 	mov.w	r1, #0
 800687a:	0018      	movs	r0, r3
 800687c:	2100      	movs	r1, #0
 800687e:	e9d7 235e 	ldrd	r2, r3, [r7, #376]	@ 0x178
 8006882:	1814      	adds	r4, r2, r0
 8006884:	62bc      	str	r4, [r7, #40]	@ 0x28
 8006886:	414b      	adcs	r3, r1
 8006888:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800688a:	e9d7 340a 	ldrd	r3, r4, [r7, #40]	@ 0x28
 800688e:	e9c7 345e 	strd	r3, r4, [r7, #376]	@ 0x178
        acc0 = (uint32_t) d0;
 8006892:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 8006896:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
        acc1 = (uint32_t) d1;
 800689a:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 800689e:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
        acc2 = (uint32_t) d2;
 80068a2:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 80068a6:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
        acc3 = (uint32_t) d3;
 80068aa:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 80068ae:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
        acc4 = (uint32_t) ( d3 >> 32 ) + acc4;
 80068b2:	e9d7 235e 	ldrd	r2, r3, [r7, #376]	@ 0x178
 80068b6:	f04f 0000 	mov.w	r0, #0
 80068ba:	f04f 0100 	mov.w	r1, #0
 80068be:	0018      	movs	r0, r3
 80068c0:	2100      	movs	r1, #0
 80068c2:	4602      	mov	r2, r0
 80068c4:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 80068c8:	4413      	add	r3, r2
 80068ca:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc

        d0 = (uint64_t) acc0 + ( acc4 >> 2 ) + ( acc4 & 0xFFFFFFFCU );
 80068ce:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 80068d2:	2200      	movs	r2, #0
 80068d4:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
 80068d8:	f8c7 20dc 	str.w	r2, [r7, #220]	@ 0xdc
 80068dc:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 80068e0:	089b      	lsrs	r3, r3, #2
 80068e2:	2200      	movs	r2, #0
 80068e4:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 80068e8:	f8c7 20d4 	str.w	r2, [r7, #212]	@ 0xd4
 80068ec:	e9d7 4536 	ldrd	r4, r5, [r7, #216]	@ 0xd8
 80068f0:	4623      	mov	r3, r4
 80068f2:	e9d7 0134 	ldrd	r0, r1, [r7, #208]	@ 0xd0
 80068f6:	4602      	mov	r2, r0
 80068f8:	eb13 0802 	adds.w	r8, r3, r2
 80068fc:	462b      	mov	r3, r5
 80068fe:	460a      	mov	r2, r1
 8006900:	eb43 0902 	adc.w	r9, r3, r2
 8006904:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8006908:	2200      	movs	r2, #0
 800690a:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 800690e:	f8c7 20cc 	str.w	r2, [r7, #204]	@ 0xcc
 8006912:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8006916:	f023 0303 	bic.w	r3, r3, #3
 800691a:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 800691e:	2300      	movs	r3, #0
 8006920:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 8006924:	e9d7 1230 	ldrd	r1, r2, [r7, #192]	@ 0xc0
 8006928:	460b      	mov	r3, r1
 800692a:	eb18 0303 	adds.w	r3, r8, r3
 800692e:	623b      	str	r3, [r7, #32]
 8006930:	4613      	mov	r3, r2
 8006932:	eb49 0303 	adc.w	r3, r9, r3
 8006936:	627b      	str	r3, [r7, #36]	@ 0x24
 8006938:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
 800693c:	e9c7 3464 	strd	r3, r4, [r7, #400]	@ 0x190
        acc4 &= 3U;
 8006940:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8006944:	f003 0303 	and.w	r3, r3, #3
 8006948:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
        acc0 = (uint32_t) d0;
 800694c:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 8006950:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
        d0 = (uint64_t) acc1 + ( d0 >> 32U );
 8006954:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8006958:	2200      	movs	r2, #0
 800695a:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
 800695e:	f8c7 20bc 	str.w	r2, [r7, #188]	@ 0xbc
 8006962:	e9d7 2364 	ldrd	r2, r3, [r7, #400]	@ 0x190
 8006966:	f04f 0000 	mov.w	r0, #0
 800696a:	f04f 0100 	mov.w	r1, #0
 800696e:	0018      	movs	r0, r3
 8006970:	2100      	movs	r1, #0
 8006972:	e9d7 452e 	ldrd	r4, r5, [r7, #184]	@ 0xb8
 8006976:	4623      	mov	r3, r4
 8006978:	181b      	adds	r3, r3, r0
 800697a:	61bb      	str	r3, [r7, #24]
 800697c:	462b      	mov	r3, r5
 800697e:	414b      	adcs	r3, r1
 8006980:	61fb      	str	r3, [r7, #28]
 8006982:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 8006986:	e9c7 3464 	strd	r3, r4, [r7, #400]	@ 0x190
        acc1 = (uint32_t) d0;
 800698a:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 800698e:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
        d0 = (uint64_t) acc2 + ( d0 >> 32U );
 8006992:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 8006996:	2200      	movs	r2, #0
 8006998:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
 800699c:	f8c7 20b4 	str.w	r2, [r7, #180]	@ 0xb4
 80069a0:	e9d7 2364 	ldrd	r2, r3, [r7, #400]	@ 0x190
 80069a4:	f04f 0000 	mov.w	r0, #0
 80069a8:	f04f 0100 	mov.w	r1, #0
 80069ac:	0018      	movs	r0, r3
 80069ae:	2100      	movs	r1, #0
 80069b0:	e9d7 452c 	ldrd	r4, r5, [r7, #176]	@ 0xb0
 80069b4:	4623      	mov	r3, r4
 80069b6:	181b      	adds	r3, r3, r0
 80069b8:	613b      	str	r3, [r7, #16]
 80069ba:	462b      	mov	r3, r5
 80069bc:	414b      	adcs	r3, r1
 80069be:	617b      	str	r3, [r7, #20]
 80069c0:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 80069c4:	e9c7 3464 	strd	r3, r4, [r7, #400]	@ 0x190
        acc2 = (uint32_t) d0;
 80069c8:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 80069cc:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
        d0 = (uint64_t) acc3 + ( d0 >> 32U );
 80069d0:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 80069d4:	2200      	movs	r2, #0
 80069d6:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
 80069da:	f8c7 20ac 	str.w	r2, [r7, #172]	@ 0xac
 80069de:	e9d7 2364 	ldrd	r2, r3, [r7, #400]	@ 0x190
 80069e2:	f04f 0000 	mov.w	r0, #0
 80069e6:	f04f 0100 	mov.w	r1, #0
 80069ea:	0018      	movs	r0, r3
 80069ec:	2100      	movs	r1, #0
 80069ee:	e9d7 452a 	ldrd	r4, r5, [r7, #168]	@ 0xa8
 80069f2:	4623      	mov	r3, r4
 80069f4:	181b      	adds	r3, r3, r0
 80069f6:	60bb      	str	r3, [r7, #8]
 80069f8:	462b      	mov	r3, r5
 80069fa:	414b      	adcs	r3, r1
 80069fc:	60fb      	str	r3, [r7, #12]
 80069fe:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 8006a02:	e9c7 3464 	strd	r3, r4, [r7, #400]	@ 0x190
        acc3 = (uint32_t) d0;
 8006a06:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 8006a0a:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
        d0 = (uint64_t) acc4 + ( d0 >> 32U );
 8006a0e:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8006a12:	2200      	movs	r2, #0
 8006a14:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 8006a18:	f8c7 20a4 	str.w	r2, [r7, #164]	@ 0xa4
 8006a1c:	e9d7 2364 	ldrd	r2, r3, [r7, #400]	@ 0x190
 8006a20:	f04f 0000 	mov.w	r0, #0
 8006a24:	f04f 0100 	mov.w	r1, #0
 8006a28:	0018      	movs	r0, r3
 8006a2a:	2100      	movs	r1, #0
 8006a2c:	e9d7 4528 	ldrd	r4, r5, [r7, #160]	@ 0xa0
 8006a30:	4623      	mov	r3, r4
 8006a32:	181b      	adds	r3, r3, r0
 8006a34:	603b      	str	r3, [r7, #0]
 8006a36:	462b      	mov	r3, r5
 8006a38:	414b      	adcs	r3, r1
 8006a3a:	607b      	str	r3, [r7, #4]
 8006a3c:	e9d7 3400 	ldrd	r3, r4, [r7]
 8006a40:	e9c7 3464 	strd	r3, r4, [r7, #400]	@ 0x190
        acc4 = (uint32_t) d0;
 8006a44:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 8006a48:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc

        offset    += POLY1305_BLOCK_SIZE_BYTES;
 8006a4c:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8006a50:	3310      	adds	r3, #16
 8006a52:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    for( i = 0U; i < nblocks; i++ )
 8006a56:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8006a5a:	3301      	adds	r3, #1
 8006a5c:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
 8006a60:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8006a64:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8006a68:	429a      	cmp	r2, r3
 8006a6a:	f4ff ac43 	bcc.w	80062f4 <poly1305_process+0xb0>
    }

    ctx->acc[0] = acc0;
 8006a6e:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8006a72:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8006a76:	621a      	str	r2, [r3, #32]
    ctx->acc[1] = acc1;
 8006a78:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8006a7c:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8006a80:	625a      	str	r2, [r3, #36]	@ 0x24
    ctx->acc[2] = acc2;
 8006a82:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8006a86:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8006a8a:	629a      	str	r2, [r3, #40]	@ 0x28
    ctx->acc[3] = acc3;
 8006a8c:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8006a90:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 8006a94:	62da      	str	r2, [r3, #44]	@ 0x2c
    ctx->acc[4] = acc4;
 8006a96:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8006a9a:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8006a9e:	631a      	str	r2, [r3, #48]	@ 0x30
}
 8006aa0:	bf00      	nop
 8006aa2:	f507 77e8 	add.w	r7, r7, #464	@ 0x1d0
 8006aa6:	46bd      	mov	sp, r7
 8006aa8:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08006aac <poly1305_compute_mac>:
 * \param mac               The buffer to where the MAC is written. Must be
 *                          big enough to contain the 16-byte MAC.
 */
static void poly1305_compute_mac( const mbedtls_poly1305_context *ctx,
                                  unsigned char mac[16] )
{
 8006aac:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8006ab0:	b0b3      	sub	sp, #204	@ 0xcc
 8006ab2:	af00      	add	r7, sp, #0
 8006ab4:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
 8006ab8:	f8c7 1080 	str.w	r1, [r7, #128]	@ 0x80
    uint32_t g0, g1, g2, g3, g4;
    uint32_t acc0, acc1, acc2, acc3, acc4;
    uint32_t mask;
    uint32_t mask_inv;

    acc0 = ctx->acc[0];
 8006abc:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8006ac0:	6a1b      	ldr	r3, [r3, #32]
 8006ac2:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    acc1 = ctx->acc[1];
 8006ac6:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8006aca:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8006acc:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
    acc2 = ctx->acc[2];
 8006ad0:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8006ad4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8006ad6:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    acc3 = ctx->acc[3];
 8006ada:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8006ade:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8006ae0:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    acc4 = ctx->acc[4];
 8006ae4:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8006ae8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8006aea:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
     * We do this by calculating acc - (2^130 - 5), then checking if
     * the 131st bit is set. If it is, then reduce: acc -= (2^130 - 5)
     */

    /* Calculate acc + -(2^130 - 5) */
    d  = ( (uint64_t) acc0 + 5U );
 8006aee:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8006af2:	2200      	movs	r2, #0
 8006af4:	461c      	mov	r4, r3
 8006af6:	4615      	mov	r5, r2
 8006af8:	f114 0805 	adds.w	r8, r4, #5
 8006afc:	f145 0900 	adc.w	r9, r5, #0
 8006b00:	e9c7 892a 	strd	r8, r9, [r7, #168]	@ 0xa8
    g0 = (uint32_t) d;
 8006b04:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8006b08:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    d  = ( (uint64_t) acc1 + ( d >> 32 ) );
 8006b0c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8006b10:	2200      	movs	r2, #0
 8006b12:	469a      	mov	sl, r3
 8006b14:	4693      	mov	fp, r2
 8006b16:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	@ 0xa8
 8006b1a:	f04f 0000 	mov.w	r0, #0
 8006b1e:	f04f 0100 	mov.w	r1, #0
 8006b22:	0018      	movs	r0, r3
 8006b24:	2100      	movs	r1, #0
 8006b26:	eb1a 0300 	adds.w	r3, sl, r0
 8006b2a:	62bb      	str	r3, [r7, #40]	@ 0x28
 8006b2c:	eb4b 0301 	adc.w	r3, fp, r1
 8006b30:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8006b32:	e9d7 340a 	ldrd	r3, r4, [r7, #40]	@ 0x28
 8006b36:	e9c7 342a 	strd	r3, r4, [r7, #168]	@ 0xa8
    g1 = (uint32_t) d;
 8006b3a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8006b3e:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
    d  = ( (uint64_t) acc2 + ( d >> 32 ) );
 8006b42:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8006b46:	2200      	movs	r2, #0
 8006b48:	67bb      	str	r3, [r7, #120]	@ 0x78
 8006b4a:	67fa      	str	r2, [r7, #124]	@ 0x7c
 8006b4c:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	@ 0xa8
 8006b50:	f04f 0000 	mov.w	r0, #0
 8006b54:	f04f 0100 	mov.w	r1, #0
 8006b58:	0018      	movs	r0, r3
 8006b5a:	2100      	movs	r1, #0
 8006b5c:	e9d7 451e 	ldrd	r4, r5, [r7, #120]	@ 0x78
 8006b60:	4623      	mov	r3, r4
 8006b62:	181b      	adds	r3, r3, r0
 8006b64:	623b      	str	r3, [r7, #32]
 8006b66:	462b      	mov	r3, r5
 8006b68:	eb41 0303 	adc.w	r3, r1, r3
 8006b6c:	627b      	str	r3, [r7, #36]	@ 0x24
 8006b6e:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
 8006b72:	e9c7 342a 	strd	r3, r4, [r7, #168]	@ 0xa8
    g2 = (uint32_t) d;
 8006b76:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8006b7a:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
    d  = ( (uint64_t) acc3 + ( d >> 32 ) );
 8006b7e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8006b82:	2200      	movs	r2, #0
 8006b84:	673b      	str	r3, [r7, #112]	@ 0x70
 8006b86:	677a      	str	r2, [r7, #116]	@ 0x74
 8006b88:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	@ 0xa8
 8006b8c:	f04f 0000 	mov.w	r0, #0
 8006b90:	f04f 0100 	mov.w	r1, #0
 8006b94:	0018      	movs	r0, r3
 8006b96:	2100      	movs	r1, #0
 8006b98:	e9d7 451c 	ldrd	r4, r5, [r7, #112]	@ 0x70
 8006b9c:	4623      	mov	r3, r4
 8006b9e:	181b      	adds	r3, r3, r0
 8006ba0:	61bb      	str	r3, [r7, #24]
 8006ba2:	462b      	mov	r3, r5
 8006ba4:	eb41 0303 	adc.w	r3, r1, r3
 8006ba8:	61fb      	str	r3, [r7, #28]
 8006baa:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 8006bae:	e9c7 342a 	strd	r3, r4, [r7, #168]	@ 0xa8
    g3 = (uint32_t) d;
 8006bb2:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8006bb6:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
    g4 = acc4 + (uint32_t) ( d >> 32U );
 8006bba:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	@ 0xa8
 8006bbe:	f04f 0000 	mov.w	r0, #0
 8006bc2:	f04f 0100 	mov.w	r1, #0
 8006bc6:	0018      	movs	r0, r3
 8006bc8:	2100      	movs	r1, #0
 8006bca:	4602      	mov	r2, r0
 8006bcc:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8006bd0:	4413      	add	r3, r2
 8006bd2:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

    /* mask == 0xFFFFFFFF if 131st bit is set, otherwise mask == 0 */
    mask = (uint32_t) 0U - ( g4 >> 2U );
 8006bd6:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8006bda:	089b      	lsrs	r3, r3, #2
 8006bdc:	425b      	negs	r3, r3
 8006bde:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
    mask_inv = ~mask;
 8006be2:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8006be6:	43db      	mvns	r3, r3
 8006be8:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c

    /* If 131st bit is set then acc=g, otherwise, acc is unmodified */
    acc0 = ( acc0 & mask_inv ) | ( g0 & mask );
 8006bec:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8006bf0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8006bf4:	ea02 0103 	and.w	r1, r2, r3
 8006bf8:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 8006bfc:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8006c00:	4013      	ands	r3, r2
 8006c02:	430b      	orrs	r3, r1
 8006c04:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    acc1 = ( acc1 & mask_inv ) | ( g1 & mask );
 8006c08:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
 8006c0c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8006c10:	ea02 0103 	and.w	r1, r2, r3
 8006c14:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 8006c18:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8006c1c:	4013      	ands	r3, r2
 8006c1e:	430b      	orrs	r3, r1
 8006c20:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
    acc2 = ( acc2 & mask_inv ) | ( g2 & mask );
 8006c24:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8006c28:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8006c2c:	ea02 0103 	and.w	r1, r2, r3
 8006c30:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 8006c34:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8006c38:	4013      	ands	r3, r2
 8006c3a:	430b      	orrs	r3, r1
 8006c3c:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    acc3 = ( acc3 & mask_inv ) | ( g3 & mask );
 8006c40:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 8006c44:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8006c48:	ea02 0103 	and.w	r1, r2, r3
 8006c4c:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 8006c50:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8006c54:	4013      	ands	r3, r2
 8006c56:	430b      	orrs	r3, r1
 8006c58:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

    /* Add 's' */
    d = (uint64_t) acc0 + ctx->s[0];
 8006c5c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8006c60:	2200      	movs	r2, #0
 8006c62:	66bb      	str	r3, [r7, #104]	@ 0x68
 8006c64:	66fa      	str	r2, [r7, #108]	@ 0x6c
 8006c66:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8006c6a:	691b      	ldr	r3, [r3, #16]
 8006c6c:	2200      	movs	r2, #0
 8006c6e:	663b      	str	r3, [r7, #96]	@ 0x60
 8006c70:	667a      	str	r2, [r7, #100]	@ 0x64
 8006c72:	e9d7 451a 	ldrd	r4, r5, [r7, #104]	@ 0x68
 8006c76:	4623      	mov	r3, r4
 8006c78:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
 8006c7c:	4602      	mov	r2, r0
 8006c7e:	189b      	adds	r3, r3, r2
 8006c80:	613b      	str	r3, [r7, #16]
 8006c82:	460b      	mov	r3, r1
 8006c84:	462a      	mov	r2, r5
 8006c86:	eb42 0303 	adc.w	r3, r2, r3
 8006c8a:	617b      	str	r3, [r7, #20]
 8006c8c:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 8006c90:	e9c7 342a 	strd	r3, r4, [r7, #168]	@ 0xa8
    acc0 = (uint32_t) d;
 8006c94:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8006c98:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    d = (uint64_t) acc1 + ctx->s[1] + ( d >> 32U );
 8006c9c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8006ca0:	2200      	movs	r2, #0
 8006ca2:	65bb      	str	r3, [r7, #88]	@ 0x58
 8006ca4:	65fa      	str	r2, [r7, #92]	@ 0x5c
 8006ca6:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8006caa:	695b      	ldr	r3, [r3, #20]
 8006cac:	2200      	movs	r2, #0
 8006cae:	653b      	str	r3, [r7, #80]	@ 0x50
 8006cb0:	657a      	str	r2, [r7, #84]	@ 0x54
 8006cb2:	e9d7 4516 	ldrd	r4, r5, [r7, #88]	@ 0x58
 8006cb6:	4623      	mov	r3, r4
 8006cb8:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
 8006cbc:	4602      	mov	r2, r0
 8006cbe:	189b      	adds	r3, r3, r2
 8006cc0:	64bb      	str	r3, [r7, #72]	@ 0x48
 8006cc2:	460b      	mov	r3, r1
 8006cc4:	462a      	mov	r2, r5
 8006cc6:	eb42 0303 	adc.w	r3, r2, r3
 8006cca:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8006ccc:	e9d7 012a 	ldrd	r0, r1, [r7, #168]	@ 0xa8
 8006cd0:	f04f 0200 	mov.w	r2, #0
 8006cd4:	f04f 0300 	mov.w	r3, #0
 8006cd8:	000a      	movs	r2, r1
 8006cda:	2300      	movs	r3, #0
 8006cdc:	e9d7 4512 	ldrd	r4, r5, [r7, #72]	@ 0x48
 8006ce0:	4621      	mov	r1, r4
 8006ce2:	1889      	adds	r1, r1, r2
 8006ce4:	60b9      	str	r1, [r7, #8]
 8006ce6:	4629      	mov	r1, r5
 8006ce8:	eb43 0101 	adc.w	r1, r3, r1
 8006cec:	60f9      	str	r1, [r7, #12]
 8006cee:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 8006cf2:	e9c7 342a 	strd	r3, r4, [r7, #168]	@ 0xa8
    acc1 = (uint32_t) d;
 8006cf6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8006cfa:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
    d = (uint64_t) acc2 + ctx->s[2] + ( d >> 32U );
 8006cfe:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8006d02:	2200      	movs	r2, #0
 8006d04:	643b      	str	r3, [r7, #64]	@ 0x40
 8006d06:	647a      	str	r2, [r7, #68]	@ 0x44
 8006d08:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8006d0c:	699b      	ldr	r3, [r3, #24]
 8006d0e:	2200      	movs	r2, #0
 8006d10:	63bb      	str	r3, [r7, #56]	@ 0x38
 8006d12:	63fa      	str	r2, [r7, #60]	@ 0x3c
 8006d14:	e9d7 4510 	ldrd	r4, r5, [r7, #64]	@ 0x40
 8006d18:	4623      	mov	r3, r4
 8006d1a:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
 8006d1e:	4602      	mov	r2, r0
 8006d20:	189b      	adds	r3, r3, r2
 8006d22:	633b      	str	r3, [r7, #48]	@ 0x30
 8006d24:	460b      	mov	r3, r1
 8006d26:	462a      	mov	r2, r5
 8006d28:	eb42 0303 	adc.w	r3, r2, r3
 8006d2c:	637b      	str	r3, [r7, #52]	@ 0x34
 8006d2e:	e9d7 012a 	ldrd	r0, r1, [r7, #168]	@ 0xa8
 8006d32:	f04f 0200 	mov.w	r2, #0
 8006d36:	f04f 0300 	mov.w	r3, #0
 8006d3a:	000a      	movs	r2, r1
 8006d3c:	2300      	movs	r3, #0
 8006d3e:	e9d7 450c 	ldrd	r4, r5, [r7, #48]	@ 0x30
 8006d42:	4621      	mov	r1, r4
 8006d44:	1889      	adds	r1, r1, r2
 8006d46:	6039      	str	r1, [r7, #0]
 8006d48:	4629      	mov	r1, r5
 8006d4a:	eb43 0101 	adc.w	r1, r3, r1
 8006d4e:	6079      	str	r1, [r7, #4]
 8006d50:	e9d7 3400 	ldrd	r3, r4, [r7]
 8006d54:	e9c7 342a 	strd	r3, r4, [r7, #168]	@ 0xa8
    acc2 = (uint32_t) d;
 8006d58:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8006d5c:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    acc3 += ctx->s[3] + (uint32_t) ( d >> 32U );
 8006d60:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8006d64:	69dc      	ldr	r4, [r3, #28]
 8006d66:	e9d7 012a 	ldrd	r0, r1, [r7, #168]	@ 0xa8
 8006d6a:	f04f 0200 	mov.w	r2, #0
 8006d6e:	f04f 0300 	mov.w	r3, #0
 8006d72:	000a      	movs	r2, r1
 8006d74:	2300      	movs	r3, #0
 8006d76:	4613      	mov	r3, r2
 8006d78:	4423      	add	r3, r4
 8006d7a:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 8006d7e:	4413      	add	r3, r2
 8006d80:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

    /* Compute MAC (128 least significant bits of the accumulator) */
    mac[ 0] = (unsigned char)( acc0       );
 8006d84:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8006d88:	b2da      	uxtb	r2, r3
 8006d8a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8006d8e:	701a      	strb	r2, [r3, #0]
    mac[ 1] = (unsigned char)( acc0 >>  8 );
 8006d90:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8006d94:	0a1a      	lsrs	r2, r3, #8
 8006d96:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8006d9a:	3301      	adds	r3, #1
 8006d9c:	b2d2      	uxtb	r2, r2
 8006d9e:	701a      	strb	r2, [r3, #0]
    mac[ 2] = (unsigned char)( acc0 >> 16 );
 8006da0:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8006da4:	0c1a      	lsrs	r2, r3, #16
 8006da6:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8006daa:	3302      	adds	r3, #2
 8006dac:	b2d2      	uxtb	r2, r2
 8006dae:	701a      	strb	r2, [r3, #0]
    mac[ 3] = (unsigned char)( acc0 >> 24 );
 8006db0:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8006db4:	0e1a      	lsrs	r2, r3, #24
 8006db6:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8006dba:	3303      	adds	r3, #3
 8006dbc:	b2d2      	uxtb	r2, r2
 8006dbe:	701a      	strb	r2, [r3, #0]
    mac[ 4] = (unsigned char)( acc1       );
 8006dc0:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8006dc4:	3304      	adds	r3, #4
 8006dc6:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
 8006dca:	b2d2      	uxtb	r2, r2
 8006dcc:	701a      	strb	r2, [r3, #0]
    mac[ 5] = (unsigned char)( acc1 >>  8 );
 8006dce:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8006dd2:	0a1a      	lsrs	r2, r3, #8
 8006dd4:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8006dd8:	3305      	adds	r3, #5
 8006dda:	b2d2      	uxtb	r2, r2
 8006ddc:	701a      	strb	r2, [r3, #0]
    mac[ 6] = (unsigned char)( acc1 >> 16 );
 8006dde:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8006de2:	0c1a      	lsrs	r2, r3, #16
 8006de4:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8006de8:	3306      	adds	r3, #6
 8006dea:	b2d2      	uxtb	r2, r2
 8006dec:	701a      	strb	r2, [r3, #0]
    mac[ 7] = (unsigned char)( acc1 >> 24 );
 8006dee:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8006df2:	0e1a      	lsrs	r2, r3, #24
 8006df4:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8006df8:	3307      	adds	r3, #7
 8006dfa:	b2d2      	uxtb	r2, r2
 8006dfc:	701a      	strb	r2, [r3, #0]
    mac[ 8] = (unsigned char)( acc2       );
 8006dfe:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8006e02:	3308      	adds	r3, #8
 8006e04:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8006e08:	b2d2      	uxtb	r2, r2
 8006e0a:	701a      	strb	r2, [r3, #0]
    mac[ 9] = (unsigned char)( acc2 >>  8 );
 8006e0c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8006e10:	0a1a      	lsrs	r2, r3, #8
 8006e12:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8006e16:	3309      	adds	r3, #9
 8006e18:	b2d2      	uxtb	r2, r2
 8006e1a:	701a      	strb	r2, [r3, #0]
    mac[10] = (unsigned char)( acc2 >> 16 );
 8006e1c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8006e20:	0c1a      	lsrs	r2, r3, #16
 8006e22:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8006e26:	330a      	adds	r3, #10
 8006e28:	b2d2      	uxtb	r2, r2
 8006e2a:	701a      	strb	r2, [r3, #0]
    mac[11] = (unsigned char)( acc2 >> 24 );
 8006e2c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8006e30:	0e1a      	lsrs	r2, r3, #24
 8006e32:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8006e36:	330b      	adds	r3, #11
 8006e38:	b2d2      	uxtb	r2, r2
 8006e3a:	701a      	strb	r2, [r3, #0]
    mac[12] = (unsigned char)( acc3       );
 8006e3c:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8006e40:	330c      	adds	r3, #12
 8006e42:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 8006e46:	b2d2      	uxtb	r2, r2
 8006e48:	701a      	strb	r2, [r3, #0]
    mac[13] = (unsigned char)( acc3 >>  8 );
 8006e4a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8006e4e:	0a1a      	lsrs	r2, r3, #8
 8006e50:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8006e54:	330d      	adds	r3, #13
 8006e56:	b2d2      	uxtb	r2, r2
 8006e58:	701a      	strb	r2, [r3, #0]
    mac[14] = (unsigned char)( acc3 >> 16 );
 8006e5a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8006e5e:	0c1a      	lsrs	r2, r3, #16
 8006e60:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8006e64:	330e      	adds	r3, #14
 8006e66:	b2d2      	uxtb	r2, r2
 8006e68:	701a      	strb	r2, [r3, #0]
    mac[15] = (unsigned char)( acc3 >> 24 );
 8006e6a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8006e6e:	0e1a      	lsrs	r2, r3, #24
 8006e70:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8006e74:	330f      	adds	r3, #15
 8006e76:	b2d2      	uxtb	r2, r2
 8006e78:	701a      	strb	r2, [r3, #0]
}
 8006e7a:	bf00      	nop
 8006e7c:	37cc      	adds	r7, #204	@ 0xcc
 8006e7e:	46bd      	mov	sp, r7
 8006e80:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8006e84:	4770      	bx	lr

08006e86 <mbedtls_poly1305_init>:

void mbedtls_poly1305_init( mbedtls_poly1305_context *ctx )
{
 8006e86:	b580      	push	{r7, lr}
 8006e88:	b082      	sub	sp, #8
 8006e8a:	af00      	add	r7, sp, #0
 8006e8c:	6078      	str	r0, [r7, #4]
    POLY1305_VALIDATE( ctx != NULL );

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_poly1305_context ) );
 8006e8e:	2148      	movs	r1, #72	@ 0x48
 8006e90:	6878      	ldr	r0, [r7, #4]
 8006e92:	f7ff f9a5 	bl	80061e0 <mbedtls_platform_zeroize>
}
 8006e96:	bf00      	nop
 8006e98:	3708      	adds	r7, #8
 8006e9a:	46bd      	mov	sp, r7
 8006e9c:	bd80      	pop	{r7, pc}

08006e9e <mbedtls_poly1305_free>:

void mbedtls_poly1305_free( mbedtls_poly1305_context *ctx )
{
 8006e9e:	b580      	push	{r7, lr}
 8006ea0:	b082      	sub	sp, #8
 8006ea2:	af00      	add	r7, sp, #0
 8006ea4:	6078      	str	r0, [r7, #4]
    if( ctx == NULL )
 8006ea6:	687b      	ldr	r3, [r7, #4]
 8006ea8:	2b00      	cmp	r3, #0
 8006eaa:	d004      	beq.n	8006eb6 <mbedtls_poly1305_free+0x18>
        return;

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_poly1305_context ) );
 8006eac:	2148      	movs	r1, #72	@ 0x48
 8006eae:	6878      	ldr	r0, [r7, #4]
 8006eb0:	f7ff f996 	bl	80061e0 <mbedtls_platform_zeroize>
 8006eb4:	e000      	b.n	8006eb8 <mbedtls_poly1305_free+0x1a>
        return;
 8006eb6:	bf00      	nop
}
 8006eb8:	3708      	adds	r7, #8
 8006eba:	46bd      	mov	sp, r7
 8006ebc:	bd80      	pop	{r7, pc}

08006ebe <mbedtls_poly1305_starts>:

int mbedtls_poly1305_starts( mbedtls_poly1305_context *ctx,
                             const unsigned char key[32] )
{
 8006ebe:	b580      	push	{r7, lr}
 8006ec0:	b082      	sub	sp, #8
 8006ec2:	af00      	add	r7, sp, #0
 8006ec4:	6078      	str	r0, [r7, #4]
 8006ec6:	6039      	str	r1, [r7, #0]
    POLY1305_VALIDATE_RET( ctx != NULL );
    POLY1305_VALIDATE_RET( key != NULL );

    /* r &= 0x0ffffffc0ffffffc0ffffffc0fffffff */
    ctx->r[0] = BYTES_TO_U32_LE( key, 0 )  & 0x0FFFFFFFU;
 8006ec8:	683b      	ldr	r3, [r7, #0]
 8006eca:	781b      	ldrb	r3, [r3, #0]
 8006ecc:	461a      	mov	r2, r3
 8006ece:	683b      	ldr	r3, [r7, #0]
 8006ed0:	3301      	adds	r3, #1
 8006ed2:	781b      	ldrb	r3, [r3, #0]
 8006ed4:	021b      	lsls	r3, r3, #8
 8006ed6:	431a      	orrs	r2, r3
 8006ed8:	683b      	ldr	r3, [r7, #0]
 8006eda:	3302      	adds	r3, #2
 8006edc:	781b      	ldrb	r3, [r3, #0]
 8006ede:	041b      	lsls	r3, r3, #16
 8006ee0:	431a      	orrs	r2, r3
 8006ee2:	683b      	ldr	r3, [r7, #0]
 8006ee4:	3303      	adds	r3, #3
 8006ee6:	781b      	ldrb	r3, [r3, #0]
 8006ee8:	061b      	lsls	r3, r3, #24
 8006eea:	4313      	orrs	r3, r2
 8006eec:	f023 4270 	bic.w	r2, r3, #4026531840	@ 0xf0000000
 8006ef0:	687b      	ldr	r3, [r7, #4]
 8006ef2:	601a      	str	r2, [r3, #0]
    ctx->r[1] = BYTES_TO_U32_LE( key, 4 )  & 0x0FFFFFFCU;
 8006ef4:	683b      	ldr	r3, [r7, #0]
 8006ef6:	3304      	adds	r3, #4
 8006ef8:	781b      	ldrb	r3, [r3, #0]
 8006efa:	461a      	mov	r2, r3
 8006efc:	683b      	ldr	r3, [r7, #0]
 8006efe:	3305      	adds	r3, #5
 8006f00:	781b      	ldrb	r3, [r3, #0]
 8006f02:	021b      	lsls	r3, r3, #8
 8006f04:	431a      	orrs	r2, r3
 8006f06:	683b      	ldr	r3, [r7, #0]
 8006f08:	3306      	adds	r3, #6
 8006f0a:	781b      	ldrb	r3, [r3, #0]
 8006f0c:	041b      	lsls	r3, r3, #16
 8006f0e:	431a      	orrs	r2, r3
 8006f10:	683b      	ldr	r3, [r7, #0]
 8006f12:	3307      	adds	r3, #7
 8006f14:	781b      	ldrb	r3, [r3, #0]
 8006f16:	061b      	lsls	r3, r3, #24
 8006f18:	4313      	orrs	r3, r2
 8006f1a:	f023 4370 	bic.w	r3, r3, #4026531840	@ 0xf0000000
 8006f1e:	f023 0303 	bic.w	r3, r3, #3
 8006f22:	687a      	ldr	r2, [r7, #4]
 8006f24:	6053      	str	r3, [r2, #4]
    ctx->r[2] = BYTES_TO_U32_LE( key, 8 )  & 0x0FFFFFFCU;
 8006f26:	683b      	ldr	r3, [r7, #0]
 8006f28:	3308      	adds	r3, #8
 8006f2a:	781b      	ldrb	r3, [r3, #0]
 8006f2c:	461a      	mov	r2, r3
 8006f2e:	683b      	ldr	r3, [r7, #0]
 8006f30:	3309      	adds	r3, #9
 8006f32:	781b      	ldrb	r3, [r3, #0]
 8006f34:	021b      	lsls	r3, r3, #8
 8006f36:	431a      	orrs	r2, r3
 8006f38:	683b      	ldr	r3, [r7, #0]
 8006f3a:	330a      	adds	r3, #10
 8006f3c:	781b      	ldrb	r3, [r3, #0]
 8006f3e:	041b      	lsls	r3, r3, #16
 8006f40:	431a      	orrs	r2, r3
 8006f42:	683b      	ldr	r3, [r7, #0]
 8006f44:	330b      	adds	r3, #11
 8006f46:	781b      	ldrb	r3, [r3, #0]
 8006f48:	061b      	lsls	r3, r3, #24
 8006f4a:	4313      	orrs	r3, r2
 8006f4c:	f023 4370 	bic.w	r3, r3, #4026531840	@ 0xf0000000
 8006f50:	f023 0303 	bic.w	r3, r3, #3
 8006f54:	687a      	ldr	r2, [r7, #4]
 8006f56:	6093      	str	r3, [r2, #8]
    ctx->r[3] = BYTES_TO_U32_LE( key, 12 ) & 0x0FFFFFFCU;
 8006f58:	683b      	ldr	r3, [r7, #0]
 8006f5a:	330c      	adds	r3, #12
 8006f5c:	781b      	ldrb	r3, [r3, #0]
 8006f5e:	461a      	mov	r2, r3
 8006f60:	683b      	ldr	r3, [r7, #0]
 8006f62:	330d      	adds	r3, #13
 8006f64:	781b      	ldrb	r3, [r3, #0]
 8006f66:	021b      	lsls	r3, r3, #8
 8006f68:	431a      	orrs	r2, r3
 8006f6a:	683b      	ldr	r3, [r7, #0]
 8006f6c:	330e      	adds	r3, #14
 8006f6e:	781b      	ldrb	r3, [r3, #0]
 8006f70:	041b      	lsls	r3, r3, #16
 8006f72:	431a      	orrs	r2, r3
 8006f74:	683b      	ldr	r3, [r7, #0]
 8006f76:	330f      	adds	r3, #15
 8006f78:	781b      	ldrb	r3, [r3, #0]
 8006f7a:	061b      	lsls	r3, r3, #24
 8006f7c:	4313      	orrs	r3, r2
 8006f7e:	f023 4370 	bic.w	r3, r3, #4026531840	@ 0xf0000000
 8006f82:	f023 0303 	bic.w	r3, r3, #3
 8006f86:	687a      	ldr	r2, [r7, #4]
 8006f88:	60d3      	str	r3, [r2, #12]

    ctx->s[0] = BYTES_TO_U32_LE( key, 16 );
 8006f8a:	683b      	ldr	r3, [r7, #0]
 8006f8c:	3310      	adds	r3, #16
 8006f8e:	781b      	ldrb	r3, [r3, #0]
 8006f90:	461a      	mov	r2, r3
 8006f92:	683b      	ldr	r3, [r7, #0]
 8006f94:	3311      	adds	r3, #17
 8006f96:	781b      	ldrb	r3, [r3, #0]
 8006f98:	021b      	lsls	r3, r3, #8
 8006f9a:	431a      	orrs	r2, r3
 8006f9c:	683b      	ldr	r3, [r7, #0]
 8006f9e:	3312      	adds	r3, #18
 8006fa0:	781b      	ldrb	r3, [r3, #0]
 8006fa2:	041b      	lsls	r3, r3, #16
 8006fa4:	431a      	orrs	r2, r3
 8006fa6:	683b      	ldr	r3, [r7, #0]
 8006fa8:	3313      	adds	r3, #19
 8006faa:	781b      	ldrb	r3, [r3, #0]
 8006fac:	061b      	lsls	r3, r3, #24
 8006fae:	431a      	orrs	r2, r3
 8006fb0:	687b      	ldr	r3, [r7, #4]
 8006fb2:	611a      	str	r2, [r3, #16]
    ctx->s[1] = BYTES_TO_U32_LE( key, 20 );
 8006fb4:	683b      	ldr	r3, [r7, #0]
 8006fb6:	3314      	adds	r3, #20
 8006fb8:	781b      	ldrb	r3, [r3, #0]
 8006fba:	461a      	mov	r2, r3
 8006fbc:	683b      	ldr	r3, [r7, #0]
 8006fbe:	3315      	adds	r3, #21
 8006fc0:	781b      	ldrb	r3, [r3, #0]
 8006fc2:	021b      	lsls	r3, r3, #8
 8006fc4:	431a      	orrs	r2, r3
 8006fc6:	683b      	ldr	r3, [r7, #0]
 8006fc8:	3316      	adds	r3, #22
 8006fca:	781b      	ldrb	r3, [r3, #0]
 8006fcc:	041b      	lsls	r3, r3, #16
 8006fce:	431a      	orrs	r2, r3
 8006fd0:	683b      	ldr	r3, [r7, #0]
 8006fd2:	3317      	adds	r3, #23
 8006fd4:	781b      	ldrb	r3, [r3, #0]
 8006fd6:	061b      	lsls	r3, r3, #24
 8006fd8:	431a      	orrs	r2, r3
 8006fda:	687b      	ldr	r3, [r7, #4]
 8006fdc:	615a      	str	r2, [r3, #20]
    ctx->s[2] = BYTES_TO_U32_LE( key, 24 );
 8006fde:	683b      	ldr	r3, [r7, #0]
 8006fe0:	3318      	adds	r3, #24
 8006fe2:	781b      	ldrb	r3, [r3, #0]
 8006fe4:	461a      	mov	r2, r3
 8006fe6:	683b      	ldr	r3, [r7, #0]
 8006fe8:	3319      	adds	r3, #25
 8006fea:	781b      	ldrb	r3, [r3, #0]
 8006fec:	021b      	lsls	r3, r3, #8
 8006fee:	431a      	orrs	r2, r3
 8006ff0:	683b      	ldr	r3, [r7, #0]
 8006ff2:	331a      	adds	r3, #26
 8006ff4:	781b      	ldrb	r3, [r3, #0]
 8006ff6:	041b      	lsls	r3, r3, #16
 8006ff8:	431a      	orrs	r2, r3
 8006ffa:	683b      	ldr	r3, [r7, #0]
 8006ffc:	331b      	adds	r3, #27
 8006ffe:	781b      	ldrb	r3, [r3, #0]
 8007000:	061b      	lsls	r3, r3, #24
 8007002:	431a      	orrs	r2, r3
 8007004:	687b      	ldr	r3, [r7, #4]
 8007006:	619a      	str	r2, [r3, #24]
    ctx->s[3] = BYTES_TO_U32_LE( key, 28 );
 8007008:	683b      	ldr	r3, [r7, #0]
 800700a:	331c      	adds	r3, #28
 800700c:	781b      	ldrb	r3, [r3, #0]
 800700e:	461a      	mov	r2, r3
 8007010:	683b      	ldr	r3, [r7, #0]
 8007012:	331d      	adds	r3, #29
 8007014:	781b      	ldrb	r3, [r3, #0]
 8007016:	021b      	lsls	r3, r3, #8
 8007018:	431a      	orrs	r2, r3
 800701a:	683b      	ldr	r3, [r7, #0]
 800701c:	331e      	adds	r3, #30
 800701e:	781b      	ldrb	r3, [r3, #0]
 8007020:	041b      	lsls	r3, r3, #16
 8007022:	431a      	orrs	r2, r3
 8007024:	683b      	ldr	r3, [r7, #0]
 8007026:	331f      	adds	r3, #31
 8007028:	781b      	ldrb	r3, [r3, #0]
 800702a:	061b      	lsls	r3, r3, #24
 800702c:	431a      	orrs	r2, r3
 800702e:	687b      	ldr	r3, [r7, #4]
 8007030:	61da      	str	r2, [r3, #28]

    /* Initial accumulator state */
    ctx->acc[0] = 0U;
 8007032:	687b      	ldr	r3, [r7, #4]
 8007034:	2200      	movs	r2, #0
 8007036:	621a      	str	r2, [r3, #32]
    ctx->acc[1] = 0U;
 8007038:	687b      	ldr	r3, [r7, #4]
 800703a:	2200      	movs	r2, #0
 800703c:	625a      	str	r2, [r3, #36]	@ 0x24
    ctx->acc[2] = 0U;
 800703e:	687b      	ldr	r3, [r7, #4]
 8007040:	2200      	movs	r2, #0
 8007042:	629a      	str	r2, [r3, #40]	@ 0x28
    ctx->acc[3] = 0U;
 8007044:	687b      	ldr	r3, [r7, #4]
 8007046:	2200      	movs	r2, #0
 8007048:	62da      	str	r2, [r3, #44]	@ 0x2c
    ctx->acc[4] = 0U;
 800704a:	687b      	ldr	r3, [r7, #4]
 800704c:	2200      	movs	r2, #0
 800704e:	631a      	str	r2, [r3, #48]	@ 0x30

    /* Queue initially empty */
    mbedtls_platform_zeroize( ctx->queue, sizeof( ctx->queue ) );
 8007050:	687b      	ldr	r3, [r7, #4]
 8007052:	3334      	adds	r3, #52	@ 0x34
 8007054:	2110      	movs	r1, #16
 8007056:	4618      	mov	r0, r3
 8007058:	f7ff f8c2 	bl	80061e0 <mbedtls_platform_zeroize>
    ctx->queue_len = 0U;
 800705c:	687b      	ldr	r3, [r7, #4]
 800705e:	2200      	movs	r2, #0
 8007060:	645a      	str	r2, [r3, #68]	@ 0x44

    return( 0 );
 8007062:	2300      	movs	r3, #0
}
 8007064:	4618      	mov	r0, r3
 8007066:	3708      	adds	r7, #8
 8007068:	46bd      	mov	sp, r7
 800706a:	bd80      	pop	{r7, pc}

0800706c <mbedtls_poly1305_update>:

int mbedtls_poly1305_update( mbedtls_poly1305_context *ctx,
                             const unsigned char *input,
                             size_t ilen )
{
 800706c:	b580      	push	{r7, lr}
 800706e:	b088      	sub	sp, #32
 8007070:	af00      	add	r7, sp, #0
 8007072:	60f8      	str	r0, [r7, #12]
 8007074:	60b9      	str	r1, [r7, #8]
 8007076:	607a      	str	r2, [r7, #4]
    size_t offset    = 0U;
 8007078:	2300      	movs	r3, #0
 800707a:	61fb      	str	r3, [r7, #28]
    size_t remaining = ilen;
 800707c:	687b      	ldr	r3, [r7, #4]
 800707e:	61bb      	str	r3, [r7, #24]
    size_t queue_free_len;
    size_t nblocks;
    POLY1305_VALIDATE_RET( ctx != NULL );
    POLY1305_VALIDATE_RET( ilen == 0 || input != NULL );

    if( ( remaining > 0U ) && ( ctx->queue_len > 0U ) )
 8007080:	69bb      	ldr	r3, [r7, #24]
 8007082:	2b00      	cmp	r3, #0
 8007084:	d03e      	beq.n	8007104 <mbedtls_poly1305_update+0x98>
 8007086:	68fb      	ldr	r3, [r7, #12]
 8007088:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800708a:	2b00      	cmp	r3, #0
 800708c:	d03a      	beq.n	8007104 <mbedtls_poly1305_update+0x98>
    {
        queue_free_len = ( POLY1305_BLOCK_SIZE_BYTES - ctx->queue_len );
 800708e:	68fb      	ldr	r3, [r7, #12]
 8007090:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8007092:	f1c3 0310 	rsb	r3, r3, #16
 8007096:	617b      	str	r3, [r7, #20]

        if( ilen < queue_free_len )
 8007098:	687a      	ldr	r2, [r7, #4]
 800709a:	697b      	ldr	r3, [r7, #20]
 800709c:	429a      	cmp	r2, r3
 800709e:	d213      	bcs.n	80070c8 <mbedtls_poly1305_update+0x5c>
        {
            /* Not enough data to complete the block.
             * Store this data with the other leftovers.
             */
            memcpy( &ctx->queue[ctx->queue_len],
 80070a0:	68fb      	ldr	r3, [r7, #12]
 80070a2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80070a4:	3330      	adds	r3, #48	@ 0x30
 80070a6:	68fa      	ldr	r2, [r7, #12]
 80070a8:	4413      	add	r3, r2
 80070aa:	3304      	adds	r3, #4
 80070ac:	687a      	ldr	r2, [r7, #4]
 80070ae:	68b9      	ldr	r1, [r7, #8]
 80070b0:	4618      	mov	r0, r3
 80070b2:	f00e fa54 	bl	801555e <memcpy>
                    input,
                    ilen );

            ctx->queue_len += ilen;
 80070b6:	68fb      	ldr	r3, [r7, #12]
 80070b8:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80070ba:	687b      	ldr	r3, [r7, #4]
 80070bc:	441a      	add	r2, r3
 80070be:	68fb      	ldr	r3, [r7, #12]
 80070c0:	645a      	str	r2, [r3, #68]	@ 0x44

            remaining = 0U;
 80070c2:	2300      	movs	r3, #0
 80070c4:	61bb      	str	r3, [r7, #24]
 80070c6:	e01d      	b.n	8007104 <mbedtls_poly1305_update+0x98>
        }
        else
        {
            /* Enough data to produce a complete block */
            memcpy( &ctx->queue[ctx->queue_len],
 80070c8:	68fb      	ldr	r3, [r7, #12]
 80070ca:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80070cc:	3330      	adds	r3, #48	@ 0x30
 80070ce:	68fa      	ldr	r2, [r7, #12]
 80070d0:	4413      	add	r3, r2
 80070d2:	3304      	adds	r3, #4
 80070d4:	697a      	ldr	r2, [r7, #20]
 80070d6:	68b9      	ldr	r1, [r7, #8]
 80070d8:	4618      	mov	r0, r3
 80070da:	f00e fa40 	bl	801555e <memcpy>
                    input,
                    queue_free_len );

            ctx->queue_len = 0U;
 80070de:	68fb      	ldr	r3, [r7, #12]
 80070e0:	2200      	movs	r2, #0
 80070e2:	645a      	str	r2, [r3, #68]	@ 0x44

            poly1305_process( ctx, 1U, ctx->queue, 1U ); /* add padding bit */
 80070e4:	68fb      	ldr	r3, [r7, #12]
 80070e6:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 80070ea:	2301      	movs	r3, #1
 80070ec:	2101      	movs	r1, #1
 80070ee:	68f8      	ldr	r0, [r7, #12]
 80070f0:	f7ff f8a8 	bl	8006244 <poly1305_process>

            offset    += queue_free_len;
 80070f4:	69fa      	ldr	r2, [r7, #28]
 80070f6:	697b      	ldr	r3, [r7, #20]
 80070f8:	4413      	add	r3, r2
 80070fa:	61fb      	str	r3, [r7, #28]
            remaining -= queue_free_len;
 80070fc:	69ba      	ldr	r2, [r7, #24]
 80070fe:	697b      	ldr	r3, [r7, #20]
 8007100:	1ad3      	subs	r3, r2, r3
 8007102:	61bb      	str	r3, [r7, #24]
        }
    }

    if( remaining >= POLY1305_BLOCK_SIZE_BYTES )
 8007104:	69bb      	ldr	r3, [r7, #24]
 8007106:	2b0f      	cmp	r3, #15
 8007108:	d913      	bls.n	8007132 <mbedtls_poly1305_update+0xc6>
    {
        nblocks = remaining / POLY1305_BLOCK_SIZE_BYTES;
 800710a:	69bb      	ldr	r3, [r7, #24]
 800710c:	091b      	lsrs	r3, r3, #4
 800710e:	613b      	str	r3, [r7, #16]

        poly1305_process( ctx, nblocks, &input[offset], 1U );
 8007110:	68ba      	ldr	r2, [r7, #8]
 8007112:	69fb      	ldr	r3, [r7, #28]
 8007114:	441a      	add	r2, r3
 8007116:	2301      	movs	r3, #1
 8007118:	6939      	ldr	r1, [r7, #16]
 800711a:	68f8      	ldr	r0, [r7, #12]
 800711c:	f7ff f892 	bl	8006244 <poly1305_process>

        offset += nblocks * POLY1305_BLOCK_SIZE_BYTES;
 8007120:	693b      	ldr	r3, [r7, #16]
 8007122:	011b      	lsls	r3, r3, #4
 8007124:	69fa      	ldr	r2, [r7, #28]
 8007126:	4413      	add	r3, r2
 8007128:	61fb      	str	r3, [r7, #28]
        remaining %= POLY1305_BLOCK_SIZE_BYTES;
 800712a:	69bb      	ldr	r3, [r7, #24]
 800712c:	f003 030f 	and.w	r3, r3, #15
 8007130:	61bb      	str	r3, [r7, #24]
    }

    if( remaining > 0U )
 8007132:	69bb      	ldr	r3, [r7, #24]
 8007134:	2b00      	cmp	r3, #0
 8007136:	d00c      	beq.n	8007152 <mbedtls_poly1305_update+0xe6>
    {
        /* Store partial block */
        ctx->queue_len = remaining;
 8007138:	68fb      	ldr	r3, [r7, #12]
 800713a:	69ba      	ldr	r2, [r7, #24]
 800713c:	645a      	str	r2, [r3, #68]	@ 0x44
        memcpy( ctx->queue, &input[offset], remaining );
 800713e:	68fb      	ldr	r3, [r7, #12]
 8007140:	f103 0034 	add.w	r0, r3, #52	@ 0x34
 8007144:	68ba      	ldr	r2, [r7, #8]
 8007146:	69fb      	ldr	r3, [r7, #28]
 8007148:	4413      	add	r3, r2
 800714a:	69ba      	ldr	r2, [r7, #24]
 800714c:	4619      	mov	r1, r3
 800714e:	f00e fa06 	bl	801555e <memcpy>
    }

    return( 0 );
 8007152:	2300      	movs	r3, #0
}
 8007154:	4618      	mov	r0, r3
 8007156:	3720      	adds	r7, #32
 8007158:	46bd      	mov	sp, r7
 800715a:	bd80      	pop	{r7, pc}

0800715c <mbedtls_poly1305_finish>:

int mbedtls_poly1305_finish( mbedtls_poly1305_context *ctx,
                             unsigned char mac[16] )
{
 800715c:	b580      	push	{r7, lr}
 800715e:	b082      	sub	sp, #8
 8007160:	af00      	add	r7, sp, #0
 8007162:	6078      	str	r0, [r7, #4]
 8007164:	6039      	str	r1, [r7, #0]
    POLY1305_VALIDATE_RET( ctx != NULL );
    POLY1305_VALIDATE_RET( mac != NULL );

    /* Process any leftover data */
    if( ctx->queue_len > 0U )
 8007166:	687b      	ldr	r3, [r7, #4]
 8007168:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800716a:	2b00      	cmp	r3, #0
 800716c:	d021      	beq.n	80071b2 <mbedtls_poly1305_finish+0x56>
    {
        /* Add padding bit */
        ctx->queue[ctx->queue_len] = 1U;
 800716e:	687b      	ldr	r3, [r7, #4]
 8007170:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8007172:	687a      	ldr	r2, [r7, #4]
 8007174:	4413      	add	r3, r2
 8007176:	2201      	movs	r2, #1
 8007178:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
        ctx->queue_len++;
 800717c:	687b      	ldr	r3, [r7, #4]
 800717e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8007180:	1c5a      	adds	r2, r3, #1
 8007182:	687b      	ldr	r3, [r7, #4]
 8007184:	645a      	str	r2, [r3, #68]	@ 0x44

        /* Pad with zeroes */
        memset( &ctx->queue[ctx->queue_len],
 8007186:	687b      	ldr	r3, [r7, #4]
 8007188:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800718a:	3330      	adds	r3, #48	@ 0x30
 800718c:	687a      	ldr	r2, [r7, #4]
 800718e:	4413      	add	r3, r2
 8007190:	1d18      	adds	r0, r3, #4
                0,
                POLY1305_BLOCK_SIZE_BYTES - ctx->queue_len );
 8007192:	687b      	ldr	r3, [r7, #4]
 8007194:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
        memset( &ctx->queue[ctx->queue_len],
 8007196:	f1c3 0310 	rsb	r3, r3, #16
 800719a:	461a      	mov	r2, r3
 800719c:	2100      	movs	r1, #0
 800719e:	f00e f953 	bl	8015448 <memset>

        poly1305_process( ctx, 1U,          /* Process 1 block */
                          ctx->queue, 0U ); /* Already padded above */
 80071a2:	687b      	ldr	r3, [r7, #4]
 80071a4:	f103 0234 	add.w	r2, r3, #52	@ 0x34
        poly1305_process( ctx, 1U,          /* Process 1 block */
 80071a8:	2300      	movs	r3, #0
 80071aa:	2101      	movs	r1, #1
 80071ac:	6878      	ldr	r0, [r7, #4]
 80071ae:	f7ff f849 	bl	8006244 <poly1305_process>
    }

    poly1305_compute_mac( ctx, mac );
 80071b2:	6839      	ldr	r1, [r7, #0]
 80071b4:	6878      	ldr	r0, [r7, #4]
 80071b6:	f7ff fc79 	bl	8006aac <poly1305_compute_mac>

    return( 0 );
 80071ba:	2300      	movs	r3, #0
}
 80071bc:	4618      	mov	r0, r3
 80071be:	3708      	adds	r7, #8
 80071c0:	46bd      	mov	sp, r7
 80071c2:	bd80      	pop	{r7, pc}

080071c4 <mbedtls_sha256_init>:
    (b)[(i) + 3] = (unsigned char) ( (n)       );       \
} while( 0 )
#endif

void mbedtls_sha256_init( mbedtls_sha256_context *ctx )
{
 80071c4:	b580      	push	{r7, lr}
 80071c6:	b082      	sub	sp, #8
 80071c8:	af00      	add	r7, sp, #0
 80071ca:	6078      	str	r0, [r7, #4]
    SHA256_VALIDATE( ctx != NULL );

    memset( ctx, 0, sizeof( mbedtls_sha256_context ) );
 80071cc:	226c      	movs	r2, #108	@ 0x6c
 80071ce:	2100      	movs	r1, #0
 80071d0:	6878      	ldr	r0, [r7, #4]
 80071d2:	f00e f939 	bl	8015448 <memset>
}
 80071d6:	bf00      	nop
 80071d8:	3708      	adds	r7, #8
 80071da:	46bd      	mov	sp, r7
 80071dc:	bd80      	pop	{r7, pc}
	...

080071e0 <mbedtls_sha256_starts>:

/*
 * SHA-256 context setup
 */
int mbedtls_sha256_starts( mbedtls_sha256_context *ctx, int is224 )
{
 80071e0:	b480      	push	{r7}
 80071e2:	b083      	sub	sp, #12
 80071e4:	af00      	add	r7, sp, #0
 80071e6:	6078      	str	r0, [r7, #4]
 80071e8:	6039      	str	r1, [r7, #0]
    SHA256_VALIDATE_RET( is224 == 0 || is224 == 1 );
#else
    SHA256_VALIDATE_RET( is224 == 0 );
#endif

    ctx->total[0] = 0;
 80071ea:	687b      	ldr	r3, [r7, #4]
 80071ec:	2200      	movs	r2, #0
 80071ee:	601a      	str	r2, [r3, #0]
    ctx->total[1] = 0;
 80071f0:	687b      	ldr	r3, [r7, #4]
 80071f2:	2200      	movs	r2, #0
 80071f4:	605a      	str	r2, [r3, #4]

    if( is224 == 0 )
 80071f6:	683b      	ldr	r3, [r7, #0]
 80071f8:	2b00      	cmp	r3, #0
 80071fa:	d118      	bne.n	800722e <mbedtls_sha256_starts+0x4e>
    {
        /* SHA-256 */
        ctx->state[0] = 0x6A09E667;
 80071fc:	687b      	ldr	r3, [r7, #4]
 80071fe:	4a1d      	ldr	r2, [pc, #116]	@ (8007274 <mbedtls_sha256_starts+0x94>)
 8007200:	609a      	str	r2, [r3, #8]
        ctx->state[1] = 0xBB67AE85;
 8007202:	687b      	ldr	r3, [r7, #4]
 8007204:	4a1c      	ldr	r2, [pc, #112]	@ (8007278 <mbedtls_sha256_starts+0x98>)
 8007206:	60da      	str	r2, [r3, #12]
        ctx->state[2] = 0x3C6EF372;
 8007208:	687b      	ldr	r3, [r7, #4]
 800720a:	4a1c      	ldr	r2, [pc, #112]	@ (800727c <mbedtls_sha256_starts+0x9c>)
 800720c:	611a      	str	r2, [r3, #16]
        ctx->state[3] = 0xA54FF53A;
 800720e:	687b      	ldr	r3, [r7, #4]
 8007210:	4a1b      	ldr	r2, [pc, #108]	@ (8007280 <mbedtls_sha256_starts+0xa0>)
 8007212:	615a      	str	r2, [r3, #20]
        ctx->state[4] = 0x510E527F;
 8007214:	687b      	ldr	r3, [r7, #4]
 8007216:	4a1b      	ldr	r2, [pc, #108]	@ (8007284 <mbedtls_sha256_starts+0xa4>)
 8007218:	619a      	str	r2, [r3, #24]
        ctx->state[5] = 0x9B05688C;
 800721a:	687b      	ldr	r3, [r7, #4]
 800721c:	4a1a      	ldr	r2, [pc, #104]	@ (8007288 <mbedtls_sha256_starts+0xa8>)
 800721e:	61da      	str	r2, [r3, #28]
        ctx->state[6] = 0x1F83D9AB;
 8007220:	687b      	ldr	r3, [r7, #4]
 8007222:	4a1a      	ldr	r2, [pc, #104]	@ (800728c <mbedtls_sha256_starts+0xac>)
 8007224:	621a      	str	r2, [r3, #32]
        ctx->state[7] = 0x5BE0CD19;
 8007226:	687b      	ldr	r3, [r7, #4]
 8007228:	4a19      	ldr	r2, [pc, #100]	@ (8007290 <mbedtls_sha256_starts+0xb0>)
 800722a:	625a      	str	r2, [r3, #36]	@ 0x24
 800722c:	e017      	b.n	800725e <mbedtls_sha256_starts+0x7e>
    }
    else
    {
#if defined(MBEDTLS_SHA224_C)
        /* SHA-224 */
        ctx->state[0] = 0xC1059ED8;
 800722e:	687b      	ldr	r3, [r7, #4]
 8007230:	4a18      	ldr	r2, [pc, #96]	@ (8007294 <mbedtls_sha256_starts+0xb4>)
 8007232:	609a      	str	r2, [r3, #8]
        ctx->state[1] = 0x367CD507;
 8007234:	687b      	ldr	r3, [r7, #4]
 8007236:	4a18      	ldr	r2, [pc, #96]	@ (8007298 <mbedtls_sha256_starts+0xb8>)
 8007238:	60da      	str	r2, [r3, #12]
        ctx->state[2] = 0x3070DD17;
 800723a:	687b      	ldr	r3, [r7, #4]
 800723c:	4a17      	ldr	r2, [pc, #92]	@ (800729c <mbedtls_sha256_starts+0xbc>)
 800723e:	611a      	str	r2, [r3, #16]
        ctx->state[3] = 0xF70E5939;
 8007240:	687b      	ldr	r3, [r7, #4]
 8007242:	4a17      	ldr	r2, [pc, #92]	@ (80072a0 <mbedtls_sha256_starts+0xc0>)
 8007244:	615a      	str	r2, [r3, #20]
        ctx->state[4] = 0xFFC00B31;
 8007246:	687b      	ldr	r3, [r7, #4]
 8007248:	4a16      	ldr	r2, [pc, #88]	@ (80072a4 <mbedtls_sha256_starts+0xc4>)
 800724a:	619a      	str	r2, [r3, #24]
        ctx->state[5] = 0x68581511;
 800724c:	687b      	ldr	r3, [r7, #4]
 800724e:	4a16      	ldr	r2, [pc, #88]	@ (80072a8 <mbedtls_sha256_starts+0xc8>)
 8007250:	61da      	str	r2, [r3, #28]
        ctx->state[6] = 0x64F98FA7;
 8007252:	687b      	ldr	r3, [r7, #4]
 8007254:	4a15      	ldr	r2, [pc, #84]	@ (80072ac <mbedtls_sha256_starts+0xcc>)
 8007256:	621a      	str	r2, [r3, #32]
        ctx->state[7] = 0xBEFA4FA4;
 8007258:	687b      	ldr	r3, [r7, #4]
 800725a:	4a15      	ldr	r2, [pc, #84]	@ (80072b0 <mbedtls_sha256_starts+0xd0>)
 800725c:	625a      	str	r2, [r3, #36]	@ 0x24
#endif
    }

    ctx->is224 = is224;
 800725e:	687b      	ldr	r3, [r7, #4]
 8007260:	683a      	ldr	r2, [r7, #0]
 8007262:	669a      	str	r2, [r3, #104]	@ 0x68

    return( 0 );
 8007264:	2300      	movs	r3, #0
}
 8007266:	4618      	mov	r0, r3
 8007268:	370c      	adds	r7, #12
 800726a:	46bd      	mov	sp, r7
 800726c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007270:	4770      	bx	lr
 8007272:	bf00      	nop
 8007274:	6a09e667 	.word	0x6a09e667
 8007278:	bb67ae85 	.word	0xbb67ae85
 800727c:	3c6ef372 	.word	0x3c6ef372
 8007280:	a54ff53a 	.word	0xa54ff53a
 8007284:	510e527f 	.word	0x510e527f
 8007288:	9b05688c 	.word	0x9b05688c
 800728c:	1f83d9ab 	.word	0x1f83d9ab
 8007290:	5be0cd19 	.word	0x5be0cd19
 8007294:	c1059ed8 	.word	0xc1059ed8
 8007298:	367cd507 	.word	0x367cd507
 800729c:	3070dd17 	.word	0x3070dd17
 80072a0:	f70e5939 	.word	0xf70e5939
 80072a4:	ffc00b31 	.word	0xffc00b31
 80072a8:	68581511 	.word	0x68581511
 80072ac:	64f98fa7 	.word	0x64f98fa7
 80072b0:	befa4fa4 	.word	0xbefa4fa4

080072b4 <mbedtls_internal_sha256_process>:
        (d) += local.temp1; (h) = local.temp1 + local.temp2;        \
    } while( 0 )

int mbedtls_internal_sha256_process( mbedtls_sha256_context *ctx,
                                const unsigned char data[64] )
{
 80072b4:	b590      	push	{r4, r7, lr}
 80072b6:	b0cf      	sub	sp, #316	@ 0x13c
 80072b8:	af00      	add	r7, sp, #0
 80072ba:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80072be:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
 80072c2:	6018      	str	r0, [r3, #0]
 80072c4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80072c8:	f5a3 739c 	sub.w	r3, r3, #312	@ 0x138
 80072cc:	6019      	str	r1, [r3, #0]
    unsigned int i;

    SHA256_VALIDATE_RET( ctx != NULL );
    SHA256_VALIDATE_RET( (const unsigned char *)data != NULL );

    for( i = 0; i < 8; i++ )
 80072ce:	2300      	movs	r3, #0
 80072d0:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
 80072d4:	e017      	b.n	8007306 <mbedtls_internal_sha256_process+0x52>
        local.A[i] = ctx->state[i];
 80072d6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80072da:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
 80072de:	681b      	ldr	r3, [r3, #0]
 80072e0:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 80072e4:	3202      	adds	r2, #2
 80072e6:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80072ea:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80072ee:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80072f2:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 80072f6:	3242      	adds	r2, #66	@ 0x42
 80072f8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for( i = 0; i < 8; i++ )
 80072fc:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8007300:	3301      	adds	r3, #1
 8007302:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
 8007306:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800730a:	2b07      	cmp	r3, #7
 800730c:	d9e3      	bls.n	80072d6 <mbedtls_internal_sha256_process+0x22>
        local.A[4] = local.A[3]; local.A[3] = local.A[2];
        local.A[2] = local.A[1]; local.A[1] = local.A[0];
        local.A[0] = local.temp1;
    }
#else /* MBEDTLS_SHA256_SMALLER */
    for( i = 0; i < 16; i++ )
 800730e:	2300      	movs	r3, #0
 8007310:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
 8007314:	e03f      	b.n	8007396 <mbedtls_internal_sha256_process+0xe2>
        GET_UINT32_BE( local.W[i], data, 4 * i );
 8007316:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800731a:	009b      	lsls	r3, r3, #2
 800731c:	f507 729c 	add.w	r2, r7, #312	@ 0x138
 8007320:	f5a2 729c 	sub.w	r2, r2, #312	@ 0x138
 8007324:	6812      	ldr	r2, [r2, #0]
 8007326:	4413      	add	r3, r2
 8007328:	781b      	ldrb	r3, [r3, #0]
 800732a:	061a      	lsls	r2, r3, #24
 800732c:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8007330:	009b      	lsls	r3, r3, #2
 8007332:	3301      	adds	r3, #1
 8007334:	f507 719c 	add.w	r1, r7, #312	@ 0x138
 8007338:	f5a1 719c 	sub.w	r1, r1, #312	@ 0x138
 800733c:	6809      	ldr	r1, [r1, #0]
 800733e:	440b      	add	r3, r1
 8007340:	781b      	ldrb	r3, [r3, #0]
 8007342:	041b      	lsls	r3, r3, #16
 8007344:	431a      	orrs	r2, r3
 8007346:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800734a:	009b      	lsls	r3, r3, #2
 800734c:	3302      	adds	r3, #2
 800734e:	f507 719c 	add.w	r1, r7, #312	@ 0x138
 8007352:	f5a1 719c 	sub.w	r1, r1, #312	@ 0x138
 8007356:	6809      	ldr	r1, [r1, #0]
 8007358:	440b      	add	r3, r1
 800735a:	781b      	ldrb	r3, [r3, #0]
 800735c:	021b      	lsls	r3, r3, #8
 800735e:	4313      	orrs	r3, r2
 8007360:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8007364:	0092      	lsls	r2, r2, #2
 8007366:	3203      	adds	r2, #3
 8007368:	f507 719c 	add.w	r1, r7, #312	@ 0x138
 800736c:	f5a1 719c 	sub.w	r1, r1, #312	@ 0x138
 8007370:	6809      	ldr	r1, [r1, #0]
 8007372:	440a      	add	r2, r1
 8007374:	7812      	ldrb	r2, [r2, #0]
 8007376:	ea43 0102 	orr.w	r1, r3, r2
 800737a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800737e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007382:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8007386:	3202      	adds	r2, #2
 8007388:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for( i = 0; i < 16; i++ )
 800738c:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8007390:	3301      	adds	r3, #1
 8007392:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
 8007396:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800739a:	2b0f      	cmp	r3, #15
 800739c:	d9bb      	bls.n	8007316 <mbedtls_internal_sha256_process+0x62>

    for( i = 0; i < 16; i += 8 )
 800739e:	2300      	movs	r3, #0
 80073a0:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
 80073a4:	f000 bdd1 	b.w	8007f4a <mbedtls_internal_sha256_process+0xc96>
    {
        P( local.A[0], local.A[1], local.A[2], local.A[3], local.A[4],
 80073a8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80073ac:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80073b0:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
 80073b4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80073b8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80073bc:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 80073c0:	ea4f 11b3 	mov.w	r1, r3, ror #6
 80073c4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80073c8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80073cc:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 80073d0:	ea4f 23f3 	mov.w	r3, r3, ror #11
 80073d4:	4059      	eors	r1, r3
 80073d6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80073da:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80073de:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 80073e2:	ea4f 6373 	mov.w	r3, r3, ror #25
 80073e6:	404b      	eors	r3, r1
 80073e8:	441a      	add	r2, r3
 80073ea:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80073ee:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80073f2:	f8d3 1120 	ldr.w	r1, [r3, #288]	@ 0x120
 80073f6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80073fa:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80073fe:	f8d3 0118 	ldr.w	r0, [r3, #280]	@ 0x118
 8007402:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007406:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800740a:	f8d3 411c 	ldr.w	r4, [r3, #284]	@ 0x11c
 800740e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007412:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007416:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
 800741a:	4063      	eors	r3, r4
 800741c:	4003      	ands	r3, r0
 800741e:	404b      	eors	r3, r1
 8007420:	441a      	add	r2, r3
 8007422:	49f5      	ldr	r1, [pc, #980]	@ (80077f8 <mbedtls_internal_sha256_process+0x544>)
 8007424:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8007428:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800742c:	441a      	add	r2, r3
 800742e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007432:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007436:	f8d7 1134 	ldr.w	r1, [r7, #308]	@ 0x134
 800743a:	3102      	adds	r1, #2
 800743c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8007440:	441a      	add	r2, r3
 8007442:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007446:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800744a:	601a      	str	r2, [r3, #0]
 800744c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007450:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007454:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 8007458:	ea4f 02b3 	mov.w	r2, r3, ror #2
 800745c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007460:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007464:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 8007468:	ea4f 3373 	mov.w	r3, r3, ror #13
 800746c:	405a      	eors	r2, r3
 800746e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007472:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007476:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 800747a:	ea4f 53b3 	mov.w	r3, r3, ror #22
 800747e:	405a      	eors	r2, r3
 8007480:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007484:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007488:	f8d3 1108 	ldr.w	r1, [r3, #264]	@ 0x108
 800748c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007490:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007494:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8007498:	4019      	ands	r1, r3
 800749a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800749e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80074a2:	f8d3 0110 	ldr.w	r0, [r3, #272]	@ 0x110
 80074a6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80074aa:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80074ae:	f8d3 4108 	ldr.w	r4, [r3, #264]	@ 0x108
 80074b2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80074b6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80074ba:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 80074be:	4323      	orrs	r3, r4
 80074c0:	4003      	ands	r3, r0
 80074c2:	430b      	orrs	r3, r1
 80074c4:	441a      	add	r2, r3
 80074c6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80074ca:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80074ce:	605a      	str	r2, [r3, #4]
 80074d0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80074d4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80074d8:	f8d3 2114 	ldr.w	r2, [r3, #276]	@ 0x114
 80074dc:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80074e0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80074e4:	681b      	ldr	r3, [r3, #0]
 80074e6:	441a      	add	r2, r3
 80074e8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80074ec:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80074f0:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
 80074f4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80074f8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80074fc:	681a      	ldr	r2, [r3, #0]
 80074fe:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007502:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007506:	685b      	ldr	r3, [r3, #4]
 8007508:	441a      	add	r2, r3
 800750a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800750e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007512:	f8c3 2124 	str.w	r2, [r3, #292]	@ 0x124
           local.A[5], local.A[6], local.A[7], local.W[i+0], K[i+0] );
        P( local.A[7], local.A[0], local.A[1], local.A[2], local.A[3],
 8007516:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800751a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800751e:	f8d3 2120 	ldr.w	r2, [r3, #288]	@ 0x120
 8007522:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007526:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800752a:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 800752e:	ea4f 11b3 	mov.w	r1, r3, ror #6
 8007532:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007536:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800753a:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 800753e:	ea4f 23f3 	mov.w	r3, r3, ror #11
 8007542:	4059      	eors	r1, r3
 8007544:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007548:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800754c:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 8007550:	ea4f 6373 	mov.w	r3, r3, ror #25
 8007554:	404b      	eors	r3, r1
 8007556:	441a      	add	r2, r3
 8007558:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800755c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007560:	f8d3 111c 	ldr.w	r1, [r3, #284]	@ 0x11c
 8007564:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007568:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800756c:	f8d3 0114 	ldr.w	r0, [r3, #276]	@ 0x114
 8007570:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007574:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007578:	f8d3 4118 	ldr.w	r4, [r3, #280]	@ 0x118
 800757c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007580:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007584:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 8007588:	4063      	eors	r3, r4
 800758a:	4003      	ands	r3, r0
 800758c:	404b      	eors	r3, r1
 800758e:	441a      	add	r2, r3
 8007590:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8007594:	3301      	adds	r3, #1
 8007596:	4998      	ldr	r1, [pc, #608]	@ (80077f8 <mbedtls_internal_sha256_process+0x544>)
 8007598:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800759c:	441a      	add	r2, r3
 800759e:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80075a2:	1c59      	adds	r1, r3, #1
 80075a4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80075a8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80075ac:	3102      	adds	r1, #2
 80075ae:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80075b2:	441a      	add	r2, r3
 80075b4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80075b8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80075bc:	601a      	str	r2, [r3, #0]
 80075be:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80075c2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80075c6:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 80075ca:	ea4f 02b3 	mov.w	r2, r3, ror #2
 80075ce:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80075d2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80075d6:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 80075da:	ea4f 3373 	mov.w	r3, r3, ror #13
 80075de:	405a      	eors	r2, r3
 80075e0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80075e4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80075e8:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 80075ec:	ea4f 53b3 	mov.w	r3, r3, ror #22
 80075f0:	405a      	eors	r2, r3
 80075f2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80075f6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80075fa:	f8d3 1124 	ldr.w	r1, [r3, #292]	@ 0x124
 80075fe:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007602:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007606:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 800760a:	4019      	ands	r1, r3
 800760c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007610:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007614:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
 8007618:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800761c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007620:	f8d3 4124 	ldr.w	r4, [r3, #292]	@ 0x124
 8007624:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007628:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800762c:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 8007630:	4323      	orrs	r3, r4
 8007632:	4003      	ands	r3, r0
 8007634:	430b      	orrs	r3, r1
 8007636:	441a      	add	r2, r3
 8007638:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800763c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007640:	605a      	str	r2, [r3, #4]
 8007642:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007646:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800764a:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
 800764e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007652:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007656:	681b      	ldr	r3, [r3, #0]
 8007658:	441a      	add	r2, r3
 800765a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800765e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007662:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
 8007666:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800766a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800766e:	681a      	ldr	r2, [r3, #0]
 8007670:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007674:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007678:	685b      	ldr	r3, [r3, #4]
 800767a:	441a      	add	r2, r3
 800767c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007680:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007684:	f8c3 2120 	str.w	r2, [r3, #288]	@ 0x120
           local.A[4], local.A[5], local.A[6], local.W[i+1], K[i+1] );
        P( local.A[6], local.A[7], local.A[0], local.A[1], local.A[2],
 8007688:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800768c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007690:	f8d3 211c 	ldr.w	r2, [r3, #284]	@ 0x11c
 8007694:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007698:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800769c:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 80076a0:	ea4f 11b3 	mov.w	r1, r3, ror #6
 80076a4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80076a8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80076ac:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 80076b0:	ea4f 23f3 	mov.w	r3, r3, ror #11
 80076b4:	4059      	eors	r1, r3
 80076b6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80076ba:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80076be:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 80076c2:	ea4f 6373 	mov.w	r3, r3, ror #25
 80076c6:	404b      	eors	r3, r1
 80076c8:	441a      	add	r2, r3
 80076ca:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80076ce:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80076d2:	f8d3 1118 	ldr.w	r1, [r3, #280]	@ 0x118
 80076d6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80076da:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80076de:	f8d3 0110 	ldr.w	r0, [r3, #272]	@ 0x110
 80076e2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80076e6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80076ea:	f8d3 4114 	ldr.w	r4, [r3, #276]	@ 0x114
 80076ee:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80076f2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80076f6:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 80076fa:	4063      	eors	r3, r4
 80076fc:	4003      	ands	r3, r0
 80076fe:	404b      	eors	r3, r1
 8007700:	441a      	add	r2, r3
 8007702:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8007706:	3302      	adds	r3, #2
 8007708:	493b      	ldr	r1, [pc, #236]	@ (80077f8 <mbedtls_internal_sha256_process+0x544>)
 800770a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800770e:	441a      	add	r2, r3
 8007710:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8007714:	1c99      	adds	r1, r3, #2
 8007716:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800771a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800771e:	3102      	adds	r1, #2
 8007720:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8007724:	441a      	add	r2, r3
 8007726:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800772a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800772e:	601a      	str	r2, [r3, #0]
 8007730:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007734:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007738:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
 800773c:	ea4f 02b3 	mov.w	r2, r3, ror #2
 8007740:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007744:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007748:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
 800774c:	ea4f 3373 	mov.w	r3, r3, ror #13
 8007750:	405a      	eors	r2, r3
 8007752:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007756:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800775a:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
 800775e:	ea4f 53b3 	mov.w	r3, r3, ror #22
 8007762:	405a      	eors	r2, r3
 8007764:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007768:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800776c:	f8d3 1120 	ldr.w	r1, [r3, #288]	@ 0x120
 8007770:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007774:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007778:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800777c:	4019      	ands	r1, r3
 800777e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007782:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007786:	f8d3 0108 	ldr.w	r0, [r3, #264]	@ 0x108
 800778a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800778e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007792:	f8d3 4120 	ldr.w	r4, [r3, #288]	@ 0x120
 8007796:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800779a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800779e:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 80077a2:	4323      	orrs	r3, r4
 80077a4:	4003      	ands	r3, r0
 80077a6:	430b      	orrs	r3, r1
 80077a8:	441a      	add	r2, r3
 80077aa:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80077ae:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80077b2:	605a      	str	r2, [r3, #4]
 80077b4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80077b8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80077bc:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 80077c0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80077c4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80077c8:	681b      	ldr	r3, [r3, #0]
 80077ca:	441a      	add	r2, r3
 80077cc:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80077d0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80077d4:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
 80077d8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80077dc:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80077e0:	681a      	ldr	r2, [r3, #0]
 80077e2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80077e6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80077ea:	685b      	ldr	r3, [r3, #4]
 80077ec:	441a      	add	r2, r3
 80077ee:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80077f2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80077f6:	e001      	b.n	80077fc <mbedtls_internal_sha256_process+0x548>
 80077f8:	08016c4c 	.word	0x08016c4c
 80077fc:	f8c3 211c 	str.w	r2, [r3, #284]	@ 0x11c
           local.A[3], local.A[4], local.A[5], local.W[i+2], K[i+2] );
        P( local.A[5], local.A[6], local.A[7], local.A[0], local.A[1],
 8007800:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007804:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007808:	f8d3 2118 	ldr.w	r2, [r3, #280]	@ 0x118
 800780c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007810:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007814:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8007818:	ea4f 11b3 	mov.w	r1, r3, ror #6
 800781c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007820:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007824:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8007828:	ea4f 23f3 	mov.w	r3, r3, ror #11
 800782c:	4059      	eors	r1, r3
 800782e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007832:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007836:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 800783a:	ea4f 6373 	mov.w	r3, r3, ror #25
 800783e:	404b      	eors	r3, r1
 8007840:	441a      	add	r2, r3
 8007842:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007846:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800784a:	f8d3 1114 	ldr.w	r1, [r3, #276]	@ 0x114
 800784e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007852:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007856:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
 800785a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800785e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007862:	f8d3 4110 	ldr.w	r4, [r3, #272]	@ 0x110
 8007866:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800786a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800786e:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 8007872:	4063      	eors	r3, r4
 8007874:	4003      	ands	r3, r0
 8007876:	404b      	eors	r3, r1
 8007878:	441a      	add	r2, r3
 800787a:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800787e:	3303      	adds	r3, #3
 8007880:	49f4      	ldr	r1, [pc, #976]	@ (8007c54 <mbedtls_internal_sha256_process+0x9a0>)
 8007882:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8007886:	441a      	add	r2, r3
 8007888:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800788c:	1cd9      	adds	r1, r3, #3
 800788e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007892:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007896:	3102      	adds	r1, #2
 8007898:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 800789c:	441a      	add	r2, r3
 800789e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80078a2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80078a6:	601a      	str	r2, [r3, #0]
 80078a8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80078ac:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80078b0:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 80078b4:	ea4f 02b3 	mov.w	r2, r3, ror #2
 80078b8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80078bc:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80078c0:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 80078c4:	ea4f 3373 	mov.w	r3, r3, ror #13
 80078c8:	405a      	eors	r2, r3
 80078ca:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80078ce:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80078d2:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 80078d6:	ea4f 53b3 	mov.w	r3, r3, ror #22
 80078da:	405a      	eors	r2, r3
 80078dc:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80078e0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80078e4:	f8d3 111c 	ldr.w	r1, [r3, #284]	@ 0x11c
 80078e8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80078ec:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80078f0:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
 80078f4:	4019      	ands	r1, r3
 80078f6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80078fa:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80078fe:	f8d3 0124 	ldr.w	r0, [r3, #292]	@ 0x124
 8007902:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007906:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800790a:	f8d3 411c 	ldr.w	r4, [r3, #284]	@ 0x11c
 800790e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007912:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007916:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
 800791a:	4323      	orrs	r3, r4
 800791c:	4003      	ands	r3, r0
 800791e:	430b      	orrs	r3, r1
 8007920:	441a      	add	r2, r3
 8007922:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007926:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800792a:	605a      	str	r2, [r3, #4]
 800792c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007930:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007934:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
 8007938:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800793c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007940:	681b      	ldr	r3, [r3, #0]
 8007942:	441a      	add	r2, r3
 8007944:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007948:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800794c:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
 8007950:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007954:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007958:	681a      	ldr	r2, [r3, #0]
 800795a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800795e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007962:	685b      	ldr	r3, [r3, #4]
 8007964:	441a      	add	r2, r3
 8007966:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800796a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800796e:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
           local.A[2], local.A[3], local.A[4], local.W[i+3], K[i+3] );
        P( local.A[4], local.A[5], local.A[6], local.A[7], local.A[0],
 8007972:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007976:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800797a:	f8d3 2114 	ldr.w	r2, [r3, #276]	@ 0x114
 800797e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007982:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007986:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 800798a:	ea4f 11b3 	mov.w	r1, r3, ror #6
 800798e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007992:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007996:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 800799a:	ea4f 23f3 	mov.w	r3, r3, ror #11
 800799e:	4059      	eors	r1, r3
 80079a0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80079a4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80079a8:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 80079ac:	ea4f 6373 	mov.w	r3, r3, ror #25
 80079b0:	404b      	eors	r3, r1
 80079b2:	441a      	add	r2, r3
 80079b4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80079b8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80079bc:	f8d3 1110 	ldr.w	r1, [r3, #272]	@ 0x110
 80079c0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80079c4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80079c8:	f8d3 0108 	ldr.w	r0, [r3, #264]	@ 0x108
 80079cc:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80079d0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80079d4:	f8d3 410c 	ldr.w	r4, [r3, #268]	@ 0x10c
 80079d8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80079dc:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80079e0:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 80079e4:	4063      	eors	r3, r4
 80079e6:	4003      	ands	r3, r0
 80079e8:	404b      	eors	r3, r1
 80079ea:	441a      	add	r2, r3
 80079ec:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80079f0:	3304      	adds	r3, #4
 80079f2:	4998      	ldr	r1, [pc, #608]	@ (8007c54 <mbedtls_internal_sha256_process+0x9a0>)
 80079f4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80079f8:	441a      	add	r2, r3
 80079fa:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80079fe:	1d19      	adds	r1, r3, #4
 8007a00:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007a04:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007a08:	3102      	adds	r1, #2
 8007a0a:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8007a0e:	441a      	add	r2, r3
 8007a10:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007a14:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007a18:	601a      	str	r2, [r3, #0]
 8007a1a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007a1e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007a22:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8007a26:	ea4f 02b3 	mov.w	r2, r3, ror #2
 8007a2a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007a2e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007a32:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8007a36:	ea4f 3373 	mov.w	r3, r3, ror #13
 8007a3a:	405a      	eors	r2, r3
 8007a3c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007a40:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007a44:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8007a48:	ea4f 53b3 	mov.w	r3, r3, ror #22
 8007a4c:	405a      	eors	r2, r3
 8007a4e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007a52:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007a56:	f8d3 1118 	ldr.w	r1, [r3, #280]	@ 0x118
 8007a5a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007a5e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007a62:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 8007a66:	4019      	ands	r1, r3
 8007a68:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007a6c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007a70:	f8d3 0120 	ldr.w	r0, [r3, #288]	@ 0x120
 8007a74:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007a78:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007a7c:	f8d3 4118 	ldr.w	r4, [r3, #280]	@ 0x118
 8007a80:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007a84:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007a88:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 8007a8c:	4323      	orrs	r3, r4
 8007a8e:	4003      	ands	r3, r0
 8007a90:	430b      	orrs	r3, r1
 8007a92:	441a      	add	r2, r3
 8007a94:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007a98:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007a9c:	605a      	str	r2, [r3, #4]
 8007a9e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007aa2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007aa6:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
 8007aaa:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007aae:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007ab2:	681b      	ldr	r3, [r3, #0]
 8007ab4:	441a      	add	r2, r3
 8007ab6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007aba:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007abe:	f8c3 2124 	str.w	r2, [r3, #292]	@ 0x124
 8007ac2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007ac6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007aca:	681a      	ldr	r2, [r3, #0]
 8007acc:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007ad0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007ad4:	685b      	ldr	r3, [r3, #4]
 8007ad6:	441a      	add	r2, r3
 8007ad8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007adc:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007ae0:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
           local.A[1], local.A[2], local.A[3], local.W[i+4], K[i+4] );
        P( local.A[3], local.A[4], local.A[5], local.A[6], local.A[7],
 8007ae4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007ae8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007aec:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
 8007af0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007af4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007af8:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 8007afc:	ea4f 11b3 	mov.w	r1, r3, ror #6
 8007b00:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007b04:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007b08:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 8007b0c:	ea4f 23f3 	mov.w	r3, r3, ror #11
 8007b10:	4059      	eors	r1, r3
 8007b12:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007b16:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007b1a:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 8007b1e:	ea4f 6373 	mov.w	r3, r3, ror #25
 8007b22:	404b      	eors	r3, r1
 8007b24:	441a      	add	r2, r3
 8007b26:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007b2a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007b2e:	f8d3 110c 	ldr.w	r1, [r3, #268]	@ 0x10c
 8007b32:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007b36:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007b3a:	f8d3 0124 	ldr.w	r0, [r3, #292]	@ 0x124
 8007b3e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007b42:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007b46:	f8d3 4108 	ldr.w	r4, [r3, #264]	@ 0x108
 8007b4a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007b4e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007b52:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8007b56:	4063      	eors	r3, r4
 8007b58:	4003      	ands	r3, r0
 8007b5a:	404b      	eors	r3, r1
 8007b5c:	441a      	add	r2, r3
 8007b5e:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8007b62:	3305      	adds	r3, #5
 8007b64:	493b      	ldr	r1, [pc, #236]	@ (8007c54 <mbedtls_internal_sha256_process+0x9a0>)
 8007b66:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8007b6a:	441a      	add	r2, r3
 8007b6c:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8007b70:	1d59      	adds	r1, r3, #5
 8007b72:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007b76:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007b7a:	3102      	adds	r1, #2
 8007b7c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8007b80:	441a      	add	r2, r3
 8007b82:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007b86:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007b8a:	601a      	str	r2, [r3, #0]
 8007b8c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007b90:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007b94:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 8007b98:	ea4f 02b3 	mov.w	r2, r3, ror #2
 8007b9c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007ba0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007ba4:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 8007ba8:	ea4f 3373 	mov.w	r3, r3, ror #13
 8007bac:	405a      	eors	r2, r3
 8007bae:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007bb2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007bb6:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 8007bba:	ea4f 53b3 	mov.w	r3, r3, ror #22
 8007bbe:	405a      	eors	r2, r3
 8007bc0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007bc4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007bc8:	f8d3 1114 	ldr.w	r1, [r3, #276]	@ 0x114
 8007bcc:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007bd0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007bd4:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8007bd8:	4019      	ands	r1, r3
 8007bda:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007bde:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007be2:	f8d3 011c 	ldr.w	r0, [r3, #284]	@ 0x11c
 8007be6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007bea:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007bee:	f8d3 4114 	ldr.w	r4, [r3, #276]	@ 0x114
 8007bf2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007bf6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007bfa:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8007bfe:	4323      	orrs	r3, r4
 8007c00:	4003      	ands	r3, r0
 8007c02:	430b      	orrs	r3, r1
 8007c04:	441a      	add	r2, r3
 8007c06:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007c0a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007c0e:	605a      	str	r2, [r3, #4]
 8007c10:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007c14:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007c18:	f8d3 2120 	ldr.w	r2, [r3, #288]	@ 0x120
 8007c1c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007c20:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007c24:	681b      	ldr	r3, [r3, #0]
 8007c26:	441a      	add	r2, r3
 8007c28:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007c2c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007c30:	f8c3 2120 	str.w	r2, [r3, #288]	@ 0x120
 8007c34:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007c38:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007c3c:	681a      	ldr	r2, [r3, #0]
 8007c3e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007c42:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007c46:	685b      	ldr	r3, [r3, #4]
 8007c48:	441a      	add	r2, r3
 8007c4a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007c4e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007c52:	e001      	b.n	8007c58 <mbedtls_internal_sha256_process+0x9a4>
 8007c54:	08016c4c 	.word	0x08016c4c
 8007c58:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
           local.A[0], local.A[1], local.A[2], local.W[i+5], K[i+5] );
        P( local.A[2], local.A[3], local.A[4], local.A[5], local.A[6],
 8007c5c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007c60:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007c64:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 8007c68:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007c6c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007c70:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
 8007c74:	ea4f 11b3 	mov.w	r1, r3, ror #6
 8007c78:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007c7c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007c80:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
 8007c84:	ea4f 23f3 	mov.w	r3, r3, ror #11
 8007c88:	4059      	eors	r1, r3
 8007c8a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007c8e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007c92:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
 8007c96:	ea4f 6373 	mov.w	r3, r3, ror #25
 8007c9a:	404b      	eors	r3, r1
 8007c9c:	441a      	add	r2, r3
 8007c9e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007ca2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007ca6:	f8d3 1108 	ldr.w	r1, [r3, #264]	@ 0x108
 8007caa:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007cae:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007cb2:	f8d3 0120 	ldr.w	r0, [r3, #288]	@ 0x120
 8007cb6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007cba:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007cbe:	f8d3 4124 	ldr.w	r4, [r3, #292]	@ 0x124
 8007cc2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007cc6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007cca:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 8007cce:	4063      	eors	r3, r4
 8007cd0:	4003      	ands	r3, r0
 8007cd2:	404b      	eors	r3, r1
 8007cd4:	441a      	add	r2, r3
 8007cd6:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8007cda:	3306      	adds	r3, #6
 8007cdc:	49a0      	ldr	r1, [pc, #640]	@ (8007f60 <mbedtls_internal_sha256_process+0xcac>)
 8007cde:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8007ce2:	441a      	add	r2, r3
 8007ce4:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8007ce8:	1d99      	adds	r1, r3, #6
 8007cea:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007cee:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007cf2:	3102      	adds	r1, #2
 8007cf4:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8007cf8:	441a      	add	r2, r3
 8007cfa:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007cfe:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007d02:	601a      	str	r2, [r3, #0]
 8007d04:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007d08:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007d0c:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 8007d10:	ea4f 02b3 	mov.w	r2, r3, ror #2
 8007d14:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007d18:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007d1c:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 8007d20:	ea4f 3373 	mov.w	r3, r3, ror #13
 8007d24:	405a      	eors	r2, r3
 8007d26:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007d2a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007d2e:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 8007d32:	ea4f 53b3 	mov.w	r3, r3, ror #22
 8007d36:	405a      	eors	r2, r3
 8007d38:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007d3c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007d40:	f8d3 1110 	ldr.w	r1, [r3, #272]	@ 0x110
 8007d44:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007d48:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007d4c:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 8007d50:	4019      	ands	r1, r3
 8007d52:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007d56:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007d5a:	f8d3 0118 	ldr.w	r0, [r3, #280]	@ 0x118
 8007d5e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007d62:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007d66:	f8d3 4110 	ldr.w	r4, [r3, #272]	@ 0x110
 8007d6a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007d6e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007d72:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 8007d76:	4323      	orrs	r3, r4
 8007d78:	4003      	ands	r3, r0
 8007d7a:	430b      	orrs	r3, r1
 8007d7c:	441a      	add	r2, r3
 8007d7e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007d82:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007d86:	605a      	str	r2, [r3, #4]
 8007d88:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007d8c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007d90:	f8d3 211c 	ldr.w	r2, [r3, #284]	@ 0x11c
 8007d94:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007d98:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007d9c:	681b      	ldr	r3, [r3, #0]
 8007d9e:	441a      	add	r2, r3
 8007da0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007da4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007da8:	f8c3 211c 	str.w	r2, [r3, #284]	@ 0x11c
 8007dac:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007db0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007db4:	681a      	ldr	r2, [r3, #0]
 8007db6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007dba:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007dbe:	685b      	ldr	r3, [r3, #4]
 8007dc0:	441a      	add	r2, r3
 8007dc2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007dc6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007dca:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
           local.A[7], local.A[0], local.A[1], local.W[i+6], K[i+6] );
        P( local.A[1], local.A[2], local.A[3], local.A[4], local.A[5],
 8007dce:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007dd2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007dd6:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
 8007dda:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007dde:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007de2:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 8007de6:	ea4f 11b3 	mov.w	r1, r3, ror #6
 8007dea:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007dee:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007df2:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 8007df6:	ea4f 23f3 	mov.w	r3, r3, ror #11
 8007dfa:	4059      	eors	r1, r3
 8007dfc:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007e00:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007e04:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 8007e08:	ea4f 6373 	mov.w	r3, r3, ror #25
 8007e0c:	404b      	eors	r3, r1
 8007e0e:	441a      	add	r2, r3
 8007e10:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007e14:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007e18:	f8d3 1124 	ldr.w	r1, [r3, #292]	@ 0x124
 8007e1c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007e20:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007e24:	f8d3 011c 	ldr.w	r0, [r3, #284]	@ 0x11c
 8007e28:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007e2c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007e30:	f8d3 4120 	ldr.w	r4, [r3, #288]	@ 0x120
 8007e34:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007e38:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007e3c:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 8007e40:	4063      	eors	r3, r4
 8007e42:	4003      	ands	r3, r0
 8007e44:	404b      	eors	r3, r1
 8007e46:	441a      	add	r2, r3
 8007e48:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8007e4c:	3307      	adds	r3, #7
 8007e4e:	4944      	ldr	r1, [pc, #272]	@ (8007f60 <mbedtls_internal_sha256_process+0xcac>)
 8007e50:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8007e54:	441a      	add	r2, r3
 8007e56:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8007e5a:	1dd9      	adds	r1, r3, #7
 8007e5c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007e60:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007e64:	3102      	adds	r1, #2
 8007e66:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8007e6a:	441a      	add	r2, r3
 8007e6c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007e70:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007e74:	601a      	str	r2, [r3, #0]
 8007e76:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007e7a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007e7e:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8007e82:	ea4f 02b3 	mov.w	r2, r3, ror #2
 8007e86:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007e8a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007e8e:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8007e92:	ea4f 3373 	mov.w	r3, r3, ror #13
 8007e96:	405a      	eors	r2, r3
 8007e98:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007e9c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007ea0:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8007ea4:	ea4f 53b3 	mov.w	r3, r3, ror #22
 8007ea8:	405a      	eors	r2, r3
 8007eaa:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007eae:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007eb2:	f8d3 110c 	ldr.w	r1, [r3, #268]	@ 0x10c
 8007eb6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007eba:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007ebe:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 8007ec2:	4019      	ands	r1, r3
 8007ec4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007ec8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007ecc:	f8d3 0114 	ldr.w	r0, [r3, #276]	@ 0x114
 8007ed0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007ed4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007ed8:	f8d3 410c 	ldr.w	r4, [r3, #268]	@ 0x10c
 8007edc:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007ee0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007ee4:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 8007ee8:	4323      	orrs	r3, r4
 8007eea:	4003      	ands	r3, r0
 8007eec:	430b      	orrs	r3, r1
 8007eee:	441a      	add	r2, r3
 8007ef0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007ef4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007ef8:	605a      	str	r2, [r3, #4]
 8007efa:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007efe:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007f02:	f8d3 2118 	ldr.w	r2, [r3, #280]	@ 0x118
 8007f06:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007f0a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007f0e:	681b      	ldr	r3, [r3, #0]
 8007f10:	441a      	add	r2, r3
 8007f12:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007f16:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007f1a:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
 8007f1e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007f22:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007f26:	681a      	ldr	r2, [r3, #0]
 8007f28:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007f2c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007f30:	685b      	ldr	r3, [r3, #4]
 8007f32:	441a      	add	r2, r3
 8007f34:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007f38:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007f3c:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
    for( i = 0; i < 16; i += 8 )
 8007f40:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8007f44:	3308      	adds	r3, #8
 8007f46:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
 8007f4a:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8007f4e:	2b0f      	cmp	r3, #15
 8007f50:	f67f aa2a 	bls.w	80073a8 <mbedtls_internal_sha256_process+0xf4>
           local.A[6], local.A[7], local.A[0], local.W[i+7], K[i+7] );
    }

    for( i = 16; i < 64; i += 8 )
 8007f54:	2310      	movs	r3, #16
 8007f56:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
 8007f5a:	f001 b939 	b.w	80091d0 <mbedtls_internal_sha256_process+0x1f1c>
 8007f5e:	bf00      	nop
 8007f60:	08016c4c 	.word	0x08016c4c
    {
        P( local.A[0], local.A[1], local.A[2], local.A[3], local.A[4],
 8007f64:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007f68:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007f6c:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
 8007f70:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007f74:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007f78:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8007f7c:	ea4f 11b3 	mov.w	r1, r3, ror #6
 8007f80:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007f84:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007f88:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8007f8c:	ea4f 23f3 	mov.w	r3, r3, ror #11
 8007f90:	4059      	eors	r1, r3
 8007f92:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007f96:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007f9a:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8007f9e:	ea4f 6373 	mov.w	r3, r3, ror #25
 8007fa2:	404b      	eors	r3, r1
 8007fa4:	441a      	add	r2, r3
 8007fa6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007faa:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007fae:	f8d3 1120 	ldr.w	r1, [r3, #288]	@ 0x120
 8007fb2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007fb6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007fba:	f8d3 0118 	ldr.w	r0, [r3, #280]	@ 0x118
 8007fbe:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007fc2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007fc6:	f8d3 411c 	ldr.w	r4, [r3, #284]	@ 0x11c
 8007fca:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007fce:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007fd2:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
 8007fd6:	4063      	eors	r3, r4
 8007fd8:	4003      	ands	r3, r0
 8007fda:	404b      	eors	r3, r1
 8007fdc:	441a      	add	r2, r3
 8007fde:	49f9      	ldr	r1, [pc, #996]	@ (80083c4 <mbedtls_internal_sha256_process+0x1110>)
 8007fe0:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8007fe4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8007fe8:	441a      	add	r2, r3
 8007fea:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8007fee:	1e99      	subs	r1, r3, #2
 8007ff0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8007ff4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8007ff8:	3102      	adds	r1, #2
 8007ffa:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8007ffe:	ea4f 4173 	mov.w	r1, r3, ror #17
 8008002:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008006:	1e98      	subs	r0, r3, #2
 8008008:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800800c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008010:	3002      	adds	r0, #2
 8008012:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008016:	ea4f 43f3 	mov.w	r3, r3, ror #19
 800801a:	4059      	eors	r1, r3
 800801c:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008020:	1e98      	subs	r0, r3, #2
 8008022:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008026:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800802a:	3002      	adds	r0, #2
 800802c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008030:	0a9b      	lsrs	r3, r3, #10
 8008032:	4059      	eors	r1, r3
 8008034:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008038:	1fd8      	subs	r0, r3, #7
 800803a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800803e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008042:	3002      	adds	r0, #2
 8008044:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008048:	4419      	add	r1, r3
 800804a:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800804e:	f1a3 000f 	sub.w	r0, r3, #15
 8008052:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008056:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800805a:	3002      	adds	r0, #2
 800805c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008060:	ea4f 10f3 	mov.w	r0, r3, ror #7
 8008064:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008068:	f1a3 040f 	sub.w	r4, r3, #15
 800806c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008070:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008074:	3402      	adds	r4, #2
 8008076:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 800807a:	ea4f 43b3 	mov.w	r3, r3, ror #18
 800807e:	4058      	eors	r0, r3
 8008080:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008084:	f1a3 040f 	sub.w	r4, r3, #15
 8008088:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800808c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008090:	3402      	adds	r4, #2
 8008092:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8008096:	08db      	lsrs	r3, r3, #3
 8008098:	4043      	eors	r3, r0
 800809a:	4419      	add	r1, r3
 800809c:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80080a0:	f1a3 0010 	sub.w	r0, r3, #16
 80080a4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80080a8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80080ac:	3002      	adds	r0, #2
 80080ae:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80080b2:	18c8      	adds	r0, r1, r3
 80080b4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80080b8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80080bc:	f8d7 1134 	ldr.w	r1, [r7, #308]	@ 0x134
 80080c0:	3102      	adds	r1, #2
 80080c2:	f843 0021 	str.w	r0, [r3, r1, lsl #2]
 80080c6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80080ca:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80080ce:	f8d7 1134 	ldr.w	r1, [r7, #308]	@ 0x134
 80080d2:	3102      	adds	r1, #2
 80080d4:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80080d8:	441a      	add	r2, r3
 80080da:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80080de:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80080e2:	601a      	str	r2, [r3, #0]
 80080e4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80080e8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80080ec:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 80080f0:	ea4f 02b3 	mov.w	r2, r3, ror #2
 80080f4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80080f8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80080fc:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 8008100:	ea4f 3373 	mov.w	r3, r3, ror #13
 8008104:	405a      	eors	r2, r3
 8008106:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800810a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800810e:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 8008112:	ea4f 53b3 	mov.w	r3, r3, ror #22
 8008116:	405a      	eors	r2, r3
 8008118:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800811c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008120:	f8d3 1108 	ldr.w	r1, [r3, #264]	@ 0x108
 8008124:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008128:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800812c:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8008130:	4019      	ands	r1, r3
 8008132:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008136:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800813a:	f8d3 0110 	ldr.w	r0, [r3, #272]	@ 0x110
 800813e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008142:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008146:	f8d3 4108 	ldr.w	r4, [r3, #264]	@ 0x108
 800814a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800814e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008152:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8008156:	4323      	orrs	r3, r4
 8008158:	4003      	ands	r3, r0
 800815a:	430b      	orrs	r3, r1
 800815c:	441a      	add	r2, r3
 800815e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008162:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008166:	605a      	str	r2, [r3, #4]
 8008168:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800816c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008170:	f8d3 2114 	ldr.w	r2, [r3, #276]	@ 0x114
 8008174:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008178:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800817c:	681b      	ldr	r3, [r3, #0]
 800817e:	441a      	add	r2, r3
 8008180:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008184:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008188:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
 800818c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008190:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008194:	681a      	ldr	r2, [r3, #0]
 8008196:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800819a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800819e:	685b      	ldr	r3, [r3, #4]
 80081a0:	441a      	add	r2, r3
 80081a2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80081a6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80081aa:	f8c3 2124 	str.w	r2, [r3, #292]	@ 0x124
           local.A[5], local.A[6], local.A[7], R(i+0), K[i+0] );
        P( local.A[7], local.A[0], local.A[1], local.A[2], local.A[3],
 80081ae:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80081b2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80081b6:	f8d3 2120 	ldr.w	r2, [r3, #288]	@ 0x120
 80081ba:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80081be:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80081c2:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 80081c6:	ea4f 11b3 	mov.w	r1, r3, ror #6
 80081ca:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80081ce:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80081d2:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 80081d6:	ea4f 23f3 	mov.w	r3, r3, ror #11
 80081da:	4059      	eors	r1, r3
 80081dc:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80081e0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80081e4:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 80081e8:	ea4f 6373 	mov.w	r3, r3, ror #25
 80081ec:	404b      	eors	r3, r1
 80081ee:	441a      	add	r2, r3
 80081f0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80081f4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80081f8:	f8d3 111c 	ldr.w	r1, [r3, #284]	@ 0x11c
 80081fc:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008200:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008204:	f8d3 0114 	ldr.w	r0, [r3, #276]	@ 0x114
 8008208:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800820c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008210:	f8d3 4118 	ldr.w	r4, [r3, #280]	@ 0x118
 8008214:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008218:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800821c:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 8008220:	4063      	eors	r3, r4
 8008222:	4003      	ands	r3, r0
 8008224:	404b      	eors	r3, r1
 8008226:	441a      	add	r2, r3
 8008228:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800822c:	3301      	adds	r3, #1
 800822e:	4965      	ldr	r1, [pc, #404]	@ (80083c4 <mbedtls_internal_sha256_process+0x1110>)
 8008230:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8008234:	441a      	add	r2, r3
 8008236:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800823a:	1e59      	subs	r1, r3, #1
 800823c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008240:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008244:	3102      	adds	r1, #2
 8008246:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 800824a:	ea4f 4173 	mov.w	r1, r3, ror #17
 800824e:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008252:	1e58      	subs	r0, r3, #1
 8008254:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008258:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800825c:	3002      	adds	r0, #2
 800825e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008262:	ea4f 43f3 	mov.w	r3, r3, ror #19
 8008266:	4059      	eors	r1, r3
 8008268:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800826c:	1e58      	subs	r0, r3, #1
 800826e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008272:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008276:	3002      	adds	r0, #2
 8008278:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 800827c:	0a9b      	lsrs	r3, r3, #10
 800827e:	4059      	eors	r1, r3
 8008280:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008284:	1f98      	subs	r0, r3, #6
 8008286:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800828a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800828e:	3002      	adds	r0, #2
 8008290:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008294:	4419      	add	r1, r3
 8008296:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800829a:	f1a3 000e 	sub.w	r0, r3, #14
 800829e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80082a2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80082a6:	3002      	adds	r0, #2
 80082a8:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80082ac:	ea4f 10f3 	mov.w	r0, r3, ror #7
 80082b0:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80082b4:	f1a3 040e 	sub.w	r4, r3, #14
 80082b8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80082bc:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80082c0:	3402      	adds	r4, #2
 80082c2:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 80082c6:	ea4f 43b3 	mov.w	r3, r3, ror #18
 80082ca:	4058      	eors	r0, r3
 80082cc:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80082d0:	f1a3 040e 	sub.w	r4, r3, #14
 80082d4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80082d8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80082dc:	3402      	adds	r4, #2
 80082de:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 80082e2:	08db      	lsrs	r3, r3, #3
 80082e4:	4043      	eors	r3, r0
 80082e6:	18c8      	adds	r0, r1, r3
 80082e8:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80082ec:	f1a3 010f 	sub.w	r1, r3, #15
 80082f0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80082f4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80082f8:	3102      	adds	r1, #2
 80082fa:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 80082fe:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008302:	3301      	adds	r3, #1
 8008304:	1844      	adds	r4, r0, r1
 8008306:	f507 719c 	add.w	r1, r7, #312	@ 0x138
 800830a:	f5a1 7196 	sub.w	r1, r1, #300	@ 0x12c
 800830e:	1c98      	adds	r0, r3, #2
 8008310:	f841 4020 	str.w	r4, [r1, r0, lsl #2]
 8008314:	f507 719c 	add.w	r1, r7, #312	@ 0x138
 8008318:	f5a1 7196 	sub.w	r1, r1, #300	@ 0x12c
 800831c:	3302      	adds	r3, #2
 800831e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8008322:	441a      	add	r2, r3
 8008324:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008328:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800832c:	601a      	str	r2, [r3, #0]
 800832e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008332:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008336:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800833a:	ea4f 02b3 	mov.w	r2, r3, ror #2
 800833e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008342:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008346:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800834a:	ea4f 3373 	mov.w	r3, r3, ror #13
 800834e:	405a      	eors	r2, r3
 8008350:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008354:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008358:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800835c:	ea4f 53b3 	mov.w	r3, r3, ror #22
 8008360:	405a      	eors	r2, r3
 8008362:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008366:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800836a:	f8d3 1124 	ldr.w	r1, [r3, #292]	@ 0x124
 800836e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008372:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008376:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 800837a:	4019      	ands	r1, r3
 800837c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008380:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008384:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
 8008388:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800838c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008390:	f8d3 4124 	ldr.w	r4, [r3, #292]	@ 0x124
 8008394:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008398:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800839c:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 80083a0:	4323      	orrs	r3, r4
 80083a2:	4003      	ands	r3, r0
 80083a4:	430b      	orrs	r3, r1
 80083a6:	441a      	add	r2, r3
 80083a8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80083ac:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80083b0:	605a      	str	r2, [r3, #4]
 80083b2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80083b6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80083ba:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
 80083be:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80083c2:	e001      	b.n	80083c8 <mbedtls_internal_sha256_process+0x1114>
 80083c4:	08016c4c 	.word	0x08016c4c
 80083c8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80083cc:	681b      	ldr	r3, [r3, #0]
 80083ce:	441a      	add	r2, r3
 80083d0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80083d4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80083d8:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
 80083dc:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80083e0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80083e4:	681a      	ldr	r2, [r3, #0]
 80083e6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80083ea:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80083ee:	685b      	ldr	r3, [r3, #4]
 80083f0:	441a      	add	r2, r3
 80083f2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80083f6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80083fa:	f8c3 2120 	str.w	r2, [r3, #288]	@ 0x120
           local.A[4], local.A[5], local.A[6], R(i+1), K[i+1] );
        P( local.A[6], local.A[7], local.A[0], local.A[1], local.A[2],
 80083fe:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008402:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008406:	f8d3 211c 	ldr.w	r2, [r3, #284]	@ 0x11c
 800840a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800840e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008412:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 8008416:	ea4f 11b3 	mov.w	r1, r3, ror #6
 800841a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800841e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008422:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 8008426:	ea4f 23f3 	mov.w	r3, r3, ror #11
 800842a:	4059      	eors	r1, r3
 800842c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008430:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008434:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 8008438:	ea4f 6373 	mov.w	r3, r3, ror #25
 800843c:	404b      	eors	r3, r1
 800843e:	441a      	add	r2, r3
 8008440:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008444:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008448:	f8d3 1118 	ldr.w	r1, [r3, #280]	@ 0x118
 800844c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008450:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008454:	f8d3 0110 	ldr.w	r0, [r3, #272]	@ 0x110
 8008458:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800845c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008460:	f8d3 4114 	ldr.w	r4, [r3, #276]	@ 0x114
 8008464:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008468:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800846c:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8008470:	4063      	eors	r3, r4
 8008472:	4003      	ands	r3, r0
 8008474:	404b      	eors	r3, r1
 8008476:	441a      	add	r2, r3
 8008478:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800847c:	3302      	adds	r3, #2
 800847e:	49f9      	ldr	r1, [pc, #996]	@ (8008864 <mbedtls_internal_sha256_process+0x15b0>)
 8008480:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8008484:	441a      	add	r2, r3
 8008486:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800848a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800848e:	f8d7 1134 	ldr.w	r1, [r7, #308]	@ 0x134
 8008492:	3102      	adds	r1, #2
 8008494:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8008498:	ea4f 4173 	mov.w	r1, r3, ror #17
 800849c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80084a0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80084a4:	f8d7 0134 	ldr.w	r0, [r7, #308]	@ 0x134
 80084a8:	3002      	adds	r0, #2
 80084aa:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80084ae:	ea4f 43f3 	mov.w	r3, r3, ror #19
 80084b2:	4059      	eors	r1, r3
 80084b4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80084b8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80084bc:	f8d7 0134 	ldr.w	r0, [r7, #308]	@ 0x134
 80084c0:	3002      	adds	r0, #2
 80084c2:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80084c6:	0a9b      	lsrs	r3, r3, #10
 80084c8:	4059      	eors	r1, r3
 80084ca:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80084ce:	1f58      	subs	r0, r3, #5
 80084d0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80084d4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80084d8:	3002      	adds	r0, #2
 80084da:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80084de:	4419      	add	r1, r3
 80084e0:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80084e4:	f1a3 000d 	sub.w	r0, r3, #13
 80084e8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80084ec:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80084f0:	3002      	adds	r0, #2
 80084f2:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80084f6:	ea4f 10f3 	mov.w	r0, r3, ror #7
 80084fa:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80084fe:	f1a3 040d 	sub.w	r4, r3, #13
 8008502:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008506:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800850a:	3402      	adds	r4, #2
 800850c:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8008510:	ea4f 43b3 	mov.w	r3, r3, ror #18
 8008514:	4058      	eors	r0, r3
 8008516:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800851a:	f1a3 040d 	sub.w	r4, r3, #13
 800851e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008522:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008526:	3402      	adds	r4, #2
 8008528:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 800852c:	08db      	lsrs	r3, r3, #3
 800852e:	4043      	eors	r3, r0
 8008530:	18c8      	adds	r0, r1, r3
 8008532:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008536:	f1a3 010e 	sub.w	r1, r3, #14
 800853a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800853e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008542:	3102      	adds	r1, #2
 8008544:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 8008548:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800854c:	3302      	adds	r3, #2
 800854e:	1844      	adds	r4, r0, r1
 8008550:	f507 719c 	add.w	r1, r7, #312	@ 0x138
 8008554:	f5a1 7196 	sub.w	r1, r1, #300	@ 0x12c
 8008558:	1c98      	adds	r0, r3, #2
 800855a:	f841 4020 	str.w	r4, [r1, r0, lsl #2]
 800855e:	f507 719c 	add.w	r1, r7, #312	@ 0x138
 8008562:	f5a1 7196 	sub.w	r1, r1, #300	@ 0x12c
 8008566:	3302      	adds	r3, #2
 8008568:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800856c:	441a      	add	r2, r3
 800856e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008572:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008576:	601a      	str	r2, [r3, #0]
 8008578:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800857c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008580:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
 8008584:	ea4f 02b3 	mov.w	r2, r3, ror #2
 8008588:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800858c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008590:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
 8008594:	ea4f 3373 	mov.w	r3, r3, ror #13
 8008598:	405a      	eors	r2, r3
 800859a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800859e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80085a2:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
 80085a6:	ea4f 53b3 	mov.w	r3, r3, ror #22
 80085aa:	405a      	eors	r2, r3
 80085ac:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80085b0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80085b4:	f8d3 1120 	ldr.w	r1, [r3, #288]	@ 0x120
 80085b8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80085bc:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80085c0:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 80085c4:	4019      	ands	r1, r3
 80085c6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80085ca:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80085ce:	f8d3 0108 	ldr.w	r0, [r3, #264]	@ 0x108
 80085d2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80085d6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80085da:	f8d3 4120 	ldr.w	r4, [r3, #288]	@ 0x120
 80085de:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80085e2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80085e6:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 80085ea:	4323      	orrs	r3, r4
 80085ec:	4003      	ands	r3, r0
 80085ee:	430b      	orrs	r3, r1
 80085f0:	441a      	add	r2, r3
 80085f2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80085f6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80085fa:	605a      	str	r2, [r3, #4]
 80085fc:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008600:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008604:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 8008608:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800860c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008610:	681b      	ldr	r3, [r3, #0]
 8008612:	441a      	add	r2, r3
 8008614:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008618:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800861c:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
 8008620:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008624:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008628:	681a      	ldr	r2, [r3, #0]
 800862a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800862e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008632:	685b      	ldr	r3, [r3, #4]
 8008634:	441a      	add	r2, r3
 8008636:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800863a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800863e:	f8c3 211c 	str.w	r2, [r3, #284]	@ 0x11c
           local.A[3], local.A[4], local.A[5], R(i+2), K[i+2] );
        P( local.A[5], local.A[6], local.A[7], local.A[0], local.A[1],
 8008642:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008646:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800864a:	f8d3 2118 	ldr.w	r2, [r3, #280]	@ 0x118
 800864e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008652:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008656:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 800865a:	ea4f 11b3 	mov.w	r1, r3, ror #6
 800865e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008662:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008666:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 800866a:	ea4f 23f3 	mov.w	r3, r3, ror #11
 800866e:	4059      	eors	r1, r3
 8008670:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008674:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008678:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 800867c:	ea4f 6373 	mov.w	r3, r3, ror #25
 8008680:	404b      	eors	r3, r1
 8008682:	441a      	add	r2, r3
 8008684:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008688:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800868c:	f8d3 1114 	ldr.w	r1, [r3, #276]	@ 0x114
 8008690:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008694:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008698:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
 800869c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80086a0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80086a4:	f8d3 4110 	ldr.w	r4, [r3, #272]	@ 0x110
 80086a8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80086ac:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80086b0:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 80086b4:	4063      	eors	r3, r4
 80086b6:	4003      	ands	r3, r0
 80086b8:	404b      	eors	r3, r1
 80086ba:	441a      	add	r2, r3
 80086bc:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80086c0:	3303      	adds	r3, #3
 80086c2:	4968      	ldr	r1, [pc, #416]	@ (8008864 <mbedtls_internal_sha256_process+0x15b0>)
 80086c4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80086c8:	441a      	add	r2, r3
 80086ca:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80086ce:	1c59      	adds	r1, r3, #1
 80086d0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80086d4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80086d8:	3102      	adds	r1, #2
 80086da:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80086de:	ea4f 4173 	mov.w	r1, r3, ror #17
 80086e2:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80086e6:	1c58      	adds	r0, r3, #1
 80086e8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80086ec:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80086f0:	3002      	adds	r0, #2
 80086f2:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80086f6:	ea4f 43f3 	mov.w	r3, r3, ror #19
 80086fa:	4059      	eors	r1, r3
 80086fc:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008700:	1c58      	adds	r0, r3, #1
 8008702:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008706:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800870a:	3002      	adds	r0, #2
 800870c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008710:	0a9b      	lsrs	r3, r3, #10
 8008712:	4059      	eors	r1, r3
 8008714:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008718:	1f18      	subs	r0, r3, #4
 800871a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800871e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008722:	3002      	adds	r0, #2
 8008724:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008728:	4419      	add	r1, r3
 800872a:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800872e:	f1a3 000c 	sub.w	r0, r3, #12
 8008732:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008736:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800873a:	3002      	adds	r0, #2
 800873c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008740:	ea4f 10f3 	mov.w	r0, r3, ror #7
 8008744:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008748:	f1a3 040c 	sub.w	r4, r3, #12
 800874c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008750:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008754:	3402      	adds	r4, #2
 8008756:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 800875a:	ea4f 43b3 	mov.w	r3, r3, ror #18
 800875e:	4058      	eors	r0, r3
 8008760:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008764:	f1a3 040c 	sub.w	r4, r3, #12
 8008768:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800876c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008770:	3402      	adds	r4, #2
 8008772:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8008776:	08db      	lsrs	r3, r3, #3
 8008778:	4043      	eors	r3, r0
 800877a:	18c8      	adds	r0, r1, r3
 800877c:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008780:	f1a3 010d 	sub.w	r1, r3, #13
 8008784:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008788:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800878c:	3102      	adds	r1, #2
 800878e:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 8008792:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008796:	3303      	adds	r3, #3
 8008798:	1844      	adds	r4, r0, r1
 800879a:	f507 719c 	add.w	r1, r7, #312	@ 0x138
 800879e:	f5a1 7196 	sub.w	r1, r1, #300	@ 0x12c
 80087a2:	1c98      	adds	r0, r3, #2
 80087a4:	f841 4020 	str.w	r4, [r1, r0, lsl #2]
 80087a8:	f507 719c 	add.w	r1, r7, #312	@ 0x138
 80087ac:	f5a1 7196 	sub.w	r1, r1, #300	@ 0x12c
 80087b0:	3302      	adds	r3, #2
 80087b2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80087b6:	441a      	add	r2, r3
 80087b8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80087bc:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80087c0:	601a      	str	r2, [r3, #0]
 80087c2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80087c6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80087ca:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 80087ce:	ea4f 02b3 	mov.w	r2, r3, ror #2
 80087d2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80087d6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80087da:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 80087de:	ea4f 3373 	mov.w	r3, r3, ror #13
 80087e2:	405a      	eors	r2, r3
 80087e4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80087e8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80087ec:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 80087f0:	ea4f 53b3 	mov.w	r3, r3, ror #22
 80087f4:	405a      	eors	r2, r3
 80087f6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80087fa:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80087fe:	f8d3 111c 	ldr.w	r1, [r3, #284]	@ 0x11c
 8008802:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008806:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800880a:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
 800880e:	4019      	ands	r1, r3
 8008810:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008814:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008818:	f8d3 0124 	ldr.w	r0, [r3, #292]	@ 0x124
 800881c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008820:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008824:	f8d3 411c 	ldr.w	r4, [r3, #284]	@ 0x11c
 8008828:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800882c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008830:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
 8008834:	4323      	orrs	r3, r4
 8008836:	4003      	ands	r3, r0
 8008838:	430b      	orrs	r3, r1
 800883a:	441a      	add	r2, r3
 800883c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008840:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008844:	605a      	str	r2, [r3, #4]
 8008846:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800884a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800884e:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
 8008852:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008856:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800885a:	681b      	ldr	r3, [r3, #0]
 800885c:	441a      	add	r2, r3
 800885e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008862:	e001      	b.n	8008868 <mbedtls_internal_sha256_process+0x15b4>
 8008864:	08016c4c 	.word	0x08016c4c
 8008868:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800886c:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
 8008870:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008874:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008878:	681a      	ldr	r2, [r3, #0]
 800887a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800887e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008882:	685b      	ldr	r3, [r3, #4]
 8008884:	441a      	add	r2, r3
 8008886:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800888a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800888e:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
           local.A[2], local.A[3], local.A[4], R(i+3), K[i+3] );
        P( local.A[4], local.A[5], local.A[6], local.A[7], local.A[0],
 8008892:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008896:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800889a:	f8d3 2114 	ldr.w	r2, [r3, #276]	@ 0x114
 800889e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80088a2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80088a6:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 80088aa:	ea4f 11b3 	mov.w	r1, r3, ror #6
 80088ae:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80088b2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80088b6:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 80088ba:	ea4f 23f3 	mov.w	r3, r3, ror #11
 80088be:	4059      	eors	r1, r3
 80088c0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80088c4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80088c8:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 80088cc:	ea4f 6373 	mov.w	r3, r3, ror #25
 80088d0:	404b      	eors	r3, r1
 80088d2:	441a      	add	r2, r3
 80088d4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80088d8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80088dc:	f8d3 1110 	ldr.w	r1, [r3, #272]	@ 0x110
 80088e0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80088e4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80088e8:	f8d3 0108 	ldr.w	r0, [r3, #264]	@ 0x108
 80088ec:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80088f0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80088f4:	f8d3 410c 	ldr.w	r4, [r3, #268]	@ 0x10c
 80088f8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80088fc:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008900:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 8008904:	4063      	eors	r3, r4
 8008906:	4003      	ands	r3, r0
 8008908:	404b      	eors	r3, r1
 800890a:	441a      	add	r2, r3
 800890c:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008910:	3304      	adds	r3, #4
 8008912:	49f9      	ldr	r1, [pc, #996]	@ (8008cf8 <mbedtls_internal_sha256_process+0x1a44>)
 8008914:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8008918:	441a      	add	r2, r3
 800891a:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800891e:	1c99      	adds	r1, r3, #2
 8008920:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008924:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008928:	3102      	adds	r1, #2
 800892a:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 800892e:	ea4f 4173 	mov.w	r1, r3, ror #17
 8008932:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008936:	1c98      	adds	r0, r3, #2
 8008938:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800893c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008940:	3002      	adds	r0, #2
 8008942:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008946:	ea4f 43f3 	mov.w	r3, r3, ror #19
 800894a:	4059      	eors	r1, r3
 800894c:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008950:	1c98      	adds	r0, r3, #2
 8008952:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008956:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800895a:	3002      	adds	r0, #2
 800895c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008960:	0a9b      	lsrs	r3, r3, #10
 8008962:	4059      	eors	r1, r3
 8008964:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008968:	1ed8      	subs	r0, r3, #3
 800896a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800896e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008972:	3002      	adds	r0, #2
 8008974:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008978:	4419      	add	r1, r3
 800897a:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800897e:	f1a3 000b 	sub.w	r0, r3, #11
 8008982:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008986:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800898a:	3002      	adds	r0, #2
 800898c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008990:	ea4f 10f3 	mov.w	r0, r3, ror #7
 8008994:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008998:	f1a3 040b 	sub.w	r4, r3, #11
 800899c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80089a0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80089a4:	3402      	adds	r4, #2
 80089a6:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 80089aa:	ea4f 43b3 	mov.w	r3, r3, ror #18
 80089ae:	4058      	eors	r0, r3
 80089b0:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80089b4:	f1a3 040b 	sub.w	r4, r3, #11
 80089b8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80089bc:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80089c0:	3402      	adds	r4, #2
 80089c2:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 80089c6:	08db      	lsrs	r3, r3, #3
 80089c8:	4043      	eors	r3, r0
 80089ca:	18c8      	adds	r0, r1, r3
 80089cc:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80089d0:	f1a3 010c 	sub.w	r1, r3, #12
 80089d4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80089d8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80089dc:	3102      	adds	r1, #2
 80089de:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 80089e2:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80089e6:	3304      	adds	r3, #4
 80089e8:	1844      	adds	r4, r0, r1
 80089ea:	f507 719c 	add.w	r1, r7, #312	@ 0x138
 80089ee:	f5a1 7196 	sub.w	r1, r1, #300	@ 0x12c
 80089f2:	1c98      	adds	r0, r3, #2
 80089f4:	f841 4020 	str.w	r4, [r1, r0, lsl #2]
 80089f8:	f507 719c 	add.w	r1, r7, #312	@ 0x138
 80089fc:	f5a1 7196 	sub.w	r1, r1, #300	@ 0x12c
 8008a00:	3302      	adds	r3, #2
 8008a02:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8008a06:	441a      	add	r2, r3
 8008a08:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008a0c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008a10:	601a      	str	r2, [r3, #0]
 8008a12:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008a16:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008a1a:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8008a1e:	ea4f 02b3 	mov.w	r2, r3, ror #2
 8008a22:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008a26:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008a2a:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8008a2e:	ea4f 3373 	mov.w	r3, r3, ror #13
 8008a32:	405a      	eors	r2, r3
 8008a34:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008a38:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008a3c:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8008a40:	ea4f 53b3 	mov.w	r3, r3, ror #22
 8008a44:	405a      	eors	r2, r3
 8008a46:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008a4a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008a4e:	f8d3 1118 	ldr.w	r1, [r3, #280]	@ 0x118
 8008a52:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008a56:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008a5a:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 8008a5e:	4019      	ands	r1, r3
 8008a60:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008a64:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008a68:	f8d3 0120 	ldr.w	r0, [r3, #288]	@ 0x120
 8008a6c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008a70:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008a74:	f8d3 4118 	ldr.w	r4, [r3, #280]	@ 0x118
 8008a78:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008a7c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008a80:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 8008a84:	4323      	orrs	r3, r4
 8008a86:	4003      	ands	r3, r0
 8008a88:	430b      	orrs	r3, r1
 8008a8a:	441a      	add	r2, r3
 8008a8c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008a90:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008a94:	605a      	str	r2, [r3, #4]
 8008a96:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008a9a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008a9e:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
 8008aa2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008aa6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008aaa:	681b      	ldr	r3, [r3, #0]
 8008aac:	441a      	add	r2, r3
 8008aae:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008ab2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008ab6:	f8c3 2124 	str.w	r2, [r3, #292]	@ 0x124
 8008aba:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008abe:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008ac2:	681a      	ldr	r2, [r3, #0]
 8008ac4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008ac8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008acc:	685b      	ldr	r3, [r3, #4]
 8008ace:	441a      	add	r2, r3
 8008ad0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008ad4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008ad8:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
           local.A[1], local.A[2], local.A[3], R(i+4), K[i+4] );
        P( local.A[3], local.A[4], local.A[5], local.A[6], local.A[7],
 8008adc:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008ae0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008ae4:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
 8008ae8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008aec:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008af0:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 8008af4:	ea4f 11b3 	mov.w	r1, r3, ror #6
 8008af8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008afc:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008b00:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 8008b04:	ea4f 23f3 	mov.w	r3, r3, ror #11
 8008b08:	4059      	eors	r1, r3
 8008b0a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008b0e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008b12:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 8008b16:	ea4f 6373 	mov.w	r3, r3, ror #25
 8008b1a:	404b      	eors	r3, r1
 8008b1c:	441a      	add	r2, r3
 8008b1e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008b22:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008b26:	f8d3 110c 	ldr.w	r1, [r3, #268]	@ 0x10c
 8008b2a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008b2e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008b32:	f8d3 0124 	ldr.w	r0, [r3, #292]	@ 0x124
 8008b36:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008b3a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008b3e:	f8d3 4108 	ldr.w	r4, [r3, #264]	@ 0x108
 8008b42:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008b46:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008b4a:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8008b4e:	4063      	eors	r3, r4
 8008b50:	4003      	ands	r3, r0
 8008b52:	404b      	eors	r3, r1
 8008b54:	441a      	add	r2, r3
 8008b56:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008b5a:	3305      	adds	r3, #5
 8008b5c:	4966      	ldr	r1, [pc, #408]	@ (8008cf8 <mbedtls_internal_sha256_process+0x1a44>)
 8008b5e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8008b62:	441a      	add	r2, r3
 8008b64:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008b68:	1cd9      	adds	r1, r3, #3
 8008b6a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008b6e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008b72:	3102      	adds	r1, #2
 8008b74:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8008b78:	ea4f 4173 	mov.w	r1, r3, ror #17
 8008b7c:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008b80:	1cd8      	adds	r0, r3, #3
 8008b82:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008b86:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008b8a:	3002      	adds	r0, #2
 8008b8c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008b90:	ea4f 43f3 	mov.w	r3, r3, ror #19
 8008b94:	4059      	eors	r1, r3
 8008b96:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008b9a:	1cd8      	adds	r0, r3, #3
 8008b9c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008ba0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008ba4:	3002      	adds	r0, #2
 8008ba6:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008baa:	0a9b      	lsrs	r3, r3, #10
 8008bac:	4059      	eors	r1, r3
 8008bae:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008bb2:	1e98      	subs	r0, r3, #2
 8008bb4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008bb8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008bbc:	3002      	adds	r0, #2
 8008bbe:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008bc2:	4419      	add	r1, r3
 8008bc4:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008bc8:	f1a3 000a 	sub.w	r0, r3, #10
 8008bcc:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008bd0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008bd4:	3002      	adds	r0, #2
 8008bd6:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008bda:	ea4f 10f3 	mov.w	r0, r3, ror #7
 8008bde:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008be2:	f1a3 040a 	sub.w	r4, r3, #10
 8008be6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008bea:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008bee:	3402      	adds	r4, #2
 8008bf0:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8008bf4:	ea4f 43b3 	mov.w	r3, r3, ror #18
 8008bf8:	4058      	eors	r0, r3
 8008bfa:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008bfe:	f1a3 040a 	sub.w	r4, r3, #10
 8008c02:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008c06:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008c0a:	3402      	adds	r4, #2
 8008c0c:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8008c10:	08db      	lsrs	r3, r3, #3
 8008c12:	4043      	eors	r3, r0
 8008c14:	18c8      	adds	r0, r1, r3
 8008c16:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008c1a:	f1a3 010b 	sub.w	r1, r3, #11
 8008c1e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008c22:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008c26:	3102      	adds	r1, #2
 8008c28:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 8008c2c:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008c30:	3305      	adds	r3, #5
 8008c32:	1844      	adds	r4, r0, r1
 8008c34:	f507 719c 	add.w	r1, r7, #312	@ 0x138
 8008c38:	f5a1 7196 	sub.w	r1, r1, #300	@ 0x12c
 8008c3c:	1c98      	adds	r0, r3, #2
 8008c3e:	f841 4020 	str.w	r4, [r1, r0, lsl #2]
 8008c42:	f507 719c 	add.w	r1, r7, #312	@ 0x138
 8008c46:	f5a1 7196 	sub.w	r1, r1, #300	@ 0x12c
 8008c4a:	3302      	adds	r3, #2
 8008c4c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8008c50:	441a      	add	r2, r3
 8008c52:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008c56:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008c5a:	601a      	str	r2, [r3, #0]
 8008c5c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008c60:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008c64:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 8008c68:	ea4f 02b3 	mov.w	r2, r3, ror #2
 8008c6c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008c70:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008c74:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 8008c78:	ea4f 3373 	mov.w	r3, r3, ror #13
 8008c7c:	405a      	eors	r2, r3
 8008c7e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008c82:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008c86:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 8008c8a:	ea4f 53b3 	mov.w	r3, r3, ror #22
 8008c8e:	405a      	eors	r2, r3
 8008c90:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008c94:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008c98:	f8d3 1114 	ldr.w	r1, [r3, #276]	@ 0x114
 8008c9c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008ca0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008ca4:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8008ca8:	4019      	ands	r1, r3
 8008caa:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008cae:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008cb2:	f8d3 011c 	ldr.w	r0, [r3, #284]	@ 0x11c
 8008cb6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008cba:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008cbe:	f8d3 4114 	ldr.w	r4, [r3, #276]	@ 0x114
 8008cc2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008cc6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008cca:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8008cce:	4323      	orrs	r3, r4
 8008cd0:	4003      	ands	r3, r0
 8008cd2:	430b      	orrs	r3, r1
 8008cd4:	441a      	add	r2, r3
 8008cd6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008cda:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008cde:	605a      	str	r2, [r3, #4]
 8008ce0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008ce4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008ce8:	f8d3 2120 	ldr.w	r2, [r3, #288]	@ 0x120
 8008cec:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008cf0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008cf4:	681b      	ldr	r3, [r3, #0]
 8008cf6:	e001      	b.n	8008cfc <mbedtls_internal_sha256_process+0x1a48>
 8008cf8:	08016c4c 	.word	0x08016c4c
 8008cfc:	441a      	add	r2, r3
 8008cfe:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008d02:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008d06:	f8c3 2120 	str.w	r2, [r3, #288]	@ 0x120
 8008d0a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008d0e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008d12:	681a      	ldr	r2, [r3, #0]
 8008d14:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008d18:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008d1c:	685b      	ldr	r3, [r3, #4]
 8008d1e:	441a      	add	r2, r3
 8008d20:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008d24:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008d28:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
           local.A[0], local.A[1], local.A[2], R(i+5), K[i+5] );
        P( local.A[2], local.A[3], local.A[4], local.A[5], local.A[6],
 8008d2c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008d30:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008d34:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 8008d38:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008d3c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008d40:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
 8008d44:	ea4f 11b3 	mov.w	r1, r3, ror #6
 8008d48:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008d4c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008d50:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
 8008d54:	ea4f 23f3 	mov.w	r3, r3, ror #11
 8008d58:	4059      	eors	r1, r3
 8008d5a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008d5e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008d62:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
 8008d66:	ea4f 6373 	mov.w	r3, r3, ror #25
 8008d6a:	404b      	eors	r3, r1
 8008d6c:	441a      	add	r2, r3
 8008d6e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008d72:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008d76:	f8d3 1108 	ldr.w	r1, [r3, #264]	@ 0x108
 8008d7a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008d7e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008d82:	f8d3 0120 	ldr.w	r0, [r3, #288]	@ 0x120
 8008d86:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008d8a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008d8e:	f8d3 4124 	ldr.w	r4, [r3, #292]	@ 0x124
 8008d92:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008d96:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008d9a:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 8008d9e:	4063      	eors	r3, r4
 8008da0:	4003      	ands	r3, r0
 8008da2:	404b      	eors	r3, r1
 8008da4:	441a      	add	r2, r3
 8008da6:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008daa:	3306      	adds	r3, #6
 8008dac:	49f9      	ldr	r1, [pc, #996]	@ (8009194 <mbedtls_internal_sha256_process+0x1ee0>)
 8008dae:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8008db2:	441a      	add	r2, r3
 8008db4:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008db8:	1d19      	adds	r1, r3, #4
 8008dba:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008dbe:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008dc2:	3102      	adds	r1, #2
 8008dc4:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8008dc8:	ea4f 4173 	mov.w	r1, r3, ror #17
 8008dcc:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008dd0:	1d18      	adds	r0, r3, #4
 8008dd2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008dd6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008dda:	3002      	adds	r0, #2
 8008ddc:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008de0:	ea4f 43f3 	mov.w	r3, r3, ror #19
 8008de4:	4059      	eors	r1, r3
 8008de6:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008dea:	1d18      	adds	r0, r3, #4
 8008dec:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008df0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008df4:	3002      	adds	r0, #2
 8008df6:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008dfa:	0a9b      	lsrs	r3, r3, #10
 8008dfc:	4059      	eors	r1, r3
 8008dfe:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008e02:	1e58      	subs	r0, r3, #1
 8008e04:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008e08:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008e0c:	3002      	adds	r0, #2
 8008e0e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008e12:	4419      	add	r1, r3
 8008e14:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008e18:	f1a3 0009 	sub.w	r0, r3, #9
 8008e1c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008e20:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008e24:	3002      	adds	r0, #2
 8008e26:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008e2a:	ea4f 10f3 	mov.w	r0, r3, ror #7
 8008e2e:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008e32:	f1a3 0409 	sub.w	r4, r3, #9
 8008e36:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008e3a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008e3e:	3402      	adds	r4, #2
 8008e40:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8008e44:	ea4f 43b3 	mov.w	r3, r3, ror #18
 8008e48:	4058      	eors	r0, r3
 8008e4a:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008e4e:	f1a3 0409 	sub.w	r4, r3, #9
 8008e52:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008e56:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008e5a:	3402      	adds	r4, #2
 8008e5c:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8008e60:	08db      	lsrs	r3, r3, #3
 8008e62:	4043      	eors	r3, r0
 8008e64:	18c8      	adds	r0, r1, r3
 8008e66:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008e6a:	f1a3 010a 	sub.w	r1, r3, #10
 8008e6e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008e72:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008e76:	3102      	adds	r1, #2
 8008e78:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 8008e7c:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008e80:	3306      	adds	r3, #6
 8008e82:	1844      	adds	r4, r0, r1
 8008e84:	f507 719c 	add.w	r1, r7, #312	@ 0x138
 8008e88:	f5a1 7196 	sub.w	r1, r1, #300	@ 0x12c
 8008e8c:	1c98      	adds	r0, r3, #2
 8008e8e:	f841 4020 	str.w	r4, [r1, r0, lsl #2]
 8008e92:	f507 719c 	add.w	r1, r7, #312	@ 0x138
 8008e96:	f5a1 7196 	sub.w	r1, r1, #300	@ 0x12c
 8008e9a:	3302      	adds	r3, #2
 8008e9c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8008ea0:	441a      	add	r2, r3
 8008ea2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008ea6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008eaa:	601a      	str	r2, [r3, #0]
 8008eac:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008eb0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008eb4:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 8008eb8:	ea4f 02b3 	mov.w	r2, r3, ror #2
 8008ebc:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008ec0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008ec4:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 8008ec8:	ea4f 3373 	mov.w	r3, r3, ror #13
 8008ecc:	405a      	eors	r2, r3
 8008ece:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008ed2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008ed6:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 8008eda:	ea4f 53b3 	mov.w	r3, r3, ror #22
 8008ede:	405a      	eors	r2, r3
 8008ee0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008ee4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008ee8:	f8d3 1110 	ldr.w	r1, [r3, #272]	@ 0x110
 8008eec:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008ef0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008ef4:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 8008ef8:	4019      	ands	r1, r3
 8008efa:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008efe:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008f02:	f8d3 0118 	ldr.w	r0, [r3, #280]	@ 0x118
 8008f06:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008f0a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008f0e:	f8d3 4110 	ldr.w	r4, [r3, #272]	@ 0x110
 8008f12:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008f16:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008f1a:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 8008f1e:	4323      	orrs	r3, r4
 8008f20:	4003      	ands	r3, r0
 8008f22:	430b      	orrs	r3, r1
 8008f24:	441a      	add	r2, r3
 8008f26:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008f2a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008f2e:	605a      	str	r2, [r3, #4]
 8008f30:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008f34:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008f38:	f8d3 211c 	ldr.w	r2, [r3, #284]	@ 0x11c
 8008f3c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008f40:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008f44:	681b      	ldr	r3, [r3, #0]
 8008f46:	441a      	add	r2, r3
 8008f48:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008f4c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008f50:	f8c3 211c 	str.w	r2, [r3, #284]	@ 0x11c
 8008f54:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008f58:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008f5c:	681a      	ldr	r2, [r3, #0]
 8008f5e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008f62:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008f66:	685b      	ldr	r3, [r3, #4]
 8008f68:	441a      	add	r2, r3
 8008f6a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008f6e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008f72:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
           local.A[7], local.A[0], local.A[1], R(i+6), K[i+6] );
        P( local.A[1], local.A[2], local.A[3], local.A[4], local.A[5],
 8008f76:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008f7a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008f7e:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
 8008f82:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008f86:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008f8a:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 8008f8e:	ea4f 11b3 	mov.w	r1, r3, ror #6
 8008f92:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008f96:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008f9a:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 8008f9e:	ea4f 23f3 	mov.w	r3, r3, ror #11
 8008fa2:	4059      	eors	r1, r3
 8008fa4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008fa8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008fac:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 8008fb0:	ea4f 6373 	mov.w	r3, r3, ror #25
 8008fb4:	404b      	eors	r3, r1
 8008fb6:	441a      	add	r2, r3
 8008fb8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008fbc:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008fc0:	f8d3 1124 	ldr.w	r1, [r3, #292]	@ 0x124
 8008fc4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008fc8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008fcc:	f8d3 011c 	ldr.w	r0, [r3, #284]	@ 0x11c
 8008fd0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008fd4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008fd8:	f8d3 4120 	ldr.w	r4, [r3, #288]	@ 0x120
 8008fdc:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8008fe0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8008fe4:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 8008fe8:	4063      	eors	r3, r4
 8008fea:	4003      	ands	r3, r0
 8008fec:	404b      	eors	r3, r1
 8008fee:	441a      	add	r2, r3
 8008ff0:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8008ff4:	3307      	adds	r3, #7
 8008ff6:	4967      	ldr	r1, [pc, #412]	@ (8009194 <mbedtls_internal_sha256_process+0x1ee0>)
 8008ff8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8008ffc:	441a      	add	r2, r3
 8008ffe:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8009002:	1d59      	adds	r1, r3, #5
 8009004:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8009008:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800900c:	3102      	adds	r1, #2
 800900e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8009012:	ea4f 4173 	mov.w	r1, r3, ror #17
 8009016:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800901a:	1d58      	adds	r0, r3, #5
 800901c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8009020:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8009024:	3002      	adds	r0, #2
 8009026:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 800902a:	ea4f 43f3 	mov.w	r3, r3, ror #19
 800902e:	4059      	eors	r1, r3
 8009030:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8009034:	1d58      	adds	r0, r3, #5
 8009036:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800903a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800903e:	3002      	adds	r0, #2
 8009040:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8009044:	0a9b      	lsrs	r3, r3, #10
 8009046:	4059      	eors	r1, r3
 8009048:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800904c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8009050:	f8d7 0134 	ldr.w	r0, [r7, #308]	@ 0x134
 8009054:	3002      	adds	r0, #2
 8009056:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 800905a:	4419      	add	r1, r3
 800905c:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8009060:	f1a3 0008 	sub.w	r0, r3, #8
 8009064:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8009068:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800906c:	3002      	adds	r0, #2
 800906e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8009072:	ea4f 10f3 	mov.w	r0, r3, ror #7
 8009076:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800907a:	f1a3 0408 	sub.w	r4, r3, #8
 800907e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8009082:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8009086:	3402      	adds	r4, #2
 8009088:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 800908c:	ea4f 43b3 	mov.w	r3, r3, ror #18
 8009090:	4058      	eors	r0, r3
 8009092:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8009096:	f1a3 0408 	sub.w	r4, r3, #8
 800909a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800909e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80090a2:	3402      	adds	r4, #2
 80090a4:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 80090a8:	08db      	lsrs	r3, r3, #3
 80090aa:	4043      	eors	r3, r0
 80090ac:	18c8      	adds	r0, r1, r3
 80090ae:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80090b2:	f1a3 0109 	sub.w	r1, r3, #9
 80090b6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80090ba:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80090be:	3102      	adds	r1, #2
 80090c0:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 80090c4:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80090c8:	3307      	adds	r3, #7
 80090ca:	1844      	adds	r4, r0, r1
 80090cc:	f507 719c 	add.w	r1, r7, #312	@ 0x138
 80090d0:	f5a1 7196 	sub.w	r1, r1, #300	@ 0x12c
 80090d4:	1c98      	adds	r0, r3, #2
 80090d6:	f841 4020 	str.w	r4, [r1, r0, lsl #2]
 80090da:	f507 719c 	add.w	r1, r7, #312	@ 0x138
 80090de:	f5a1 7196 	sub.w	r1, r1, #300	@ 0x12c
 80090e2:	3302      	adds	r3, #2
 80090e4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80090e8:	441a      	add	r2, r3
 80090ea:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80090ee:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80090f2:	601a      	str	r2, [r3, #0]
 80090f4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80090f8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80090fc:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8009100:	ea4f 02b3 	mov.w	r2, r3, ror #2
 8009104:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8009108:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800910c:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8009110:	ea4f 3373 	mov.w	r3, r3, ror #13
 8009114:	405a      	eors	r2, r3
 8009116:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800911a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800911e:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8009122:	ea4f 53b3 	mov.w	r3, r3, ror #22
 8009126:	405a      	eors	r2, r3
 8009128:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800912c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8009130:	f8d3 110c 	ldr.w	r1, [r3, #268]	@ 0x10c
 8009134:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8009138:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800913c:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 8009140:	4019      	ands	r1, r3
 8009142:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8009146:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800914a:	f8d3 0114 	ldr.w	r0, [r3, #276]	@ 0x114
 800914e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8009152:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8009156:	f8d3 410c 	ldr.w	r4, [r3, #268]	@ 0x10c
 800915a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800915e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8009162:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 8009166:	4323      	orrs	r3, r4
 8009168:	4003      	ands	r3, r0
 800916a:	430b      	orrs	r3, r1
 800916c:	441a      	add	r2, r3
 800916e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8009172:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8009176:	605a      	str	r2, [r3, #4]
 8009178:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800917c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8009180:	f8d3 2118 	ldr.w	r2, [r3, #280]	@ 0x118
 8009184:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 8009188:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800918c:	681b      	ldr	r3, [r3, #0]
 800918e:	441a      	add	r2, r3
 8009190:	e002      	b.n	8009198 <mbedtls_internal_sha256_process+0x1ee4>
 8009192:	bf00      	nop
 8009194:	08016c4c 	.word	0x08016c4c
 8009198:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800919c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80091a0:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
 80091a4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80091a8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80091ac:	681a      	ldr	r2, [r3, #0]
 80091ae:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80091b2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80091b6:	685b      	ldr	r3, [r3, #4]
 80091b8:	441a      	add	r2, r3
 80091ba:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80091be:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80091c2:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
    for( i = 16; i < 64; i += 8 )
 80091c6:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80091ca:	3308      	adds	r3, #8
 80091cc:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
 80091d0:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80091d4:	2b3f      	cmp	r3, #63	@ 0x3f
 80091d6:	f67e aec5 	bls.w	8007f64 <mbedtls_internal_sha256_process+0xcb0>
           local.A[6], local.A[7], local.A[0], R(i+7), K[i+7] );
    }
#endif /* MBEDTLS_SHA256_SMALLER */

    for( i = 0; i < 8; i++ )
 80091da:	2300      	movs	r3, #0
 80091dc:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
 80091e0:	e022      	b.n	8009228 <mbedtls_internal_sha256_process+0x1f74>
        ctx->state[i] += local.A[i];
 80091e2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80091e6:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
 80091ea:	681b      	ldr	r3, [r3, #0]
 80091ec:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 80091f0:	3202      	adds	r2, #2
 80091f2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80091f6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 80091fa:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 80091fe:	f8d7 1134 	ldr.w	r1, [r7, #308]	@ 0x134
 8009202:	3142      	adds	r1, #66	@ 0x42
 8009204:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8009208:	18d1      	adds	r1, r2, r3
 800920a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 800920e:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
 8009212:	681b      	ldr	r3, [r3, #0]
 8009214:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8009218:	3202      	adds	r2, #2
 800921a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for( i = 0; i < 8; i++ )
 800921e:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8009222:	3301      	adds	r3, #1
 8009224:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
 8009228:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800922c:	2b07      	cmp	r3, #7
 800922e:	d9d8      	bls.n	80091e2 <mbedtls_internal_sha256_process+0x1f2e>

    /* Zeroise buffers and variables to clear sensitive data from memory. */
    mbedtls_platform_zeroize( &local, sizeof( local ) );
 8009230:	f107 030c 	add.w	r3, r7, #12
 8009234:	f44f 7194 	mov.w	r1, #296	@ 0x128
 8009238:	4618      	mov	r0, r3
 800923a:	f7fc ffd1 	bl	80061e0 <mbedtls_platform_zeroize>

    return( 0 );
 800923e:	2300      	movs	r3, #0
}
 8009240:	4618      	mov	r0, r3
 8009242:	f507 779e 	add.w	r7, r7, #316	@ 0x13c
 8009246:	46bd      	mov	sp, r7
 8009248:	bd90      	pop	{r4, r7, pc}
 800924a:	bf00      	nop

0800924c <mbedtls_sha256_update>:
 * SHA-256 process buffer
 */
int mbedtls_sha256_update( mbedtls_sha256_context *ctx,
                               const unsigned char *input,
                               size_t ilen )
{
 800924c:	b580      	push	{r7, lr}
 800924e:	b088      	sub	sp, #32
 8009250:	af00      	add	r7, sp, #0
 8009252:	60f8      	str	r0, [r7, #12]
 8009254:	60b9      	str	r1, [r7, #8]
 8009256:	607a      	str	r2, [r7, #4]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 8009258:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 800925c:	61bb      	str	r3, [r7, #24]
    uint32_t left;

    SHA256_VALIDATE_RET( ctx != NULL );
    SHA256_VALIDATE_RET( ilen == 0 || input != NULL );

    if( ilen == 0 )
 800925e:	687b      	ldr	r3, [r7, #4]
 8009260:	2b00      	cmp	r3, #0
 8009262:	d101      	bne.n	8009268 <mbedtls_sha256_update+0x1c>
        return( 0 );
 8009264:	2300      	movs	r3, #0
 8009266:	e065      	b.n	8009334 <mbedtls_sha256_update+0xe8>

    left = ctx->total[0] & 0x3F;
 8009268:	68fb      	ldr	r3, [r7, #12]
 800926a:	681b      	ldr	r3, [r3, #0]
 800926c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8009270:	61fb      	str	r3, [r7, #28]
    fill = 64 - left;
 8009272:	69fb      	ldr	r3, [r7, #28]
 8009274:	f1c3 0340 	rsb	r3, r3, #64	@ 0x40
 8009278:	617b      	str	r3, [r7, #20]

    ctx->total[0] += (uint32_t) ilen;
 800927a:	68fb      	ldr	r3, [r7, #12]
 800927c:	681a      	ldr	r2, [r3, #0]
 800927e:	687b      	ldr	r3, [r7, #4]
 8009280:	441a      	add	r2, r3
 8009282:	68fb      	ldr	r3, [r7, #12]
 8009284:	601a      	str	r2, [r3, #0]
    ctx->total[0] &= 0xFFFFFFFF;
 8009286:	68fb      	ldr	r3, [r7, #12]
 8009288:	681a      	ldr	r2, [r3, #0]
 800928a:	68fb      	ldr	r3, [r7, #12]
 800928c:	601a      	str	r2, [r3, #0]

    if( ctx->total[0] < (uint32_t) ilen )
 800928e:	68fb      	ldr	r3, [r7, #12]
 8009290:	681b      	ldr	r3, [r3, #0]
 8009292:	687a      	ldr	r2, [r7, #4]
 8009294:	429a      	cmp	r2, r3
 8009296:	d904      	bls.n	80092a2 <mbedtls_sha256_update+0x56>
        ctx->total[1]++;
 8009298:	68fb      	ldr	r3, [r7, #12]
 800929a:	685b      	ldr	r3, [r3, #4]
 800929c:	1c5a      	adds	r2, r3, #1
 800929e:	68fb      	ldr	r3, [r7, #12]
 80092a0:	605a      	str	r2, [r3, #4]

    if( left && ilen >= fill )
 80092a2:	69fb      	ldr	r3, [r7, #28]
 80092a4:	2b00      	cmp	r3, #0
 80092a6:	d034      	beq.n	8009312 <mbedtls_sha256_update+0xc6>
 80092a8:	687a      	ldr	r2, [r7, #4]
 80092aa:	697b      	ldr	r3, [r7, #20]
 80092ac:	429a      	cmp	r2, r3
 80092ae:	d330      	bcc.n	8009312 <mbedtls_sha256_update+0xc6>
    {
        memcpy( (void *) (ctx->buffer + left), input, fill );
 80092b0:	68fb      	ldr	r3, [r7, #12]
 80092b2:	f103 0228 	add.w	r2, r3, #40	@ 0x28
 80092b6:	69fb      	ldr	r3, [r7, #28]
 80092b8:	4413      	add	r3, r2
 80092ba:	697a      	ldr	r2, [r7, #20]
 80092bc:	68b9      	ldr	r1, [r7, #8]
 80092be:	4618      	mov	r0, r3
 80092c0:	f00c f94d 	bl	801555e <memcpy>

        if( ( ret = mbedtls_internal_sha256_process( ctx, ctx->buffer ) ) != 0 )
 80092c4:	68fb      	ldr	r3, [r7, #12]
 80092c6:	3328      	adds	r3, #40	@ 0x28
 80092c8:	4619      	mov	r1, r3
 80092ca:	68f8      	ldr	r0, [r7, #12]
 80092cc:	f7fd fff2 	bl	80072b4 <mbedtls_internal_sha256_process>
 80092d0:	61b8      	str	r0, [r7, #24]
 80092d2:	69bb      	ldr	r3, [r7, #24]
 80092d4:	2b00      	cmp	r3, #0
 80092d6:	d001      	beq.n	80092dc <mbedtls_sha256_update+0x90>
            return( ret );
 80092d8:	69bb      	ldr	r3, [r7, #24]
 80092da:	e02b      	b.n	8009334 <mbedtls_sha256_update+0xe8>

        input += fill;
 80092dc:	68ba      	ldr	r2, [r7, #8]
 80092de:	697b      	ldr	r3, [r7, #20]
 80092e0:	4413      	add	r3, r2
 80092e2:	60bb      	str	r3, [r7, #8]
        ilen  -= fill;
 80092e4:	687a      	ldr	r2, [r7, #4]
 80092e6:	697b      	ldr	r3, [r7, #20]
 80092e8:	1ad3      	subs	r3, r2, r3
 80092ea:	607b      	str	r3, [r7, #4]
        left = 0;
 80092ec:	2300      	movs	r3, #0
 80092ee:	61fb      	str	r3, [r7, #28]
    }

    while( ilen >= 64 )
 80092f0:	e00f      	b.n	8009312 <mbedtls_sha256_update+0xc6>
    {
        if( ( ret = mbedtls_internal_sha256_process( ctx, input ) ) != 0 )
 80092f2:	68b9      	ldr	r1, [r7, #8]
 80092f4:	68f8      	ldr	r0, [r7, #12]
 80092f6:	f7fd ffdd 	bl	80072b4 <mbedtls_internal_sha256_process>
 80092fa:	61b8      	str	r0, [r7, #24]
 80092fc:	69bb      	ldr	r3, [r7, #24]
 80092fe:	2b00      	cmp	r3, #0
 8009300:	d001      	beq.n	8009306 <mbedtls_sha256_update+0xba>
            return( ret );
 8009302:	69bb      	ldr	r3, [r7, #24]
 8009304:	e016      	b.n	8009334 <mbedtls_sha256_update+0xe8>

        input += 64;
 8009306:	68bb      	ldr	r3, [r7, #8]
 8009308:	3340      	adds	r3, #64	@ 0x40
 800930a:	60bb      	str	r3, [r7, #8]
        ilen  -= 64;
 800930c:	687b      	ldr	r3, [r7, #4]
 800930e:	3b40      	subs	r3, #64	@ 0x40
 8009310:	607b      	str	r3, [r7, #4]
    while( ilen >= 64 )
 8009312:	687b      	ldr	r3, [r7, #4]
 8009314:	2b3f      	cmp	r3, #63	@ 0x3f
 8009316:	d8ec      	bhi.n	80092f2 <mbedtls_sha256_update+0xa6>
    }

    if( ilen > 0 )
 8009318:	687b      	ldr	r3, [r7, #4]
 800931a:	2b00      	cmp	r3, #0
 800931c:	d009      	beq.n	8009332 <mbedtls_sha256_update+0xe6>
        memcpy( (void *) (ctx->buffer + left), input, ilen );
 800931e:	68fb      	ldr	r3, [r7, #12]
 8009320:	f103 0228 	add.w	r2, r3, #40	@ 0x28
 8009324:	69fb      	ldr	r3, [r7, #28]
 8009326:	4413      	add	r3, r2
 8009328:	687a      	ldr	r2, [r7, #4]
 800932a:	68b9      	ldr	r1, [r7, #8]
 800932c:	4618      	mov	r0, r3
 800932e:	f00c f916 	bl	801555e <memcpy>

    return( 0 );
 8009332:	2300      	movs	r3, #0
}
 8009334:	4618      	mov	r0, r3
 8009336:	3720      	adds	r7, #32
 8009338:	46bd      	mov	sp, r7
 800933a:	bd80      	pop	{r7, pc}

0800933c <mbedtls_sha256_finish>:
/*
 * SHA-256 final digest
 */
int mbedtls_sha256_finish( mbedtls_sha256_context *ctx,
                               unsigned char *output )
{
 800933c:	b580      	push	{r7, lr}
 800933e:	b086      	sub	sp, #24
 8009340:	af00      	add	r7, sp, #0
 8009342:	6078      	str	r0, [r7, #4]
 8009344:	6039      	str	r1, [r7, #0]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 8009346:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 800934a:	617b      	str	r3, [r7, #20]
    SHA256_VALIDATE_RET( (unsigned char *)output != NULL );

    /*
     * Add padding: 0x80 then 0x00 until 8 bytes remain for the length
     */
    used = ctx->total[0] & 0x3F;
 800934c:	687b      	ldr	r3, [r7, #4]
 800934e:	681b      	ldr	r3, [r3, #0]
 8009350:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8009354:	613b      	str	r3, [r7, #16]

    ctx->buffer[used++] = 0x80;
 8009356:	693b      	ldr	r3, [r7, #16]
 8009358:	1c5a      	adds	r2, r3, #1
 800935a:	613a      	str	r2, [r7, #16]
 800935c:	687a      	ldr	r2, [r7, #4]
 800935e:	4413      	add	r3, r2
 8009360:	2280      	movs	r2, #128	@ 0x80
 8009362:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28

    if( used <= 56 )
 8009366:	693b      	ldr	r3, [r7, #16]
 8009368:	2b38      	cmp	r3, #56	@ 0x38
 800936a:	d80c      	bhi.n	8009386 <mbedtls_sha256_finish+0x4a>
    {
        /* Enough room for padding + length in current block */
        memset( ctx->buffer + used, 0, 56 - used );
 800936c:	687b      	ldr	r3, [r7, #4]
 800936e:	f103 0228 	add.w	r2, r3, #40	@ 0x28
 8009372:	693b      	ldr	r3, [r7, #16]
 8009374:	18d0      	adds	r0, r2, r3
 8009376:	693b      	ldr	r3, [r7, #16]
 8009378:	f1c3 0338 	rsb	r3, r3, #56	@ 0x38
 800937c:	461a      	mov	r2, r3
 800937e:	2100      	movs	r1, #0
 8009380:	f00c f862 	bl	8015448 <memset>
 8009384:	e01e      	b.n	80093c4 <mbedtls_sha256_finish+0x88>
    }
    else
    {
        /* We'll need an extra block */
        memset( ctx->buffer + used, 0, 64 - used );
 8009386:	687b      	ldr	r3, [r7, #4]
 8009388:	f103 0228 	add.w	r2, r3, #40	@ 0x28
 800938c:	693b      	ldr	r3, [r7, #16]
 800938e:	18d0      	adds	r0, r2, r3
 8009390:	693b      	ldr	r3, [r7, #16]
 8009392:	f1c3 0340 	rsb	r3, r3, #64	@ 0x40
 8009396:	461a      	mov	r2, r3
 8009398:	2100      	movs	r1, #0
 800939a:	f00c f855 	bl	8015448 <memset>

        if( ( ret = mbedtls_internal_sha256_process( ctx, ctx->buffer ) ) != 0 )
 800939e:	687b      	ldr	r3, [r7, #4]
 80093a0:	3328      	adds	r3, #40	@ 0x28
 80093a2:	4619      	mov	r1, r3
 80093a4:	6878      	ldr	r0, [r7, #4]
 80093a6:	f7fd ff85 	bl	80072b4 <mbedtls_internal_sha256_process>
 80093aa:	6178      	str	r0, [r7, #20]
 80093ac:	697b      	ldr	r3, [r7, #20]
 80093ae:	2b00      	cmp	r3, #0
 80093b0:	d001      	beq.n	80093b6 <mbedtls_sha256_finish+0x7a>
            return( ret );
 80093b2:	697b      	ldr	r3, [r7, #20]
 80093b4:	e128      	b.n	8009608 <mbedtls_sha256_finish+0x2cc>

        memset( ctx->buffer, 0, 56 );
 80093b6:	687b      	ldr	r3, [r7, #4]
 80093b8:	3328      	adds	r3, #40	@ 0x28
 80093ba:	2238      	movs	r2, #56	@ 0x38
 80093bc:	2100      	movs	r1, #0
 80093be:	4618      	mov	r0, r3
 80093c0:	f00c f842 	bl	8015448 <memset>
    }

    /*
     * Add message length
     */
    high = ( ctx->total[0] >> 29 )
 80093c4:	687b      	ldr	r3, [r7, #4]
 80093c6:	681b      	ldr	r3, [r3, #0]
 80093c8:	0f5a      	lsrs	r2, r3, #29
         | ( ctx->total[1] <<  3 );
 80093ca:	687b      	ldr	r3, [r7, #4]
 80093cc:	685b      	ldr	r3, [r3, #4]
 80093ce:	00db      	lsls	r3, r3, #3
    high = ( ctx->total[0] >> 29 )
 80093d0:	4313      	orrs	r3, r2
 80093d2:	60fb      	str	r3, [r7, #12]
    low  = ( ctx->total[0] <<  3 );
 80093d4:	687b      	ldr	r3, [r7, #4]
 80093d6:	681b      	ldr	r3, [r3, #0]
 80093d8:	00db      	lsls	r3, r3, #3
 80093da:	60bb      	str	r3, [r7, #8]

    PUT_UINT32_BE( high, ctx->buffer, 56 );
 80093dc:	68fb      	ldr	r3, [r7, #12]
 80093de:	0e1b      	lsrs	r3, r3, #24
 80093e0:	b2da      	uxtb	r2, r3
 80093e2:	687b      	ldr	r3, [r7, #4]
 80093e4:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
 80093e8:	68fb      	ldr	r3, [r7, #12]
 80093ea:	0c1b      	lsrs	r3, r3, #16
 80093ec:	b2da      	uxtb	r2, r3
 80093ee:	687b      	ldr	r3, [r7, #4]
 80093f0:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61
 80093f4:	68fb      	ldr	r3, [r7, #12]
 80093f6:	0a1b      	lsrs	r3, r3, #8
 80093f8:	b2da      	uxtb	r2, r3
 80093fa:	687b      	ldr	r3, [r7, #4]
 80093fc:	f883 2062 	strb.w	r2, [r3, #98]	@ 0x62
 8009400:	68fb      	ldr	r3, [r7, #12]
 8009402:	b2da      	uxtb	r2, r3
 8009404:	687b      	ldr	r3, [r7, #4]
 8009406:	f883 2063 	strb.w	r2, [r3, #99]	@ 0x63
    PUT_UINT32_BE( low,  ctx->buffer, 60 );
 800940a:	68bb      	ldr	r3, [r7, #8]
 800940c:	0e1b      	lsrs	r3, r3, #24
 800940e:	b2da      	uxtb	r2, r3
 8009410:	687b      	ldr	r3, [r7, #4]
 8009412:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
 8009416:	68bb      	ldr	r3, [r7, #8]
 8009418:	0c1b      	lsrs	r3, r3, #16
 800941a:	b2da      	uxtb	r2, r3
 800941c:	687b      	ldr	r3, [r7, #4]
 800941e:	f883 2065 	strb.w	r2, [r3, #101]	@ 0x65
 8009422:	68bb      	ldr	r3, [r7, #8]
 8009424:	0a1b      	lsrs	r3, r3, #8
 8009426:	b2da      	uxtb	r2, r3
 8009428:	687b      	ldr	r3, [r7, #4]
 800942a:	f883 2066 	strb.w	r2, [r3, #102]	@ 0x66
 800942e:	68bb      	ldr	r3, [r7, #8]
 8009430:	b2da      	uxtb	r2, r3
 8009432:	687b      	ldr	r3, [r7, #4]
 8009434:	f883 2067 	strb.w	r2, [r3, #103]	@ 0x67

    if( ( ret = mbedtls_internal_sha256_process( ctx, ctx->buffer ) ) != 0 )
 8009438:	687b      	ldr	r3, [r7, #4]
 800943a:	3328      	adds	r3, #40	@ 0x28
 800943c:	4619      	mov	r1, r3
 800943e:	6878      	ldr	r0, [r7, #4]
 8009440:	f7fd ff38 	bl	80072b4 <mbedtls_internal_sha256_process>
 8009444:	6178      	str	r0, [r7, #20]
 8009446:	697b      	ldr	r3, [r7, #20]
 8009448:	2b00      	cmp	r3, #0
 800944a:	d001      	beq.n	8009450 <mbedtls_sha256_finish+0x114>
        return( ret );
 800944c:	697b      	ldr	r3, [r7, #20]
 800944e:	e0db      	b.n	8009608 <mbedtls_sha256_finish+0x2cc>

    /*
     * Output final state
     */
    PUT_UINT32_BE( ctx->state[0], output,  0 );
 8009450:	687b      	ldr	r3, [r7, #4]
 8009452:	689b      	ldr	r3, [r3, #8]
 8009454:	0e1b      	lsrs	r3, r3, #24
 8009456:	b2da      	uxtb	r2, r3
 8009458:	683b      	ldr	r3, [r7, #0]
 800945a:	701a      	strb	r2, [r3, #0]
 800945c:	687b      	ldr	r3, [r7, #4]
 800945e:	689b      	ldr	r3, [r3, #8]
 8009460:	0c1a      	lsrs	r2, r3, #16
 8009462:	683b      	ldr	r3, [r7, #0]
 8009464:	3301      	adds	r3, #1
 8009466:	b2d2      	uxtb	r2, r2
 8009468:	701a      	strb	r2, [r3, #0]
 800946a:	687b      	ldr	r3, [r7, #4]
 800946c:	689b      	ldr	r3, [r3, #8]
 800946e:	0a1a      	lsrs	r2, r3, #8
 8009470:	683b      	ldr	r3, [r7, #0]
 8009472:	3302      	adds	r3, #2
 8009474:	b2d2      	uxtb	r2, r2
 8009476:	701a      	strb	r2, [r3, #0]
 8009478:	687b      	ldr	r3, [r7, #4]
 800947a:	689a      	ldr	r2, [r3, #8]
 800947c:	683b      	ldr	r3, [r7, #0]
 800947e:	3303      	adds	r3, #3
 8009480:	b2d2      	uxtb	r2, r2
 8009482:	701a      	strb	r2, [r3, #0]
    PUT_UINT32_BE( ctx->state[1], output,  4 );
 8009484:	687b      	ldr	r3, [r7, #4]
 8009486:	68db      	ldr	r3, [r3, #12]
 8009488:	0e1a      	lsrs	r2, r3, #24
 800948a:	683b      	ldr	r3, [r7, #0]
 800948c:	3304      	adds	r3, #4
 800948e:	b2d2      	uxtb	r2, r2
 8009490:	701a      	strb	r2, [r3, #0]
 8009492:	687b      	ldr	r3, [r7, #4]
 8009494:	68db      	ldr	r3, [r3, #12]
 8009496:	0c1a      	lsrs	r2, r3, #16
 8009498:	683b      	ldr	r3, [r7, #0]
 800949a:	3305      	adds	r3, #5
 800949c:	b2d2      	uxtb	r2, r2
 800949e:	701a      	strb	r2, [r3, #0]
 80094a0:	687b      	ldr	r3, [r7, #4]
 80094a2:	68db      	ldr	r3, [r3, #12]
 80094a4:	0a1a      	lsrs	r2, r3, #8
 80094a6:	683b      	ldr	r3, [r7, #0]
 80094a8:	3306      	adds	r3, #6
 80094aa:	b2d2      	uxtb	r2, r2
 80094ac:	701a      	strb	r2, [r3, #0]
 80094ae:	687b      	ldr	r3, [r7, #4]
 80094b0:	68da      	ldr	r2, [r3, #12]
 80094b2:	683b      	ldr	r3, [r7, #0]
 80094b4:	3307      	adds	r3, #7
 80094b6:	b2d2      	uxtb	r2, r2
 80094b8:	701a      	strb	r2, [r3, #0]
    PUT_UINT32_BE( ctx->state[2], output,  8 );
 80094ba:	687b      	ldr	r3, [r7, #4]
 80094bc:	691b      	ldr	r3, [r3, #16]
 80094be:	0e1a      	lsrs	r2, r3, #24
 80094c0:	683b      	ldr	r3, [r7, #0]
 80094c2:	3308      	adds	r3, #8
 80094c4:	b2d2      	uxtb	r2, r2
 80094c6:	701a      	strb	r2, [r3, #0]
 80094c8:	687b      	ldr	r3, [r7, #4]
 80094ca:	691b      	ldr	r3, [r3, #16]
 80094cc:	0c1a      	lsrs	r2, r3, #16
 80094ce:	683b      	ldr	r3, [r7, #0]
 80094d0:	3309      	adds	r3, #9
 80094d2:	b2d2      	uxtb	r2, r2
 80094d4:	701a      	strb	r2, [r3, #0]
 80094d6:	687b      	ldr	r3, [r7, #4]
 80094d8:	691b      	ldr	r3, [r3, #16]
 80094da:	0a1a      	lsrs	r2, r3, #8
 80094dc:	683b      	ldr	r3, [r7, #0]
 80094de:	330a      	adds	r3, #10
 80094e0:	b2d2      	uxtb	r2, r2
 80094e2:	701a      	strb	r2, [r3, #0]
 80094e4:	687b      	ldr	r3, [r7, #4]
 80094e6:	691a      	ldr	r2, [r3, #16]
 80094e8:	683b      	ldr	r3, [r7, #0]
 80094ea:	330b      	adds	r3, #11
 80094ec:	b2d2      	uxtb	r2, r2
 80094ee:	701a      	strb	r2, [r3, #0]
    PUT_UINT32_BE( ctx->state[3], output, 12 );
 80094f0:	687b      	ldr	r3, [r7, #4]
 80094f2:	695b      	ldr	r3, [r3, #20]
 80094f4:	0e1a      	lsrs	r2, r3, #24
 80094f6:	683b      	ldr	r3, [r7, #0]
 80094f8:	330c      	adds	r3, #12
 80094fa:	b2d2      	uxtb	r2, r2
 80094fc:	701a      	strb	r2, [r3, #0]
 80094fe:	687b      	ldr	r3, [r7, #4]
 8009500:	695b      	ldr	r3, [r3, #20]
 8009502:	0c1a      	lsrs	r2, r3, #16
 8009504:	683b      	ldr	r3, [r7, #0]
 8009506:	330d      	adds	r3, #13
 8009508:	b2d2      	uxtb	r2, r2
 800950a:	701a      	strb	r2, [r3, #0]
 800950c:	687b      	ldr	r3, [r7, #4]
 800950e:	695b      	ldr	r3, [r3, #20]
 8009510:	0a1a      	lsrs	r2, r3, #8
 8009512:	683b      	ldr	r3, [r7, #0]
 8009514:	330e      	adds	r3, #14
 8009516:	b2d2      	uxtb	r2, r2
 8009518:	701a      	strb	r2, [r3, #0]
 800951a:	687b      	ldr	r3, [r7, #4]
 800951c:	695a      	ldr	r2, [r3, #20]
 800951e:	683b      	ldr	r3, [r7, #0]
 8009520:	330f      	adds	r3, #15
 8009522:	b2d2      	uxtb	r2, r2
 8009524:	701a      	strb	r2, [r3, #0]
    PUT_UINT32_BE( ctx->state[4], output, 16 );
 8009526:	687b      	ldr	r3, [r7, #4]
 8009528:	699b      	ldr	r3, [r3, #24]
 800952a:	0e1a      	lsrs	r2, r3, #24
 800952c:	683b      	ldr	r3, [r7, #0]
 800952e:	3310      	adds	r3, #16
 8009530:	b2d2      	uxtb	r2, r2
 8009532:	701a      	strb	r2, [r3, #0]
 8009534:	687b      	ldr	r3, [r7, #4]
 8009536:	699b      	ldr	r3, [r3, #24]
 8009538:	0c1a      	lsrs	r2, r3, #16
 800953a:	683b      	ldr	r3, [r7, #0]
 800953c:	3311      	adds	r3, #17
 800953e:	b2d2      	uxtb	r2, r2
 8009540:	701a      	strb	r2, [r3, #0]
 8009542:	687b      	ldr	r3, [r7, #4]
 8009544:	699b      	ldr	r3, [r3, #24]
 8009546:	0a1a      	lsrs	r2, r3, #8
 8009548:	683b      	ldr	r3, [r7, #0]
 800954a:	3312      	adds	r3, #18
 800954c:	b2d2      	uxtb	r2, r2
 800954e:	701a      	strb	r2, [r3, #0]
 8009550:	687b      	ldr	r3, [r7, #4]
 8009552:	699a      	ldr	r2, [r3, #24]
 8009554:	683b      	ldr	r3, [r7, #0]
 8009556:	3313      	adds	r3, #19
 8009558:	b2d2      	uxtb	r2, r2
 800955a:	701a      	strb	r2, [r3, #0]
    PUT_UINT32_BE( ctx->state[5], output, 20 );
 800955c:	687b      	ldr	r3, [r7, #4]
 800955e:	69db      	ldr	r3, [r3, #28]
 8009560:	0e1a      	lsrs	r2, r3, #24
 8009562:	683b      	ldr	r3, [r7, #0]
 8009564:	3314      	adds	r3, #20
 8009566:	b2d2      	uxtb	r2, r2
 8009568:	701a      	strb	r2, [r3, #0]
 800956a:	687b      	ldr	r3, [r7, #4]
 800956c:	69db      	ldr	r3, [r3, #28]
 800956e:	0c1a      	lsrs	r2, r3, #16
 8009570:	683b      	ldr	r3, [r7, #0]
 8009572:	3315      	adds	r3, #21
 8009574:	b2d2      	uxtb	r2, r2
 8009576:	701a      	strb	r2, [r3, #0]
 8009578:	687b      	ldr	r3, [r7, #4]
 800957a:	69db      	ldr	r3, [r3, #28]
 800957c:	0a1a      	lsrs	r2, r3, #8
 800957e:	683b      	ldr	r3, [r7, #0]
 8009580:	3316      	adds	r3, #22
 8009582:	b2d2      	uxtb	r2, r2
 8009584:	701a      	strb	r2, [r3, #0]
 8009586:	687b      	ldr	r3, [r7, #4]
 8009588:	69da      	ldr	r2, [r3, #28]
 800958a:	683b      	ldr	r3, [r7, #0]
 800958c:	3317      	adds	r3, #23
 800958e:	b2d2      	uxtb	r2, r2
 8009590:	701a      	strb	r2, [r3, #0]
    PUT_UINT32_BE( ctx->state[6], output, 24 );
 8009592:	687b      	ldr	r3, [r7, #4]
 8009594:	6a1b      	ldr	r3, [r3, #32]
 8009596:	0e1a      	lsrs	r2, r3, #24
 8009598:	683b      	ldr	r3, [r7, #0]
 800959a:	3318      	adds	r3, #24
 800959c:	b2d2      	uxtb	r2, r2
 800959e:	701a      	strb	r2, [r3, #0]
 80095a0:	687b      	ldr	r3, [r7, #4]
 80095a2:	6a1b      	ldr	r3, [r3, #32]
 80095a4:	0c1a      	lsrs	r2, r3, #16
 80095a6:	683b      	ldr	r3, [r7, #0]
 80095a8:	3319      	adds	r3, #25
 80095aa:	b2d2      	uxtb	r2, r2
 80095ac:	701a      	strb	r2, [r3, #0]
 80095ae:	687b      	ldr	r3, [r7, #4]
 80095b0:	6a1b      	ldr	r3, [r3, #32]
 80095b2:	0a1a      	lsrs	r2, r3, #8
 80095b4:	683b      	ldr	r3, [r7, #0]
 80095b6:	331a      	adds	r3, #26
 80095b8:	b2d2      	uxtb	r2, r2
 80095ba:	701a      	strb	r2, [r3, #0]
 80095bc:	687b      	ldr	r3, [r7, #4]
 80095be:	6a1a      	ldr	r2, [r3, #32]
 80095c0:	683b      	ldr	r3, [r7, #0]
 80095c2:	331b      	adds	r3, #27
 80095c4:	b2d2      	uxtb	r2, r2
 80095c6:	701a      	strb	r2, [r3, #0]

#if defined(MBEDTLS_SHA224_C)
    if( ctx->is224 == 0 )
 80095c8:	687b      	ldr	r3, [r7, #4]
 80095ca:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 80095cc:	2b00      	cmp	r3, #0
 80095ce:	d11a      	bne.n	8009606 <mbedtls_sha256_finish+0x2ca>
#endif
        PUT_UINT32_BE( ctx->state[7], output, 28 );
 80095d0:	687b      	ldr	r3, [r7, #4]
 80095d2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80095d4:	0e1a      	lsrs	r2, r3, #24
 80095d6:	683b      	ldr	r3, [r7, #0]
 80095d8:	331c      	adds	r3, #28
 80095da:	b2d2      	uxtb	r2, r2
 80095dc:	701a      	strb	r2, [r3, #0]
 80095de:	687b      	ldr	r3, [r7, #4]
 80095e0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80095e2:	0c1a      	lsrs	r2, r3, #16
 80095e4:	683b      	ldr	r3, [r7, #0]
 80095e6:	331d      	adds	r3, #29
 80095e8:	b2d2      	uxtb	r2, r2
 80095ea:	701a      	strb	r2, [r3, #0]
 80095ec:	687b      	ldr	r3, [r7, #4]
 80095ee:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80095f0:	0a1a      	lsrs	r2, r3, #8
 80095f2:	683b      	ldr	r3, [r7, #0]
 80095f4:	331e      	adds	r3, #30
 80095f6:	b2d2      	uxtb	r2, r2
 80095f8:	701a      	strb	r2, [r3, #0]
 80095fa:	687b      	ldr	r3, [r7, #4]
 80095fc:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 80095fe:	683b      	ldr	r3, [r7, #0]
 8009600:	331f      	adds	r3, #31
 8009602:	b2d2      	uxtb	r2, r2
 8009604:	701a      	strb	r2, [r3, #0]

    return( 0 );
 8009606:	2300      	movs	r3, #0
}
 8009608:	4618      	mov	r0, r3
 800960a:	3718      	adds	r7, #24
 800960c:	46bd      	mov	sp, r7
 800960e:	bd80      	pop	{r7, pc}

08009610 <mbedtls_sha512_init>:
#else
#define sha512_put_uint64_be    PUT_UINT64_BE
#endif /* MBEDTLS_SHA512_SMALLER */

void mbedtls_sha512_init( mbedtls_sha512_context *ctx )
{
 8009610:	b580      	push	{r7, lr}
 8009612:	b082      	sub	sp, #8
 8009614:	af00      	add	r7, sp, #0
 8009616:	6078      	str	r0, [r7, #4]
    SHA512_VALIDATE( ctx != NULL );

    memset( ctx, 0, sizeof( mbedtls_sha512_context ) );
 8009618:	22d8      	movs	r2, #216	@ 0xd8
 800961a:	2100      	movs	r1, #0
 800961c:	6878      	ldr	r0, [r7, #4]
 800961e:	f00b ff13 	bl	8015448 <memset>
}
 8009622:	bf00      	nop
 8009624:	3708      	adds	r7, #8
 8009626:	46bd      	mov	sp, r7
 8009628:	bd80      	pop	{r7, pc}
 800962a:	0000      	movs	r0, r0
 800962c:	0000      	movs	r0, r0
	...

08009630 <mbedtls_sha512_starts>:

/*
 * SHA-512 context setup
 */
int mbedtls_sha512_starts( mbedtls_sha512_context *ctx, int is384 )
{
 8009630:	b480      	push	{r7}
 8009632:	b083      	sub	sp, #12
 8009634:	af00      	add	r7, sp, #0
 8009636:	6078      	str	r0, [r7, #4]
 8009638:	6039      	str	r1, [r7, #0]
    SHA512_VALIDATE_RET( is384 == 0 || is384 == 1 );
#else
    SHA512_VALIDATE_RET( is384 == 0 );
#endif

    ctx->total[0] = 0;
 800963a:	6879      	ldr	r1, [r7, #4]
 800963c:	f04f 0200 	mov.w	r2, #0
 8009640:	f04f 0300 	mov.w	r3, #0
 8009644:	e9c1 2300 	strd	r2, r3, [r1]
    ctx->total[1] = 0;
 8009648:	6879      	ldr	r1, [r7, #4]
 800964a:	f04f 0200 	mov.w	r2, #0
 800964e:	f04f 0300 	mov.w	r3, #0
 8009652:	e9c1 2302 	strd	r2, r3, [r1, #8]

    if( is384 == 0 )
 8009656:	683b      	ldr	r3, [r7, #0]
 8009658:	2b00      	cmp	r3, #0
 800965a:	d130      	bne.n	80096be <mbedtls_sha512_starts+0x8e>
    {
        /* SHA-512 */
        ctx->state[0] = UL64(0x6A09E667F3BCC908);
 800965c:	6879      	ldr	r1, [r7, #4]
 800965e:	a336      	add	r3, pc, #216	@ (adr r3, 8009738 <mbedtls_sha512_starts+0x108>)
 8009660:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009664:	e9c1 2304 	strd	r2, r3, [r1, #16]
        ctx->state[1] = UL64(0xBB67AE8584CAA73B);
 8009668:	6879      	ldr	r1, [r7, #4]
 800966a:	a335      	add	r3, pc, #212	@ (adr r3, 8009740 <mbedtls_sha512_starts+0x110>)
 800966c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009670:	e9c1 2306 	strd	r2, r3, [r1, #24]
        ctx->state[2] = UL64(0x3C6EF372FE94F82B);
 8009674:	6879      	ldr	r1, [r7, #4]
 8009676:	a334      	add	r3, pc, #208	@ (adr r3, 8009748 <mbedtls_sha512_starts+0x118>)
 8009678:	e9d3 2300 	ldrd	r2, r3, [r3]
 800967c:	e9c1 2308 	strd	r2, r3, [r1, #32]
        ctx->state[3] = UL64(0xA54FF53A5F1D36F1);
 8009680:	6879      	ldr	r1, [r7, #4]
 8009682:	a333      	add	r3, pc, #204	@ (adr r3, 8009750 <mbedtls_sha512_starts+0x120>)
 8009684:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009688:	e9c1 230a 	strd	r2, r3, [r1, #40]	@ 0x28
        ctx->state[4] = UL64(0x510E527FADE682D1);
 800968c:	6879      	ldr	r1, [r7, #4]
 800968e:	a332      	add	r3, pc, #200	@ (adr r3, 8009758 <mbedtls_sha512_starts+0x128>)
 8009690:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009694:	e9c1 230c 	strd	r2, r3, [r1, #48]	@ 0x30
        ctx->state[5] = UL64(0x9B05688C2B3E6C1F);
 8009698:	6879      	ldr	r1, [r7, #4]
 800969a:	a331      	add	r3, pc, #196	@ (adr r3, 8009760 <mbedtls_sha512_starts+0x130>)
 800969c:	e9d3 2300 	ldrd	r2, r3, [r3]
 80096a0:	e9c1 230e 	strd	r2, r3, [r1, #56]	@ 0x38
        ctx->state[6] = UL64(0x1F83D9ABFB41BD6B);
 80096a4:	6879      	ldr	r1, [r7, #4]
 80096a6:	a330      	add	r3, pc, #192	@ (adr r3, 8009768 <mbedtls_sha512_starts+0x138>)
 80096a8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80096ac:	e9c1 2310 	strd	r2, r3, [r1, #64]	@ 0x40
        ctx->state[7] = UL64(0x5BE0CD19137E2179);
 80096b0:	6879      	ldr	r1, [r7, #4]
 80096b2:	a32f      	add	r3, pc, #188	@ (adr r3, 8009770 <mbedtls_sha512_starts+0x140>)
 80096b4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80096b8:	e9c1 2312 	strd	r2, r3, [r1, #72]	@ 0x48
 80096bc:	e02f      	b.n	800971e <mbedtls_sha512_starts+0xee>
    {
#if !defined(MBEDTLS_SHA384_C)
        return( MBEDTLS_ERR_SHA512_BAD_INPUT_DATA );
#else
        /* SHA-384 */
        ctx->state[0] = UL64(0xCBBB9D5DC1059ED8);
 80096be:	6879      	ldr	r1, [r7, #4]
 80096c0:	a32d      	add	r3, pc, #180	@ (adr r3, 8009778 <mbedtls_sha512_starts+0x148>)
 80096c2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80096c6:	e9c1 2304 	strd	r2, r3, [r1, #16]
        ctx->state[1] = UL64(0x629A292A367CD507);
 80096ca:	6879      	ldr	r1, [r7, #4]
 80096cc:	a32c      	add	r3, pc, #176	@ (adr r3, 8009780 <mbedtls_sha512_starts+0x150>)
 80096ce:	e9d3 2300 	ldrd	r2, r3, [r3]
 80096d2:	e9c1 2306 	strd	r2, r3, [r1, #24]
        ctx->state[2] = UL64(0x9159015A3070DD17);
 80096d6:	6879      	ldr	r1, [r7, #4]
 80096d8:	a32b      	add	r3, pc, #172	@ (adr r3, 8009788 <mbedtls_sha512_starts+0x158>)
 80096da:	e9d3 2300 	ldrd	r2, r3, [r3]
 80096de:	e9c1 2308 	strd	r2, r3, [r1, #32]
        ctx->state[3] = UL64(0x152FECD8F70E5939);
 80096e2:	6879      	ldr	r1, [r7, #4]
 80096e4:	a32a      	add	r3, pc, #168	@ (adr r3, 8009790 <mbedtls_sha512_starts+0x160>)
 80096e6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80096ea:	e9c1 230a 	strd	r2, r3, [r1, #40]	@ 0x28
        ctx->state[4] = UL64(0x67332667FFC00B31);
 80096ee:	6879      	ldr	r1, [r7, #4]
 80096f0:	a329      	add	r3, pc, #164	@ (adr r3, 8009798 <mbedtls_sha512_starts+0x168>)
 80096f2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80096f6:	e9c1 230c 	strd	r2, r3, [r1, #48]	@ 0x30
        ctx->state[5] = UL64(0x8EB44A8768581511);
 80096fa:	6879      	ldr	r1, [r7, #4]
 80096fc:	a328      	add	r3, pc, #160	@ (adr r3, 80097a0 <mbedtls_sha512_starts+0x170>)
 80096fe:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009702:	e9c1 230e 	strd	r2, r3, [r1, #56]	@ 0x38
        ctx->state[6] = UL64(0xDB0C2E0D64F98FA7);
 8009706:	6879      	ldr	r1, [r7, #4]
 8009708:	a327      	add	r3, pc, #156	@ (adr r3, 80097a8 <mbedtls_sha512_starts+0x178>)
 800970a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800970e:	e9c1 2310 	strd	r2, r3, [r1, #64]	@ 0x40
        ctx->state[7] = UL64(0x47B5481DBEFA4FA4);
 8009712:	6879      	ldr	r1, [r7, #4]
 8009714:	a326      	add	r3, pc, #152	@ (adr r3, 80097b0 <mbedtls_sha512_starts+0x180>)
 8009716:	e9d3 2300 	ldrd	r2, r3, [r3]
 800971a:	e9c1 2312 	strd	r2, r3, [r1, #72]	@ 0x48
#endif /* MBEDTLS_SHA384_C */
    }

#if defined(MBEDTLS_SHA384_C)
    ctx->is384 = is384;
 800971e:	687b      	ldr	r3, [r7, #4]
 8009720:	683a      	ldr	r2, [r7, #0]
 8009722:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
#endif

    return( 0 );
 8009726:	2300      	movs	r3, #0
}
 8009728:	4618      	mov	r0, r3
 800972a:	370c      	adds	r7, #12
 800972c:	46bd      	mov	sp, r7
 800972e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009732:	4770      	bx	lr
 8009734:	f3af 8000 	nop.w
 8009738:	f3bcc908 	.word	0xf3bcc908
 800973c:	6a09e667 	.word	0x6a09e667
 8009740:	84caa73b 	.word	0x84caa73b
 8009744:	bb67ae85 	.word	0xbb67ae85
 8009748:	fe94f82b 	.word	0xfe94f82b
 800974c:	3c6ef372 	.word	0x3c6ef372
 8009750:	5f1d36f1 	.word	0x5f1d36f1
 8009754:	a54ff53a 	.word	0xa54ff53a
 8009758:	ade682d1 	.word	0xade682d1
 800975c:	510e527f 	.word	0x510e527f
 8009760:	2b3e6c1f 	.word	0x2b3e6c1f
 8009764:	9b05688c 	.word	0x9b05688c
 8009768:	fb41bd6b 	.word	0xfb41bd6b
 800976c:	1f83d9ab 	.word	0x1f83d9ab
 8009770:	137e2179 	.word	0x137e2179
 8009774:	5be0cd19 	.word	0x5be0cd19
 8009778:	c1059ed8 	.word	0xc1059ed8
 800977c:	cbbb9d5d 	.word	0xcbbb9d5d
 8009780:	367cd507 	.word	0x367cd507
 8009784:	629a292a 	.word	0x629a292a
 8009788:	3070dd17 	.word	0x3070dd17
 800978c:	9159015a 	.word	0x9159015a
 8009790:	f70e5939 	.word	0xf70e5939
 8009794:	152fecd8 	.word	0x152fecd8
 8009798:	ffc00b31 	.word	0xffc00b31
 800979c:	67332667 	.word	0x67332667
 80097a0:	68581511 	.word	0x68581511
 80097a4:	8eb44a87 	.word	0x8eb44a87
 80097a8:	64f98fa7 	.word	0x64f98fa7
 80097ac:	db0c2e0d 	.word	0xdb0c2e0d
 80097b0:	befa4fa4 	.word	0xbefa4fa4
 80097b4:	47b5481d 	.word	0x47b5481d

080097b8 <mbedtls_internal_sha512_process>:
    UL64(0x5FCB6FAB3AD6FAEC),  UL64(0x6C44198C4A475817)
};

int mbedtls_internal_sha512_process( mbedtls_sha512_context *ctx,
                                     const unsigned char data[128] )
{
 80097b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80097bc:	f6ad 1dac 	subw	sp, sp, #2476	@ 0x9ac
 80097c0:	af00      	add	r7, sp, #0
 80097c2:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 80097c6:	f5a3 7337 	sub.w	r3, r3, #732	@ 0x2dc
 80097ca:	6018      	str	r0, [r3, #0]
 80097cc:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 80097d0:	f5a3 7338 	sub.w	r3, r3, #736	@ 0x2e0
 80097d4:	6019      	str	r1, [r3, #0]
        local.temp1 = (h) + S3(e) + F1((e),(f),(g)) + (K) + (x);    \
        local.temp2 = S2(a) + F0((a),(b),(c));                      \
        (d) += local.temp1; (h) = local.temp1 + local.temp2;        \
    } while( 0 )

    for( i = 0; i < 8; i++ )
 80097d6:	2300      	movs	r3, #0
 80097d8:	f8c7 39a4 	str.w	r3, [r7, #2468]	@ 0x9a4
 80097dc:	e01b      	b.n	8009816 <mbedtls_internal_sha512_process+0x5e>
        local.A[i] = ctx->state[i];
 80097de:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 80097e2:	f5a3 7337 	sub.w	r3, r3, #732	@ 0x2dc
 80097e6:	681a      	ldr	r2, [r3, #0]
 80097e8:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 80097ec:	3302      	adds	r3, #2
 80097ee:	00db      	lsls	r3, r3, #3
 80097f0:	4413      	add	r3, r2
 80097f2:	e9d3 0100 	ldrd	r0, r1, [r3]
 80097f6:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 80097fa:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 80097fe:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009802:	3352      	adds	r3, #82	@ 0x52
 8009804:	00db      	lsls	r3, r3, #3
 8009806:	4413      	add	r3, r2
 8009808:	e9c3 0100 	strd	r0, r1, [r3]
    for( i = 0; i < 8; i++ )
 800980c:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009810:	3301      	adds	r3, #1
 8009812:	f8c7 39a4 	str.w	r3, [r7, #2468]	@ 0x9a4
 8009816:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800981a:	2b07      	cmp	r3, #7
 800981c:	dddf      	ble.n	80097de <mbedtls_internal_sha512_process+0x26>
        local.A[4] = local.A[3]; local.A[3] = local.A[2];
        local.A[2] = local.A[1]; local.A[1] = local.A[0];
        local.A[0] = local.temp1;
    }
#else /* MBEDTLS_SHA512_SMALLER */
    for( i = 0; i < 16; i++ )
 800981e:	2300      	movs	r3, #0
 8009820:	f8c7 39a4 	str.w	r3, [r7, #2468]	@ 0x9a4
 8009824:	e11f      	b.n	8009a66 <mbedtls_internal_sha512_process+0x2ae>
    {
        GET_UINT64_BE( local.W[i], data, i << 3 );
 8009826:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800982a:	00da      	lsls	r2, r3, #3
 800982c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009830:	f5a3 7338 	sub.w	r3, r3, #736	@ 0x2e0
 8009834:	681b      	ldr	r3, [r3, #0]
 8009836:	4413      	add	r3, r2
 8009838:	781b      	ldrb	r3, [r3, #0]
 800983a:	b2db      	uxtb	r3, r3
 800983c:	2200      	movs	r2, #0
 800983e:	f8c7 3698 	str.w	r3, [r7, #1688]	@ 0x698
 8009842:	f8c7 269c 	str.w	r2, [r7, #1692]	@ 0x69c
 8009846:	f04f 0000 	mov.w	r0, #0
 800984a:	f04f 0100 	mov.w	r1, #0
 800984e:	f8d7 3698 	ldr.w	r3, [r7, #1688]	@ 0x698
 8009852:	0619      	lsls	r1, r3, #24
 8009854:	2000      	movs	r0, #0
 8009856:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800985a:	00db      	lsls	r3, r3, #3
 800985c:	1c5a      	adds	r2, r3, #1
 800985e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009862:	f5a3 7338 	sub.w	r3, r3, #736	@ 0x2e0
 8009866:	681b      	ldr	r3, [r3, #0]
 8009868:	4413      	add	r3, r2
 800986a:	781b      	ldrb	r3, [r3, #0]
 800986c:	b2db      	uxtb	r3, r3
 800986e:	2200      	movs	r2, #0
 8009870:	f8c7 3690 	str.w	r3, [r7, #1680]	@ 0x690
 8009874:	f8c7 2694 	str.w	r2, [r7, #1684]	@ 0x694
 8009878:	f04f 0200 	mov.w	r2, #0
 800987c:	f04f 0300 	mov.w	r3, #0
 8009880:	f8d7 6690 	ldr.w	r6, [r7, #1680]	@ 0x690
 8009884:	0433      	lsls	r3, r6, #16
 8009886:	2200      	movs	r2, #0
 8009888:	ea40 0602 	orr.w	r6, r0, r2
 800988c:	f8c7 66b0 	str.w	r6, [r7, #1712]	@ 0x6b0
 8009890:	430b      	orrs	r3, r1
 8009892:	f8c7 36b4 	str.w	r3, [r7, #1716]	@ 0x6b4
 8009896:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800989a:	00db      	lsls	r3, r3, #3
 800989c:	1c9a      	adds	r2, r3, #2
 800989e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 80098a2:	f5a3 7338 	sub.w	r3, r3, #736	@ 0x2e0
 80098a6:	681b      	ldr	r3, [r3, #0]
 80098a8:	4413      	add	r3, r2
 80098aa:	781b      	ldrb	r3, [r3, #0]
 80098ac:	b2db      	uxtb	r3, r3
 80098ae:	2200      	movs	r2, #0
 80098b0:	f8c7 3688 	str.w	r3, [r7, #1672]	@ 0x688
 80098b4:	f8c7 268c 	str.w	r2, [r7, #1676]	@ 0x68c
 80098b8:	f04f 0200 	mov.w	r2, #0
 80098bc:	f04f 0300 	mov.w	r3, #0
 80098c0:	f8d7 1688 	ldr.w	r1, [r7, #1672]	@ 0x688
 80098c4:	020b      	lsls	r3, r1, #8
 80098c6:	2200      	movs	r2, #0
 80098c8:	f8d7 16b0 	ldr.w	r1, [r7, #1712]	@ 0x6b0
 80098cc:	4311      	orrs	r1, r2
 80098ce:	f8c7 16a8 	str.w	r1, [r7, #1704]	@ 0x6a8
 80098d2:	f8d7 16b4 	ldr.w	r1, [r7, #1716]	@ 0x6b4
 80098d6:	430b      	orrs	r3, r1
 80098d8:	f8c7 36ac 	str.w	r3, [r7, #1708]	@ 0x6ac
 80098dc:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 80098e0:	00db      	lsls	r3, r3, #3
 80098e2:	1cda      	adds	r2, r3, #3
 80098e4:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 80098e8:	f5a3 7338 	sub.w	r3, r3, #736	@ 0x2e0
 80098ec:	681b      	ldr	r3, [r3, #0]
 80098ee:	4413      	add	r3, r2
 80098f0:	781b      	ldrb	r3, [r3, #0]
 80098f2:	b2db      	uxtb	r3, r3
 80098f4:	2200      	movs	r2, #0
 80098f6:	f8c7 3680 	str.w	r3, [r7, #1664]	@ 0x680
 80098fa:	f8c7 2684 	str.w	r2, [r7, #1668]	@ 0x684
 80098fe:	f04f 0200 	mov.w	r2, #0
 8009902:	f04f 0300 	mov.w	r3, #0
 8009906:	f8d7 1680 	ldr.w	r1, [r7, #1664]	@ 0x680
 800990a:	000b      	movs	r3, r1
 800990c:	2200      	movs	r2, #0
 800990e:	f8d7 16a8 	ldr.w	r1, [r7, #1704]	@ 0x6a8
 8009912:	4311      	orrs	r1, r2
 8009914:	f8c7 16a0 	str.w	r1, [r7, #1696]	@ 0x6a0
 8009918:	f8d7 16ac 	ldr.w	r1, [r7, #1708]	@ 0x6ac
 800991c:	430b      	orrs	r3, r1
 800991e:	f8c7 36a4 	str.w	r3, [r7, #1700]	@ 0x6a4
 8009922:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009926:	00db      	lsls	r3, r3, #3
 8009928:	1d1a      	adds	r2, r3, #4
 800992a:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800992e:	f5a3 7338 	sub.w	r3, r3, #736	@ 0x2e0
 8009932:	681b      	ldr	r3, [r3, #0]
 8009934:	4413      	add	r3, r2
 8009936:	781b      	ldrb	r3, [r3, #0]
 8009938:	b2db      	uxtb	r3, r3
 800993a:	2200      	movs	r2, #0
 800993c:	f8c7 3678 	str.w	r3, [r7, #1656]	@ 0x678
 8009940:	f8c7 267c 	str.w	r2, [r7, #1660]	@ 0x67c
 8009944:	f507 63cf 	add.w	r3, r7, #1656	@ 0x678
 8009948:	e9d3 1200 	ldrd	r1, r2, [r3]
 800994c:	460b      	mov	r3, r1
 800994e:	0a1b      	lsrs	r3, r3, #8
 8009950:	f8c7 3674 	str.w	r3, [r7, #1652]	@ 0x674
 8009954:	460b      	mov	r3, r1
 8009956:	061b      	lsls	r3, r3, #24
 8009958:	f8c7 3670 	str.w	r3, [r7, #1648]	@ 0x670
 800995c:	f8d7 36a0 	ldr.w	r3, [r7, #1696]	@ 0x6a0
 8009960:	f507 62ce 	add.w	r2, r7, #1648	@ 0x670
 8009964:	e9d2 0100 	ldrd	r0, r1, [r2]
 8009968:	4602      	mov	r2, r0
 800996a:	ea43 0a02 	orr.w	sl, r3, r2
 800996e:	f8d7 36a4 	ldr.w	r3, [r7, #1700]	@ 0x6a4
 8009972:	460a      	mov	r2, r1
 8009974:	ea43 0b02 	orr.w	fp, r3, r2
 8009978:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800997c:	00db      	lsls	r3, r3, #3
 800997e:	1d5a      	adds	r2, r3, #5
 8009980:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009984:	f5a3 7338 	sub.w	r3, r3, #736	@ 0x2e0
 8009988:	681b      	ldr	r3, [r3, #0]
 800998a:	4413      	add	r3, r2
 800998c:	781b      	ldrb	r3, [r3, #0]
 800998e:	b2db      	uxtb	r3, r3
 8009990:	2200      	movs	r2, #0
 8009992:	f8c7 36c0 	str.w	r3, [r7, #1728]	@ 0x6c0
 8009996:	f8c7 26c4 	str.w	r2, [r7, #1732]	@ 0x6c4
 800999a:	f04f 0200 	mov.w	r2, #0
 800999e:	f04f 0300 	mov.w	r3, #0
 80099a2:	f8d7 16c4 	ldr.w	r1, [r7, #1732]	@ 0x6c4
 80099a6:	040b      	lsls	r3, r1, #16
 80099a8:	f8d7 16c0 	ldr.w	r1, [r7, #1728]	@ 0x6c0
 80099ac:	ea43 4311 	orr.w	r3, r3, r1, lsr #16
 80099b0:	f8d7 16c0 	ldr.w	r1, [r7, #1728]	@ 0x6c0
 80099b4:	040a      	lsls	r2, r1, #16
 80099b6:	ea4a 0802 	orr.w	r8, sl, r2
 80099ba:	ea4b 0903 	orr.w	r9, fp, r3
 80099be:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 80099c2:	00db      	lsls	r3, r3, #3
 80099c4:	1d9a      	adds	r2, r3, #6
 80099c6:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 80099ca:	f5a3 7338 	sub.w	r3, r3, #736	@ 0x2e0
 80099ce:	681b      	ldr	r3, [r3, #0]
 80099d0:	4413      	add	r3, r2
 80099d2:	781b      	ldrb	r3, [r3, #0]
 80099d4:	b2db      	uxtb	r3, r3
 80099d6:	2200      	movs	r2, #0
 80099d8:	f8c7 36b8 	str.w	r3, [r7, #1720]	@ 0x6b8
 80099dc:	f8c7 26bc 	str.w	r2, [r7, #1724]	@ 0x6bc
 80099e0:	f04f 0200 	mov.w	r2, #0
 80099e4:	f04f 0300 	mov.w	r3, #0
 80099e8:	f8d7 16bc 	ldr.w	r1, [r7, #1724]	@ 0x6bc
 80099ec:	020b      	lsls	r3, r1, #8
 80099ee:	f8d7 16b8 	ldr.w	r1, [r7, #1720]	@ 0x6b8
 80099f2:	ea43 6311 	orr.w	r3, r3, r1, lsr #24
 80099f6:	f8d7 16b8 	ldr.w	r1, [r7, #1720]	@ 0x6b8
 80099fa:	020a      	lsls	r2, r1, #8
 80099fc:	ea48 0402 	orr.w	r4, r8, r2
 8009a00:	ea49 0503 	orr.w	r5, r9, r3
 8009a04:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009a08:	00db      	lsls	r3, r3, #3
 8009a0a:	1dda      	adds	r2, r3, #7
 8009a0c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009a10:	f5a3 7338 	sub.w	r3, r3, #736	@ 0x2e0
 8009a14:	681b      	ldr	r3, [r3, #0]
 8009a16:	4413      	add	r3, r2
 8009a18:	781b      	ldrb	r3, [r3, #0]
 8009a1a:	b2db      	uxtb	r3, r3
 8009a1c:	2200      	movs	r2, #0
 8009a1e:	f8c7 3668 	str.w	r3, [r7, #1640]	@ 0x668
 8009a22:	f8c7 266c 	str.w	r2, [r7, #1644]	@ 0x66c
 8009a26:	f507 63cd 	add.w	r3, r7, #1640	@ 0x668
 8009a2a:	e9d3 1200 	ldrd	r1, r2, [r3]
 8009a2e:	460b      	mov	r3, r1
 8009a30:	4323      	orrs	r3, r4
 8009a32:	f8c7 3660 	str.w	r3, [r7, #1632]	@ 0x660
 8009a36:	4613      	mov	r3, r2
 8009a38:	432b      	orrs	r3, r5
 8009a3a:	f8c7 3664 	str.w	r3, [r7, #1636]	@ 0x664
 8009a3e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009a42:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 8009a46:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009a4a:	3302      	adds	r3, #2
 8009a4c:	00db      	lsls	r3, r3, #3
 8009a4e:	4413      	add	r3, r2
 8009a50:	f507 62cc 	add.w	r2, r7, #1632	@ 0x660
 8009a54:	e9d2 1200 	ldrd	r1, r2, [r2]
 8009a58:	e9c3 1200 	strd	r1, r2, [r3]
    for( i = 0; i < 16; i++ )
 8009a5c:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009a60:	3301      	adds	r3, #1
 8009a62:	f8c7 39a4 	str.w	r3, [r7, #2468]	@ 0x9a4
 8009a66:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009a6a:	2b0f      	cmp	r3, #15
 8009a6c:	f77f aedb 	ble.w	8009826 <mbedtls_internal_sha512_process+0x6e>
    }

    for( ; i < 80; i++ )
 8009a70:	e117      	b.n	8009ca2 <mbedtls_internal_sha512_process+0x4ea>
    {
        local.W[i] = S1(local.W[i -  2]) + local.W[i -  7] +
 8009a72:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009a76:	1e99      	subs	r1, r3, #2
 8009a78:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009a7c:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 8009a80:	1c8b      	adds	r3, r1, #2
 8009a82:	00db      	lsls	r3, r3, #3
 8009a84:	4413      	add	r3, r2
 8009a86:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009a8a:	0358      	lsls	r0, r3, #13
 8009a8c:	0cd1      	lsrs	r1, r2, #19
 8009a8e:	4301      	orrs	r1, r0
 8009a90:	f8c7 1658 	str.w	r1, [r7, #1624]	@ 0x658
 8009a94:	0351      	lsls	r1, r2, #13
 8009a96:	0cdb      	lsrs	r3, r3, #19
 8009a98:	430b      	orrs	r3, r1
 8009a9a:	f8c7 365c 	str.w	r3, [r7, #1628]	@ 0x65c
 8009a9e:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009aa2:	1e99      	subs	r1, r3, #2
 8009aa4:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009aa8:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 8009aac:	1c8b      	adds	r3, r1, #2
 8009aae:	00db      	lsls	r3, r3, #3
 8009ab0:	4413      	add	r3, r2
 8009ab2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009ab6:	0f50      	lsrs	r0, r2, #29
 8009ab8:	00d9      	lsls	r1, r3, #3
 8009aba:	4301      	orrs	r1, r0
 8009abc:	f8c7 1654 	str.w	r1, [r7, #1620]	@ 0x654
 8009ac0:	0f59      	lsrs	r1, r3, #29
 8009ac2:	00d3      	lsls	r3, r2, #3
 8009ac4:	430b      	orrs	r3, r1
 8009ac6:	f8c7 3650 	str.w	r3, [r7, #1616]	@ 0x650
 8009aca:	f507 63cb 	add.w	r3, r7, #1624	@ 0x658
 8009ace:	e9d3 4500 	ldrd	r4, r5, [r3]
 8009ad2:	4623      	mov	r3, r4
 8009ad4:	f507 62ca 	add.w	r2, r7, #1616	@ 0x650
 8009ad8:	e9d2 0100 	ldrd	r0, r1, [r2]
 8009adc:	4602      	mov	r2, r0
 8009ade:	4053      	eors	r3, r2
 8009ae0:	f8c7 3648 	str.w	r3, [r7, #1608]	@ 0x648
 8009ae4:	462b      	mov	r3, r5
 8009ae6:	460a      	mov	r2, r1
 8009ae8:	4053      	eors	r3, r2
 8009aea:	f8c7 364c 	str.w	r3, [r7, #1612]	@ 0x64c
 8009aee:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009af2:	1e99      	subs	r1, r3, #2
 8009af4:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009af8:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 8009afc:	1c8b      	adds	r3, r1, #2
 8009afe:	00db      	lsls	r3, r3, #3
 8009b00:	4413      	add	r3, r2
 8009b02:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009b06:	f04f 0000 	mov.w	r0, #0
 8009b0a:	f04f 0100 	mov.w	r1, #0
 8009b0e:	0990      	lsrs	r0, r2, #6
 8009b10:	ea40 6083 	orr.w	r0, r0, r3, lsl #26
 8009b14:	0999      	lsrs	r1, r3, #6
 8009b16:	f507 63c9 	add.w	r3, r7, #1608	@ 0x648
 8009b1a:	e9d3 4500 	ldrd	r4, r5, [r3]
 8009b1e:	4623      	mov	r3, r4
 8009b20:	4043      	eors	r3, r0
 8009b22:	f8c7 3640 	str.w	r3, [r7, #1600]	@ 0x640
 8009b26:	462b      	mov	r3, r5
 8009b28:	404b      	eors	r3, r1
 8009b2a:	f8c7 3644 	str.w	r3, [r7, #1604]	@ 0x644
 8009b2e:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009b32:	1fd9      	subs	r1, r3, #7
 8009b34:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009b38:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 8009b3c:	1c8b      	adds	r3, r1, #2
 8009b3e:	00db      	lsls	r3, r3, #3
 8009b40:	4413      	add	r3, r2
 8009b42:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009b46:	f507 61c8 	add.w	r1, r7, #1600	@ 0x640
 8009b4a:	e9d1 4500 	ldrd	r4, r5, [r1]
 8009b4e:	4621      	mov	r1, r4
 8009b50:	1889      	adds	r1, r1, r2
 8009b52:	f8c7 1638 	str.w	r1, [r7, #1592]	@ 0x638
 8009b56:	4629      	mov	r1, r5
 8009b58:	eb41 0303 	adc.w	r3, r1, r3
 8009b5c:	f8c7 363c 	str.w	r3, [r7, #1596]	@ 0x63c
               S0(local.W[i - 15]) + local.W[i - 16];
 8009b60:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009b64:	f1a3 010f 	sub.w	r1, r3, #15
 8009b68:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009b6c:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 8009b70:	1c8b      	adds	r3, r1, #2
 8009b72:	00db      	lsls	r3, r3, #3
 8009b74:	4413      	add	r3, r2
 8009b76:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009b7a:	07d8      	lsls	r0, r3, #31
 8009b7c:	0851      	lsrs	r1, r2, #1
 8009b7e:	4301      	orrs	r1, r0
 8009b80:	f8c7 1630 	str.w	r1, [r7, #1584]	@ 0x630
 8009b84:	07d1      	lsls	r1, r2, #31
 8009b86:	085b      	lsrs	r3, r3, #1
 8009b88:	430b      	orrs	r3, r1
 8009b8a:	f8c7 3634 	str.w	r3, [r7, #1588]	@ 0x634
 8009b8e:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009b92:	f1a3 010f 	sub.w	r1, r3, #15
 8009b96:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009b9a:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 8009b9e:	1c8b      	adds	r3, r1, #2
 8009ba0:	00db      	lsls	r3, r3, #3
 8009ba2:	4413      	add	r3, r2
 8009ba4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009ba8:	0618      	lsls	r0, r3, #24
 8009baa:	0a11      	lsrs	r1, r2, #8
 8009bac:	4301      	orrs	r1, r0
 8009bae:	f8c7 1628 	str.w	r1, [r7, #1576]	@ 0x628
 8009bb2:	0611      	lsls	r1, r2, #24
 8009bb4:	0a1b      	lsrs	r3, r3, #8
 8009bb6:	430b      	orrs	r3, r1
 8009bb8:	f8c7 362c 	str.w	r3, [r7, #1580]	@ 0x62c
 8009bbc:	f507 63c6 	add.w	r3, r7, #1584	@ 0x630
 8009bc0:	e9d3 4500 	ldrd	r4, r5, [r3]
 8009bc4:	4623      	mov	r3, r4
 8009bc6:	f507 62c5 	add.w	r2, r7, #1576	@ 0x628
 8009bca:	e9d2 0100 	ldrd	r0, r1, [r2]
 8009bce:	4602      	mov	r2, r0
 8009bd0:	4053      	eors	r3, r2
 8009bd2:	f8c7 3620 	str.w	r3, [r7, #1568]	@ 0x620
 8009bd6:	462b      	mov	r3, r5
 8009bd8:	460a      	mov	r2, r1
 8009bda:	4053      	eors	r3, r2
 8009bdc:	f8c7 3624 	str.w	r3, [r7, #1572]	@ 0x624
 8009be0:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009be4:	f1a3 010f 	sub.w	r1, r3, #15
 8009be8:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009bec:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 8009bf0:	1c8b      	adds	r3, r1, #2
 8009bf2:	00db      	lsls	r3, r3, #3
 8009bf4:	4413      	add	r3, r2
 8009bf6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009bfa:	f04f 0000 	mov.w	r0, #0
 8009bfe:	f04f 0100 	mov.w	r1, #0
 8009c02:	09d0      	lsrs	r0, r2, #7
 8009c04:	ea40 6043 	orr.w	r0, r0, r3, lsl #25
 8009c08:	09d9      	lsrs	r1, r3, #7
 8009c0a:	f507 63c4 	add.w	r3, r7, #1568	@ 0x620
 8009c0e:	e9d3 4500 	ldrd	r4, r5, [r3]
 8009c12:	4623      	mov	r3, r4
 8009c14:	4043      	eors	r3, r0
 8009c16:	f8c7 3618 	str.w	r3, [r7, #1560]	@ 0x618
 8009c1a:	462b      	mov	r3, r5
 8009c1c:	404b      	eors	r3, r1
 8009c1e:	f8c7 361c 	str.w	r3, [r7, #1564]	@ 0x61c
        local.W[i] = S1(local.W[i -  2]) + local.W[i -  7] +
 8009c22:	f507 63c7 	add.w	r3, r7, #1592	@ 0x638
 8009c26:	e9d3 4500 	ldrd	r4, r5, [r3]
 8009c2a:	4623      	mov	r3, r4
 8009c2c:	f507 62c3 	add.w	r2, r7, #1560	@ 0x618
 8009c30:	e9d2 0100 	ldrd	r0, r1, [r2]
 8009c34:	4602      	mov	r2, r0
 8009c36:	189b      	adds	r3, r3, r2
 8009c38:	f8c7 3610 	str.w	r3, [r7, #1552]	@ 0x610
 8009c3c:	462b      	mov	r3, r5
 8009c3e:	460a      	mov	r2, r1
 8009c40:	4153      	adcs	r3, r2
 8009c42:	f8c7 3614 	str.w	r3, [r7, #1556]	@ 0x614
               S0(local.W[i - 15]) + local.W[i - 16];
 8009c46:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009c4a:	f1a3 0110 	sub.w	r1, r3, #16
 8009c4e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009c52:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 8009c56:	1c8b      	adds	r3, r1, #2
 8009c58:	00db      	lsls	r3, r3, #3
 8009c5a:	4413      	add	r3, r2
 8009c5c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009c60:	f507 61c2 	add.w	r1, r7, #1552	@ 0x610
 8009c64:	e9d1 4500 	ldrd	r4, r5, [r1]
 8009c68:	4621      	mov	r1, r4
 8009c6a:	1889      	adds	r1, r1, r2
 8009c6c:	f8c7 1608 	str.w	r1, [r7, #1544]	@ 0x608
 8009c70:	4629      	mov	r1, r5
 8009c72:	eb41 0303 	adc.w	r3, r1, r3
 8009c76:	f8c7 360c 	str.w	r3, [r7, #1548]	@ 0x60c
        local.W[i] = S1(local.W[i -  2]) + local.W[i -  7] +
 8009c7a:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009c7e:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 8009c82:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009c86:	3302      	adds	r3, #2
 8009c88:	00db      	lsls	r3, r3, #3
 8009c8a:	4413      	add	r3, r2
 8009c8c:	f507 62c1 	add.w	r2, r7, #1544	@ 0x608
 8009c90:	e9d2 1200 	ldrd	r1, r2, [r2]
 8009c94:	e9c3 1200 	strd	r1, r2, [r3]
    for( ; i < 80; i++ )
 8009c98:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009c9c:	3301      	adds	r3, #1
 8009c9e:	f8c7 39a4 	str.w	r3, [r7, #2468]	@ 0x9a4
 8009ca2:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009ca6:	2b4f      	cmp	r3, #79	@ 0x4f
 8009ca8:	f77f aee3 	ble.w	8009a72 <mbedtls_internal_sha512_process+0x2ba>
    }

    i = 0;
 8009cac:	2300      	movs	r3, #0
 8009cae:	f8c7 39a4 	str.w	r3, [r7, #2468]	@ 0x9a4
    do
    {
        P( local.A[0], local.A[1], local.A[2], local.A[3], local.A[4],
 8009cb2:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009cb6:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 8009cba:	e9d3 45b2 	ldrd	r4, r5, [r3, #712]	@ 0x2c8
 8009cbe:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009cc2:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 8009cc6:	e9d3 23ac 	ldrd	r2, r3, [r3, #688]	@ 0x2b0
 8009cca:	0498      	lsls	r0, r3, #18
 8009ccc:	0b91      	lsrs	r1, r2, #14
 8009cce:	4301      	orrs	r1, r0
 8009cd0:	f8c7 1600 	str.w	r1, [r7, #1536]	@ 0x600
 8009cd4:	0491      	lsls	r1, r2, #18
 8009cd6:	0b9b      	lsrs	r3, r3, #14
 8009cd8:	430b      	orrs	r3, r1
 8009cda:	f8c7 3604 	str.w	r3, [r7, #1540]	@ 0x604
 8009cde:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009ce2:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 8009ce6:	e9d3 23ac 	ldrd	r2, r3, [r3, #688]	@ 0x2b0
 8009cea:	0398      	lsls	r0, r3, #14
 8009cec:	0c91      	lsrs	r1, r2, #18
 8009cee:	4301      	orrs	r1, r0
 8009cf0:	f8c7 15f8 	str.w	r1, [r7, #1528]	@ 0x5f8
 8009cf4:	0391      	lsls	r1, r2, #14
 8009cf6:	0c9b      	lsrs	r3, r3, #18
 8009cf8:	430b      	orrs	r3, r1
 8009cfa:	f8c7 35fc 	str.w	r3, [r7, #1532]	@ 0x5fc
 8009cfe:	f507 63c0 	add.w	r3, r7, #1536	@ 0x600
 8009d02:	e9d3 8900 	ldrd	r8, r9, [r3]
 8009d06:	4643      	mov	r3, r8
 8009d08:	f507 62bf 	add.w	r2, r7, #1528	@ 0x5f8
 8009d0c:	e9d2 0100 	ldrd	r0, r1, [r2]
 8009d10:	4602      	mov	r2, r0
 8009d12:	4053      	eors	r3, r2
 8009d14:	f8c7 35f0 	str.w	r3, [r7, #1520]	@ 0x5f0
 8009d18:	464b      	mov	r3, r9
 8009d1a:	460a      	mov	r2, r1
 8009d1c:	4053      	eors	r3, r2
 8009d1e:	f8c7 35f4 	str.w	r3, [r7, #1524]	@ 0x5f4
 8009d22:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009d26:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 8009d2a:	e9d3 23ac 	ldrd	r2, r3, [r3, #688]	@ 0x2b0
 8009d2e:	0a50      	lsrs	r0, r2, #9
 8009d30:	05d9      	lsls	r1, r3, #23
 8009d32:	4301      	orrs	r1, r0
 8009d34:	f8c7 15ec 	str.w	r1, [r7, #1516]	@ 0x5ec
 8009d38:	0a59      	lsrs	r1, r3, #9
 8009d3a:	05d3      	lsls	r3, r2, #23
 8009d3c:	430b      	orrs	r3, r1
 8009d3e:	f8c7 35e8 	str.w	r3, [r7, #1512]	@ 0x5e8
 8009d42:	f507 63be 	add.w	r3, r7, #1520	@ 0x5f0
 8009d46:	e9d3 8900 	ldrd	r8, r9, [r3]
 8009d4a:	4643      	mov	r3, r8
 8009d4c:	f507 62bd 	add.w	r2, r7, #1512	@ 0x5e8
 8009d50:	e9d2 0100 	ldrd	r0, r1, [r2]
 8009d54:	4602      	mov	r2, r0
 8009d56:	4053      	eors	r3, r2
 8009d58:	f8c7 35e0 	str.w	r3, [r7, #1504]	@ 0x5e0
 8009d5c:	464b      	mov	r3, r9
 8009d5e:	460a      	mov	r2, r1
 8009d60:	4053      	eors	r3, r2
 8009d62:	f8c7 35e4 	str.w	r3, [r7, #1508]	@ 0x5e4
 8009d66:	f507 63bc 	add.w	r3, r7, #1504	@ 0x5e0
 8009d6a:	e9d3 1200 	ldrd	r1, r2, [r3]
 8009d6e:	460b      	mov	r3, r1
 8009d70:	18e3      	adds	r3, r4, r3
 8009d72:	f8c7 35d8 	str.w	r3, [r7, #1496]	@ 0x5d8
 8009d76:	4613      	mov	r3, r2
 8009d78:	eb45 0303 	adc.w	r3, r5, r3
 8009d7c:	f8c7 35dc 	str.w	r3, [r7, #1500]	@ 0x5dc
 8009d80:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009d84:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 8009d88:	e9d3 89b0 	ldrd	r8, r9, [r3, #704]	@ 0x2c0
 8009d8c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009d90:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 8009d94:	e9d3 45ac 	ldrd	r4, r5, [r3, #688]	@ 0x2b0
 8009d98:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009d9c:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 8009da0:	e9d3 01ae 	ldrd	r0, r1, [r3, #696]	@ 0x2b8
 8009da4:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009da8:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 8009dac:	e9d3 23b0 	ldrd	r2, r3, [r3, #704]	@ 0x2c0
 8009db0:	ea80 0602 	eor.w	r6, r0, r2
 8009db4:	f8c7 65d0 	str.w	r6, [r7, #1488]	@ 0x5d0
 8009db8:	404b      	eors	r3, r1
 8009dba:	f8c7 35d4 	str.w	r3, [r7, #1492]	@ 0x5d4
 8009dbe:	f507 63ba 	add.w	r3, r7, #1488	@ 0x5d0
 8009dc2:	e9d3 1200 	ldrd	r1, r2, [r3]
 8009dc6:	460b      	mov	r3, r1
 8009dc8:	4023      	ands	r3, r4
 8009dca:	f8c7 35c8 	str.w	r3, [r7, #1480]	@ 0x5c8
 8009dce:	4613      	mov	r3, r2
 8009dd0:	402b      	ands	r3, r5
 8009dd2:	f8c7 35cc 	str.w	r3, [r7, #1484]	@ 0x5cc
 8009dd6:	f507 63b9 	add.w	r3, r7, #1480	@ 0x5c8
 8009dda:	e9d3 1200 	ldrd	r1, r2, [r3]
 8009dde:	460b      	mov	r3, r1
 8009de0:	ea88 0303 	eor.w	r3, r8, r3
 8009de4:	f8c7 35c0 	str.w	r3, [r7, #1472]	@ 0x5c0
 8009de8:	4613      	mov	r3, r2
 8009dea:	ea89 0303 	eor.w	r3, r9, r3
 8009dee:	f8c7 35c4 	str.w	r3, [r7, #1476]	@ 0x5c4
 8009df2:	f507 63bb 	add.w	r3, r7, #1496	@ 0x5d8
 8009df6:	e9d3 4500 	ldrd	r4, r5, [r3]
 8009dfa:	4623      	mov	r3, r4
 8009dfc:	f507 62b8 	add.w	r2, r7, #1472	@ 0x5c0
 8009e00:	e9d2 0100 	ldrd	r0, r1, [r2]
 8009e04:	4602      	mov	r2, r0
 8009e06:	189b      	adds	r3, r3, r2
 8009e08:	f8c7 35b8 	str.w	r3, [r7, #1464]	@ 0x5b8
 8009e0c:	462b      	mov	r3, r5
 8009e0e:	460a      	mov	r2, r1
 8009e10:	4153      	adcs	r3, r2
 8009e12:	f8c7 35bc 	str.w	r3, [r7, #1468]	@ 0x5bc
 8009e16:	4afc      	ldr	r2, [pc, #1008]	@ (800a208 <mbedtls_internal_sha512_process+0xa50>)
 8009e18:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009e1c:	00db      	lsls	r3, r3, #3
 8009e1e:	4413      	add	r3, r2
 8009e20:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009e24:	f507 61b7 	add.w	r1, r7, #1464	@ 0x5b8
 8009e28:	e9d1 4500 	ldrd	r4, r5, [r1]
 8009e2c:	4621      	mov	r1, r4
 8009e2e:	1889      	adds	r1, r1, r2
 8009e30:	f8c7 15b0 	str.w	r1, [r7, #1456]	@ 0x5b0
 8009e34:	4629      	mov	r1, r5
 8009e36:	eb41 0303 	adc.w	r3, r1, r3
 8009e3a:	f8c7 35b4 	str.w	r3, [r7, #1460]	@ 0x5b4
 8009e3e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009e42:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 8009e46:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 8009e4a:	3302      	adds	r3, #2
 8009e4c:	00db      	lsls	r3, r3, #3
 8009e4e:	4413      	add	r3, r2
 8009e50:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009e54:	f507 61b6 	add.w	r1, r7, #1456	@ 0x5b0
 8009e58:	e9d1 4500 	ldrd	r4, r5, [r1]
 8009e5c:	4621      	mov	r1, r4
 8009e5e:	1889      	adds	r1, r1, r2
 8009e60:	f8c7 15a8 	str.w	r1, [r7, #1448]	@ 0x5a8
 8009e64:	4629      	mov	r1, r5
 8009e66:	eb41 0303 	adc.w	r3, r1, r3
 8009e6a:	f8c7 35ac 	str.w	r3, [r7, #1452]	@ 0x5ac
 8009e6e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009e72:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 8009e76:	f507 62b5 	add.w	r2, r7, #1448	@ 0x5a8
 8009e7a:	e9d2 1200 	ldrd	r1, r2, [r2]
 8009e7e:	e9c3 1200 	strd	r1, r2, [r3]
 8009e82:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009e86:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 8009e8a:	e9d3 23a4 	ldrd	r2, r3, [r3, #656]	@ 0x290
 8009e8e:	0118      	lsls	r0, r3, #4
 8009e90:	0f11      	lsrs	r1, r2, #28
 8009e92:	4301      	orrs	r1, r0
 8009e94:	f8c7 15a0 	str.w	r1, [r7, #1440]	@ 0x5a0
 8009e98:	0111      	lsls	r1, r2, #4
 8009e9a:	0f1b      	lsrs	r3, r3, #28
 8009e9c:	430b      	orrs	r3, r1
 8009e9e:	f8c7 35a4 	str.w	r3, [r7, #1444]	@ 0x5a4
 8009ea2:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009ea6:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 8009eaa:	e9d3 23a4 	ldrd	r2, r3, [r3, #656]	@ 0x290
 8009eae:	0890      	lsrs	r0, r2, #2
 8009eb0:	0799      	lsls	r1, r3, #30
 8009eb2:	4301      	orrs	r1, r0
 8009eb4:	f8c7 159c 	str.w	r1, [r7, #1436]	@ 0x59c
 8009eb8:	0899      	lsrs	r1, r3, #2
 8009eba:	0793      	lsls	r3, r2, #30
 8009ebc:	430b      	orrs	r3, r1
 8009ebe:	f8c7 3598 	str.w	r3, [r7, #1432]	@ 0x598
 8009ec2:	f507 63b4 	add.w	r3, r7, #1440	@ 0x5a0
 8009ec6:	e9d3 4500 	ldrd	r4, r5, [r3]
 8009eca:	4623      	mov	r3, r4
 8009ecc:	f507 62b3 	add.w	r2, r7, #1432	@ 0x598
 8009ed0:	e9d2 0100 	ldrd	r0, r1, [r2]
 8009ed4:	4602      	mov	r2, r0
 8009ed6:	4053      	eors	r3, r2
 8009ed8:	f8c7 3590 	str.w	r3, [r7, #1424]	@ 0x590
 8009edc:	462b      	mov	r3, r5
 8009ede:	460a      	mov	r2, r1
 8009ee0:	4053      	eors	r3, r2
 8009ee2:	f8c7 3594 	str.w	r3, [r7, #1428]	@ 0x594
 8009ee6:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009eea:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 8009eee:	e9d3 23a4 	ldrd	r2, r3, [r3, #656]	@ 0x290
 8009ef2:	09d0      	lsrs	r0, r2, #7
 8009ef4:	0659      	lsls	r1, r3, #25
 8009ef6:	4301      	orrs	r1, r0
 8009ef8:	f8c7 158c 	str.w	r1, [r7, #1420]	@ 0x58c
 8009efc:	09d9      	lsrs	r1, r3, #7
 8009efe:	0653      	lsls	r3, r2, #25
 8009f00:	430b      	orrs	r3, r1
 8009f02:	f8c7 3588 	str.w	r3, [r7, #1416]	@ 0x588
 8009f06:	f507 63b2 	add.w	r3, r7, #1424	@ 0x590
 8009f0a:	e9d3 4500 	ldrd	r4, r5, [r3]
 8009f0e:	4623      	mov	r3, r4
 8009f10:	f507 62b1 	add.w	r2, r7, #1416	@ 0x588
 8009f14:	e9d2 0100 	ldrd	r0, r1, [r2]
 8009f18:	4602      	mov	r2, r0
 8009f1a:	4053      	eors	r3, r2
 8009f1c:	f8c7 3580 	str.w	r3, [r7, #1408]	@ 0x580
 8009f20:	462b      	mov	r3, r5
 8009f22:	460a      	mov	r2, r1
 8009f24:	4053      	eors	r3, r2
 8009f26:	f8c7 3584 	str.w	r3, [r7, #1412]	@ 0x584
 8009f2a:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009f2e:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 8009f32:	e9d3 01a4 	ldrd	r0, r1, [r3, #656]	@ 0x290
 8009f36:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009f3a:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 8009f3e:	e9d3 23a6 	ldrd	r2, r3, [r3, #664]	@ 0x298
 8009f42:	ea00 0402 	and.w	r4, r0, r2
 8009f46:	f8c7 4578 	str.w	r4, [r7, #1400]	@ 0x578
 8009f4a:	400b      	ands	r3, r1
 8009f4c:	f8c7 357c 	str.w	r3, [r7, #1404]	@ 0x57c
 8009f50:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009f54:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 8009f58:	e9d3 45a8 	ldrd	r4, r5, [r3, #672]	@ 0x2a0
 8009f5c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009f60:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 8009f64:	e9d3 01a4 	ldrd	r0, r1, [r3, #656]	@ 0x290
 8009f68:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009f6c:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 8009f70:	e9d3 23a6 	ldrd	r2, r3, [r3, #664]	@ 0x298
 8009f74:	ea40 0602 	orr.w	r6, r0, r2
 8009f78:	f8c7 6570 	str.w	r6, [r7, #1392]	@ 0x570
 8009f7c:	430b      	orrs	r3, r1
 8009f7e:	f8c7 3574 	str.w	r3, [r7, #1396]	@ 0x574
 8009f82:	f507 63ae 	add.w	r3, r7, #1392	@ 0x570
 8009f86:	e9d3 1200 	ldrd	r1, r2, [r3]
 8009f8a:	460b      	mov	r3, r1
 8009f8c:	4023      	ands	r3, r4
 8009f8e:	f8c7 3568 	str.w	r3, [r7, #1384]	@ 0x568
 8009f92:	4613      	mov	r3, r2
 8009f94:	402b      	ands	r3, r5
 8009f96:	f8c7 356c 	str.w	r3, [r7, #1388]	@ 0x56c
 8009f9a:	f507 63af 	add.w	r3, r7, #1400	@ 0x578
 8009f9e:	e9d3 4500 	ldrd	r4, r5, [r3]
 8009fa2:	4623      	mov	r3, r4
 8009fa4:	f507 62ad 	add.w	r2, r7, #1384	@ 0x568
 8009fa8:	e9d2 0100 	ldrd	r0, r1, [r2]
 8009fac:	4602      	mov	r2, r0
 8009fae:	4313      	orrs	r3, r2
 8009fb0:	f8c7 3560 	str.w	r3, [r7, #1376]	@ 0x560
 8009fb4:	462b      	mov	r3, r5
 8009fb6:	460a      	mov	r2, r1
 8009fb8:	4313      	orrs	r3, r2
 8009fba:	f8c7 3564 	str.w	r3, [r7, #1380]	@ 0x564
 8009fbe:	f507 63b0 	add.w	r3, r7, #1408	@ 0x580
 8009fc2:	e9d3 4500 	ldrd	r4, r5, [r3]
 8009fc6:	4623      	mov	r3, r4
 8009fc8:	f507 62ac 	add.w	r2, r7, #1376	@ 0x560
 8009fcc:	e9d2 0100 	ldrd	r0, r1, [r2]
 8009fd0:	4602      	mov	r2, r0
 8009fd2:	189b      	adds	r3, r3, r2
 8009fd4:	f8c7 3558 	str.w	r3, [r7, #1368]	@ 0x558
 8009fd8:	462b      	mov	r3, r5
 8009fda:	460a      	mov	r2, r1
 8009fdc:	4153      	adcs	r3, r2
 8009fde:	f8c7 355c 	str.w	r3, [r7, #1372]	@ 0x55c
 8009fe2:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009fe6:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 8009fea:	f507 62ab 	add.w	r2, r7, #1368	@ 0x558
 8009fee:	e9d2 1200 	ldrd	r1, r2, [r2]
 8009ff2:	e9c3 1202 	strd	r1, r2, [r3, #8]
 8009ff6:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 8009ffa:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 8009ffe:	e9d3 01aa 	ldrd	r0, r1, [r3, #680]	@ 0x2a8
 800a002:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a006:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a00a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a00e:	1884      	adds	r4, r0, r2
 800a010:	f8c7 4550 	str.w	r4, [r7, #1360]	@ 0x550
 800a014:	eb41 0303 	adc.w	r3, r1, r3
 800a018:	f8c7 3554 	str.w	r3, [r7, #1364]	@ 0x554
 800a01c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a020:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a024:	f507 62aa 	add.w	r2, r7, #1360	@ 0x550
 800a028:	e9d2 1200 	ldrd	r1, r2, [r2]
 800a02c:	e9c3 12aa 	strd	r1, r2, [r3, #680]	@ 0x2a8
 800a030:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a034:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a038:	e9d3 0100 	ldrd	r0, r1, [r3]
 800a03c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a040:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a044:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a048:	1884      	adds	r4, r0, r2
 800a04a:	f8c7 4548 	str.w	r4, [r7, #1352]	@ 0x548
 800a04e:	eb41 0303 	adc.w	r3, r1, r3
 800a052:	f8c7 354c 	str.w	r3, [r7, #1356]	@ 0x54c
 800a056:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a05a:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a05e:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 800a062:	e9d2 1200 	ldrd	r1, r2, [r2]
 800a066:	e9c3 12b2 	strd	r1, r2, [r3, #712]	@ 0x2c8
           local.A[5], local.A[6], local.A[7], local.W[i], K[i] ); i++;
 800a06a:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800a06e:	3301      	adds	r3, #1
 800a070:	f8c7 39a4 	str.w	r3, [r7, #2468]	@ 0x9a4
        P( local.A[7], local.A[0], local.A[1], local.A[2], local.A[3],
 800a074:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a078:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a07c:	e9d3 45b0 	ldrd	r4, r5, [r3, #704]	@ 0x2c0
 800a080:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a084:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a088:	e9d3 23aa 	ldrd	r2, r3, [r3, #680]	@ 0x2a8
 800a08c:	0498      	lsls	r0, r3, #18
 800a08e:	0b91      	lsrs	r1, r2, #14
 800a090:	4301      	orrs	r1, r0
 800a092:	f8c7 1540 	str.w	r1, [r7, #1344]	@ 0x540
 800a096:	0491      	lsls	r1, r2, #18
 800a098:	0b9b      	lsrs	r3, r3, #14
 800a09a:	430b      	orrs	r3, r1
 800a09c:	f8c7 3544 	str.w	r3, [r7, #1348]	@ 0x544
 800a0a0:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a0a4:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a0a8:	e9d3 23aa 	ldrd	r2, r3, [r3, #680]	@ 0x2a8
 800a0ac:	0398      	lsls	r0, r3, #14
 800a0ae:	0c91      	lsrs	r1, r2, #18
 800a0b0:	4301      	orrs	r1, r0
 800a0b2:	f8c7 1538 	str.w	r1, [r7, #1336]	@ 0x538
 800a0b6:	0391      	lsls	r1, r2, #14
 800a0b8:	0c9b      	lsrs	r3, r3, #18
 800a0ba:	430b      	orrs	r3, r1
 800a0bc:	f8c7 353c 	str.w	r3, [r7, #1340]	@ 0x53c
 800a0c0:	f507 63a8 	add.w	r3, r7, #1344	@ 0x540
 800a0c4:	e9d3 8900 	ldrd	r8, r9, [r3]
 800a0c8:	4643      	mov	r3, r8
 800a0ca:	f507 62a7 	add.w	r2, r7, #1336	@ 0x538
 800a0ce:	e9d2 0100 	ldrd	r0, r1, [r2]
 800a0d2:	4602      	mov	r2, r0
 800a0d4:	4053      	eors	r3, r2
 800a0d6:	f8c7 3530 	str.w	r3, [r7, #1328]	@ 0x530
 800a0da:	464b      	mov	r3, r9
 800a0dc:	460a      	mov	r2, r1
 800a0de:	4053      	eors	r3, r2
 800a0e0:	f8c7 3534 	str.w	r3, [r7, #1332]	@ 0x534
 800a0e4:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a0e8:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a0ec:	e9d3 23aa 	ldrd	r2, r3, [r3, #680]	@ 0x2a8
 800a0f0:	0a50      	lsrs	r0, r2, #9
 800a0f2:	05d9      	lsls	r1, r3, #23
 800a0f4:	4301      	orrs	r1, r0
 800a0f6:	f8c7 152c 	str.w	r1, [r7, #1324]	@ 0x52c
 800a0fa:	0a59      	lsrs	r1, r3, #9
 800a0fc:	05d3      	lsls	r3, r2, #23
 800a0fe:	430b      	orrs	r3, r1
 800a100:	f8c7 3528 	str.w	r3, [r7, #1320]	@ 0x528
 800a104:	f507 63a6 	add.w	r3, r7, #1328	@ 0x530
 800a108:	e9d3 8900 	ldrd	r8, r9, [r3]
 800a10c:	4643      	mov	r3, r8
 800a10e:	f507 62a5 	add.w	r2, r7, #1320	@ 0x528
 800a112:	e9d2 0100 	ldrd	r0, r1, [r2]
 800a116:	4602      	mov	r2, r0
 800a118:	4053      	eors	r3, r2
 800a11a:	f8c7 3520 	str.w	r3, [r7, #1312]	@ 0x520
 800a11e:	464b      	mov	r3, r9
 800a120:	460a      	mov	r2, r1
 800a122:	4053      	eors	r3, r2
 800a124:	f8c7 3524 	str.w	r3, [r7, #1316]	@ 0x524
 800a128:	f507 63a4 	add.w	r3, r7, #1312	@ 0x520
 800a12c:	e9d3 1200 	ldrd	r1, r2, [r3]
 800a130:	460b      	mov	r3, r1
 800a132:	18e3      	adds	r3, r4, r3
 800a134:	f8c7 3518 	str.w	r3, [r7, #1304]	@ 0x518
 800a138:	4613      	mov	r3, r2
 800a13a:	eb45 0303 	adc.w	r3, r5, r3
 800a13e:	f8c7 351c 	str.w	r3, [r7, #1308]	@ 0x51c
 800a142:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a146:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a14a:	e9d3 89ae 	ldrd	r8, r9, [r3, #696]	@ 0x2b8
 800a14e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a152:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a156:	e9d3 45aa 	ldrd	r4, r5, [r3, #680]	@ 0x2a8
 800a15a:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a15e:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a162:	e9d3 01ac 	ldrd	r0, r1, [r3, #688]	@ 0x2b0
 800a166:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a16a:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a16e:	e9d3 23ae 	ldrd	r2, r3, [r3, #696]	@ 0x2b8
 800a172:	ea80 0602 	eor.w	r6, r0, r2
 800a176:	f8c7 6510 	str.w	r6, [r7, #1296]	@ 0x510
 800a17a:	404b      	eors	r3, r1
 800a17c:	f8c7 3514 	str.w	r3, [r7, #1300]	@ 0x514
 800a180:	f507 63a2 	add.w	r3, r7, #1296	@ 0x510
 800a184:	e9d3 1200 	ldrd	r1, r2, [r3]
 800a188:	460b      	mov	r3, r1
 800a18a:	4023      	ands	r3, r4
 800a18c:	f8c7 3508 	str.w	r3, [r7, #1288]	@ 0x508
 800a190:	4613      	mov	r3, r2
 800a192:	402b      	ands	r3, r5
 800a194:	f8c7 350c 	str.w	r3, [r7, #1292]	@ 0x50c
 800a198:	f507 63a1 	add.w	r3, r7, #1288	@ 0x508
 800a19c:	e9d3 1200 	ldrd	r1, r2, [r3]
 800a1a0:	460b      	mov	r3, r1
 800a1a2:	ea88 0303 	eor.w	r3, r8, r3
 800a1a6:	f8c7 3500 	str.w	r3, [r7, #1280]	@ 0x500
 800a1aa:	4613      	mov	r3, r2
 800a1ac:	ea89 0303 	eor.w	r3, r9, r3
 800a1b0:	f8c7 3504 	str.w	r3, [r7, #1284]	@ 0x504
 800a1b4:	f507 63a3 	add.w	r3, r7, #1304	@ 0x518
 800a1b8:	e9d3 4500 	ldrd	r4, r5, [r3]
 800a1bc:	4623      	mov	r3, r4
 800a1be:	f507 62a0 	add.w	r2, r7, #1280	@ 0x500
 800a1c2:	e9d2 0100 	ldrd	r0, r1, [r2]
 800a1c6:	4602      	mov	r2, r0
 800a1c8:	189b      	adds	r3, r3, r2
 800a1ca:	f8c7 34f8 	str.w	r3, [r7, #1272]	@ 0x4f8
 800a1ce:	462b      	mov	r3, r5
 800a1d0:	460a      	mov	r2, r1
 800a1d2:	4153      	adcs	r3, r2
 800a1d4:	f8c7 34fc 	str.w	r3, [r7, #1276]	@ 0x4fc
 800a1d8:	4a0b      	ldr	r2, [pc, #44]	@ (800a208 <mbedtls_internal_sha512_process+0xa50>)
 800a1da:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800a1de:	00db      	lsls	r3, r3, #3
 800a1e0:	4413      	add	r3, r2
 800a1e2:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a1e6:	f507 619f 	add.w	r1, r7, #1272	@ 0x4f8
 800a1ea:	e9d1 4500 	ldrd	r4, r5, [r1]
 800a1ee:	4621      	mov	r1, r4
 800a1f0:	1889      	adds	r1, r1, r2
 800a1f2:	f8c7 14f0 	str.w	r1, [r7, #1264]	@ 0x4f0
 800a1f6:	4629      	mov	r1, r5
 800a1f8:	eb41 0303 	adc.w	r3, r1, r3
 800a1fc:	f8c7 34f4 	str.w	r3, [r7, #1268]	@ 0x4f4
 800a200:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a204:	e002      	b.n	800a20c <mbedtls_internal_sha512_process+0xa54>
 800a206:	bf00      	nop
 800a208:	08016d50 	.word	0x08016d50
 800a20c:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 800a210:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800a214:	3302      	adds	r3, #2
 800a216:	00db      	lsls	r3, r3, #3
 800a218:	4413      	add	r3, r2
 800a21a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a21e:	f507 619e 	add.w	r1, r7, #1264	@ 0x4f0
 800a222:	e9d1 4500 	ldrd	r4, r5, [r1]
 800a226:	4621      	mov	r1, r4
 800a228:	1889      	adds	r1, r1, r2
 800a22a:	f8c7 14e8 	str.w	r1, [r7, #1256]	@ 0x4e8
 800a22e:	4629      	mov	r1, r5
 800a230:	eb41 0303 	adc.w	r3, r1, r3
 800a234:	f8c7 34ec 	str.w	r3, [r7, #1260]	@ 0x4ec
 800a238:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a23c:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a240:	f507 629d 	add.w	r2, r7, #1256	@ 0x4e8
 800a244:	e9d2 1200 	ldrd	r1, r2, [r2]
 800a248:	e9c3 1200 	strd	r1, r2, [r3]
 800a24c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a250:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a254:	e9d3 23b2 	ldrd	r2, r3, [r3, #712]	@ 0x2c8
 800a258:	0118      	lsls	r0, r3, #4
 800a25a:	0f11      	lsrs	r1, r2, #28
 800a25c:	4301      	orrs	r1, r0
 800a25e:	f8c7 14e0 	str.w	r1, [r7, #1248]	@ 0x4e0
 800a262:	0111      	lsls	r1, r2, #4
 800a264:	0f1b      	lsrs	r3, r3, #28
 800a266:	430b      	orrs	r3, r1
 800a268:	f8c7 34e4 	str.w	r3, [r7, #1252]	@ 0x4e4
 800a26c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a270:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a274:	e9d3 23b2 	ldrd	r2, r3, [r3, #712]	@ 0x2c8
 800a278:	0890      	lsrs	r0, r2, #2
 800a27a:	0799      	lsls	r1, r3, #30
 800a27c:	4301      	orrs	r1, r0
 800a27e:	f8c7 14dc 	str.w	r1, [r7, #1244]	@ 0x4dc
 800a282:	0899      	lsrs	r1, r3, #2
 800a284:	0793      	lsls	r3, r2, #30
 800a286:	430b      	orrs	r3, r1
 800a288:	f8c7 34d8 	str.w	r3, [r7, #1240]	@ 0x4d8
 800a28c:	f507 639c 	add.w	r3, r7, #1248	@ 0x4e0
 800a290:	e9d3 4500 	ldrd	r4, r5, [r3]
 800a294:	4623      	mov	r3, r4
 800a296:	f507 629b 	add.w	r2, r7, #1240	@ 0x4d8
 800a29a:	e9d2 0100 	ldrd	r0, r1, [r2]
 800a29e:	4602      	mov	r2, r0
 800a2a0:	4053      	eors	r3, r2
 800a2a2:	f8c7 34d0 	str.w	r3, [r7, #1232]	@ 0x4d0
 800a2a6:	462b      	mov	r3, r5
 800a2a8:	460a      	mov	r2, r1
 800a2aa:	4053      	eors	r3, r2
 800a2ac:	f8c7 34d4 	str.w	r3, [r7, #1236]	@ 0x4d4
 800a2b0:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a2b4:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a2b8:	e9d3 23b2 	ldrd	r2, r3, [r3, #712]	@ 0x2c8
 800a2bc:	09d0      	lsrs	r0, r2, #7
 800a2be:	0659      	lsls	r1, r3, #25
 800a2c0:	4301      	orrs	r1, r0
 800a2c2:	f8c7 14cc 	str.w	r1, [r7, #1228]	@ 0x4cc
 800a2c6:	09d9      	lsrs	r1, r3, #7
 800a2c8:	0653      	lsls	r3, r2, #25
 800a2ca:	430b      	orrs	r3, r1
 800a2cc:	f8c7 34c8 	str.w	r3, [r7, #1224]	@ 0x4c8
 800a2d0:	f507 639a 	add.w	r3, r7, #1232	@ 0x4d0
 800a2d4:	e9d3 4500 	ldrd	r4, r5, [r3]
 800a2d8:	4623      	mov	r3, r4
 800a2da:	f507 6299 	add.w	r2, r7, #1224	@ 0x4c8
 800a2de:	e9d2 0100 	ldrd	r0, r1, [r2]
 800a2e2:	4602      	mov	r2, r0
 800a2e4:	4053      	eors	r3, r2
 800a2e6:	f8c7 34c0 	str.w	r3, [r7, #1216]	@ 0x4c0
 800a2ea:	462b      	mov	r3, r5
 800a2ec:	460a      	mov	r2, r1
 800a2ee:	4053      	eors	r3, r2
 800a2f0:	f8c7 34c4 	str.w	r3, [r7, #1220]	@ 0x4c4
 800a2f4:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a2f8:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a2fc:	e9d3 01b2 	ldrd	r0, r1, [r3, #712]	@ 0x2c8
 800a300:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a304:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a308:	e9d3 23a4 	ldrd	r2, r3, [r3, #656]	@ 0x290
 800a30c:	ea00 0402 	and.w	r4, r0, r2
 800a310:	f8c7 44b8 	str.w	r4, [r7, #1208]	@ 0x4b8
 800a314:	400b      	ands	r3, r1
 800a316:	f8c7 34bc 	str.w	r3, [r7, #1212]	@ 0x4bc
 800a31a:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a31e:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a322:	e9d3 45a6 	ldrd	r4, r5, [r3, #664]	@ 0x298
 800a326:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a32a:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a32e:	e9d3 01b2 	ldrd	r0, r1, [r3, #712]	@ 0x2c8
 800a332:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a336:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a33a:	e9d3 23a4 	ldrd	r2, r3, [r3, #656]	@ 0x290
 800a33e:	ea40 0602 	orr.w	r6, r0, r2
 800a342:	f8c7 64b0 	str.w	r6, [r7, #1200]	@ 0x4b0
 800a346:	430b      	orrs	r3, r1
 800a348:	f8c7 34b4 	str.w	r3, [r7, #1204]	@ 0x4b4
 800a34c:	f507 6396 	add.w	r3, r7, #1200	@ 0x4b0
 800a350:	e9d3 1200 	ldrd	r1, r2, [r3]
 800a354:	460b      	mov	r3, r1
 800a356:	4023      	ands	r3, r4
 800a358:	f8c7 34a8 	str.w	r3, [r7, #1192]	@ 0x4a8
 800a35c:	4613      	mov	r3, r2
 800a35e:	402b      	ands	r3, r5
 800a360:	f8c7 34ac 	str.w	r3, [r7, #1196]	@ 0x4ac
 800a364:	f507 6397 	add.w	r3, r7, #1208	@ 0x4b8
 800a368:	e9d3 4500 	ldrd	r4, r5, [r3]
 800a36c:	4623      	mov	r3, r4
 800a36e:	f507 6295 	add.w	r2, r7, #1192	@ 0x4a8
 800a372:	e9d2 0100 	ldrd	r0, r1, [r2]
 800a376:	4602      	mov	r2, r0
 800a378:	4313      	orrs	r3, r2
 800a37a:	f8c7 34a0 	str.w	r3, [r7, #1184]	@ 0x4a0
 800a37e:	462b      	mov	r3, r5
 800a380:	460a      	mov	r2, r1
 800a382:	4313      	orrs	r3, r2
 800a384:	f8c7 34a4 	str.w	r3, [r7, #1188]	@ 0x4a4
 800a388:	f507 6398 	add.w	r3, r7, #1216	@ 0x4c0
 800a38c:	e9d3 4500 	ldrd	r4, r5, [r3]
 800a390:	4623      	mov	r3, r4
 800a392:	f507 6294 	add.w	r2, r7, #1184	@ 0x4a0
 800a396:	e9d2 0100 	ldrd	r0, r1, [r2]
 800a39a:	4602      	mov	r2, r0
 800a39c:	189b      	adds	r3, r3, r2
 800a39e:	f8c7 3498 	str.w	r3, [r7, #1176]	@ 0x498
 800a3a2:	462b      	mov	r3, r5
 800a3a4:	460a      	mov	r2, r1
 800a3a6:	4153      	adcs	r3, r2
 800a3a8:	f8c7 349c 	str.w	r3, [r7, #1180]	@ 0x49c
 800a3ac:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a3b0:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a3b4:	f507 6293 	add.w	r2, r7, #1176	@ 0x498
 800a3b8:	e9d2 1200 	ldrd	r1, r2, [r2]
 800a3bc:	e9c3 1202 	strd	r1, r2, [r3, #8]
 800a3c0:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a3c4:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a3c8:	e9d3 01a8 	ldrd	r0, r1, [r3, #672]	@ 0x2a0
 800a3cc:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a3d0:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a3d4:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a3d8:	1884      	adds	r4, r0, r2
 800a3da:	f8c7 4490 	str.w	r4, [r7, #1168]	@ 0x490
 800a3de:	eb41 0303 	adc.w	r3, r1, r3
 800a3e2:	f8c7 3494 	str.w	r3, [r7, #1172]	@ 0x494
 800a3e6:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a3ea:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a3ee:	f507 6292 	add.w	r2, r7, #1168	@ 0x490
 800a3f2:	e9d2 1200 	ldrd	r1, r2, [r2]
 800a3f6:	e9c3 12a8 	strd	r1, r2, [r3, #672]	@ 0x2a0
 800a3fa:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a3fe:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a402:	e9d3 0100 	ldrd	r0, r1, [r3]
 800a406:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a40a:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a40e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a412:	1884      	adds	r4, r0, r2
 800a414:	f8c7 4488 	str.w	r4, [r7, #1160]	@ 0x488
 800a418:	eb41 0303 	adc.w	r3, r1, r3
 800a41c:	f8c7 348c 	str.w	r3, [r7, #1164]	@ 0x48c
 800a420:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a424:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a428:	f507 6291 	add.w	r2, r7, #1160	@ 0x488
 800a42c:	e9d2 1200 	ldrd	r1, r2, [r2]
 800a430:	e9c3 12b0 	strd	r1, r2, [r3, #704]	@ 0x2c0
           local.A[4], local.A[5], local.A[6], local.W[i], K[i] ); i++;
 800a434:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800a438:	3301      	adds	r3, #1
 800a43a:	f8c7 39a4 	str.w	r3, [r7, #2468]	@ 0x9a4
        P( local.A[6], local.A[7], local.A[0], local.A[1], local.A[2],
 800a43e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a442:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a446:	e9d3 45ae 	ldrd	r4, r5, [r3, #696]	@ 0x2b8
 800a44a:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a44e:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a452:	e9d3 23a8 	ldrd	r2, r3, [r3, #672]	@ 0x2a0
 800a456:	0498      	lsls	r0, r3, #18
 800a458:	0b91      	lsrs	r1, r2, #14
 800a45a:	4301      	orrs	r1, r0
 800a45c:	f8c7 1480 	str.w	r1, [r7, #1152]	@ 0x480
 800a460:	0491      	lsls	r1, r2, #18
 800a462:	0b9b      	lsrs	r3, r3, #14
 800a464:	430b      	orrs	r3, r1
 800a466:	f8c7 3484 	str.w	r3, [r7, #1156]	@ 0x484
 800a46a:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a46e:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a472:	e9d3 23a8 	ldrd	r2, r3, [r3, #672]	@ 0x2a0
 800a476:	0398      	lsls	r0, r3, #14
 800a478:	0c91      	lsrs	r1, r2, #18
 800a47a:	4301      	orrs	r1, r0
 800a47c:	f8c7 1478 	str.w	r1, [r7, #1144]	@ 0x478
 800a480:	0391      	lsls	r1, r2, #14
 800a482:	0c9b      	lsrs	r3, r3, #18
 800a484:	430b      	orrs	r3, r1
 800a486:	f8c7 347c 	str.w	r3, [r7, #1148]	@ 0x47c
 800a48a:	f507 6390 	add.w	r3, r7, #1152	@ 0x480
 800a48e:	e9d3 8900 	ldrd	r8, r9, [r3]
 800a492:	4643      	mov	r3, r8
 800a494:	f507 628f 	add.w	r2, r7, #1144	@ 0x478
 800a498:	e9d2 0100 	ldrd	r0, r1, [r2]
 800a49c:	4602      	mov	r2, r0
 800a49e:	4053      	eors	r3, r2
 800a4a0:	f8c7 3470 	str.w	r3, [r7, #1136]	@ 0x470
 800a4a4:	464b      	mov	r3, r9
 800a4a6:	460a      	mov	r2, r1
 800a4a8:	4053      	eors	r3, r2
 800a4aa:	f8c7 3474 	str.w	r3, [r7, #1140]	@ 0x474
 800a4ae:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a4b2:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a4b6:	e9d3 23a8 	ldrd	r2, r3, [r3, #672]	@ 0x2a0
 800a4ba:	0a50      	lsrs	r0, r2, #9
 800a4bc:	05d9      	lsls	r1, r3, #23
 800a4be:	4301      	orrs	r1, r0
 800a4c0:	f8c7 146c 	str.w	r1, [r7, #1132]	@ 0x46c
 800a4c4:	0a59      	lsrs	r1, r3, #9
 800a4c6:	05d3      	lsls	r3, r2, #23
 800a4c8:	430b      	orrs	r3, r1
 800a4ca:	f8c7 3468 	str.w	r3, [r7, #1128]	@ 0x468
 800a4ce:	f507 638e 	add.w	r3, r7, #1136	@ 0x470
 800a4d2:	e9d3 8900 	ldrd	r8, r9, [r3]
 800a4d6:	4643      	mov	r3, r8
 800a4d8:	f507 628d 	add.w	r2, r7, #1128	@ 0x468
 800a4dc:	e9d2 0100 	ldrd	r0, r1, [r2]
 800a4e0:	4602      	mov	r2, r0
 800a4e2:	4053      	eors	r3, r2
 800a4e4:	f8c7 3460 	str.w	r3, [r7, #1120]	@ 0x460
 800a4e8:	464b      	mov	r3, r9
 800a4ea:	460a      	mov	r2, r1
 800a4ec:	4053      	eors	r3, r2
 800a4ee:	f8c7 3464 	str.w	r3, [r7, #1124]	@ 0x464
 800a4f2:	f507 638c 	add.w	r3, r7, #1120	@ 0x460
 800a4f6:	e9d3 1200 	ldrd	r1, r2, [r3]
 800a4fa:	460b      	mov	r3, r1
 800a4fc:	18e3      	adds	r3, r4, r3
 800a4fe:	f8c7 3458 	str.w	r3, [r7, #1112]	@ 0x458
 800a502:	4613      	mov	r3, r2
 800a504:	eb45 0303 	adc.w	r3, r5, r3
 800a508:	f8c7 345c 	str.w	r3, [r7, #1116]	@ 0x45c
 800a50c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a510:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a514:	e9d3 89ac 	ldrd	r8, r9, [r3, #688]	@ 0x2b0
 800a518:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a51c:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a520:	e9d3 45a8 	ldrd	r4, r5, [r3, #672]	@ 0x2a0
 800a524:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a528:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a52c:	e9d3 01aa 	ldrd	r0, r1, [r3, #680]	@ 0x2a8
 800a530:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a534:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a538:	e9d3 23ac 	ldrd	r2, r3, [r3, #688]	@ 0x2b0
 800a53c:	ea80 0602 	eor.w	r6, r0, r2
 800a540:	f8c7 6450 	str.w	r6, [r7, #1104]	@ 0x450
 800a544:	404b      	eors	r3, r1
 800a546:	f8c7 3454 	str.w	r3, [r7, #1108]	@ 0x454
 800a54a:	f507 638a 	add.w	r3, r7, #1104	@ 0x450
 800a54e:	e9d3 1200 	ldrd	r1, r2, [r3]
 800a552:	460b      	mov	r3, r1
 800a554:	4023      	ands	r3, r4
 800a556:	f8c7 3448 	str.w	r3, [r7, #1096]	@ 0x448
 800a55a:	4613      	mov	r3, r2
 800a55c:	402b      	ands	r3, r5
 800a55e:	f8c7 344c 	str.w	r3, [r7, #1100]	@ 0x44c
 800a562:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 800a566:	e9d3 1200 	ldrd	r1, r2, [r3]
 800a56a:	460b      	mov	r3, r1
 800a56c:	ea88 0303 	eor.w	r3, r8, r3
 800a570:	f8c7 3440 	str.w	r3, [r7, #1088]	@ 0x440
 800a574:	4613      	mov	r3, r2
 800a576:	ea89 0303 	eor.w	r3, r9, r3
 800a57a:	f8c7 3444 	str.w	r3, [r7, #1092]	@ 0x444
 800a57e:	f507 638b 	add.w	r3, r7, #1112	@ 0x458
 800a582:	e9d3 4500 	ldrd	r4, r5, [r3]
 800a586:	4623      	mov	r3, r4
 800a588:	f507 6288 	add.w	r2, r7, #1088	@ 0x440
 800a58c:	e9d2 0100 	ldrd	r0, r1, [r2]
 800a590:	4602      	mov	r2, r0
 800a592:	189b      	adds	r3, r3, r2
 800a594:	f8c7 3438 	str.w	r3, [r7, #1080]	@ 0x438
 800a598:	462b      	mov	r3, r5
 800a59a:	460a      	mov	r2, r1
 800a59c:	4153      	adcs	r3, r2
 800a59e:	f8c7 343c 	str.w	r3, [r7, #1084]	@ 0x43c
 800a5a2:	4afc      	ldr	r2, [pc, #1008]	@ (800a994 <mbedtls_internal_sha512_process+0x11dc>)
 800a5a4:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800a5a8:	00db      	lsls	r3, r3, #3
 800a5aa:	4413      	add	r3, r2
 800a5ac:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a5b0:	f507 6187 	add.w	r1, r7, #1080	@ 0x438
 800a5b4:	e9d1 4500 	ldrd	r4, r5, [r1]
 800a5b8:	4621      	mov	r1, r4
 800a5ba:	1889      	adds	r1, r1, r2
 800a5bc:	f8c7 1430 	str.w	r1, [r7, #1072]	@ 0x430
 800a5c0:	4629      	mov	r1, r5
 800a5c2:	eb41 0303 	adc.w	r3, r1, r3
 800a5c6:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
 800a5ca:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a5ce:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 800a5d2:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800a5d6:	3302      	adds	r3, #2
 800a5d8:	00db      	lsls	r3, r3, #3
 800a5da:	4413      	add	r3, r2
 800a5dc:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a5e0:	f507 6186 	add.w	r1, r7, #1072	@ 0x430
 800a5e4:	e9d1 4500 	ldrd	r4, r5, [r1]
 800a5e8:	4621      	mov	r1, r4
 800a5ea:	1889      	adds	r1, r1, r2
 800a5ec:	f8c7 1428 	str.w	r1, [r7, #1064]	@ 0x428
 800a5f0:	4629      	mov	r1, r5
 800a5f2:	eb41 0303 	adc.w	r3, r1, r3
 800a5f6:	f8c7 342c 	str.w	r3, [r7, #1068]	@ 0x42c
 800a5fa:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a5fe:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a602:	f507 6285 	add.w	r2, r7, #1064	@ 0x428
 800a606:	e9d2 1200 	ldrd	r1, r2, [r2]
 800a60a:	e9c3 1200 	strd	r1, r2, [r3]
 800a60e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a612:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a616:	e9d3 23b0 	ldrd	r2, r3, [r3, #704]	@ 0x2c0
 800a61a:	0118      	lsls	r0, r3, #4
 800a61c:	0f11      	lsrs	r1, r2, #28
 800a61e:	4301      	orrs	r1, r0
 800a620:	f8c7 1420 	str.w	r1, [r7, #1056]	@ 0x420
 800a624:	0111      	lsls	r1, r2, #4
 800a626:	0f1b      	lsrs	r3, r3, #28
 800a628:	430b      	orrs	r3, r1
 800a62a:	f8c7 3424 	str.w	r3, [r7, #1060]	@ 0x424
 800a62e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a632:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a636:	e9d3 23b0 	ldrd	r2, r3, [r3, #704]	@ 0x2c0
 800a63a:	0890      	lsrs	r0, r2, #2
 800a63c:	0799      	lsls	r1, r3, #30
 800a63e:	4301      	orrs	r1, r0
 800a640:	f8c7 141c 	str.w	r1, [r7, #1052]	@ 0x41c
 800a644:	0899      	lsrs	r1, r3, #2
 800a646:	0793      	lsls	r3, r2, #30
 800a648:	430b      	orrs	r3, r1
 800a64a:	f8c7 3418 	str.w	r3, [r7, #1048]	@ 0x418
 800a64e:	f507 6384 	add.w	r3, r7, #1056	@ 0x420
 800a652:	e9d3 4500 	ldrd	r4, r5, [r3]
 800a656:	4623      	mov	r3, r4
 800a658:	f507 6283 	add.w	r2, r7, #1048	@ 0x418
 800a65c:	e9d2 0100 	ldrd	r0, r1, [r2]
 800a660:	4602      	mov	r2, r0
 800a662:	4053      	eors	r3, r2
 800a664:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
 800a668:	462b      	mov	r3, r5
 800a66a:	460a      	mov	r2, r1
 800a66c:	4053      	eors	r3, r2
 800a66e:	f8c7 3414 	str.w	r3, [r7, #1044]	@ 0x414
 800a672:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a676:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a67a:	e9d3 23b0 	ldrd	r2, r3, [r3, #704]	@ 0x2c0
 800a67e:	09d0      	lsrs	r0, r2, #7
 800a680:	0659      	lsls	r1, r3, #25
 800a682:	4301      	orrs	r1, r0
 800a684:	f8c7 140c 	str.w	r1, [r7, #1036]	@ 0x40c
 800a688:	09d9      	lsrs	r1, r3, #7
 800a68a:	0653      	lsls	r3, r2, #25
 800a68c:	430b      	orrs	r3, r1
 800a68e:	f8c7 3408 	str.w	r3, [r7, #1032]	@ 0x408
 800a692:	f507 6382 	add.w	r3, r7, #1040	@ 0x410
 800a696:	e9d3 4500 	ldrd	r4, r5, [r3]
 800a69a:	4623      	mov	r3, r4
 800a69c:	f507 6281 	add.w	r2, r7, #1032	@ 0x408
 800a6a0:	e9d2 0100 	ldrd	r0, r1, [r2]
 800a6a4:	4602      	mov	r2, r0
 800a6a6:	4053      	eors	r3, r2
 800a6a8:	f8c7 3400 	str.w	r3, [r7, #1024]	@ 0x400
 800a6ac:	462b      	mov	r3, r5
 800a6ae:	460a      	mov	r2, r1
 800a6b0:	4053      	eors	r3, r2
 800a6b2:	f8c7 3404 	str.w	r3, [r7, #1028]	@ 0x404
 800a6b6:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a6ba:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a6be:	e9d3 01b0 	ldrd	r0, r1, [r3, #704]	@ 0x2c0
 800a6c2:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a6c6:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a6ca:	e9d3 23b2 	ldrd	r2, r3, [r3, #712]	@ 0x2c8
 800a6ce:	ea00 0402 	and.w	r4, r0, r2
 800a6d2:	f8c7 43f8 	str.w	r4, [r7, #1016]	@ 0x3f8
 800a6d6:	400b      	ands	r3, r1
 800a6d8:	f8c7 33fc 	str.w	r3, [r7, #1020]	@ 0x3fc
 800a6dc:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a6e0:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a6e4:	e9d3 45a4 	ldrd	r4, r5, [r3, #656]	@ 0x290
 800a6e8:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a6ec:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a6f0:	e9d3 01b0 	ldrd	r0, r1, [r3, #704]	@ 0x2c0
 800a6f4:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a6f8:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a6fc:	e9d3 23b2 	ldrd	r2, r3, [r3, #712]	@ 0x2c8
 800a700:	ea40 0602 	orr.w	r6, r0, r2
 800a704:	f8c7 63f0 	str.w	r6, [r7, #1008]	@ 0x3f0
 800a708:	430b      	orrs	r3, r1
 800a70a:	f8c7 33f4 	str.w	r3, [r7, #1012]	@ 0x3f4
 800a70e:	e9d7 12fc 	ldrd	r1, r2, [r7, #1008]	@ 0x3f0
 800a712:	460b      	mov	r3, r1
 800a714:	4023      	ands	r3, r4
 800a716:	f8c7 33e8 	str.w	r3, [r7, #1000]	@ 0x3e8
 800a71a:	4613      	mov	r3, r2
 800a71c:	402b      	ands	r3, r5
 800a71e:	f8c7 33ec 	str.w	r3, [r7, #1004]	@ 0x3ec
 800a722:	e9d7 45fe 	ldrd	r4, r5, [r7, #1016]	@ 0x3f8
 800a726:	4623      	mov	r3, r4
 800a728:	e9d7 01fa 	ldrd	r0, r1, [r7, #1000]	@ 0x3e8
 800a72c:	4602      	mov	r2, r0
 800a72e:	4313      	orrs	r3, r2
 800a730:	f8c7 33e0 	str.w	r3, [r7, #992]	@ 0x3e0
 800a734:	462b      	mov	r3, r5
 800a736:	460a      	mov	r2, r1
 800a738:	4313      	orrs	r3, r2
 800a73a:	f8c7 33e4 	str.w	r3, [r7, #996]	@ 0x3e4
 800a73e:	f507 6380 	add.w	r3, r7, #1024	@ 0x400
 800a742:	e9d3 4500 	ldrd	r4, r5, [r3]
 800a746:	4623      	mov	r3, r4
 800a748:	e9d7 01f8 	ldrd	r0, r1, [r7, #992]	@ 0x3e0
 800a74c:	4602      	mov	r2, r0
 800a74e:	189b      	adds	r3, r3, r2
 800a750:	f8c7 33d8 	str.w	r3, [r7, #984]	@ 0x3d8
 800a754:	462b      	mov	r3, r5
 800a756:	460a      	mov	r2, r1
 800a758:	4153      	adcs	r3, r2
 800a75a:	f8c7 33dc 	str.w	r3, [r7, #988]	@ 0x3dc
 800a75e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a762:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a766:	e9d7 12f6 	ldrd	r1, r2, [r7, #984]	@ 0x3d8
 800a76a:	e9c3 1202 	strd	r1, r2, [r3, #8]
 800a76e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a772:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a776:	e9d3 01a6 	ldrd	r0, r1, [r3, #664]	@ 0x298
 800a77a:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a77e:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a782:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a786:	1884      	adds	r4, r0, r2
 800a788:	f8c7 43d0 	str.w	r4, [r7, #976]	@ 0x3d0
 800a78c:	eb41 0303 	adc.w	r3, r1, r3
 800a790:	f8c7 33d4 	str.w	r3, [r7, #980]	@ 0x3d4
 800a794:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a798:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a79c:	e9d7 12f4 	ldrd	r1, r2, [r7, #976]	@ 0x3d0
 800a7a0:	e9c3 12a6 	strd	r1, r2, [r3, #664]	@ 0x298
 800a7a4:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a7a8:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a7ac:	e9d3 0100 	ldrd	r0, r1, [r3]
 800a7b0:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a7b4:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a7b8:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a7bc:	1884      	adds	r4, r0, r2
 800a7be:	f8c7 43c8 	str.w	r4, [r7, #968]	@ 0x3c8
 800a7c2:	eb41 0303 	adc.w	r3, r1, r3
 800a7c6:	f8c7 33cc 	str.w	r3, [r7, #972]	@ 0x3cc
 800a7ca:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a7ce:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a7d2:	e9d7 12f2 	ldrd	r1, r2, [r7, #968]	@ 0x3c8
 800a7d6:	e9c3 12ae 	strd	r1, r2, [r3, #696]	@ 0x2b8
           local.A[3], local.A[4], local.A[5], local.W[i], K[i] ); i++;
 800a7da:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800a7de:	3301      	adds	r3, #1
 800a7e0:	f8c7 39a4 	str.w	r3, [r7, #2468]	@ 0x9a4
        P( local.A[5], local.A[6], local.A[7], local.A[0], local.A[1],
 800a7e4:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a7e8:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a7ec:	e9d3 45ac 	ldrd	r4, r5, [r3, #688]	@ 0x2b0
 800a7f0:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a7f4:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a7f8:	e9d3 23a6 	ldrd	r2, r3, [r3, #664]	@ 0x298
 800a7fc:	0498      	lsls	r0, r3, #18
 800a7fe:	0b91      	lsrs	r1, r2, #14
 800a800:	4301      	orrs	r1, r0
 800a802:	f8c7 13c0 	str.w	r1, [r7, #960]	@ 0x3c0
 800a806:	0491      	lsls	r1, r2, #18
 800a808:	0b9b      	lsrs	r3, r3, #14
 800a80a:	430b      	orrs	r3, r1
 800a80c:	f8c7 33c4 	str.w	r3, [r7, #964]	@ 0x3c4
 800a810:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a814:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a818:	e9d3 23a6 	ldrd	r2, r3, [r3, #664]	@ 0x298
 800a81c:	0398      	lsls	r0, r3, #14
 800a81e:	0c91      	lsrs	r1, r2, #18
 800a820:	4301      	orrs	r1, r0
 800a822:	f8c7 13b8 	str.w	r1, [r7, #952]	@ 0x3b8
 800a826:	0391      	lsls	r1, r2, #14
 800a828:	0c9b      	lsrs	r3, r3, #18
 800a82a:	430b      	orrs	r3, r1
 800a82c:	f8c7 33bc 	str.w	r3, [r7, #956]	@ 0x3bc
 800a830:	e9d7 89f0 	ldrd	r8, r9, [r7, #960]	@ 0x3c0
 800a834:	4643      	mov	r3, r8
 800a836:	e9d7 01ee 	ldrd	r0, r1, [r7, #952]	@ 0x3b8
 800a83a:	4602      	mov	r2, r0
 800a83c:	4053      	eors	r3, r2
 800a83e:	f8c7 33b0 	str.w	r3, [r7, #944]	@ 0x3b0
 800a842:	464b      	mov	r3, r9
 800a844:	460a      	mov	r2, r1
 800a846:	4053      	eors	r3, r2
 800a848:	f8c7 33b4 	str.w	r3, [r7, #948]	@ 0x3b4
 800a84c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a850:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a854:	e9d3 23a6 	ldrd	r2, r3, [r3, #664]	@ 0x298
 800a858:	0a50      	lsrs	r0, r2, #9
 800a85a:	05d9      	lsls	r1, r3, #23
 800a85c:	4301      	orrs	r1, r0
 800a85e:	f8c7 13ac 	str.w	r1, [r7, #940]	@ 0x3ac
 800a862:	0a59      	lsrs	r1, r3, #9
 800a864:	05d3      	lsls	r3, r2, #23
 800a866:	430b      	orrs	r3, r1
 800a868:	f8c7 33a8 	str.w	r3, [r7, #936]	@ 0x3a8
 800a86c:	e9d7 89ec 	ldrd	r8, r9, [r7, #944]	@ 0x3b0
 800a870:	4643      	mov	r3, r8
 800a872:	e9d7 01ea 	ldrd	r0, r1, [r7, #936]	@ 0x3a8
 800a876:	4602      	mov	r2, r0
 800a878:	4053      	eors	r3, r2
 800a87a:	f8c7 33a0 	str.w	r3, [r7, #928]	@ 0x3a0
 800a87e:	464b      	mov	r3, r9
 800a880:	460a      	mov	r2, r1
 800a882:	4053      	eors	r3, r2
 800a884:	f8c7 33a4 	str.w	r3, [r7, #932]	@ 0x3a4
 800a888:	e9d7 12e8 	ldrd	r1, r2, [r7, #928]	@ 0x3a0
 800a88c:	460b      	mov	r3, r1
 800a88e:	18e3      	adds	r3, r4, r3
 800a890:	f8c7 3398 	str.w	r3, [r7, #920]	@ 0x398
 800a894:	4613      	mov	r3, r2
 800a896:	eb45 0303 	adc.w	r3, r5, r3
 800a89a:	f8c7 339c 	str.w	r3, [r7, #924]	@ 0x39c
 800a89e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a8a2:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a8a6:	e9d3 89aa 	ldrd	r8, r9, [r3, #680]	@ 0x2a8
 800a8aa:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a8ae:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a8b2:	e9d3 45a6 	ldrd	r4, r5, [r3, #664]	@ 0x298
 800a8b6:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a8ba:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a8be:	e9d3 01a8 	ldrd	r0, r1, [r3, #672]	@ 0x2a0
 800a8c2:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a8c6:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a8ca:	e9d3 23aa 	ldrd	r2, r3, [r3, #680]	@ 0x2a8
 800a8ce:	ea80 0602 	eor.w	r6, r0, r2
 800a8d2:	f8c7 6390 	str.w	r6, [r7, #912]	@ 0x390
 800a8d6:	404b      	eors	r3, r1
 800a8d8:	f8c7 3394 	str.w	r3, [r7, #916]	@ 0x394
 800a8dc:	e9d7 12e4 	ldrd	r1, r2, [r7, #912]	@ 0x390
 800a8e0:	460b      	mov	r3, r1
 800a8e2:	4023      	ands	r3, r4
 800a8e4:	f8c7 3388 	str.w	r3, [r7, #904]	@ 0x388
 800a8e8:	4613      	mov	r3, r2
 800a8ea:	402b      	ands	r3, r5
 800a8ec:	f8c7 338c 	str.w	r3, [r7, #908]	@ 0x38c
 800a8f0:	e9d7 12e2 	ldrd	r1, r2, [r7, #904]	@ 0x388
 800a8f4:	460b      	mov	r3, r1
 800a8f6:	ea88 0303 	eor.w	r3, r8, r3
 800a8fa:	f8c7 3380 	str.w	r3, [r7, #896]	@ 0x380
 800a8fe:	4613      	mov	r3, r2
 800a900:	ea89 0303 	eor.w	r3, r9, r3
 800a904:	f8c7 3384 	str.w	r3, [r7, #900]	@ 0x384
 800a908:	e9d7 45e6 	ldrd	r4, r5, [r7, #920]	@ 0x398
 800a90c:	4623      	mov	r3, r4
 800a90e:	e9d7 01e0 	ldrd	r0, r1, [r7, #896]	@ 0x380
 800a912:	4602      	mov	r2, r0
 800a914:	189b      	adds	r3, r3, r2
 800a916:	f8c7 3378 	str.w	r3, [r7, #888]	@ 0x378
 800a91a:	462b      	mov	r3, r5
 800a91c:	460a      	mov	r2, r1
 800a91e:	4153      	adcs	r3, r2
 800a920:	f8c7 337c 	str.w	r3, [r7, #892]	@ 0x37c
 800a924:	4a1b      	ldr	r2, [pc, #108]	@ (800a994 <mbedtls_internal_sha512_process+0x11dc>)
 800a926:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800a92a:	00db      	lsls	r3, r3, #3
 800a92c:	4413      	add	r3, r2
 800a92e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a932:	e9d7 45de 	ldrd	r4, r5, [r7, #888]	@ 0x378
 800a936:	4621      	mov	r1, r4
 800a938:	1889      	adds	r1, r1, r2
 800a93a:	f8c7 1370 	str.w	r1, [r7, #880]	@ 0x370
 800a93e:	4629      	mov	r1, r5
 800a940:	eb41 0303 	adc.w	r3, r1, r3
 800a944:	f8c7 3374 	str.w	r3, [r7, #884]	@ 0x374
 800a948:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a94c:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 800a950:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800a954:	3302      	adds	r3, #2
 800a956:	00db      	lsls	r3, r3, #3
 800a958:	4413      	add	r3, r2
 800a95a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a95e:	e9d7 45dc 	ldrd	r4, r5, [r7, #880]	@ 0x370
 800a962:	4621      	mov	r1, r4
 800a964:	1889      	adds	r1, r1, r2
 800a966:	f8c7 1368 	str.w	r1, [r7, #872]	@ 0x368
 800a96a:	4629      	mov	r1, r5
 800a96c:	eb41 0303 	adc.w	r3, r1, r3
 800a970:	f8c7 336c 	str.w	r3, [r7, #876]	@ 0x36c
 800a974:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a978:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a97c:	e9d7 12da 	ldrd	r1, r2, [r7, #872]	@ 0x368
 800a980:	e9c3 1200 	strd	r1, r2, [r3]
 800a984:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a988:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a98c:	e9d3 23ae 	ldrd	r2, r3, [r3, #696]	@ 0x2b8
 800a990:	0118      	lsls	r0, r3, #4
 800a992:	e001      	b.n	800a998 <mbedtls_internal_sha512_process+0x11e0>
 800a994:	08016d50 	.word	0x08016d50
 800a998:	0f11      	lsrs	r1, r2, #28
 800a99a:	4301      	orrs	r1, r0
 800a99c:	f8c7 1360 	str.w	r1, [r7, #864]	@ 0x360
 800a9a0:	0111      	lsls	r1, r2, #4
 800a9a2:	0f1b      	lsrs	r3, r3, #28
 800a9a4:	430b      	orrs	r3, r1
 800a9a6:	f8c7 3364 	str.w	r3, [r7, #868]	@ 0x364
 800a9aa:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a9ae:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a9b2:	e9d3 23ae 	ldrd	r2, r3, [r3, #696]	@ 0x2b8
 800a9b6:	0890      	lsrs	r0, r2, #2
 800a9b8:	0799      	lsls	r1, r3, #30
 800a9ba:	4301      	orrs	r1, r0
 800a9bc:	f8c7 135c 	str.w	r1, [r7, #860]	@ 0x35c
 800a9c0:	0899      	lsrs	r1, r3, #2
 800a9c2:	0793      	lsls	r3, r2, #30
 800a9c4:	430b      	orrs	r3, r1
 800a9c6:	f8c7 3358 	str.w	r3, [r7, #856]	@ 0x358
 800a9ca:	e9d7 45d8 	ldrd	r4, r5, [r7, #864]	@ 0x360
 800a9ce:	4623      	mov	r3, r4
 800a9d0:	e9d7 01d6 	ldrd	r0, r1, [r7, #856]	@ 0x358
 800a9d4:	4602      	mov	r2, r0
 800a9d6:	4053      	eors	r3, r2
 800a9d8:	f8c7 3350 	str.w	r3, [r7, #848]	@ 0x350
 800a9dc:	462b      	mov	r3, r5
 800a9de:	460a      	mov	r2, r1
 800a9e0:	4053      	eors	r3, r2
 800a9e2:	f8c7 3354 	str.w	r3, [r7, #852]	@ 0x354
 800a9e6:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800a9ea:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800a9ee:	e9d3 23ae 	ldrd	r2, r3, [r3, #696]	@ 0x2b8
 800a9f2:	09d0      	lsrs	r0, r2, #7
 800a9f4:	0659      	lsls	r1, r3, #25
 800a9f6:	4301      	orrs	r1, r0
 800a9f8:	f8c7 134c 	str.w	r1, [r7, #844]	@ 0x34c
 800a9fc:	09d9      	lsrs	r1, r3, #7
 800a9fe:	0653      	lsls	r3, r2, #25
 800aa00:	430b      	orrs	r3, r1
 800aa02:	f8c7 3348 	str.w	r3, [r7, #840]	@ 0x348
 800aa06:	e9d7 45d4 	ldrd	r4, r5, [r7, #848]	@ 0x350
 800aa0a:	4623      	mov	r3, r4
 800aa0c:	e9d7 01d2 	ldrd	r0, r1, [r7, #840]	@ 0x348
 800aa10:	4602      	mov	r2, r0
 800aa12:	4053      	eors	r3, r2
 800aa14:	f8c7 3340 	str.w	r3, [r7, #832]	@ 0x340
 800aa18:	462b      	mov	r3, r5
 800aa1a:	460a      	mov	r2, r1
 800aa1c:	4053      	eors	r3, r2
 800aa1e:	f8c7 3344 	str.w	r3, [r7, #836]	@ 0x344
 800aa22:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800aa26:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800aa2a:	e9d3 01ae 	ldrd	r0, r1, [r3, #696]	@ 0x2b8
 800aa2e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800aa32:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800aa36:	e9d3 23b0 	ldrd	r2, r3, [r3, #704]	@ 0x2c0
 800aa3a:	ea00 0402 	and.w	r4, r0, r2
 800aa3e:	f8c7 4338 	str.w	r4, [r7, #824]	@ 0x338
 800aa42:	400b      	ands	r3, r1
 800aa44:	f8c7 333c 	str.w	r3, [r7, #828]	@ 0x33c
 800aa48:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800aa4c:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800aa50:	e9d3 45b2 	ldrd	r4, r5, [r3, #712]	@ 0x2c8
 800aa54:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800aa58:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800aa5c:	e9d3 01ae 	ldrd	r0, r1, [r3, #696]	@ 0x2b8
 800aa60:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800aa64:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800aa68:	e9d3 23b0 	ldrd	r2, r3, [r3, #704]	@ 0x2c0
 800aa6c:	ea40 0602 	orr.w	r6, r0, r2
 800aa70:	f8c7 6330 	str.w	r6, [r7, #816]	@ 0x330
 800aa74:	430b      	orrs	r3, r1
 800aa76:	f8c7 3334 	str.w	r3, [r7, #820]	@ 0x334
 800aa7a:	e9d7 12cc 	ldrd	r1, r2, [r7, #816]	@ 0x330
 800aa7e:	460b      	mov	r3, r1
 800aa80:	4023      	ands	r3, r4
 800aa82:	f8c7 3328 	str.w	r3, [r7, #808]	@ 0x328
 800aa86:	4613      	mov	r3, r2
 800aa88:	402b      	ands	r3, r5
 800aa8a:	f8c7 332c 	str.w	r3, [r7, #812]	@ 0x32c
 800aa8e:	e9d7 45ce 	ldrd	r4, r5, [r7, #824]	@ 0x338
 800aa92:	4623      	mov	r3, r4
 800aa94:	e9d7 01ca 	ldrd	r0, r1, [r7, #808]	@ 0x328
 800aa98:	4602      	mov	r2, r0
 800aa9a:	4313      	orrs	r3, r2
 800aa9c:	f8c7 3320 	str.w	r3, [r7, #800]	@ 0x320
 800aaa0:	462b      	mov	r3, r5
 800aaa2:	460a      	mov	r2, r1
 800aaa4:	4313      	orrs	r3, r2
 800aaa6:	f8c7 3324 	str.w	r3, [r7, #804]	@ 0x324
 800aaaa:	e9d7 45d0 	ldrd	r4, r5, [r7, #832]	@ 0x340
 800aaae:	4623      	mov	r3, r4
 800aab0:	e9d7 01c8 	ldrd	r0, r1, [r7, #800]	@ 0x320
 800aab4:	4602      	mov	r2, r0
 800aab6:	189b      	adds	r3, r3, r2
 800aab8:	f8c7 3318 	str.w	r3, [r7, #792]	@ 0x318
 800aabc:	462b      	mov	r3, r5
 800aabe:	460a      	mov	r2, r1
 800aac0:	4153      	adcs	r3, r2
 800aac2:	f8c7 331c 	str.w	r3, [r7, #796]	@ 0x31c
 800aac6:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800aaca:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800aace:	e9d7 12c6 	ldrd	r1, r2, [r7, #792]	@ 0x318
 800aad2:	e9c3 1202 	strd	r1, r2, [r3, #8]
 800aad6:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800aada:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800aade:	e9d3 01a4 	ldrd	r0, r1, [r3, #656]	@ 0x290
 800aae2:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800aae6:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800aaea:	e9d3 2300 	ldrd	r2, r3, [r3]
 800aaee:	1884      	adds	r4, r0, r2
 800aaf0:	f8c7 4310 	str.w	r4, [r7, #784]	@ 0x310
 800aaf4:	eb41 0303 	adc.w	r3, r1, r3
 800aaf8:	f8c7 3314 	str.w	r3, [r7, #788]	@ 0x314
 800aafc:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ab00:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ab04:	e9d7 12c4 	ldrd	r1, r2, [r7, #784]	@ 0x310
 800ab08:	e9c3 12a4 	strd	r1, r2, [r3, #656]	@ 0x290
 800ab0c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ab10:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ab14:	e9d3 0100 	ldrd	r0, r1, [r3]
 800ab18:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ab1c:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ab20:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800ab24:	1884      	adds	r4, r0, r2
 800ab26:	f8c7 4308 	str.w	r4, [r7, #776]	@ 0x308
 800ab2a:	eb41 0303 	adc.w	r3, r1, r3
 800ab2e:	f8c7 330c 	str.w	r3, [r7, #780]	@ 0x30c
 800ab32:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ab36:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ab3a:	e9d7 12c2 	ldrd	r1, r2, [r7, #776]	@ 0x308
 800ab3e:	e9c3 12ac 	strd	r1, r2, [r3, #688]	@ 0x2b0
           local.A[2], local.A[3], local.A[4], local.W[i], K[i] ); i++;
 800ab42:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800ab46:	3301      	adds	r3, #1
 800ab48:	f8c7 39a4 	str.w	r3, [r7, #2468]	@ 0x9a4
        P( local.A[4], local.A[5], local.A[6], local.A[7], local.A[0],
 800ab4c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ab50:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ab54:	e9d3 45aa 	ldrd	r4, r5, [r3, #680]	@ 0x2a8
 800ab58:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ab5c:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ab60:	e9d3 23a4 	ldrd	r2, r3, [r3, #656]	@ 0x290
 800ab64:	0498      	lsls	r0, r3, #18
 800ab66:	0b91      	lsrs	r1, r2, #14
 800ab68:	4301      	orrs	r1, r0
 800ab6a:	f8c7 1300 	str.w	r1, [r7, #768]	@ 0x300
 800ab6e:	0491      	lsls	r1, r2, #18
 800ab70:	0b9b      	lsrs	r3, r3, #14
 800ab72:	430b      	orrs	r3, r1
 800ab74:	f8c7 3304 	str.w	r3, [r7, #772]	@ 0x304
 800ab78:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ab7c:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ab80:	e9d3 23a4 	ldrd	r2, r3, [r3, #656]	@ 0x290
 800ab84:	0398      	lsls	r0, r3, #14
 800ab86:	0c91      	lsrs	r1, r2, #18
 800ab88:	4301      	orrs	r1, r0
 800ab8a:	f8c7 12f8 	str.w	r1, [r7, #760]	@ 0x2f8
 800ab8e:	0391      	lsls	r1, r2, #14
 800ab90:	0c9b      	lsrs	r3, r3, #18
 800ab92:	430b      	orrs	r3, r1
 800ab94:	f8c7 32fc 	str.w	r3, [r7, #764]	@ 0x2fc
 800ab98:	e9d7 89c0 	ldrd	r8, r9, [r7, #768]	@ 0x300
 800ab9c:	4643      	mov	r3, r8
 800ab9e:	e9d7 01be 	ldrd	r0, r1, [r7, #760]	@ 0x2f8
 800aba2:	4602      	mov	r2, r0
 800aba4:	4053      	eors	r3, r2
 800aba6:	f8c7 32f0 	str.w	r3, [r7, #752]	@ 0x2f0
 800abaa:	464b      	mov	r3, r9
 800abac:	460a      	mov	r2, r1
 800abae:	4053      	eors	r3, r2
 800abb0:	f8c7 32f4 	str.w	r3, [r7, #756]	@ 0x2f4
 800abb4:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800abb8:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800abbc:	e9d3 23a4 	ldrd	r2, r3, [r3, #656]	@ 0x290
 800abc0:	0a50      	lsrs	r0, r2, #9
 800abc2:	05d9      	lsls	r1, r3, #23
 800abc4:	4301      	orrs	r1, r0
 800abc6:	f8c7 12ec 	str.w	r1, [r7, #748]	@ 0x2ec
 800abca:	0a59      	lsrs	r1, r3, #9
 800abcc:	05d3      	lsls	r3, r2, #23
 800abce:	430b      	orrs	r3, r1
 800abd0:	f8c7 32e8 	str.w	r3, [r7, #744]	@ 0x2e8
 800abd4:	e9d7 89bc 	ldrd	r8, r9, [r7, #752]	@ 0x2f0
 800abd8:	4643      	mov	r3, r8
 800abda:	e9d7 01ba 	ldrd	r0, r1, [r7, #744]	@ 0x2e8
 800abde:	4602      	mov	r2, r0
 800abe0:	4053      	eors	r3, r2
 800abe2:	f8c7 32e0 	str.w	r3, [r7, #736]	@ 0x2e0
 800abe6:	464b      	mov	r3, r9
 800abe8:	460a      	mov	r2, r1
 800abea:	4053      	eors	r3, r2
 800abec:	f8c7 32e4 	str.w	r3, [r7, #740]	@ 0x2e4
 800abf0:	e9d7 12b8 	ldrd	r1, r2, [r7, #736]	@ 0x2e0
 800abf4:	460b      	mov	r3, r1
 800abf6:	18e3      	adds	r3, r4, r3
 800abf8:	f8c7 32d8 	str.w	r3, [r7, #728]	@ 0x2d8
 800abfc:	4613      	mov	r3, r2
 800abfe:	eb45 0303 	adc.w	r3, r5, r3
 800ac02:	f8c7 32dc 	str.w	r3, [r7, #732]	@ 0x2dc
 800ac06:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ac0a:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ac0e:	e9d3 89a8 	ldrd	r8, r9, [r3, #672]	@ 0x2a0
 800ac12:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ac16:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ac1a:	e9d3 45a4 	ldrd	r4, r5, [r3, #656]	@ 0x290
 800ac1e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ac22:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ac26:	e9d3 01a6 	ldrd	r0, r1, [r3, #664]	@ 0x298
 800ac2a:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ac2e:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ac32:	e9d3 23a8 	ldrd	r2, r3, [r3, #672]	@ 0x2a0
 800ac36:	ea80 0602 	eor.w	r6, r0, r2
 800ac3a:	f8c7 62d0 	str.w	r6, [r7, #720]	@ 0x2d0
 800ac3e:	404b      	eors	r3, r1
 800ac40:	f8c7 32d4 	str.w	r3, [r7, #724]	@ 0x2d4
 800ac44:	e9d7 12b4 	ldrd	r1, r2, [r7, #720]	@ 0x2d0
 800ac48:	460b      	mov	r3, r1
 800ac4a:	4023      	ands	r3, r4
 800ac4c:	f8c7 32c8 	str.w	r3, [r7, #712]	@ 0x2c8
 800ac50:	4613      	mov	r3, r2
 800ac52:	402b      	ands	r3, r5
 800ac54:	f8c7 32cc 	str.w	r3, [r7, #716]	@ 0x2cc
 800ac58:	e9d7 12b2 	ldrd	r1, r2, [r7, #712]	@ 0x2c8
 800ac5c:	460b      	mov	r3, r1
 800ac5e:	ea88 0303 	eor.w	r3, r8, r3
 800ac62:	f8c7 32c0 	str.w	r3, [r7, #704]	@ 0x2c0
 800ac66:	4613      	mov	r3, r2
 800ac68:	ea89 0303 	eor.w	r3, r9, r3
 800ac6c:	f8c7 32c4 	str.w	r3, [r7, #708]	@ 0x2c4
 800ac70:	e9d7 45b6 	ldrd	r4, r5, [r7, #728]	@ 0x2d8
 800ac74:	4623      	mov	r3, r4
 800ac76:	e9d7 01b0 	ldrd	r0, r1, [r7, #704]	@ 0x2c0
 800ac7a:	4602      	mov	r2, r0
 800ac7c:	189b      	adds	r3, r3, r2
 800ac7e:	f8c7 32b8 	str.w	r3, [r7, #696]	@ 0x2b8
 800ac82:	462b      	mov	r3, r5
 800ac84:	460a      	mov	r2, r1
 800ac86:	4153      	adcs	r3, r2
 800ac88:	f8c7 32bc 	str.w	r3, [r7, #700]	@ 0x2bc
 800ac8c:	4afc      	ldr	r2, [pc, #1008]	@ (800b080 <mbedtls_internal_sha512_process+0x18c8>)
 800ac8e:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800ac92:	00db      	lsls	r3, r3, #3
 800ac94:	4413      	add	r3, r2
 800ac96:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ac9a:	e9d7 45ae 	ldrd	r4, r5, [r7, #696]	@ 0x2b8
 800ac9e:	4621      	mov	r1, r4
 800aca0:	1889      	adds	r1, r1, r2
 800aca2:	f8c7 12b0 	str.w	r1, [r7, #688]	@ 0x2b0
 800aca6:	4629      	mov	r1, r5
 800aca8:	eb41 0303 	adc.w	r3, r1, r3
 800acac:	f8c7 32b4 	str.w	r3, [r7, #692]	@ 0x2b4
 800acb0:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800acb4:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 800acb8:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800acbc:	3302      	adds	r3, #2
 800acbe:	00db      	lsls	r3, r3, #3
 800acc0:	4413      	add	r3, r2
 800acc2:	e9d3 2300 	ldrd	r2, r3, [r3]
 800acc6:	e9d7 45ac 	ldrd	r4, r5, [r7, #688]	@ 0x2b0
 800acca:	4621      	mov	r1, r4
 800accc:	1889      	adds	r1, r1, r2
 800acce:	f8c7 12a8 	str.w	r1, [r7, #680]	@ 0x2a8
 800acd2:	4629      	mov	r1, r5
 800acd4:	eb41 0303 	adc.w	r3, r1, r3
 800acd8:	f8c7 32ac 	str.w	r3, [r7, #684]	@ 0x2ac
 800acdc:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ace0:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ace4:	e9d7 12aa 	ldrd	r1, r2, [r7, #680]	@ 0x2a8
 800ace8:	e9c3 1200 	strd	r1, r2, [r3]
 800acec:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800acf0:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800acf4:	e9d3 23ac 	ldrd	r2, r3, [r3, #688]	@ 0x2b0
 800acf8:	0118      	lsls	r0, r3, #4
 800acfa:	0f11      	lsrs	r1, r2, #28
 800acfc:	4301      	orrs	r1, r0
 800acfe:	f8c7 12a0 	str.w	r1, [r7, #672]	@ 0x2a0
 800ad02:	0111      	lsls	r1, r2, #4
 800ad04:	0f1b      	lsrs	r3, r3, #28
 800ad06:	430b      	orrs	r3, r1
 800ad08:	f8c7 32a4 	str.w	r3, [r7, #676]	@ 0x2a4
 800ad0c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ad10:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ad14:	e9d3 23ac 	ldrd	r2, r3, [r3, #688]	@ 0x2b0
 800ad18:	0890      	lsrs	r0, r2, #2
 800ad1a:	0799      	lsls	r1, r3, #30
 800ad1c:	4301      	orrs	r1, r0
 800ad1e:	f8c7 129c 	str.w	r1, [r7, #668]	@ 0x29c
 800ad22:	0899      	lsrs	r1, r3, #2
 800ad24:	0793      	lsls	r3, r2, #30
 800ad26:	430b      	orrs	r3, r1
 800ad28:	f8c7 3298 	str.w	r3, [r7, #664]	@ 0x298
 800ad2c:	e9d7 45a8 	ldrd	r4, r5, [r7, #672]	@ 0x2a0
 800ad30:	4623      	mov	r3, r4
 800ad32:	e9d7 01a6 	ldrd	r0, r1, [r7, #664]	@ 0x298
 800ad36:	4602      	mov	r2, r0
 800ad38:	4053      	eors	r3, r2
 800ad3a:	f8c7 3290 	str.w	r3, [r7, #656]	@ 0x290
 800ad3e:	462b      	mov	r3, r5
 800ad40:	460a      	mov	r2, r1
 800ad42:	4053      	eors	r3, r2
 800ad44:	f8c7 3294 	str.w	r3, [r7, #660]	@ 0x294
 800ad48:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ad4c:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ad50:	e9d3 23ac 	ldrd	r2, r3, [r3, #688]	@ 0x2b0
 800ad54:	09d0      	lsrs	r0, r2, #7
 800ad56:	0659      	lsls	r1, r3, #25
 800ad58:	4301      	orrs	r1, r0
 800ad5a:	f8c7 128c 	str.w	r1, [r7, #652]	@ 0x28c
 800ad5e:	09d9      	lsrs	r1, r3, #7
 800ad60:	0653      	lsls	r3, r2, #25
 800ad62:	430b      	orrs	r3, r1
 800ad64:	f8c7 3288 	str.w	r3, [r7, #648]	@ 0x288
 800ad68:	e9d7 45a4 	ldrd	r4, r5, [r7, #656]	@ 0x290
 800ad6c:	4623      	mov	r3, r4
 800ad6e:	e9d7 01a2 	ldrd	r0, r1, [r7, #648]	@ 0x288
 800ad72:	4602      	mov	r2, r0
 800ad74:	4053      	eors	r3, r2
 800ad76:	f8c7 3280 	str.w	r3, [r7, #640]	@ 0x280
 800ad7a:	462b      	mov	r3, r5
 800ad7c:	460a      	mov	r2, r1
 800ad7e:	4053      	eors	r3, r2
 800ad80:	f8c7 3284 	str.w	r3, [r7, #644]	@ 0x284
 800ad84:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ad88:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ad8c:	e9d3 01ac 	ldrd	r0, r1, [r3, #688]	@ 0x2b0
 800ad90:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ad94:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ad98:	e9d3 23ae 	ldrd	r2, r3, [r3, #696]	@ 0x2b8
 800ad9c:	ea00 0402 	and.w	r4, r0, r2
 800ada0:	f8c7 4278 	str.w	r4, [r7, #632]	@ 0x278
 800ada4:	400b      	ands	r3, r1
 800ada6:	f8c7 327c 	str.w	r3, [r7, #636]	@ 0x27c
 800adaa:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800adae:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800adb2:	e9d3 45b0 	ldrd	r4, r5, [r3, #704]	@ 0x2c0
 800adb6:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800adba:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800adbe:	e9d3 01ac 	ldrd	r0, r1, [r3, #688]	@ 0x2b0
 800adc2:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800adc6:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800adca:	e9d3 23ae 	ldrd	r2, r3, [r3, #696]	@ 0x2b8
 800adce:	ea40 0602 	orr.w	r6, r0, r2
 800add2:	f8c7 6270 	str.w	r6, [r7, #624]	@ 0x270
 800add6:	430b      	orrs	r3, r1
 800add8:	f8c7 3274 	str.w	r3, [r7, #628]	@ 0x274
 800addc:	e9d7 129c 	ldrd	r1, r2, [r7, #624]	@ 0x270
 800ade0:	460b      	mov	r3, r1
 800ade2:	4023      	ands	r3, r4
 800ade4:	f8c7 3268 	str.w	r3, [r7, #616]	@ 0x268
 800ade8:	4613      	mov	r3, r2
 800adea:	402b      	ands	r3, r5
 800adec:	f8c7 326c 	str.w	r3, [r7, #620]	@ 0x26c
 800adf0:	e9d7 459e 	ldrd	r4, r5, [r7, #632]	@ 0x278
 800adf4:	4623      	mov	r3, r4
 800adf6:	e9d7 019a 	ldrd	r0, r1, [r7, #616]	@ 0x268
 800adfa:	4602      	mov	r2, r0
 800adfc:	4313      	orrs	r3, r2
 800adfe:	f8c7 3260 	str.w	r3, [r7, #608]	@ 0x260
 800ae02:	462b      	mov	r3, r5
 800ae04:	460a      	mov	r2, r1
 800ae06:	4313      	orrs	r3, r2
 800ae08:	f8c7 3264 	str.w	r3, [r7, #612]	@ 0x264
 800ae0c:	e9d7 45a0 	ldrd	r4, r5, [r7, #640]	@ 0x280
 800ae10:	4623      	mov	r3, r4
 800ae12:	e9d7 0198 	ldrd	r0, r1, [r7, #608]	@ 0x260
 800ae16:	4602      	mov	r2, r0
 800ae18:	189b      	adds	r3, r3, r2
 800ae1a:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
 800ae1e:	462b      	mov	r3, r5
 800ae20:	460a      	mov	r2, r1
 800ae22:	4153      	adcs	r3, r2
 800ae24:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
 800ae28:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ae2c:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ae30:	e9d7 1296 	ldrd	r1, r2, [r7, #600]	@ 0x258
 800ae34:	e9c3 1202 	strd	r1, r2, [r3, #8]
 800ae38:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ae3c:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ae40:	e9d3 01b2 	ldrd	r0, r1, [r3, #712]	@ 0x2c8
 800ae44:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ae48:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ae4c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ae50:	1884      	adds	r4, r0, r2
 800ae52:	f8c7 4250 	str.w	r4, [r7, #592]	@ 0x250
 800ae56:	eb41 0303 	adc.w	r3, r1, r3
 800ae5a:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
 800ae5e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ae62:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ae66:	e9d7 1294 	ldrd	r1, r2, [r7, #592]	@ 0x250
 800ae6a:	e9c3 12b2 	strd	r1, r2, [r3, #712]	@ 0x2c8
 800ae6e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ae72:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ae76:	e9d3 0100 	ldrd	r0, r1, [r3]
 800ae7a:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ae7e:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ae82:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800ae86:	1884      	adds	r4, r0, r2
 800ae88:	f8c7 4248 	str.w	r4, [r7, #584]	@ 0x248
 800ae8c:	eb41 0303 	adc.w	r3, r1, r3
 800ae90:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
 800ae94:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800ae98:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800ae9c:	e9d7 1292 	ldrd	r1, r2, [r7, #584]	@ 0x248
 800aea0:	e9c3 12aa 	strd	r1, r2, [r3, #680]	@ 0x2a8
           local.A[1], local.A[2], local.A[3], local.W[i], K[i] ); i++;
 800aea4:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800aea8:	3301      	adds	r3, #1
 800aeaa:	f8c7 39a4 	str.w	r3, [r7, #2468]	@ 0x9a4
        P( local.A[3], local.A[4], local.A[5], local.A[6], local.A[7],
 800aeae:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800aeb2:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800aeb6:	e9d3 45a8 	ldrd	r4, r5, [r3, #672]	@ 0x2a0
 800aeba:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800aebe:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800aec2:	e9d3 23b2 	ldrd	r2, r3, [r3, #712]	@ 0x2c8
 800aec6:	0498      	lsls	r0, r3, #18
 800aec8:	0b91      	lsrs	r1, r2, #14
 800aeca:	4301      	orrs	r1, r0
 800aecc:	f8c7 1240 	str.w	r1, [r7, #576]	@ 0x240
 800aed0:	0491      	lsls	r1, r2, #18
 800aed2:	0b9b      	lsrs	r3, r3, #14
 800aed4:	430b      	orrs	r3, r1
 800aed6:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
 800aeda:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800aede:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800aee2:	e9d3 23b2 	ldrd	r2, r3, [r3, #712]	@ 0x2c8
 800aee6:	0398      	lsls	r0, r3, #14
 800aee8:	0c91      	lsrs	r1, r2, #18
 800aeea:	4301      	orrs	r1, r0
 800aeec:	f8c7 1238 	str.w	r1, [r7, #568]	@ 0x238
 800aef0:	0391      	lsls	r1, r2, #14
 800aef2:	0c9b      	lsrs	r3, r3, #18
 800aef4:	430b      	orrs	r3, r1
 800aef6:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
 800aefa:	e9d7 8990 	ldrd	r8, r9, [r7, #576]	@ 0x240
 800aefe:	4643      	mov	r3, r8
 800af00:	e9d7 018e 	ldrd	r0, r1, [r7, #568]	@ 0x238
 800af04:	4602      	mov	r2, r0
 800af06:	4053      	eors	r3, r2
 800af08:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
 800af0c:	464b      	mov	r3, r9
 800af0e:	460a      	mov	r2, r1
 800af10:	4053      	eors	r3, r2
 800af12:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
 800af16:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800af1a:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800af1e:	e9d3 23b2 	ldrd	r2, r3, [r3, #712]	@ 0x2c8
 800af22:	0a50      	lsrs	r0, r2, #9
 800af24:	05d9      	lsls	r1, r3, #23
 800af26:	4301      	orrs	r1, r0
 800af28:	f8c7 122c 	str.w	r1, [r7, #556]	@ 0x22c
 800af2c:	0a59      	lsrs	r1, r3, #9
 800af2e:	05d3      	lsls	r3, r2, #23
 800af30:	430b      	orrs	r3, r1
 800af32:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
 800af36:	e9d7 898c 	ldrd	r8, r9, [r7, #560]	@ 0x230
 800af3a:	4643      	mov	r3, r8
 800af3c:	e9d7 018a 	ldrd	r0, r1, [r7, #552]	@ 0x228
 800af40:	4602      	mov	r2, r0
 800af42:	4053      	eors	r3, r2
 800af44:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
 800af48:	464b      	mov	r3, r9
 800af4a:	460a      	mov	r2, r1
 800af4c:	4053      	eors	r3, r2
 800af4e:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
 800af52:	e9d7 1288 	ldrd	r1, r2, [r7, #544]	@ 0x220
 800af56:	460b      	mov	r3, r1
 800af58:	18e3      	adds	r3, r4, r3
 800af5a:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
 800af5e:	4613      	mov	r3, r2
 800af60:	eb45 0303 	adc.w	r3, r5, r3
 800af64:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
 800af68:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800af6c:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800af70:	e9d3 89a6 	ldrd	r8, r9, [r3, #664]	@ 0x298
 800af74:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800af78:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800af7c:	e9d3 45b2 	ldrd	r4, r5, [r3, #712]	@ 0x2c8
 800af80:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800af84:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800af88:	e9d3 01a4 	ldrd	r0, r1, [r3, #656]	@ 0x290
 800af8c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800af90:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800af94:	e9d3 23a6 	ldrd	r2, r3, [r3, #664]	@ 0x298
 800af98:	ea80 0602 	eor.w	r6, r0, r2
 800af9c:	f8c7 6210 	str.w	r6, [r7, #528]	@ 0x210
 800afa0:	404b      	eors	r3, r1
 800afa2:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
 800afa6:	e9d7 1284 	ldrd	r1, r2, [r7, #528]	@ 0x210
 800afaa:	460b      	mov	r3, r1
 800afac:	4023      	ands	r3, r4
 800afae:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208
 800afb2:	4613      	mov	r3, r2
 800afb4:	402b      	ands	r3, r5
 800afb6:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
 800afba:	e9d7 1282 	ldrd	r1, r2, [r7, #520]	@ 0x208
 800afbe:	460b      	mov	r3, r1
 800afc0:	ea88 0303 	eor.w	r3, r8, r3
 800afc4:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
 800afc8:	4613      	mov	r3, r2
 800afca:	ea89 0303 	eor.w	r3, r9, r3
 800afce:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
 800afd2:	e9d7 4586 	ldrd	r4, r5, [r7, #536]	@ 0x218
 800afd6:	4623      	mov	r3, r4
 800afd8:	e9d7 0180 	ldrd	r0, r1, [r7, #512]	@ 0x200
 800afdc:	4602      	mov	r2, r0
 800afde:	189b      	adds	r3, r3, r2
 800afe0:	f8c7 31f8 	str.w	r3, [r7, #504]	@ 0x1f8
 800afe4:	462b      	mov	r3, r5
 800afe6:	460a      	mov	r2, r1
 800afe8:	4153      	adcs	r3, r2
 800afea:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
 800afee:	4a24      	ldr	r2, [pc, #144]	@ (800b080 <mbedtls_internal_sha512_process+0x18c8>)
 800aff0:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800aff4:	00db      	lsls	r3, r3, #3
 800aff6:	4413      	add	r3, r2
 800aff8:	e9d3 2300 	ldrd	r2, r3, [r3]
 800affc:	e9d7 457e 	ldrd	r4, r5, [r7, #504]	@ 0x1f8
 800b000:	4621      	mov	r1, r4
 800b002:	1889      	adds	r1, r1, r2
 800b004:	f8c7 11f0 	str.w	r1, [r7, #496]	@ 0x1f0
 800b008:	4629      	mov	r1, r5
 800b00a:	eb41 0303 	adc.w	r3, r1, r3
 800b00e:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
 800b012:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b016:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 800b01a:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800b01e:	3302      	adds	r3, #2
 800b020:	00db      	lsls	r3, r3, #3
 800b022:	4413      	add	r3, r2
 800b024:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b028:	e9d7 457c 	ldrd	r4, r5, [r7, #496]	@ 0x1f0
 800b02c:	4621      	mov	r1, r4
 800b02e:	1889      	adds	r1, r1, r2
 800b030:	f8c7 11e8 	str.w	r1, [r7, #488]	@ 0x1e8
 800b034:	4629      	mov	r1, r5
 800b036:	eb41 0303 	adc.w	r3, r1, r3
 800b03a:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
 800b03e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b042:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b046:	e9d7 127a 	ldrd	r1, r2, [r7, #488]	@ 0x1e8
 800b04a:	e9c3 1200 	strd	r1, r2, [r3]
 800b04e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b052:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b056:	e9d3 23aa 	ldrd	r2, r3, [r3, #680]	@ 0x2a8
 800b05a:	0118      	lsls	r0, r3, #4
 800b05c:	0f11      	lsrs	r1, r2, #28
 800b05e:	4301      	orrs	r1, r0
 800b060:	f8c7 11e0 	str.w	r1, [r7, #480]	@ 0x1e0
 800b064:	0111      	lsls	r1, r2, #4
 800b066:	0f1b      	lsrs	r3, r3, #28
 800b068:	430b      	orrs	r3, r1
 800b06a:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
 800b06e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b072:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b076:	e9d3 23aa 	ldrd	r2, r3, [r3, #680]	@ 0x2a8
 800b07a:	0890      	lsrs	r0, r2, #2
 800b07c:	e002      	b.n	800b084 <mbedtls_internal_sha512_process+0x18cc>
 800b07e:	bf00      	nop
 800b080:	08016d50 	.word	0x08016d50
 800b084:	0799      	lsls	r1, r3, #30
 800b086:	4301      	orrs	r1, r0
 800b088:	f8c7 11dc 	str.w	r1, [r7, #476]	@ 0x1dc
 800b08c:	0899      	lsrs	r1, r3, #2
 800b08e:	0793      	lsls	r3, r2, #30
 800b090:	430b      	orrs	r3, r1
 800b092:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
 800b096:	e9d7 4578 	ldrd	r4, r5, [r7, #480]	@ 0x1e0
 800b09a:	4623      	mov	r3, r4
 800b09c:	e9d7 0176 	ldrd	r0, r1, [r7, #472]	@ 0x1d8
 800b0a0:	4602      	mov	r2, r0
 800b0a2:	4053      	eors	r3, r2
 800b0a4:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0
 800b0a8:	462b      	mov	r3, r5
 800b0aa:	460a      	mov	r2, r1
 800b0ac:	4053      	eors	r3, r2
 800b0ae:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
 800b0b2:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b0b6:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b0ba:	e9d3 23aa 	ldrd	r2, r3, [r3, #680]	@ 0x2a8
 800b0be:	09d0      	lsrs	r0, r2, #7
 800b0c0:	0659      	lsls	r1, r3, #25
 800b0c2:	4301      	orrs	r1, r0
 800b0c4:	f8c7 11cc 	str.w	r1, [r7, #460]	@ 0x1cc
 800b0c8:	09d9      	lsrs	r1, r3, #7
 800b0ca:	0653      	lsls	r3, r2, #25
 800b0cc:	430b      	orrs	r3, r1
 800b0ce:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
 800b0d2:	e9d7 4574 	ldrd	r4, r5, [r7, #464]	@ 0x1d0
 800b0d6:	4623      	mov	r3, r4
 800b0d8:	e9d7 0172 	ldrd	r0, r1, [r7, #456]	@ 0x1c8
 800b0dc:	4602      	mov	r2, r0
 800b0de:	4053      	eors	r3, r2
 800b0e0:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
 800b0e4:	462b      	mov	r3, r5
 800b0e6:	460a      	mov	r2, r1
 800b0e8:	4053      	eors	r3, r2
 800b0ea:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
 800b0ee:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b0f2:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b0f6:	e9d3 01aa 	ldrd	r0, r1, [r3, #680]	@ 0x2a8
 800b0fa:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b0fe:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b102:	e9d3 23ac 	ldrd	r2, r3, [r3, #688]	@ 0x2b0
 800b106:	ea00 0402 	and.w	r4, r0, r2
 800b10a:	f8c7 41b8 	str.w	r4, [r7, #440]	@ 0x1b8
 800b10e:	400b      	ands	r3, r1
 800b110:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
 800b114:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b118:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b11c:	e9d3 45ae 	ldrd	r4, r5, [r3, #696]	@ 0x2b8
 800b120:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b124:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b128:	e9d3 01aa 	ldrd	r0, r1, [r3, #680]	@ 0x2a8
 800b12c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b130:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b134:	e9d3 23ac 	ldrd	r2, r3, [r3, #688]	@ 0x2b0
 800b138:	ea40 0602 	orr.w	r6, r0, r2
 800b13c:	f8c7 61b0 	str.w	r6, [r7, #432]	@ 0x1b0
 800b140:	430b      	orrs	r3, r1
 800b142:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
 800b146:	e9d7 126c 	ldrd	r1, r2, [r7, #432]	@ 0x1b0
 800b14a:	460b      	mov	r3, r1
 800b14c:	4023      	ands	r3, r4
 800b14e:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
 800b152:	4613      	mov	r3, r2
 800b154:	402b      	ands	r3, r5
 800b156:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
 800b15a:	e9d7 456e 	ldrd	r4, r5, [r7, #440]	@ 0x1b8
 800b15e:	4623      	mov	r3, r4
 800b160:	e9d7 016a 	ldrd	r0, r1, [r7, #424]	@ 0x1a8
 800b164:	4602      	mov	r2, r0
 800b166:	4313      	orrs	r3, r2
 800b168:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
 800b16c:	462b      	mov	r3, r5
 800b16e:	460a      	mov	r2, r1
 800b170:	4313      	orrs	r3, r2
 800b172:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
 800b176:	e9d7 4570 	ldrd	r4, r5, [r7, #448]	@ 0x1c0
 800b17a:	4623      	mov	r3, r4
 800b17c:	e9d7 0168 	ldrd	r0, r1, [r7, #416]	@ 0x1a0
 800b180:	4602      	mov	r2, r0
 800b182:	189b      	adds	r3, r3, r2
 800b184:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
 800b188:	462b      	mov	r3, r5
 800b18a:	460a      	mov	r2, r1
 800b18c:	4153      	adcs	r3, r2
 800b18e:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
 800b192:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b196:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b19a:	e9d7 1266 	ldrd	r1, r2, [r7, #408]	@ 0x198
 800b19e:	e9c3 1202 	strd	r1, r2, [r3, #8]
 800b1a2:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b1a6:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b1aa:	e9d3 01b0 	ldrd	r0, r1, [r3, #704]	@ 0x2c0
 800b1ae:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b1b2:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b1b6:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b1ba:	1884      	adds	r4, r0, r2
 800b1bc:	f8c7 4190 	str.w	r4, [r7, #400]	@ 0x190
 800b1c0:	eb41 0303 	adc.w	r3, r1, r3
 800b1c4:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
 800b1c8:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b1cc:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b1d0:	e9d7 1264 	ldrd	r1, r2, [r7, #400]	@ 0x190
 800b1d4:	e9c3 12b0 	strd	r1, r2, [r3, #704]	@ 0x2c0
 800b1d8:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b1dc:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b1e0:	e9d3 0100 	ldrd	r0, r1, [r3]
 800b1e4:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b1e8:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b1ec:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800b1f0:	1884      	adds	r4, r0, r2
 800b1f2:	f8c7 4188 	str.w	r4, [r7, #392]	@ 0x188
 800b1f6:	eb41 0303 	adc.w	r3, r1, r3
 800b1fa:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
 800b1fe:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b202:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b206:	e9d7 1262 	ldrd	r1, r2, [r7, #392]	@ 0x188
 800b20a:	e9c3 12a8 	strd	r1, r2, [r3, #672]	@ 0x2a0
           local.A[0], local.A[1], local.A[2], local.W[i], K[i] ); i++;
 800b20e:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800b212:	3301      	adds	r3, #1
 800b214:	f8c7 39a4 	str.w	r3, [r7, #2468]	@ 0x9a4
        P( local.A[2], local.A[3], local.A[4], local.A[5], local.A[6],
 800b218:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b21c:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b220:	e9d3 45a6 	ldrd	r4, r5, [r3, #664]	@ 0x298
 800b224:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b228:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b22c:	e9d3 23b0 	ldrd	r2, r3, [r3, #704]	@ 0x2c0
 800b230:	0498      	lsls	r0, r3, #18
 800b232:	0b91      	lsrs	r1, r2, #14
 800b234:	4301      	orrs	r1, r0
 800b236:	f8c7 1180 	str.w	r1, [r7, #384]	@ 0x180
 800b23a:	0491      	lsls	r1, r2, #18
 800b23c:	0b9b      	lsrs	r3, r3, #14
 800b23e:	430b      	orrs	r3, r1
 800b240:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
 800b244:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b248:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b24c:	e9d3 23b0 	ldrd	r2, r3, [r3, #704]	@ 0x2c0
 800b250:	0398      	lsls	r0, r3, #14
 800b252:	0c91      	lsrs	r1, r2, #18
 800b254:	4301      	orrs	r1, r0
 800b256:	f8c7 1178 	str.w	r1, [r7, #376]	@ 0x178
 800b25a:	0391      	lsls	r1, r2, #14
 800b25c:	0c9b      	lsrs	r3, r3, #18
 800b25e:	430b      	orrs	r3, r1
 800b260:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
 800b264:	e9d7 8960 	ldrd	r8, r9, [r7, #384]	@ 0x180
 800b268:	4643      	mov	r3, r8
 800b26a:	e9d7 015e 	ldrd	r0, r1, [r7, #376]	@ 0x178
 800b26e:	4602      	mov	r2, r0
 800b270:	4053      	eors	r3, r2
 800b272:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
 800b276:	464b      	mov	r3, r9
 800b278:	460a      	mov	r2, r1
 800b27a:	4053      	eors	r3, r2
 800b27c:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
 800b280:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b284:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b288:	e9d3 23b0 	ldrd	r2, r3, [r3, #704]	@ 0x2c0
 800b28c:	0a50      	lsrs	r0, r2, #9
 800b28e:	05d9      	lsls	r1, r3, #23
 800b290:	4301      	orrs	r1, r0
 800b292:	f8c7 116c 	str.w	r1, [r7, #364]	@ 0x16c
 800b296:	0a59      	lsrs	r1, r3, #9
 800b298:	05d3      	lsls	r3, r2, #23
 800b29a:	430b      	orrs	r3, r1
 800b29c:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
 800b2a0:	e9d7 895c 	ldrd	r8, r9, [r7, #368]	@ 0x170
 800b2a4:	4643      	mov	r3, r8
 800b2a6:	e9d7 015a 	ldrd	r0, r1, [r7, #360]	@ 0x168
 800b2aa:	4602      	mov	r2, r0
 800b2ac:	4053      	eors	r3, r2
 800b2ae:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
 800b2b2:	464b      	mov	r3, r9
 800b2b4:	460a      	mov	r2, r1
 800b2b6:	4053      	eors	r3, r2
 800b2b8:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
 800b2bc:	e9d7 1258 	ldrd	r1, r2, [r7, #352]	@ 0x160
 800b2c0:	460b      	mov	r3, r1
 800b2c2:	18e3      	adds	r3, r4, r3
 800b2c4:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
 800b2c8:	4613      	mov	r3, r2
 800b2ca:	eb45 0303 	adc.w	r3, r5, r3
 800b2ce:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
 800b2d2:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b2d6:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b2da:	e9d3 89a4 	ldrd	r8, r9, [r3, #656]	@ 0x290
 800b2de:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b2e2:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b2e6:	e9d3 45b0 	ldrd	r4, r5, [r3, #704]	@ 0x2c0
 800b2ea:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b2ee:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b2f2:	e9d3 01b2 	ldrd	r0, r1, [r3, #712]	@ 0x2c8
 800b2f6:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b2fa:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b2fe:	e9d3 23a4 	ldrd	r2, r3, [r3, #656]	@ 0x290
 800b302:	ea80 0602 	eor.w	r6, r0, r2
 800b306:	f8c7 6150 	str.w	r6, [r7, #336]	@ 0x150
 800b30a:	404b      	eors	r3, r1
 800b30c:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
 800b310:	e9d7 1254 	ldrd	r1, r2, [r7, #336]	@ 0x150
 800b314:	460b      	mov	r3, r1
 800b316:	4023      	ands	r3, r4
 800b318:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
 800b31c:	4613      	mov	r3, r2
 800b31e:	402b      	ands	r3, r5
 800b320:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
 800b324:	e9d7 1252 	ldrd	r1, r2, [r7, #328]	@ 0x148
 800b328:	460b      	mov	r3, r1
 800b32a:	ea88 0303 	eor.w	r3, r8, r3
 800b32e:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 800b332:	4613      	mov	r3, r2
 800b334:	ea89 0303 	eor.w	r3, r9, r3
 800b338:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
 800b33c:	e9d7 4556 	ldrd	r4, r5, [r7, #344]	@ 0x158
 800b340:	4623      	mov	r3, r4
 800b342:	e9d7 0150 	ldrd	r0, r1, [r7, #320]	@ 0x140
 800b346:	4602      	mov	r2, r0
 800b348:	189b      	adds	r3, r3, r2
 800b34a:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
 800b34e:	462b      	mov	r3, r5
 800b350:	460a      	mov	r2, r1
 800b352:	4153      	adcs	r3, r2
 800b354:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
 800b358:	4af8      	ldr	r2, [pc, #992]	@ (800b73c <mbedtls_internal_sha512_process+0x1f84>)
 800b35a:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800b35e:	00db      	lsls	r3, r3, #3
 800b360:	4413      	add	r3, r2
 800b362:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b366:	e9d7 454e 	ldrd	r4, r5, [r7, #312]	@ 0x138
 800b36a:	4621      	mov	r1, r4
 800b36c:	1889      	adds	r1, r1, r2
 800b36e:	f8c7 1130 	str.w	r1, [r7, #304]	@ 0x130
 800b372:	4629      	mov	r1, r5
 800b374:	eb41 0303 	adc.w	r3, r1, r3
 800b378:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
 800b37c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b380:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 800b384:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800b388:	3302      	adds	r3, #2
 800b38a:	00db      	lsls	r3, r3, #3
 800b38c:	4413      	add	r3, r2
 800b38e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b392:	e9d7 454c 	ldrd	r4, r5, [r7, #304]	@ 0x130
 800b396:	4621      	mov	r1, r4
 800b398:	1889      	adds	r1, r1, r2
 800b39a:	f8c7 1128 	str.w	r1, [r7, #296]	@ 0x128
 800b39e:	4629      	mov	r1, r5
 800b3a0:	eb41 0303 	adc.w	r3, r1, r3
 800b3a4:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 800b3a8:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b3ac:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b3b0:	e9d7 124a 	ldrd	r1, r2, [r7, #296]	@ 0x128
 800b3b4:	e9c3 1200 	strd	r1, r2, [r3]
 800b3b8:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b3bc:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b3c0:	e9d3 23a8 	ldrd	r2, r3, [r3, #672]	@ 0x2a0
 800b3c4:	0118      	lsls	r0, r3, #4
 800b3c6:	0f11      	lsrs	r1, r2, #28
 800b3c8:	4301      	orrs	r1, r0
 800b3ca:	f8c7 1120 	str.w	r1, [r7, #288]	@ 0x120
 800b3ce:	0111      	lsls	r1, r2, #4
 800b3d0:	0f1b      	lsrs	r3, r3, #28
 800b3d2:	430b      	orrs	r3, r1
 800b3d4:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
 800b3d8:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b3dc:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b3e0:	e9d3 23a8 	ldrd	r2, r3, [r3, #672]	@ 0x2a0
 800b3e4:	0890      	lsrs	r0, r2, #2
 800b3e6:	0799      	lsls	r1, r3, #30
 800b3e8:	4301      	orrs	r1, r0
 800b3ea:	f8c7 111c 	str.w	r1, [r7, #284]	@ 0x11c
 800b3ee:	0899      	lsrs	r1, r3, #2
 800b3f0:	0793      	lsls	r3, r2, #30
 800b3f2:	430b      	orrs	r3, r1
 800b3f4:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 800b3f8:	e9d7 4548 	ldrd	r4, r5, [r7, #288]	@ 0x120
 800b3fc:	4623      	mov	r3, r4
 800b3fe:	e9d7 0146 	ldrd	r0, r1, [r7, #280]	@ 0x118
 800b402:	4602      	mov	r2, r0
 800b404:	4053      	eors	r3, r2
 800b406:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
 800b40a:	462b      	mov	r3, r5
 800b40c:	460a      	mov	r2, r1
 800b40e:	4053      	eors	r3, r2
 800b410:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
 800b414:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b418:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b41c:	e9d3 23a8 	ldrd	r2, r3, [r3, #672]	@ 0x2a0
 800b420:	09d0      	lsrs	r0, r2, #7
 800b422:	0659      	lsls	r1, r3, #25
 800b424:	4301      	orrs	r1, r0
 800b426:	f8c7 110c 	str.w	r1, [r7, #268]	@ 0x10c
 800b42a:	09d9      	lsrs	r1, r3, #7
 800b42c:	0653      	lsls	r3, r2, #25
 800b42e:	430b      	orrs	r3, r1
 800b430:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 800b434:	e9d7 4544 	ldrd	r4, r5, [r7, #272]	@ 0x110
 800b438:	4623      	mov	r3, r4
 800b43a:	e9d7 0142 	ldrd	r0, r1, [r7, #264]	@ 0x108
 800b43e:	4602      	mov	r2, r0
 800b440:	4053      	eors	r3, r2
 800b442:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
 800b446:	462b      	mov	r3, r5
 800b448:	460a      	mov	r2, r1
 800b44a:	4053      	eors	r3, r2
 800b44c:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
 800b450:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b454:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b458:	e9d3 01a8 	ldrd	r0, r1, [r3, #672]	@ 0x2a0
 800b45c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b460:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b464:	e9d3 23aa 	ldrd	r2, r3, [r3, #680]	@ 0x2a8
 800b468:	ea00 0402 	and.w	r4, r0, r2
 800b46c:	f8c7 40f8 	str.w	r4, [r7, #248]	@ 0xf8
 800b470:	400b      	ands	r3, r1
 800b472:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
 800b476:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b47a:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b47e:	e9d3 45ac 	ldrd	r4, r5, [r3, #688]	@ 0x2b0
 800b482:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b486:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b48a:	e9d3 01a8 	ldrd	r0, r1, [r3, #672]	@ 0x2a0
 800b48e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b492:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b496:	e9d3 23aa 	ldrd	r2, r3, [r3, #680]	@ 0x2a8
 800b49a:	ea40 0602 	orr.w	r6, r0, r2
 800b49e:	f8c7 60f0 	str.w	r6, [r7, #240]	@ 0xf0
 800b4a2:	430b      	orrs	r3, r1
 800b4a4:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
 800b4a8:	e9d7 123c 	ldrd	r1, r2, [r7, #240]	@ 0xf0
 800b4ac:	460b      	mov	r3, r1
 800b4ae:	4023      	ands	r3, r4
 800b4b0:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
 800b4b4:	4613      	mov	r3, r2
 800b4b6:	402b      	ands	r3, r5
 800b4b8:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
 800b4bc:	e9d7 453e 	ldrd	r4, r5, [r7, #248]	@ 0xf8
 800b4c0:	4623      	mov	r3, r4
 800b4c2:	e9d7 013a 	ldrd	r0, r1, [r7, #232]	@ 0xe8
 800b4c6:	4602      	mov	r2, r0
 800b4c8:	4313      	orrs	r3, r2
 800b4ca:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 800b4ce:	462b      	mov	r3, r5
 800b4d0:	460a      	mov	r2, r1
 800b4d2:	4313      	orrs	r3, r2
 800b4d4:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 800b4d8:	e9d7 4540 	ldrd	r4, r5, [r7, #256]	@ 0x100
 800b4dc:	4623      	mov	r3, r4
 800b4de:	e9d7 0138 	ldrd	r0, r1, [r7, #224]	@ 0xe0
 800b4e2:	4602      	mov	r2, r0
 800b4e4:	189b      	adds	r3, r3, r2
 800b4e6:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
 800b4ea:	462b      	mov	r3, r5
 800b4ec:	460a      	mov	r2, r1
 800b4ee:	4153      	adcs	r3, r2
 800b4f0:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
 800b4f4:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b4f8:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b4fc:	e9d7 1236 	ldrd	r1, r2, [r7, #216]	@ 0xd8
 800b500:	e9c3 1202 	strd	r1, r2, [r3, #8]
 800b504:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b508:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b50c:	e9d3 01ae 	ldrd	r0, r1, [r3, #696]	@ 0x2b8
 800b510:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b514:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b518:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b51c:	1884      	adds	r4, r0, r2
 800b51e:	f8c7 40d0 	str.w	r4, [r7, #208]	@ 0xd0
 800b522:	eb41 0303 	adc.w	r3, r1, r3
 800b526:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 800b52a:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b52e:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b532:	e9d7 1234 	ldrd	r1, r2, [r7, #208]	@ 0xd0
 800b536:	e9c3 12ae 	strd	r1, r2, [r3, #696]	@ 0x2b8
 800b53a:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b53e:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b542:	e9d3 0100 	ldrd	r0, r1, [r3]
 800b546:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b54a:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b54e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800b552:	1884      	adds	r4, r0, r2
 800b554:	f8c7 40c8 	str.w	r4, [r7, #200]	@ 0xc8
 800b558:	eb41 0303 	adc.w	r3, r1, r3
 800b55c:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 800b560:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b564:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b568:	e9d7 1232 	ldrd	r1, r2, [r7, #200]	@ 0xc8
 800b56c:	e9c3 12a6 	strd	r1, r2, [r3, #664]	@ 0x298
           local.A[7], local.A[0], local.A[1], local.W[i], K[i] ); i++;
 800b570:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800b574:	3301      	adds	r3, #1
 800b576:	f8c7 39a4 	str.w	r3, [r7, #2468]	@ 0x9a4
        P( local.A[1], local.A[2], local.A[3], local.A[4], local.A[5],
 800b57a:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b57e:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b582:	e9d3 45a4 	ldrd	r4, r5, [r3, #656]	@ 0x290
 800b586:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b58a:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b58e:	e9d3 23ae 	ldrd	r2, r3, [r3, #696]	@ 0x2b8
 800b592:	0498      	lsls	r0, r3, #18
 800b594:	0b91      	lsrs	r1, r2, #14
 800b596:	4301      	orrs	r1, r0
 800b598:	f8c7 10c0 	str.w	r1, [r7, #192]	@ 0xc0
 800b59c:	0491      	lsls	r1, r2, #18
 800b59e:	0b9b      	lsrs	r3, r3, #14
 800b5a0:	430b      	orrs	r3, r1
 800b5a2:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 800b5a6:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b5aa:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b5ae:	e9d3 23ae 	ldrd	r2, r3, [r3, #696]	@ 0x2b8
 800b5b2:	0398      	lsls	r0, r3, #14
 800b5b4:	0c91      	lsrs	r1, r2, #18
 800b5b6:	4301      	orrs	r1, r0
 800b5b8:	f8c7 10b8 	str.w	r1, [r7, #184]	@ 0xb8
 800b5bc:	0391      	lsls	r1, r2, #14
 800b5be:	0c9b      	lsrs	r3, r3, #18
 800b5c0:	430b      	orrs	r3, r1
 800b5c2:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
 800b5c6:	e9d7 8930 	ldrd	r8, r9, [r7, #192]	@ 0xc0
 800b5ca:	4643      	mov	r3, r8
 800b5cc:	e9d7 012e 	ldrd	r0, r1, [r7, #184]	@ 0xb8
 800b5d0:	4602      	mov	r2, r0
 800b5d2:	4053      	eors	r3, r2
 800b5d4:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
 800b5d8:	464b      	mov	r3, r9
 800b5da:	460a      	mov	r2, r1
 800b5dc:	4053      	eors	r3, r2
 800b5de:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
 800b5e2:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b5e6:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b5ea:	e9d3 23ae 	ldrd	r2, r3, [r3, #696]	@ 0x2b8
 800b5ee:	0a50      	lsrs	r0, r2, #9
 800b5f0:	05d9      	lsls	r1, r3, #23
 800b5f2:	4301      	orrs	r1, r0
 800b5f4:	f8c7 10ac 	str.w	r1, [r7, #172]	@ 0xac
 800b5f8:	0a59      	lsrs	r1, r3, #9
 800b5fa:	05d3      	lsls	r3, r2, #23
 800b5fc:	430b      	orrs	r3, r1
 800b5fe:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
 800b602:	e9d7 892c 	ldrd	r8, r9, [r7, #176]	@ 0xb0
 800b606:	4643      	mov	r3, r8
 800b608:	e9d7 012a 	ldrd	r0, r1, [r7, #168]	@ 0xa8
 800b60c:	4602      	mov	r2, r0
 800b60e:	4053      	eors	r3, r2
 800b610:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 800b614:	464b      	mov	r3, r9
 800b616:	460a      	mov	r2, r1
 800b618:	4053      	eors	r3, r2
 800b61a:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
 800b61e:	e9d7 1228 	ldrd	r1, r2, [r7, #160]	@ 0xa0
 800b622:	460b      	mov	r3, r1
 800b624:	18e3      	adds	r3, r4, r3
 800b626:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
 800b62a:	4613      	mov	r3, r2
 800b62c:	eb45 0303 	adc.w	r3, r5, r3
 800b630:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
 800b634:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b638:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b63c:	e9d3 89b2 	ldrd	r8, r9, [r3, #712]	@ 0x2c8
 800b640:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b644:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b648:	e9d3 45ae 	ldrd	r4, r5, [r3, #696]	@ 0x2b8
 800b64c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b650:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b654:	e9d3 01b0 	ldrd	r0, r1, [r3, #704]	@ 0x2c0
 800b658:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b65c:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b660:	e9d3 23b2 	ldrd	r2, r3, [r3, #712]	@ 0x2c8
 800b664:	ea80 0602 	eor.w	r6, r0, r2
 800b668:	f8c7 6090 	str.w	r6, [r7, #144]	@ 0x90
 800b66c:	404b      	eors	r3, r1
 800b66e:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
 800b672:	e9d7 1224 	ldrd	r1, r2, [r7, #144]	@ 0x90
 800b676:	460b      	mov	r3, r1
 800b678:	4023      	ands	r3, r4
 800b67a:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 800b67e:	4613      	mov	r3, r2
 800b680:	402b      	ands	r3, r5
 800b682:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 800b686:	e9d7 1222 	ldrd	r1, r2, [r7, #136]	@ 0x88
 800b68a:	460b      	mov	r3, r1
 800b68c:	ea88 0303 	eor.w	r3, r8, r3
 800b690:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 800b694:	4613      	mov	r3, r2
 800b696:	ea89 0303 	eor.w	r3, r9, r3
 800b69a:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 800b69e:	e9d7 4526 	ldrd	r4, r5, [r7, #152]	@ 0x98
 800b6a2:	4623      	mov	r3, r4
 800b6a4:	e9d7 0120 	ldrd	r0, r1, [r7, #128]	@ 0x80
 800b6a8:	4602      	mov	r2, r0
 800b6aa:	189b      	adds	r3, r3, r2
 800b6ac:	67bb      	str	r3, [r7, #120]	@ 0x78
 800b6ae:	462b      	mov	r3, r5
 800b6b0:	460a      	mov	r2, r1
 800b6b2:	4153      	adcs	r3, r2
 800b6b4:	67fb      	str	r3, [r7, #124]	@ 0x7c
 800b6b6:	4a21      	ldr	r2, [pc, #132]	@ (800b73c <mbedtls_internal_sha512_process+0x1f84>)
 800b6b8:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800b6bc:	00db      	lsls	r3, r3, #3
 800b6be:	4413      	add	r3, r2
 800b6c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b6c4:	e9d7 451e 	ldrd	r4, r5, [r7, #120]	@ 0x78
 800b6c8:	4621      	mov	r1, r4
 800b6ca:	1889      	adds	r1, r1, r2
 800b6cc:	6739      	str	r1, [r7, #112]	@ 0x70
 800b6ce:	4629      	mov	r1, r5
 800b6d0:	eb41 0303 	adc.w	r3, r1, r3
 800b6d4:	677b      	str	r3, [r7, #116]	@ 0x74
 800b6d6:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b6da:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 800b6de:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800b6e2:	3302      	adds	r3, #2
 800b6e4:	00db      	lsls	r3, r3, #3
 800b6e6:	4413      	add	r3, r2
 800b6e8:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b6ec:	e9d7 451c 	ldrd	r4, r5, [r7, #112]	@ 0x70
 800b6f0:	4621      	mov	r1, r4
 800b6f2:	1889      	adds	r1, r1, r2
 800b6f4:	66b9      	str	r1, [r7, #104]	@ 0x68
 800b6f6:	4629      	mov	r1, r5
 800b6f8:	eb41 0303 	adc.w	r3, r1, r3
 800b6fc:	66fb      	str	r3, [r7, #108]	@ 0x6c
 800b6fe:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b702:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b706:	e9d7 121a 	ldrd	r1, r2, [r7, #104]	@ 0x68
 800b70a:	e9c3 1200 	strd	r1, r2, [r3]
 800b70e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b712:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b716:	e9d3 23a6 	ldrd	r2, r3, [r3, #664]	@ 0x298
 800b71a:	0118      	lsls	r0, r3, #4
 800b71c:	0f11      	lsrs	r1, r2, #28
 800b71e:	4301      	orrs	r1, r0
 800b720:	6639      	str	r1, [r7, #96]	@ 0x60
 800b722:	0111      	lsls	r1, r2, #4
 800b724:	0f1b      	lsrs	r3, r3, #28
 800b726:	430b      	orrs	r3, r1
 800b728:	667b      	str	r3, [r7, #100]	@ 0x64
 800b72a:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b72e:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b732:	e9d3 23a6 	ldrd	r2, r3, [r3, #664]	@ 0x298
 800b736:	0890      	lsrs	r0, r2, #2
 800b738:	e002      	b.n	800b740 <mbedtls_internal_sha512_process+0x1f88>
 800b73a:	bf00      	nop
 800b73c:	08016d50 	.word	0x08016d50
 800b740:	0799      	lsls	r1, r3, #30
 800b742:	4301      	orrs	r1, r0
 800b744:	65f9      	str	r1, [r7, #92]	@ 0x5c
 800b746:	0899      	lsrs	r1, r3, #2
 800b748:	0793      	lsls	r3, r2, #30
 800b74a:	430b      	orrs	r3, r1
 800b74c:	65bb      	str	r3, [r7, #88]	@ 0x58
 800b74e:	e9d7 4518 	ldrd	r4, r5, [r7, #96]	@ 0x60
 800b752:	4623      	mov	r3, r4
 800b754:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	@ 0x58
 800b758:	4602      	mov	r2, r0
 800b75a:	4053      	eors	r3, r2
 800b75c:	653b      	str	r3, [r7, #80]	@ 0x50
 800b75e:	462b      	mov	r3, r5
 800b760:	460a      	mov	r2, r1
 800b762:	4053      	eors	r3, r2
 800b764:	657b      	str	r3, [r7, #84]	@ 0x54
 800b766:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b76a:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b76e:	e9d3 23a6 	ldrd	r2, r3, [r3, #664]	@ 0x298
 800b772:	09d0      	lsrs	r0, r2, #7
 800b774:	0659      	lsls	r1, r3, #25
 800b776:	4301      	orrs	r1, r0
 800b778:	64f9      	str	r1, [r7, #76]	@ 0x4c
 800b77a:	09d9      	lsrs	r1, r3, #7
 800b77c:	0653      	lsls	r3, r2, #25
 800b77e:	430b      	orrs	r3, r1
 800b780:	64bb      	str	r3, [r7, #72]	@ 0x48
 800b782:	e9d7 4514 	ldrd	r4, r5, [r7, #80]	@ 0x50
 800b786:	4623      	mov	r3, r4
 800b788:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
 800b78c:	4602      	mov	r2, r0
 800b78e:	4053      	eors	r3, r2
 800b790:	643b      	str	r3, [r7, #64]	@ 0x40
 800b792:	462b      	mov	r3, r5
 800b794:	460a      	mov	r2, r1
 800b796:	4053      	eors	r3, r2
 800b798:	647b      	str	r3, [r7, #68]	@ 0x44
 800b79a:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b79e:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b7a2:	e9d3 01a6 	ldrd	r0, r1, [r3, #664]	@ 0x298
 800b7a6:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b7aa:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b7ae:	e9d3 23a8 	ldrd	r2, r3, [r3, #672]	@ 0x2a0
 800b7b2:	ea00 0402 	and.w	r4, r0, r2
 800b7b6:	63bc      	str	r4, [r7, #56]	@ 0x38
 800b7b8:	400b      	ands	r3, r1
 800b7ba:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800b7bc:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b7c0:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b7c4:	e9d3 45aa 	ldrd	r4, r5, [r3, #680]	@ 0x2a8
 800b7c8:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b7cc:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b7d0:	e9d3 01a6 	ldrd	r0, r1, [r3, #664]	@ 0x298
 800b7d4:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b7d8:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b7dc:	e9d3 23a8 	ldrd	r2, r3, [r3, #672]	@ 0x2a0
 800b7e0:	ea40 0602 	orr.w	r6, r0, r2
 800b7e4:	633e      	str	r6, [r7, #48]	@ 0x30
 800b7e6:	430b      	orrs	r3, r1
 800b7e8:	637b      	str	r3, [r7, #52]	@ 0x34
 800b7ea:	e9d7 120c 	ldrd	r1, r2, [r7, #48]	@ 0x30
 800b7ee:	460b      	mov	r3, r1
 800b7f0:	4023      	ands	r3, r4
 800b7f2:	62bb      	str	r3, [r7, #40]	@ 0x28
 800b7f4:	4613      	mov	r3, r2
 800b7f6:	402b      	ands	r3, r5
 800b7f8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800b7fa:	e9d7 450e 	ldrd	r4, r5, [r7, #56]	@ 0x38
 800b7fe:	4623      	mov	r3, r4
 800b800:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
 800b804:	4602      	mov	r2, r0
 800b806:	4313      	orrs	r3, r2
 800b808:	623b      	str	r3, [r7, #32]
 800b80a:	462b      	mov	r3, r5
 800b80c:	460a      	mov	r2, r1
 800b80e:	4313      	orrs	r3, r2
 800b810:	627b      	str	r3, [r7, #36]	@ 0x24
 800b812:	e9d7 4510 	ldrd	r4, r5, [r7, #64]	@ 0x40
 800b816:	4623      	mov	r3, r4
 800b818:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 800b81c:	4602      	mov	r2, r0
 800b81e:	189b      	adds	r3, r3, r2
 800b820:	61bb      	str	r3, [r7, #24]
 800b822:	462b      	mov	r3, r5
 800b824:	460a      	mov	r2, r1
 800b826:	4153      	adcs	r3, r2
 800b828:	61fb      	str	r3, [r7, #28]
 800b82a:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b82e:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b832:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
 800b836:	e9c3 1202 	strd	r1, r2, [r3, #8]
 800b83a:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b83e:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b842:	e9d3 01ac 	ldrd	r0, r1, [r3, #688]	@ 0x2b0
 800b846:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b84a:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b84e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b852:	1884      	adds	r4, r0, r2
 800b854:	613c      	str	r4, [r7, #16]
 800b856:	eb41 0303 	adc.w	r3, r1, r3
 800b85a:	617b      	str	r3, [r7, #20]
 800b85c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b860:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b864:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 800b868:	e9c3 12ac 	strd	r1, r2, [r3, #688]	@ 0x2b0
 800b86c:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b870:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b874:	e9d3 0100 	ldrd	r0, r1, [r3]
 800b878:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b87c:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b880:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800b884:	1884      	adds	r4, r0, r2
 800b886:	60bc      	str	r4, [r7, #8]
 800b888:	eb41 0303 	adc.w	r3, r1, r3
 800b88c:	60fb      	str	r3, [r7, #12]
 800b88e:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b892:	f5a3 7336 	sub.w	r3, r3, #728	@ 0x2d8
 800b896:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 800b89a:	e9c3 12a4 	strd	r1, r2, [r3, #656]	@ 0x290
           local.A[6], local.A[7], local.A[0], local.W[i], K[i] ); i++;
 800b89e:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800b8a2:	3301      	adds	r3, #1
 800b8a4:	f8c7 39a4 	str.w	r3, [r7, #2468]	@ 0x9a4
    }
    while( i < 80 );
 800b8a8:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800b8ac:	2b4f      	cmp	r3, #79	@ 0x4f
 800b8ae:	f77e aa00 	ble.w	8009cb2 <mbedtls_internal_sha512_process+0x4fa>
#endif /* MBEDTLS_SHA512_SMALLER */

    for( i = 0; i < 8; i++ )
 800b8b2:	2300      	movs	r3, #0
 800b8b4:	f8c7 39a4 	str.w	r3, [r7, #2468]	@ 0x9a4
 800b8b8:	e02e      	b.n	800b918 <mbedtls_internal_sha512_process+0x2160>
        ctx->state[i] += local.A[i];
 800b8ba:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b8be:	f5a3 7337 	sub.w	r3, r3, #732	@ 0x2dc
 800b8c2:	681a      	ldr	r2, [r3, #0]
 800b8c4:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800b8c8:	3302      	adds	r3, #2
 800b8ca:	00db      	lsls	r3, r3, #3
 800b8cc:	4413      	add	r3, r2
 800b8ce:	e9d3 0100 	ldrd	r0, r1, [r3]
 800b8d2:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b8d6:	f5a3 7236 	sub.w	r2, r3, #728	@ 0x2d8
 800b8da:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800b8de:	3352      	adds	r3, #82	@ 0x52
 800b8e0:	00db      	lsls	r3, r3, #3
 800b8e2:	4413      	add	r3, r2
 800b8e4:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b8e8:	1884      	adds	r4, r0, r2
 800b8ea:	603c      	str	r4, [r7, #0]
 800b8ec:	eb41 0303 	adc.w	r3, r1, r3
 800b8f0:	607b      	str	r3, [r7, #4]
 800b8f2:	f607 13a8 	addw	r3, r7, #2472	@ 0x9a8
 800b8f6:	f5a3 7337 	sub.w	r3, r3, #732	@ 0x2dc
 800b8fa:	681a      	ldr	r2, [r3, #0]
 800b8fc:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800b900:	3302      	adds	r3, #2
 800b902:	00db      	lsls	r3, r3, #3
 800b904:	4413      	add	r3, r2
 800b906:	e9d7 1200 	ldrd	r1, r2, [r7]
 800b90a:	e9c3 1200 	strd	r1, r2, [r3]
    for( i = 0; i < 8; i++ )
 800b90e:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800b912:	3301      	adds	r3, #1
 800b914:	f8c7 39a4 	str.w	r3, [r7, #2468]	@ 0x9a4
 800b918:	f8d7 39a4 	ldr.w	r3, [r7, #2468]	@ 0x9a4
 800b91c:	2b07      	cmp	r3, #7
 800b91e:	ddcc      	ble.n	800b8ba <mbedtls_internal_sha512_process+0x2102>

    /* Zeroise buffers and variables to clear sensitive data from memory. */
    mbedtls_platform_zeroize( &local, sizeof( local ) );
 800b920:	f507 63da 	add.w	r3, r7, #1744	@ 0x6d0
 800b924:	f44f 7134 	mov.w	r1, #720	@ 0x2d0
 800b928:	4618      	mov	r0, r3
 800b92a:	f7fa fc59 	bl	80061e0 <mbedtls_platform_zeroize>

    return( 0 );
 800b92e:	2300      	movs	r3, #0
}
 800b930:	4618      	mov	r0, r3
 800b932:	f607 17ac 	addw	r7, r7, #2476	@ 0x9ac
 800b936:	46bd      	mov	sp, r7
 800b938:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800b93c <mbedtls_sha512_update>:
 * SHA-512 process buffer
 */
int mbedtls_sha512_update( mbedtls_sha512_context *ctx,
                               const unsigned char *input,
                               size_t ilen )
{
 800b93c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800b940:	b08a      	sub	sp, #40	@ 0x28
 800b942:	af00      	add	r7, sp, #0
 800b944:	6178      	str	r0, [r7, #20]
 800b946:	6139      	str	r1, [r7, #16]
 800b948:	60fa      	str	r2, [r7, #12]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 800b94a:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 800b94e:	623b      	str	r3, [r7, #32]
    unsigned int left;

    SHA512_VALIDATE_RET( ctx != NULL );
    SHA512_VALIDATE_RET( ilen == 0 || input != NULL );

    if( ilen == 0 )
 800b950:	68fb      	ldr	r3, [r7, #12]
 800b952:	2b00      	cmp	r3, #0
 800b954:	d101      	bne.n	800b95a <mbedtls_sha512_update+0x1e>
        return( 0 );
 800b956:	2300      	movs	r3, #0
 800b958:	e079      	b.n	800ba4e <mbedtls_sha512_update+0x112>

    left = (unsigned int) (ctx->total[0] & 0x7F);
 800b95a:	697b      	ldr	r3, [r7, #20]
 800b95c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b960:	4613      	mov	r3, r2
 800b962:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800b966:	627b      	str	r3, [r7, #36]	@ 0x24
    fill = 128 - left;
 800b968:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800b96a:	f1c3 0380 	rsb	r3, r3, #128	@ 0x80
 800b96e:	61fb      	str	r3, [r7, #28]

    ctx->total[0] += (uint64_t) ilen;
 800b970:	697b      	ldr	r3, [r7, #20]
 800b972:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b976:	68f9      	ldr	r1, [r7, #12]
 800b978:	2000      	movs	r0, #0
 800b97a:	4688      	mov	r8, r1
 800b97c:	4681      	mov	r9, r0
 800b97e:	eb12 0108 	adds.w	r1, r2, r8
 800b982:	6039      	str	r1, [r7, #0]
 800b984:	eb43 0309 	adc.w	r3, r3, r9
 800b988:	607b      	str	r3, [r7, #4]
 800b98a:	697b      	ldr	r3, [r7, #20]
 800b98c:	e9d7 1200 	ldrd	r1, r2, [r7]
 800b990:	e9c3 1200 	strd	r1, r2, [r3]

    if( ctx->total[0] < (uint64_t) ilen )
 800b994:	697b      	ldr	r3, [r7, #20]
 800b996:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b99a:	68f9      	ldr	r1, [r7, #12]
 800b99c:	2000      	movs	r0, #0
 800b99e:	460c      	mov	r4, r1
 800b9a0:	4605      	mov	r5, r0
 800b9a2:	42a2      	cmp	r2, r4
 800b9a4:	41ab      	sbcs	r3, r5
 800b9a6:	d209      	bcs.n	800b9bc <mbedtls_sha512_update+0x80>
        ctx->total[1]++;
 800b9a8:	697b      	ldr	r3, [r7, #20]
 800b9aa:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800b9ae:	f112 0a01 	adds.w	sl, r2, #1
 800b9b2:	f143 0b00 	adc.w	fp, r3, #0
 800b9b6:	697b      	ldr	r3, [r7, #20]
 800b9b8:	e9c3 ab02 	strd	sl, fp, [r3, #8]

    if( left && ilen >= fill )
 800b9bc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800b9be:	2b00      	cmp	r3, #0
 800b9c0:	d034      	beq.n	800ba2c <mbedtls_sha512_update+0xf0>
 800b9c2:	68fa      	ldr	r2, [r7, #12]
 800b9c4:	69fb      	ldr	r3, [r7, #28]
 800b9c6:	429a      	cmp	r2, r3
 800b9c8:	d330      	bcc.n	800ba2c <mbedtls_sha512_update+0xf0>
    {
        memcpy( (void *) (ctx->buffer + left), input, fill );
 800b9ca:	697b      	ldr	r3, [r7, #20]
 800b9cc:	f103 0250 	add.w	r2, r3, #80	@ 0x50
 800b9d0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800b9d2:	4413      	add	r3, r2
 800b9d4:	69fa      	ldr	r2, [r7, #28]
 800b9d6:	6939      	ldr	r1, [r7, #16]
 800b9d8:	4618      	mov	r0, r3
 800b9da:	f009 fdc0 	bl	801555e <memcpy>

        if( ( ret = mbedtls_internal_sha512_process( ctx, ctx->buffer ) ) != 0 )
 800b9de:	697b      	ldr	r3, [r7, #20]
 800b9e0:	3350      	adds	r3, #80	@ 0x50
 800b9e2:	4619      	mov	r1, r3
 800b9e4:	6978      	ldr	r0, [r7, #20]
 800b9e6:	f7fd fee7 	bl	80097b8 <mbedtls_internal_sha512_process>
 800b9ea:	6238      	str	r0, [r7, #32]
 800b9ec:	6a3b      	ldr	r3, [r7, #32]
 800b9ee:	2b00      	cmp	r3, #0
 800b9f0:	d001      	beq.n	800b9f6 <mbedtls_sha512_update+0xba>
            return( ret );
 800b9f2:	6a3b      	ldr	r3, [r7, #32]
 800b9f4:	e02b      	b.n	800ba4e <mbedtls_sha512_update+0x112>

        input += fill;
 800b9f6:	693a      	ldr	r2, [r7, #16]
 800b9f8:	69fb      	ldr	r3, [r7, #28]
 800b9fa:	4413      	add	r3, r2
 800b9fc:	613b      	str	r3, [r7, #16]
        ilen  -= fill;
 800b9fe:	68fa      	ldr	r2, [r7, #12]
 800ba00:	69fb      	ldr	r3, [r7, #28]
 800ba02:	1ad3      	subs	r3, r2, r3
 800ba04:	60fb      	str	r3, [r7, #12]
        left = 0;
 800ba06:	2300      	movs	r3, #0
 800ba08:	627b      	str	r3, [r7, #36]	@ 0x24
    }

    while( ilen >= 128 )
 800ba0a:	e00f      	b.n	800ba2c <mbedtls_sha512_update+0xf0>
    {
        if( ( ret = mbedtls_internal_sha512_process( ctx, input ) ) != 0 )
 800ba0c:	6939      	ldr	r1, [r7, #16]
 800ba0e:	6978      	ldr	r0, [r7, #20]
 800ba10:	f7fd fed2 	bl	80097b8 <mbedtls_internal_sha512_process>
 800ba14:	6238      	str	r0, [r7, #32]
 800ba16:	6a3b      	ldr	r3, [r7, #32]
 800ba18:	2b00      	cmp	r3, #0
 800ba1a:	d001      	beq.n	800ba20 <mbedtls_sha512_update+0xe4>
            return( ret );
 800ba1c:	6a3b      	ldr	r3, [r7, #32]
 800ba1e:	e016      	b.n	800ba4e <mbedtls_sha512_update+0x112>

        input += 128;
 800ba20:	693b      	ldr	r3, [r7, #16]
 800ba22:	3380      	adds	r3, #128	@ 0x80
 800ba24:	613b      	str	r3, [r7, #16]
        ilen  -= 128;
 800ba26:	68fb      	ldr	r3, [r7, #12]
 800ba28:	3b80      	subs	r3, #128	@ 0x80
 800ba2a:	60fb      	str	r3, [r7, #12]
    while( ilen >= 128 )
 800ba2c:	68fb      	ldr	r3, [r7, #12]
 800ba2e:	2b7f      	cmp	r3, #127	@ 0x7f
 800ba30:	d8ec      	bhi.n	800ba0c <mbedtls_sha512_update+0xd0>
    }

    if( ilen > 0 )
 800ba32:	68fb      	ldr	r3, [r7, #12]
 800ba34:	2b00      	cmp	r3, #0
 800ba36:	d009      	beq.n	800ba4c <mbedtls_sha512_update+0x110>
        memcpy( (void *) (ctx->buffer + left), input, ilen );
 800ba38:	697b      	ldr	r3, [r7, #20]
 800ba3a:	f103 0250 	add.w	r2, r3, #80	@ 0x50
 800ba3e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ba40:	4413      	add	r3, r2
 800ba42:	68fa      	ldr	r2, [r7, #12]
 800ba44:	6939      	ldr	r1, [r7, #16]
 800ba46:	4618      	mov	r0, r3
 800ba48:	f009 fd89 	bl	801555e <memcpy>

    return( 0 );
 800ba4c:	2300      	movs	r3, #0
}
 800ba4e:	4618      	mov	r0, r3
 800ba50:	3728      	adds	r7, #40	@ 0x28
 800ba52:	46bd      	mov	sp, r7
 800ba54:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0800ba58 <mbedtls_sha512_finish>:
/*
 * SHA-512 final digest
 */
int mbedtls_sha512_finish( mbedtls_sha512_context *ctx,
                               unsigned char *output )
{
 800ba58:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 800ba5c:	b088      	sub	sp, #32
 800ba5e:	af00      	add	r7, sp, #0
 800ba60:	6078      	str	r0, [r7, #4]
 800ba62:	6039      	str	r1, [r7, #0]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 800ba64:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 800ba68:	61fb      	str	r3, [r7, #28]
    SHA512_VALIDATE_RET( (unsigned char *)output != NULL );

    /*
     * Add padding: 0x80 then 0x00 until 16 bytes remain for the length
     */
    used = ctx->total[0] & 0x7F;
 800ba6a:	687b      	ldr	r3, [r7, #4]
 800ba6c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ba70:	4613      	mov	r3, r2
 800ba72:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800ba76:	61bb      	str	r3, [r7, #24]

    ctx->buffer[used++] = 0x80;
 800ba78:	69bb      	ldr	r3, [r7, #24]
 800ba7a:	1c5a      	adds	r2, r3, #1
 800ba7c:	61ba      	str	r2, [r7, #24]
 800ba7e:	687a      	ldr	r2, [r7, #4]
 800ba80:	4413      	add	r3, r2
 800ba82:	2280      	movs	r2, #128	@ 0x80
 800ba84:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

    if( used <= 112 )
 800ba88:	69bb      	ldr	r3, [r7, #24]
 800ba8a:	2b70      	cmp	r3, #112	@ 0x70
 800ba8c:	d80c      	bhi.n	800baa8 <mbedtls_sha512_finish+0x50>
    {
        /* Enough room for padding + length in current block */
        memset( ctx->buffer + used, 0, 112 - used );
 800ba8e:	687b      	ldr	r3, [r7, #4]
 800ba90:	f103 0250 	add.w	r2, r3, #80	@ 0x50
 800ba94:	69bb      	ldr	r3, [r7, #24]
 800ba96:	18d0      	adds	r0, r2, r3
 800ba98:	69bb      	ldr	r3, [r7, #24]
 800ba9a:	f1c3 0370 	rsb	r3, r3, #112	@ 0x70
 800ba9e:	461a      	mov	r2, r3
 800baa0:	2100      	movs	r1, #0
 800baa2:	f009 fcd1 	bl	8015448 <memset>
 800baa6:	e01f      	b.n	800bae8 <mbedtls_sha512_finish+0x90>
    }
    else
    {
        /* We'll need an extra block */
        memset( ctx->buffer + used, 0, 128 - used );
 800baa8:	687b      	ldr	r3, [r7, #4]
 800baaa:	f103 0250 	add.w	r2, r3, #80	@ 0x50
 800baae:	69bb      	ldr	r3, [r7, #24]
 800bab0:	18d0      	adds	r0, r2, r3
 800bab2:	69bb      	ldr	r3, [r7, #24]
 800bab4:	f1c3 0380 	rsb	r3, r3, #128	@ 0x80
 800bab8:	461a      	mov	r2, r3
 800baba:	2100      	movs	r1, #0
 800babc:	f009 fcc4 	bl	8015448 <memset>

        if( ( ret = mbedtls_internal_sha512_process( ctx, ctx->buffer ) ) != 0 )
 800bac0:	687b      	ldr	r3, [r7, #4]
 800bac2:	3350      	adds	r3, #80	@ 0x50
 800bac4:	4619      	mov	r1, r3
 800bac6:	6878      	ldr	r0, [r7, #4]
 800bac8:	f7fd fe76 	bl	80097b8 <mbedtls_internal_sha512_process>
 800bacc:	61f8      	str	r0, [r7, #28]
 800bace:	69fb      	ldr	r3, [r7, #28]
 800bad0:	2b00      	cmp	r3, #0
 800bad2:	d002      	beq.n	800bada <mbedtls_sha512_finish+0x82>
            return( ret );
 800bad4:	69fb      	ldr	r3, [r7, #28]
 800bad6:	f000 bc3c 	b.w	800c352 <mbedtls_sha512_finish+0x8fa>

        memset( ctx->buffer, 0, 112 );
 800bada:	687b      	ldr	r3, [r7, #4]
 800badc:	3350      	adds	r3, #80	@ 0x50
 800bade:	2270      	movs	r2, #112	@ 0x70
 800bae0:	2100      	movs	r1, #0
 800bae2:	4618      	mov	r0, r3
 800bae4:	f009 fcb0 	bl	8015448 <memset>
    }

    /*
     * Add message length
     */
    high = ( ctx->total[0] >> 61 )
 800bae8:	687b      	ldr	r3, [r7, #4]
 800baea:	e9d3 2300 	ldrd	r2, r3, [r3]
 800baee:	f04f 0000 	mov.w	r0, #0
 800baf2:	f04f 0100 	mov.w	r1, #0
 800baf6:	0f58      	lsrs	r0, r3, #29
 800baf8:	2100      	movs	r1, #0
         | ( ctx->total[1] <<  3 );
 800bafa:	687b      	ldr	r3, [r7, #4]
 800bafc:	e9d3 4502 	ldrd	r4, r5, [r3, #8]
 800bb00:	f04f 0200 	mov.w	r2, #0
 800bb04:	f04f 0300 	mov.w	r3, #0
 800bb08:	00eb      	lsls	r3, r5, #3
 800bb0a:	ea43 7354 	orr.w	r3, r3, r4, lsr #29
 800bb0e:	00e2      	lsls	r2, r4, #3
    high = ( ctx->total[0] >> 61 )
 800bb10:	ea40 0802 	orr.w	r8, r0, r2
 800bb14:	ea41 0903 	orr.w	r9, r1, r3
 800bb18:	e9c7 8904 	strd	r8, r9, [r7, #16]
    low  = ( ctx->total[0] <<  3 );
 800bb1c:	687b      	ldr	r3, [r7, #4]
 800bb1e:	e9d3 0100 	ldrd	r0, r1, [r3]
 800bb22:	f04f 0200 	mov.w	r2, #0
 800bb26:	f04f 0300 	mov.w	r3, #0
 800bb2a:	00cb      	lsls	r3, r1, #3
 800bb2c:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 800bb30:	00c2      	lsls	r2, r0, #3
 800bb32:	e9c7 2302 	strd	r2, r3, [r7, #8]

    sha512_put_uint64_be( high, ctx->buffer, 112 );
 800bb36:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 800bb3a:	f04f 0200 	mov.w	r2, #0
 800bb3e:	f04f 0300 	mov.w	r3, #0
 800bb42:	0e0a      	lsrs	r2, r1, #24
 800bb44:	2300      	movs	r3, #0
 800bb46:	b2d2      	uxtb	r2, r2
 800bb48:	687b      	ldr	r3, [r7, #4]
 800bb4a:	f883 20c0 	strb.w	r2, [r3, #192]	@ 0xc0
 800bb4e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 800bb52:	f04f 0200 	mov.w	r2, #0
 800bb56:	f04f 0300 	mov.w	r3, #0
 800bb5a:	0c0a      	lsrs	r2, r1, #16
 800bb5c:	2300      	movs	r3, #0
 800bb5e:	b2d2      	uxtb	r2, r2
 800bb60:	687b      	ldr	r3, [r7, #4]
 800bb62:	f883 20c1 	strb.w	r2, [r3, #193]	@ 0xc1
 800bb66:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 800bb6a:	f04f 0200 	mov.w	r2, #0
 800bb6e:	f04f 0300 	mov.w	r3, #0
 800bb72:	0a0a      	lsrs	r2, r1, #8
 800bb74:	2300      	movs	r3, #0
 800bb76:	b2d2      	uxtb	r2, r2
 800bb78:	687b      	ldr	r3, [r7, #4]
 800bb7a:	f883 20c2 	strb.w	r2, [r3, #194]	@ 0xc2
 800bb7e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 800bb82:	f04f 0200 	mov.w	r2, #0
 800bb86:	f04f 0300 	mov.w	r3, #0
 800bb8a:	000a      	movs	r2, r1
 800bb8c:	2300      	movs	r3, #0
 800bb8e:	b2d2      	uxtb	r2, r2
 800bb90:	687b      	ldr	r3, [r7, #4]
 800bb92:	f883 20c3 	strb.w	r2, [r3, #195]	@ 0xc3
 800bb96:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 800bb9a:	f04f 0200 	mov.w	r2, #0
 800bb9e:	f04f 0300 	mov.w	r3, #0
 800bba2:	0e02      	lsrs	r2, r0, #24
 800bba4:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800bba8:	0e0b      	lsrs	r3, r1, #24
 800bbaa:	b2d2      	uxtb	r2, r2
 800bbac:	687b      	ldr	r3, [r7, #4]
 800bbae:	f883 20c4 	strb.w	r2, [r3, #196]	@ 0xc4
 800bbb2:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 800bbb6:	f04f 0200 	mov.w	r2, #0
 800bbba:	f04f 0300 	mov.w	r3, #0
 800bbbe:	0c02      	lsrs	r2, r0, #16
 800bbc0:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800bbc4:	0c0b      	lsrs	r3, r1, #16
 800bbc6:	b2d2      	uxtb	r2, r2
 800bbc8:	687b      	ldr	r3, [r7, #4]
 800bbca:	f883 20c5 	strb.w	r2, [r3, #197]	@ 0xc5
 800bbce:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 800bbd2:	f04f 0200 	mov.w	r2, #0
 800bbd6:	f04f 0300 	mov.w	r3, #0
 800bbda:	0a02      	lsrs	r2, r0, #8
 800bbdc:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800bbe0:	0a0b      	lsrs	r3, r1, #8
 800bbe2:	b2d2      	uxtb	r2, r2
 800bbe4:	687b      	ldr	r3, [r7, #4]
 800bbe6:	f883 20c6 	strb.w	r2, [r3, #198]	@ 0xc6
 800bbea:	7c3a      	ldrb	r2, [r7, #16]
 800bbec:	687b      	ldr	r3, [r7, #4]
 800bbee:	f883 20c7 	strb.w	r2, [r3, #199]	@ 0xc7
    sha512_put_uint64_be( low,  ctx->buffer, 120 );
 800bbf2:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 800bbf6:	f04f 0200 	mov.w	r2, #0
 800bbfa:	f04f 0300 	mov.w	r3, #0
 800bbfe:	0e0a      	lsrs	r2, r1, #24
 800bc00:	2300      	movs	r3, #0
 800bc02:	b2d2      	uxtb	r2, r2
 800bc04:	687b      	ldr	r3, [r7, #4]
 800bc06:	f883 20c8 	strb.w	r2, [r3, #200]	@ 0xc8
 800bc0a:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 800bc0e:	f04f 0200 	mov.w	r2, #0
 800bc12:	f04f 0300 	mov.w	r3, #0
 800bc16:	0c0a      	lsrs	r2, r1, #16
 800bc18:	2300      	movs	r3, #0
 800bc1a:	b2d2      	uxtb	r2, r2
 800bc1c:	687b      	ldr	r3, [r7, #4]
 800bc1e:	f883 20c9 	strb.w	r2, [r3, #201]	@ 0xc9
 800bc22:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 800bc26:	f04f 0200 	mov.w	r2, #0
 800bc2a:	f04f 0300 	mov.w	r3, #0
 800bc2e:	0a0a      	lsrs	r2, r1, #8
 800bc30:	2300      	movs	r3, #0
 800bc32:	b2d2      	uxtb	r2, r2
 800bc34:	687b      	ldr	r3, [r7, #4]
 800bc36:	f883 20ca 	strb.w	r2, [r3, #202]	@ 0xca
 800bc3a:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 800bc3e:	f04f 0200 	mov.w	r2, #0
 800bc42:	f04f 0300 	mov.w	r3, #0
 800bc46:	000a      	movs	r2, r1
 800bc48:	2300      	movs	r3, #0
 800bc4a:	b2d2      	uxtb	r2, r2
 800bc4c:	687b      	ldr	r3, [r7, #4]
 800bc4e:	f883 20cb 	strb.w	r2, [r3, #203]	@ 0xcb
 800bc52:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 800bc56:	f04f 0200 	mov.w	r2, #0
 800bc5a:	f04f 0300 	mov.w	r3, #0
 800bc5e:	0e02      	lsrs	r2, r0, #24
 800bc60:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800bc64:	0e0b      	lsrs	r3, r1, #24
 800bc66:	b2d2      	uxtb	r2, r2
 800bc68:	687b      	ldr	r3, [r7, #4]
 800bc6a:	f883 20cc 	strb.w	r2, [r3, #204]	@ 0xcc
 800bc6e:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 800bc72:	f04f 0200 	mov.w	r2, #0
 800bc76:	f04f 0300 	mov.w	r3, #0
 800bc7a:	0c02      	lsrs	r2, r0, #16
 800bc7c:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800bc80:	0c0b      	lsrs	r3, r1, #16
 800bc82:	b2d2      	uxtb	r2, r2
 800bc84:	687b      	ldr	r3, [r7, #4]
 800bc86:	f883 20cd 	strb.w	r2, [r3, #205]	@ 0xcd
 800bc8a:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 800bc8e:	f04f 0200 	mov.w	r2, #0
 800bc92:	f04f 0300 	mov.w	r3, #0
 800bc96:	0a02      	lsrs	r2, r0, #8
 800bc98:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800bc9c:	0a0b      	lsrs	r3, r1, #8
 800bc9e:	b2d2      	uxtb	r2, r2
 800bca0:	687b      	ldr	r3, [r7, #4]
 800bca2:	f883 20ce 	strb.w	r2, [r3, #206]	@ 0xce
 800bca6:	7a3a      	ldrb	r2, [r7, #8]
 800bca8:	687b      	ldr	r3, [r7, #4]
 800bcaa:	f883 20cf 	strb.w	r2, [r3, #207]	@ 0xcf

    if( ( ret = mbedtls_internal_sha512_process( ctx, ctx->buffer ) ) != 0 )
 800bcae:	687b      	ldr	r3, [r7, #4]
 800bcb0:	3350      	adds	r3, #80	@ 0x50
 800bcb2:	4619      	mov	r1, r3
 800bcb4:	6878      	ldr	r0, [r7, #4]
 800bcb6:	f7fd fd7f 	bl	80097b8 <mbedtls_internal_sha512_process>
 800bcba:	61f8      	str	r0, [r7, #28]
 800bcbc:	69fb      	ldr	r3, [r7, #28]
 800bcbe:	2b00      	cmp	r3, #0
 800bcc0:	d001      	beq.n	800bcc6 <mbedtls_sha512_finish+0x26e>
        return( ret );
 800bcc2:	69fb      	ldr	r3, [r7, #28]
 800bcc4:	e345      	b.n	800c352 <mbedtls_sha512_finish+0x8fa>

    /*
     * Output final state
     */
    sha512_put_uint64_be( ctx->state[0], output,  0 );
 800bcc6:	687b      	ldr	r3, [r7, #4]
 800bcc8:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800bccc:	f04f 0200 	mov.w	r2, #0
 800bcd0:	f04f 0300 	mov.w	r3, #0
 800bcd4:	0e0a      	lsrs	r2, r1, #24
 800bcd6:	2300      	movs	r3, #0
 800bcd8:	b2d2      	uxtb	r2, r2
 800bcda:	683b      	ldr	r3, [r7, #0]
 800bcdc:	701a      	strb	r2, [r3, #0]
 800bcde:	687b      	ldr	r3, [r7, #4]
 800bce0:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800bce4:	f04f 0200 	mov.w	r2, #0
 800bce8:	f04f 0300 	mov.w	r3, #0
 800bcec:	0c0a      	lsrs	r2, r1, #16
 800bcee:	2300      	movs	r3, #0
 800bcf0:	6839      	ldr	r1, [r7, #0]
 800bcf2:	3101      	adds	r1, #1
 800bcf4:	b2d3      	uxtb	r3, r2
 800bcf6:	700b      	strb	r3, [r1, #0]
 800bcf8:	687b      	ldr	r3, [r7, #4]
 800bcfa:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800bcfe:	f04f 0200 	mov.w	r2, #0
 800bd02:	f04f 0300 	mov.w	r3, #0
 800bd06:	0a0a      	lsrs	r2, r1, #8
 800bd08:	2300      	movs	r3, #0
 800bd0a:	6839      	ldr	r1, [r7, #0]
 800bd0c:	3102      	adds	r1, #2
 800bd0e:	b2d3      	uxtb	r3, r2
 800bd10:	700b      	strb	r3, [r1, #0]
 800bd12:	687b      	ldr	r3, [r7, #4]
 800bd14:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800bd18:	f04f 0200 	mov.w	r2, #0
 800bd1c:	f04f 0300 	mov.w	r3, #0
 800bd20:	000a      	movs	r2, r1
 800bd22:	2300      	movs	r3, #0
 800bd24:	6839      	ldr	r1, [r7, #0]
 800bd26:	3103      	adds	r1, #3
 800bd28:	b2d3      	uxtb	r3, r2
 800bd2a:	700b      	strb	r3, [r1, #0]
 800bd2c:	687b      	ldr	r3, [r7, #4]
 800bd2e:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800bd32:	f04f 0200 	mov.w	r2, #0
 800bd36:	f04f 0300 	mov.w	r3, #0
 800bd3a:	0e02      	lsrs	r2, r0, #24
 800bd3c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800bd40:	0e0b      	lsrs	r3, r1, #24
 800bd42:	6839      	ldr	r1, [r7, #0]
 800bd44:	3104      	adds	r1, #4
 800bd46:	b2d3      	uxtb	r3, r2
 800bd48:	700b      	strb	r3, [r1, #0]
 800bd4a:	687b      	ldr	r3, [r7, #4]
 800bd4c:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800bd50:	f04f 0200 	mov.w	r2, #0
 800bd54:	f04f 0300 	mov.w	r3, #0
 800bd58:	0c02      	lsrs	r2, r0, #16
 800bd5a:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800bd5e:	0c0b      	lsrs	r3, r1, #16
 800bd60:	6839      	ldr	r1, [r7, #0]
 800bd62:	3105      	adds	r1, #5
 800bd64:	b2d3      	uxtb	r3, r2
 800bd66:	700b      	strb	r3, [r1, #0]
 800bd68:	687b      	ldr	r3, [r7, #4]
 800bd6a:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800bd6e:	f04f 0200 	mov.w	r2, #0
 800bd72:	f04f 0300 	mov.w	r3, #0
 800bd76:	0a02      	lsrs	r2, r0, #8
 800bd78:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800bd7c:	0a0b      	lsrs	r3, r1, #8
 800bd7e:	6839      	ldr	r1, [r7, #0]
 800bd80:	3106      	adds	r1, #6
 800bd82:	b2d3      	uxtb	r3, r2
 800bd84:	700b      	strb	r3, [r1, #0]
 800bd86:	687b      	ldr	r3, [r7, #4]
 800bd88:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800bd8c:	6839      	ldr	r1, [r7, #0]
 800bd8e:	3107      	adds	r1, #7
 800bd90:	b2d3      	uxtb	r3, r2
 800bd92:	700b      	strb	r3, [r1, #0]
    sha512_put_uint64_be( ctx->state[1], output,  8 );
 800bd94:	687b      	ldr	r3, [r7, #4]
 800bd96:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 800bd9a:	f04f 0200 	mov.w	r2, #0
 800bd9e:	f04f 0300 	mov.w	r3, #0
 800bda2:	0e0a      	lsrs	r2, r1, #24
 800bda4:	2300      	movs	r3, #0
 800bda6:	6839      	ldr	r1, [r7, #0]
 800bda8:	3108      	adds	r1, #8
 800bdaa:	b2d3      	uxtb	r3, r2
 800bdac:	700b      	strb	r3, [r1, #0]
 800bdae:	687b      	ldr	r3, [r7, #4]
 800bdb0:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 800bdb4:	f04f 0200 	mov.w	r2, #0
 800bdb8:	f04f 0300 	mov.w	r3, #0
 800bdbc:	0c0a      	lsrs	r2, r1, #16
 800bdbe:	2300      	movs	r3, #0
 800bdc0:	6839      	ldr	r1, [r7, #0]
 800bdc2:	3109      	adds	r1, #9
 800bdc4:	b2d3      	uxtb	r3, r2
 800bdc6:	700b      	strb	r3, [r1, #0]
 800bdc8:	687b      	ldr	r3, [r7, #4]
 800bdca:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 800bdce:	f04f 0200 	mov.w	r2, #0
 800bdd2:	f04f 0300 	mov.w	r3, #0
 800bdd6:	0a0a      	lsrs	r2, r1, #8
 800bdd8:	2300      	movs	r3, #0
 800bdda:	6839      	ldr	r1, [r7, #0]
 800bddc:	310a      	adds	r1, #10
 800bdde:	b2d3      	uxtb	r3, r2
 800bde0:	700b      	strb	r3, [r1, #0]
 800bde2:	687b      	ldr	r3, [r7, #4]
 800bde4:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 800bde8:	f04f 0200 	mov.w	r2, #0
 800bdec:	f04f 0300 	mov.w	r3, #0
 800bdf0:	000a      	movs	r2, r1
 800bdf2:	2300      	movs	r3, #0
 800bdf4:	6839      	ldr	r1, [r7, #0]
 800bdf6:	310b      	adds	r1, #11
 800bdf8:	b2d3      	uxtb	r3, r2
 800bdfa:	700b      	strb	r3, [r1, #0]
 800bdfc:	687b      	ldr	r3, [r7, #4]
 800bdfe:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 800be02:	f04f 0200 	mov.w	r2, #0
 800be06:	f04f 0300 	mov.w	r3, #0
 800be0a:	0e02      	lsrs	r2, r0, #24
 800be0c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800be10:	0e0b      	lsrs	r3, r1, #24
 800be12:	6839      	ldr	r1, [r7, #0]
 800be14:	310c      	adds	r1, #12
 800be16:	b2d3      	uxtb	r3, r2
 800be18:	700b      	strb	r3, [r1, #0]
 800be1a:	687b      	ldr	r3, [r7, #4]
 800be1c:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 800be20:	f04f 0200 	mov.w	r2, #0
 800be24:	f04f 0300 	mov.w	r3, #0
 800be28:	0c02      	lsrs	r2, r0, #16
 800be2a:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800be2e:	0c0b      	lsrs	r3, r1, #16
 800be30:	6839      	ldr	r1, [r7, #0]
 800be32:	310d      	adds	r1, #13
 800be34:	b2d3      	uxtb	r3, r2
 800be36:	700b      	strb	r3, [r1, #0]
 800be38:	687b      	ldr	r3, [r7, #4]
 800be3a:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 800be3e:	f04f 0200 	mov.w	r2, #0
 800be42:	f04f 0300 	mov.w	r3, #0
 800be46:	0a02      	lsrs	r2, r0, #8
 800be48:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800be4c:	0a0b      	lsrs	r3, r1, #8
 800be4e:	6839      	ldr	r1, [r7, #0]
 800be50:	310e      	adds	r1, #14
 800be52:	b2d3      	uxtb	r3, r2
 800be54:	700b      	strb	r3, [r1, #0]
 800be56:	687b      	ldr	r3, [r7, #4]
 800be58:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 800be5c:	6839      	ldr	r1, [r7, #0]
 800be5e:	310f      	adds	r1, #15
 800be60:	b2d3      	uxtb	r3, r2
 800be62:	700b      	strb	r3, [r1, #0]
    sha512_put_uint64_be( ctx->state[2], output, 16 );
 800be64:	687b      	ldr	r3, [r7, #4]
 800be66:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 800be6a:	f04f 0200 	mov.w	r2, #0
 800be6e:	f04f 0300 	mov.w	r3, #0
 800be72:	0e0a      	lsrs	r2, r1, #24
 800be74:	2300      	movs	r3, #0
 800be76:	6839      	ldr	r1, [r7, #0]
 800be78:	3110      	adds	r1, #16
 800be7a:	b2d3      	uxtb	r3, r2
 800be7c:	700b      	strb	r3, [r1, #0]
 800be7e:	687b      	ldr	r3, [r7, #4]
 800be80:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 800be84:	f04f 0200 	mov.w	r2, #0
 800be88:	f04f 0300 	mov.w	r3, #0
 800be8c:	0c0a      	lsrs	r2, r1, #16
 800be8e:	2300      	movs	r3, #0
 800be90:	6839      	ldr	r1, [r7, #0]
 800be92:	3111      	adds	r1, #17
 800be94:	b2d3      	uxtb	r3, r2
 800be96:	700b      	strb	r3, [r1, #0]
 800be98:	687b      	ldr	r3, [r7, #4]
 800be9a:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 800be9e:	f04f 0200 	mov.w	r2, #0
 800bea2:	f04f 0300 	mov.w	r3, #0
 800bea6:	0a0a      	lsrs	r2, r1, #8
 800bea8:	2300      	movs	r3, #0
 800beaa:	6839      	ldr	r1, [r7, #0]
 800beac:	3112      	adds	r1, #18
 800beae:	b2d3      	uxtb	r3, r2
 800beb0:	700b      	strb	r3, [r1, #0]
 800beb2:	687b      	ldr	r3, [r7, #4]
 800beb4:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 800beb8:	f04f 0200 	mov.w	r2, #0
 800bebc:	f04f 0300 	mov.w	r3, #0
 800bec0:	000a      	movs	r2, r1
 800bec2:	2300      	movs	r3, #0
 800bec4:	6839      	ldr	r1, [r7, #0]
 800bec6:	3113      	adds	r1, #19
 800bec8:	b2d3      	uxtb	r3, r2
 800beca:	700b      	strb	r3, [r1, #0]
 800becc:	687b      	ldr	r3, [r7, #4]
 800bece:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 800bed2:	f04f 0200 	mov.w	r2, #0
 800bed6:	f04f 0300 	mov.w	r3, #0
 800beda:	0e02      	lsrs	r2, r0, #24
 800bedc:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800bee0:	0e0b      	lsrs	r3, r1, #24
 800bee2:	6839      	ldr	r1, [r7, #0]
 800bee4:	3114      	adds	r1, #20
 800bee6:	b2d3      	uxtb	r3, r2
 800bee8:	700b      	strb	r3, [r1, #0]
 800beea:	687b      	ldr	r3, [r7, #4]
 800beec:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 800bef0:	f04f 0200 	mov.w	r2, #0
 800bef4:	f04f 0300 	mov.w	r3, #0
 800bef8:	0c02      	lsrs	r2, r0, #16
 800befa:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800befe:	0c0b      	lsrs	r3, r1, #16
 800bf00:	6839      	ldr	r1, [r7, #0]
 800bf02:	3115      	adds	r1, #21
 800bf04:	b2d3      	uxtb	r3, r2
 800bf06:	700b      	strb	r3, [r1, #0]
 800bf08:	687b      	ldr	r3, [r7, #4]
 800bf0a:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 800bf0e:	f04f 0200 	mov.w	r2, #0
 800bf12:	f04f 0300 	mov.w	r3, #0
 800bf16:	0a02      	lsrs	r2, r0, #8
 800bf18:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800bf1c:	0a0b      	lsrs	r3, r1, #8
 800bf1e:	6839      	ldr	r1, [r7, #0]
 800bf20:	3116      	adds	r1, #22
 800bf22:	b2d3      	uxtb	r3, r2
 800bf24:	700b      	strb	r3, [r1, #0]
 800bf26:	687b      	ldr	r3, [r7, #4]
 800bf28:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 800bf2c:	6839      	ldr	r1, [r7, #0]
 800bf2e:	3117      	adds	r1, #23
 800bf30:	b2d3      	uxtb	r3, r2
 800bf32:	700b      	strb	r3, [r1, #0]
    sha512_put_uint64_be( ctx->state[3], output, 24 );
 800bf34:	687b      	ldr	r3, [r7, #4]
 800bf36:	e9d3 010a 	ldrd	r0, r1, [r3, #40]	@ 0x28
 800bf3a:	f04f 0200 	mov.w	r2, #0
 800bf3e:	f04f 0300 	mov.w	r3, #0
 800bf42:	0e0a      	lsrs	r2, r1, #24
 800bf44:	2300      	movs	r3, #0
 800bf46:	6839      	ldr	r1, [r7, #0]
 800bf48:	3118      	adds	r1, #24
 800bf4a:	b2d3      	uxtb	r3, r2
 800bf4c:	700b      	strb	r3, [r1, #0]
 800bf4e:	687b      	ldr	r3, [r7, #4]
 800bf50:	e9d3 010a 	ldrd	r0, r1, [r3, #40]	@ 0x28
 800bf54:	f04f 0200 	mov.w	r2, #0
 800bf58:	f04f 0300 	mov.w	r3, #0
 800bf5c:	0c0a      	lsrs	r2, r1, #16
 800bf5e:	2300      	movs	r3, #0
 800bf60:	6839      	ldr	r1, [r7, #0]
 800bf62:	3119      	adds	r1, #25
 800bf64:	b2d3      	uxtb	r3, r2
 800bf66:	700b      	strb	r3, [r1, #0]
 800bf68:	687b      	ldr	r3, [r7, #4]
 800bf6a:	e9d3 010a 	ldrd	r0, r1, [r3, #40]	@ 0x28
 800bf6e:	f04f 0200 	mov.w	r2, #0
 800bf72:	f04f 0300 	mov.w	r3, #0
 800bf76:	0a0a      	lsrs	r2, r1, #8
 800bf78:	2300      	movs	r3, #0
 800bf7a:	6839      	ldr	r1, [r7, #0]
 800bf7c:	311a      	adds	r1, #26
 800bf7e:	b2d3      	uxtb	r3, r2
 800bf80:	700b      	strb	r3, [r1, #0]
 800bf82:	687b      	ldr	r3, [r7, #4]
 800bf84:	e9d3 010a 	ldrd	r0, r1, [r3, #40]	@ 0x28
 800bf88:	f04f 0200 	mov.w	r2, #0
 800bf8c:	f04f 0300 	mov.w	r3, #0
 800bf90:	000a      	movs	r2, r1
 800bf92:	2300      	movs	r3, #0
 800bf94:	6839      	ldr	r1, [r7, #0]
 800bf96:	311b      	adds	r1, #27
 800bf98:	b2d3      	uxtb	r3, r2
 800bf9a:	700b      	strb	r3, [r1, #0]
 800bf9c:	687b      	ldr	r3, [r7, #4]
 800bf9e:	e9d3 010a 	ldrd	r0, r1, [r3, #40]	@ 0x28
 800bfa2:	f04f 0200 	mov.w	r2, #0
 800bfa6:	f04f 0300 	mov.w	r3, #0
 800bfaa:	0e02      	lsrs	r2, r0, #24
 800bfac:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800bfb0:	0e0b      	lsrs	r3, r1, #24
 800bfb2:	6839      	ldr	r1, [r7, #0]
 800bfb4:	311c      	adds	r1, #28
 800bfb6:	b2d3      	uxtb	r3, r2
 800bfb8:	700b      	strb	r3, [r1, #0]
 800bfba:	687b      	ldr	r3, [r7, #4]
 800bfbc:	e9d3 010a 	ldrd	r0, r1, [r3, #40]	@ 0x28
 800bfc0:	f04f 0200 	mov.w	r2, #0
 800bfc4:	f04f 0300 	mov.w	r3, #0
 800bfc8:	0c02      	lsrs	r2, r0, #16
 800bfca:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800bfce:	0c0b      	lsrs	r3, r1, #16
 800bfd0:	6839      	ldr	r1, [r7, #0]
 800bfd2:	311d      	adds	r1, #29
 800bfd4:	b2d3      	uxtb	r3, r2
 800bfd6:	700b      	strb	r3, [r1, #0]
 800bfd8:	687b      	ldr	r3, [r7, #4]
 800bfda:	e9d3 010a 	ldrd	r0, r1, [r3, #40]	@ 0x28
 800bfde:	f04f 0200 	mov.w	r2, #0
 800bfe2:	f04f 0300 	mov.w	r3, #0
 800bfe6:	0a02      	lsrs	r2, r0, #8
 800bfe8:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800bfec:	0a0b      	lsrs	r3, r1, #8
 800bfee:	6839      	ldr	r1, [r7, #0]
 800bff0:	311e      	adds	r1, #30
 800bff2:	b2d3      	uxtb	r3, r2
 800bff4:	700b      	strb	r3, [r1, #0]
 800bff6:	687b      	ldr	r3, [r7, #4]
 800bff8:	e9d3 230a 	ldrd	r2, r3, [r3, #40]	@ 0x28
 800bffc:	6839      	ldr	r1, [r7, #0]
 800bffe:	311f      	adds	r1, #31
 800c000:	b2d3      	uxtb	r3, r2
 800c002:	700b      	strb	r3, [r1, #0]
    sha512_put_uint64_be( ctx->state[4], output, 32 );
 800c004:	687b      	ldr	r3, [r7, #4]
 800c006:	e9d3 010c 	ldrd	r0, r1, [r3, #48]	@ 0x30
 800c00a:	f04f 0200 	mov.w	r2, #0
 800c00e:	f04f 0300 	mov.w	r3, #0
 800c012:	0e0a      	lsrs	r2, r1, #24
 800c014:	2300      	movs	r3, #0
 800c016:	6839      	ldr	r1, [r7, #0]
 800c018:	3120      	adds	r1, #32
 800c01a:	b2d3      	uxtb	r3, r2
 800c01c:	700b      	strb	r3, [r1, #0]
 800c01e:	687b      	ldr	r3, [r7, #4]
 800c020:	e9d3 010c 	ldrd	r0, r1, [r3, #48]	@ 0x30
 800c024:	f04f 0200 	mov.w	r2, #0
 800c028:	f04f 0300 	mov.w	r3, #0
 800c02c:	0c0a      	lsrs	r2, r1, #16
 800c02e:	2300      	movs	r3, #0
 800c030:	6839      	ldr	r1, [r7, #0]
 800c032:	3121      	adds	r1, #33	@ 0x21
 800c034:	b2d3      	uxtb	r3, r2
 800c036:	700b      	strb	r3, [r1, #0]
 800c038:	687b      	ldr	r3, [r7, #4]
 800c03a:	e9d3 010c 	ldrd	r0, r1, [r3, #48]	@ 0x30
 800c03e:	f04f 0200 	mov.w	r2, #0
 800c042:	f04f 0300 	mov.w	r3, #0
 800c046:	0a0a      	lsrs	r2, r1, #8
 800c048:	2300      	movs	r3, #0
 800c04a:	6839      	ldr	r1, [r7, #0]
 800c04c:	3122      	adds	r1, #34	@ 0x22
 800c04e:	b2d3      	uxtb	r3, r2
 800c050:	700b      	strb	r3, [r1, #0]
 800c052:	687b      	ldr	r3, [r7, #4]
 800c054:	e9d3 010c 	ldrd	r0, r1, [r3, #48]	@ 0x30
 800c058:	f04f 0200 	mov.w	r2, #0
 800c05c:	f04f 0300 	mov.w	r3, #0
 800c060:	000a      	movs	r2, r1
 800c062:	2300      	movs	r3, #0
 800c064:	6839      	ldr	r1, [r7, #0]
 800c066:	3123      	adds	r1, #35	@ 0x23
 800c068:	b2d3      	uxtb	r3, r2
 800c06a:	700b      	strb	r3, [r1, #0]
 800c06c:	687b      	ldr	r3, [r7, #4]
 800c06e:	e9d3 010c 	ldrd	r0, r1, [r3, #48]	@ 0x30
 800c072:	f04f 0200 	mov.w	r2, #0
 800c076:	f04f 0300 	mov.w	r3, #0
 800c07a:	0e02      	lsrs	r2, r0, #24
 800c07c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800c080:	0e0b      	lsrs	r3, r1, #24
 800c082:	6839      	ldr	r1, [r7, #0]
 800c084:	3124      	adds	r1, #36	@ 0x24
 800c086:	b2d3      	uxtb	r3, r2
 800c088:	700b      	strb	r3, [r1, #0]
 800c08a:	687b      	ldr	r3, [r7, #4]
 800c08c:	e9d3 010c 	ldrd	r0, r1, [r3, #48]	@ 0x30
 800c090:	f04f 0200 	mov.w	r2, #0
 800c094:	f04f 0300 	mov.w	r3, #0
 800c098:	0c02      	lsrs	r2, r0, #16
 800c09a:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800c09e:	0c0b      	lsrs	r3, r1, #16
 800c0a0:	6839      	ldr	r1, [r7, #0]
 800c0a2:	3125      	adds	r1, #37	@ 0x25
 800c0a4:	b2d3      	uxtb	r3, r2
 800c0a6:	700b      	strb	r3, [r1, #0]
 800c0a8:	687b      	ldr	r3, [r7, #4]
 800c0aa:	e9d3 010c 	ldrd	r0, r1, [r3, #48]	@ 0x30
 800c0ae:	f04f 0200 	mov.w	r2, #0
 800c0b2:	f04f 0300 	mov.w	r3, #0
 800c0b6:	0a02      	lsrs	r2, r0, #8
 800c0b8:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800c0bc:	0a0b      	lsrs	r3, r1, #8
 800c0be:	6839      	ldr	r1, [r7, #0]
 800c0c0:	3126      	adds	r1, #38	@ 0x26
 800c0c2:	b2d3      	uxtb	r3, r2
 800c0c4:	700b      	strb	r3, [r1, #0]
 800c0c6:	687b      	ldr	r3, [r7, #4]
 800c0c8:	e9d3 230c 	ldrd	r2, r3, [r3, #48]	@ 0x30
 800c0cc:	6839      	ldr	r1, [r7, #0]
 800c0ce:	3127      	adds	r1, #39	@ 0x27
 800c0d0:	b2d3      	uxtb	r3, r2
 800c0d2:	700b      	strb	r3, [r1, #0]
    sha512_put_uint64_be( ctx->state[5], output, 40 );
 800c0d4:	687b      	ldr	r3, [r7, #4]
 800c0d6:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 800c0da:	f04f 0200 	mov.w	r2, #0
 800c0de:	f04f 0300 	mov.w	r3, #0
 800c0e2:	0e0a      	lsrs	r2, r1, #24
 800c0e4:	2300      	movs	r3, #0
 800c0e6:	6839      	ldr	r1, [r7, #0]
 800c0e8:	3128      	adds	r1, #40	@ 0x28
 800c0ea:	b2d3      	uxtb	r3, r2
 800c0ec:	700b      	strb	r3, [r1, #0]
 800c0ee:	687b      	ldr	r3, [r7, #4]
 800c0f0:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 800c0f4:	f04f 0200 	mov.w	r2, #0
 800c0f8:	f04f 0300 	mov.w	r3, #0
 800c0fc:	0c0a      	lsrs	r2, r1, #16
 800c0fe:	2300      	movs	r3, #0
 800c100:	6839      	ldr	r1, [r7, #0]
 800c102:	3129      	adds	r1, #41	@ 0x29
 800c104:	b2d3      	uxtb	r3, r2
 800c106:	700b      	strb	r3, [r1, #0]
 800c108:	687b      	ldr	r3, [r7, #4]
 800c10a:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 800c10e:	f04f 0200 	mov.w	r2, #0
 800c112:	f04f 0300 	mov.w	r3, #0
 800c116:	0a0a      	lsrs	r2, r1, #8
 800c118:	2300      	movs	r3, #0
 800c11a:	6839      	ldr	r1, [r7, #0]
 800c11c:	312a      	adds	r1, #42	@ 0x2a
 800c11e:	b2d3      	uxtb	r3, r2
 800c120:	700b      	strb	r3, [r1, #0]
 800c122:	687b      	ldr	r3, [r7, #4]
 800c124:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 800c128:	f04f 0200 	mov.w	r2, #0
 800c12c:	f04f 0300 	mov.w	r3, #0
 800c130:	000a      	movs	r2, r1
 800c132:	2300      	movs	r3, #0
 800c134:	6839      	ldr	r1, [r7, #0]
 800c136:	312b      	adds	r1, #43	@ 0x2b
 800c138:	b2d3      	uxtb	r3, r2
 800c13a:	700b      	strb	r3, [r1, #0]
 800c13c:	687b      	ldr	r3, [r7, #4]
 800c13e:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 800c142:	f04f 0200 	mov.w	r2, #0
 800c146:	f04f 0300 	mov.w	r3, #0
 800c14a:	0e02      	lsrs	r2, r0, #24
 800c14c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800c150:	0e0b      	lsrs	r3, r1, #24
 800c152:	6839      	ldr	r1, [r7, #0]
 800c154:	312c      	adds	r1, #44	@ 0x2c
 800c156:	b2d3      	uxtb	r3, r2
 800c158:	700b      	strb	r3, [r1, #0]
 800c15a:	687b      	ldr	r3, [r7, #4]
 800c15c:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 800c160:	f04f 0200 	mov.w	r2, #0
 800c164:	f04f 0300 	mov.w	r3, #0
 800c168:	0c02      	lsrs	r2, r0, #16
 800c16a:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800c16e:	0c0b      	lsrs	r3, r1, #16
 800c170:	6839      	ldr	r1, [r7, #0]
 800c172:	312d      	adds	r1, #45	@ 0x2d
 800c174:	b2d3      	uxtb	r3, r2
 800c176:	700b      	strb	r3, [r1, #0]
 800c178:	687b      	ldr	r3, [r7, #4]
 800c17a:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 800c17e:	f04f 0200 	mov.w	r2, #0
 800c182:	f04f 0300 	mov.w	r3, #0
 800c186:	0a02      	lsrs	r2, r0, #8
 800c188:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800c18c:	0a0b      	lsrs	r3, r1, #8
 800c18e:	6839      	ldr	r1, [r7, #0]
 800c190:	312e      	adds	r1, #46	@ 0x2e
 800c192:	b2d3      	uxtb	r3, r2
 800c194:	700b      	strb	r3, [r1, #0]
 800c196:	687b      	ldr	r3, [r7, #4]
 800c198:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 800c19c:	6839      	ldr	r1, [r7, #0]
 800c19e:	312f      	adds	r1, #47	@ 0x2f
 800c1a0:	b2d3      	uxtb	r3, r2
 800c1a2:	700b      	strb	r3, [r1, #0]

#if defined(MBEDTLS_SHA384_C)
    if( ctx->is384 == 0 )
 800c1a4:	687b      	ldr	r3, [r7, #4]
 800c1a6:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
 800c1aa:	2b00      	cmp	r3, #0
 800c1ac:	f040 80d0 	bne.w	800c350 <mbedtls_sha512_finish+0x8f8>
#endif
    {
        sha512_put_uint64_be( ctx->state[6], output, 48 );
 800c1b0:	687b      	ldr	r3, [r7, #4]
 800c1b2:	e9d3 0110 	ldrd	r0, r1, [r3, #64]	@ 0x40
 800c1b6:	f04f 0200 	mov.w	r2, #0
 800c1ba:	f04f 0300 	mov.w	r3, #0
 800c1be:	0e0a      	lsrs	r2, r1, #24
 800c1c0:	2300      	movs	r3, #0
 800c1c2:	6839      	ldr	r1, [r7, #0]
 800c1c4:	3130      	adds	r1, #48	@ 0x30
 800c1c6:	b2d3      	uxtb	r3, r2
 800c1c8:	700b      	strb	r3, [r1, #0]
 800c1ca:	687b      	ldr	r3, [r7, #4]
 800c1cc:	e9d3 0110 	ldrd	r0, r1, [r3, #64]	@ 0x40
 800c1d0:	f04f 0200 	mov.w	r2, #0
 800c1d4:	f04f 0300 	mov.w	r3, #0
 800c1d8:	0c0a      	lsrs	r2, r1, #16
 800c1da:	2300      	movs	r3, #0
 800c1dc:	6839      	ldr	r1, [r7, #0]
 800c1de:	3131      	adds	r1, #49	@ 0x31
 800c1e0:	b2d3      	uxtb	r3, r2
 800c1e2:	700b      	strb	r3, [r1, #0]
 800c1e4:	687b      	ldr	r3, [r7, #4]
 800c1e6:	e9d3 0110 	ldrd	r0, r1, [r3, #64]	@ 0x40
 800c1ea:	f04f 0200 	mov.w	r2, #0
 800c1ee:	f04f 0300 	mov.w	r3, #0
 800c1f2:	0a0a      	lsrs	r2, r1, #8
 800c1f4:	2300      	movs	r3, #0
 800c1f6:	6839      	ldr	r1, [r7, #0]
 800c1f8:	3132      	adds	r1, #50	@ 0x32
 800c1fa:	b2d3      	uxtb	r3, r2
 800c1fc:	700b      	strb	r3, [r1, #0]
 800c1fe:	687b      	ldr	r3, [r7, #4]
 800c200:	e9d3 0110 	ldrd	r0, r1, [r3, #64]	@ 0x40
 800c204:	f04f 0200 	mov.w	r2, #0
 800c208:	f04f 0300 	mov.w	r3, #0
 800c20c:	000a      	movs	r2, r1
 800c20e:	2300      	movs	r3, #0
 800c210:	6839      	ldr	r1, [r7, #0]
 800c212:	3133      	adds	r1, #51	@ 0x33
 800c214:	b2d3      	uxtb	r3, r2
 800c216:	700b      	strb	r3, [r1, #0]
 800c218:	687b      	ldr	r3, [r7, #4]
 800c21a:	e9d3 0110 	ldrd	r0, r1, [r3, #64]	@ 0x40
 800c21e:	f04f 0200 	mov.w	r2, #0
 800c222:	f04f 0300 	mov.w	r3, #0
 800c226:	0e02      	lsrs	r2, r0, #24
 800c228:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800c22c:	0e0b      	lsrs	r3, r1, #24
 800c22e:	6839      	ldr	r1, [r7, #0]
 800c230:	3134      	adds	r1, #52	@ 0x34
 800c232:	b2d3      	uxtb	r3, r2
 800c234:	700b      	strb	r3, [r1, #0]
 800c236:	687b      	ldr	r3, [r7, #4]
 800c238:	e9d3 0110 	ldrd	r0, r1, [r3, #64]	@ 0x40
 800c23c:	f04f 0200 	mov.w	r2, #0
 800c240:	f04f 0300 	mov.w	r3, #0
 800c244:	0c02      	lsrs	r2, r0, #16
 800c246:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800c24a:	0c0b      	lsrs	r3, r1, #16
 800c24c:	6839      	ldr	r1, [r7, #0]
 800c24e:	3135      	adds	r1, #53	@ 0x35
 800c250:	b2d3      	uxtb	r3, r2
 800c252:	700b      	strb	r3, [r1, #0]
 800c254:	687b      	ldr	r3, [r7, #4]
 800c256:	e9d3 0110 	ldrd	r0, r1, [r3, #64]	@ 0x40
 800c25a:	f04f 0200 	mov.w	r2, #0
 800c25e:	f04f 0300 	mov.w	r3, #0
 800c262:	0a02      	lsrs	r2, r0, #8
 800c264:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800c268:	0a0b      	lsrs	r3, r1, #8
 800c26a:	6839      	ldr	r1, [r7, #0]
 800c26c:	3136      	adds	r1, #54	@ 0x36
 800c26e:	b2d3      	uxtb	r3, r2
 800c270:	700b      	strb	r3, [r1, #0]
 800c272:	687b      	ldr	r3, [r7, #4]
 800c274:	e9d3 2310 	ldrd	r2, r3, [r3, #64]	@ 0x40
 800c278:	6839      	ldr	r1, [r7, #0]
 800c27a:	3137      	adds	r1, #55	@ 0x37
 800c27c:	b2d3      	uxtb	r3, r2
 800c27e:	700b      	strb	r3, [r1, #0]
        sha512_put_uint64_be( ctx->state[7], output, 56 );
 800c280:	687b      	ldr	r3, [r7, #4]
 800c282:	e9d3 0112 	ldrd	r0, r1, [r3, #72]	@ 0x48
 800c286:	f04f 0200 	mov.w	r2, #0
 800c28a:	f04f 0300 	mov.w	r3, #0
 800c28e:	0e0a      	lsrs	r2, r1, #24
 800c290:	2300      	movs	r3, #0
 800c292:	6839      	ldr	r1, [r7, #0]
 800c294:	3138      	adds	r1, #56	@ 0x38
 800c296:	b2d3      	uxtb	r3, r2
 800c298:	700b      	strb	r3, [r1, #0]
 800c29a:	687b      	ldr	r3, [r7, #4]
 800c29c:	e9d3 0112 	ldrd	r0, r1, [r3, #72]	@ 0x48
 800c2a0:	f04f 0200 	mov.w	r2, #0
 800c2a4:	f04f 0300 	mov.w	r3, #0
 800c2a8:	0c0a      	lsrs	r2, r1, #16
 800c2aa:	2300      	movs	r3, #0
 800c2ac:	6839      	ldr	r1, [r7, #0]
 800c2ae:	3139      	adds	r1, #57	@ 0x39
 800c2b0:	b2d3      	uxtb	r3, r2
 800c2b2:	700b      	strb	r3, [r1, #0]
 800c2b4:	687b      	ldr	r3, [r7, #4]
 800c2b6:	e9d3 0112 	ldrd	r0, r1, [r3, #72]	@ 0x48
 800c2ba:	f04f 0200 	mov.w	r2, #0
 800c2be:	f04f 0300 	mov.w	r3, #0
 800c2c2:	0a0a      	lsrs	r2, r1, #8
 800c2c4:	2300      	movs	r3, #0
 800c2c6:	6839      	ldr	r1, [r7, #0]
 800c2c8:	313a      	adds	r1, #58	@ 0x3a
 800c2ca:	b2d3      	uxtb	r3, r2
 800c2cc:	700b      	strb	r3, [r1, #0]
 800c2ce:	687b      	ldr	r3, [r7, #4]
 800c2d0:	e9d3 0112 	ldrd	r0, r1, [r3, #72]	@ 0x48
 800c2d4:	f04f 0200 	mov.w	r2, #0
 800c2d8:	f04f 0300 	mov.w	r3, #0
 800c2dc:	000a      	movs	r2, r1
 800c2de:	2300      	movs	r3, #0
 800c2e0:	6839      	ldr	r1, [r7, #0]
 800c2e2:	313b      	adds	r1, #59	@ 0x3b
 800c2e4:	b2d3      	uxtb	r3, r2
 800c2e6:	700b      	strb	r3, [r1, #0]
 800c2e8:	687b      	ldr	r3, [r7, #4]
 800c2ea:	e9d3 0112 	ldrd	r0, r1, [r3, #72]	@ 0x48
 800c2ee:	f04f 0200 	mov.w	r2, #0
 800c2f2:	f04f 0300 	mov.w	r3, #0
 800c2f6:	0e02      	lsrs	r2, r0, #24
 800c2f8:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800c2fc:	0e0b      	lsrs	r3, r1, #24
 800c2fe:	6839      	ldr	r1, [r7, #0]
 800c300:	313c      	adds	r1, #60	@ 0x3c
 800c302:	b2d3      	uxtb	r3, r2
 800c304:	700b      	strb	r3, [r1, #0]
 800c306:	687b      	ldr	r3, [r7, #4]
 800c308:	e9d3 0112 	ldrd	r0, r1, [r3, #72]	@ 0x48
 800c30c:	f04f 0200 	mov.w	r2, #0
 800c310:	f04f 0300 	mov.w	r3, #0
 800c314:	0c02      	lsrs	r2, r0, #16
 800c316:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800c31a:	0c0b      	lsrs	r3, r1, #16
 800c31c:	6839      	ldr	r1, [r7, #0]
 800c31e:	313d      	adds	r1, #61	@ 0x3d
 800c320:	b2d3      	uxtb	r3, r2
 800c322:	700b      	strb	r3, [r1, #0]
 800c324:	687b      	ldr	r3, [r7, #4]
 800c326:	e9d3 0112 	ldrd	r0, r1, [r3, #72]	@ 0x48
 800c32a:	f04f 0200 	mov.w	r2, #0
 800c32e:	f04f 0300 	mov.w	r3, #0
 800c332:	0a02      	lsrs	r2, r0, #8
 800c334:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800c338:	0a0b      	lsrs	r3, r1, #8
 800c33a:	6839      	ldr	r1, [r7, #0]
 800c33c:	313e      	adds	r1, #62	@ 0x3e
 800c33e:	b2d3      	uxtb	r3, r2
 800c340:	700b      	strb	r3, [r1, #0]
 800c342:	687b      	ldr	r3, [r7, #4]
 800c344:	e9d3 2312 	ldrd	r2, r3, [r3, #72]	@ 0x48
 800c348:	6839      	ldr	r1, [r7, #0]
 800c34a:	313f      	adds	r1, #63	@ 0x3f
 800c34c:	b2d3      	uxtb	r3, r2
 800c34e:	700b      	strb	r3, [r1, #0]
    }

    return( 0 );
 800c350:	2300      	movs	r3, #0
}
 800c352:	4618      	mov	r0, r3
 800c354:	3720      	adds	r7, #32
 800c356:	46bd      	mov	sp, r7
 800c358:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}

0800c35c <th_aes_create>:
    } additional_ctx;
} th_mbedtls_aes_context_t;

ee_status_t
th_aes_create(void **p_context, ee_aes_mode_t mode)
{
 800c35c:	b580      	push	{r7, lr}
 800c35e:	b082      	sub	sp, #8
 800c360:	af00      	add	r7, sp, #0
 800c362:	6078      	str	r0, [r7, #4]
 800c364:	460b      	mov	r3, r1
 800c366:	70fb      	strb	r3, [r7, #3]
    *p_context = (th_mbedtls_aes_context_t *)th_malloc(
 800c368:	f44f 70e0 	mov.w	r0, #448	@ 0x1c0
 800c36c:	f000 fd2e 	bl	800cdcc <th_malloc>
 800c370:	4602      	mov	r2, r0
 800c372:	687b      	ldr	r3, [r7, #4]
 800c374:	601a      	str	r2, [r3, #0]
        sizeof(th_mbedtls_aes_context_t));
    if (mode == EE_AES_ECB || mode == EE_AES_CTR || mode == EE_AES_CCM
 800c376:	78fb      	ldrb	r3, [r7, #3]
 800c378:	2b00      	cmp	r3, #0
 800c37a:	d008      	beq.n	800c38e <th_aes_create+0x32>
 800c37c:	78fb      	ldrb	r3, [r7, #3]
 800c37e:	2b01      	cmp	r3, #1
 800c380:	d005      	beq.n	800c38e <th_aes_create+0x32>
 800c382:	78fb      	ldrb	r3, [r7, #3]
 800c384:	2b02      	cmp	r3, #2
 800c386:	d002      	beq.n	800c38e <th_aes_create+0x32>
        || mode == EE_AES_GCM)
 800c388:	78fb      	ldrb	r3, [r7, #3]
 800c38a:	2b03      	cmp	r3, #3
 800c38c:	d108      	bne.n	800c3a0 <th_aes_create+0x44>
    {
        ((th_mbedtls_aes_context_t *)(*p_context))->aes_mode = mode;
 800c38e:	687b      	ldr	r3, [r7, #4]
 800c390:	681b      	ldr	r3, [r3, #0]
 800c392:	78fa      	ldrb	r2, [r7, #3]
 800c394:	701a      	strb	r2, [r3, #0]
        th_free(*p_context);
        th_printf("e-[Unknown mode in th_aes128_create]\r\n");
        return EE_STATUS_ERROR;
    }

    if (*p_context == NULL)
 800c396:	687b      	ldr	r3, [r7, #4]
 800c398:	681b      	ldr	r3, [r3, #0]
 800c39a:	2b00      	cmp	r3, #0
 800c39c:	d00a      	beq.n	800c3b4 <th_aes_create+0x58>
 800c39e:	e00e      	b.n	800c3be <th_aes_create+0x62>
        th_free(*p_context);
 800c3a0:	687b      	ldr	r3, [r7, #4]
 800c3a2:	681b      	ldr	r3, [r3, #0]
 800c3a4:	4618      	mov	r0, r3
 800c3a6:	f000 fd1d 	bl	800cde4 <th_free>
        th_printf("e-[Unknown mode in th_aes128_create]\r\n");
 800c3aa:	4807      	ldr	r0, [pc, #28]	@ (800c3c8 <th_aes_create+0x6c>)
 800c3ac:	f000 fcdc 	bl	800cd68 <th_printf>
        return EE_STATUS_ERROR;
 800c3b0:	2301      	movs	r3, #1
 800c3b2:	e005      	b.n	800c3c0 <th_aes_create+0x64>
    {
        th_printf("e-[malloc() fail in th_aes128_create]\r\n");
 800c3b4:	4805      	ldr	r0, [pc, #20]	@ (800c3cc <th_aes_create+0x70>)
 800c3b6:	f000 fcd7 	bl	800cd68 <th_printf>
        return EE_STATUS_ERROR;
 800c3ba:	2301      	movs	r3, #1
 800c3bc:	e000      	b.n	800c3c0 <th_aes_create+0x64>
    }

    return EE_STATUS_OK;
 800c3be:	2300      	movs	r3, #0
}
 800c3c0:	4618      	mov	r0, r3
 800c3c2:	3708      	adds	r7, #8
 800c3c4:	46bd      	mov	sp, r7
 800c3c6:	bd80      	pop	{r7, pc}
 800c3c8:	08015f88 	.word	0x08015f88
 800c3cc:	08015fb0 	.word	0x08015fb0

0800c3d0 <th_aes_init>:
            const uint8_t *p_key,
            uint32_t       keylen,
            const uint8_t *iv,
            ee_aes_func_t  func,
            ee_aes_mode_t  mode)
{
 800c3d0:	b580      	push	{r7, lr}
 800c3d2:	b08a      	sub	sp, #40	@ 0x28
 800c3d4:	af00      	add	r7, sp, #0
 800c3d6:	60f8      	str	r0, [r7, #12]
 800c3d8:	60b9      	str	r1, [r7, #8]
 800c3da:	607a      	str	r2, [r7, #4]
 800c3dc:	603b      	str	r3, [r7, #0]
    int                  keybits;
    mbedtls_aes_context *p_ecb;
    mbedtls_ccm_context *p_ccm;
    mbedtls_gcm_context *p_gcm;

    CHECK_NULL_CTX(p_context);
 800c3de:	68fb      	ldr	r3, [r7, #12]
 800c3e0:	2b00      	cmp	r3, #0
 800c3e2:	d106      	bne.n	800c3f2 <th_aes_init+0x22>
 800c3e4:	225f      	movs	r2, #95	@ 0x5f
 800c3e6:	4959      	ldr	r1, [pc, #356]	@ (800c54c <th_aes_init+0x17c>)
 800c3e8:	4859      	ldr	r0, [pc, #356]	@ (800c550 <th_aes_init+0x180>)
 800c3ea:	f000 fcbd 	bl	800cd68 <th_printf>
 800c3ee:	2301      	movs	r3, #1
 800c3f0:	e0a7      	b.n	800c542 <th_aes_init+0x172>

    keybits = keylen * 8;
 800c3f2:	687b      	ldr	r3, [r7, #4]
 800c3f4:	00db      	lsls	r3, r3, #3
 800c3f6:	623b      	str	r3, [r7, #32]

    if (mode != ((th_mbedtls_aes_context_t *)p_context)->aes_mode)
 800c3f8:	68fb      	ldr	r3, [r7, #12]
 800c3fa:	781b      	ldrb	r3, [r3, #0]
 800c3fc:	f897 2034 	ldrb.w	r2, [r7, #52]	@ 0x34
 800c400:	429a      	cmp	r2, r3
 800c402:	d001      	beq.n	800c408 <th_aes_init+0x38>
    {
        return EE_STATUS_ERROR;
 800c404:	2301      	movs	r3, #1
 800c406:	e09c      	b.n	800c542 <th_aes_init+0x172>
    }

    if (mode == EE_AES_ECB || mode == EE_AES_CTR)
 800c408:	f897 3034 	ldrb.w	r3, [r7, #52]	@ 0x34
 800c40c:	2b00      	cmp	r3, #0
 800c40e:	d003      	beq.n	800c418 <th_aes_init+0x48>
 800c410:	f897 3034 	ldrb.w	r3, [r7, #52]	@ 0x34
 800c414:	2b01      	cmp	r3, #1
 800c416:	d156      	bne.n	800c4c6 <th_aes_init+0xf6>
    {
        p_ecb = &((th_mbedtls_aes_context_t *)p_context)->ctx.aes_ctx;
 800c418:	68fb      	ldr	r3, [r7, #12]
 800c41a:	3308      	adds	r3, #8
 800c41c:	617b      	str	r3, [r7, #20]
        mbedtls_aes_init(p_ecb);
 800c41e:	6978      	ldr	r0, [r7, #20]
 800c420:	f7f4 fb28 	bl	8000a74 <mbedtls_aes_init>
        if (func == EE_AES_ENC)
 800c424:	f897 3030 	ldrb.w	r3, [r7, #48]	@ 0x30
 800c428:	2b00      	cmp	r3, #0
 800c42a:	d111      	bne.n	800c450 <th_aes_init+0x80>
        {
            ret = mbedtls_aes_setkey_enc(p_ecb, p_key, keybits);
 800c42c:	6a3b      	ldr	r3, [r7, #32]
 800c42e:	461a      	mov	r2, r3
 800c430:	68b9      	ldr	r1, [r7, #8]
 800c432:	6978      	ldr	r0, [r7, #20]
 800c434:	f7f4 fb66 	bl	8000b04 <mbedtls_aes_setkey_enc>
 800c438:	6278      	str	r0, [r7, #36]	@ 0x24
            if (ret != 0)
 800c43a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c43c:	2b00      	cmp	r3, #0
 800c43e:	d029      	beq.n	800c494 <th_aes_init+0xc4>
            {
                th_printf("e-[Failed to set ECB ENC key: -0x%04x]\r\n", -ret);
 800c440:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c442:	425b      	negs	r3, r3
 800c444:	4619      	mov	r1, r3
 800c446:	4843      	ldr	r0, [pc, #268]	@ (800c554 <th_aes_init+0x184>)
 800c448:	f000 fc8e 	bl	800cd68 <th_printf>
                return EE_STATUS_ERROR;
 800c44c:	2301      	movs	r3, #1
 800c44e:	e078      	b.n	800c542 <th_aes_init+0x172>
            }
        }
        else if (func == EE_AES_DEC)
 800c450:	f897 3030 	ldrb.w	r3, [r7, #48]	@ 0x30
 800c454:	2b01      	cmp	r3, #1
 800c456:	d11d      	bne.n	800c494 <th_aes_init+0xc4>
        {
            if (mode == EE_AES_CTR)
 800c458:	f897 3034 	ldrb.w	r3, [r7, #52]	@ 0x34
 800c45c:	2b01      	cmp	r3, #1
 800c45e:	d107      	bne.n	800c470 <th_aes_init+0xa0>
            {
                ret = mbedtls_aes_setkey_enc(p_ecb, p_key, keybits);
 800c460:	6a3b      	ldr	r3, [r7, #32]
 800c462:	461a      	mov	r2, r3
 800c464:	68b9      	ldr	r1, [r7, #8]
 800c466:	6978      	ldr	r0, [r7, #20]
 800c468:	f7f4 fb4c 	bl	8000b04 <mbedtls_aes_setkey_enc>
 800c46c:	6278      	str	r0, [r7, #36]	@ 0x24
 800c46e:	e006      	b.n	800c47e <th_aes_init+0xae>
            }
            else
            {
                ret = mbedtls_aes_setkey_dec(p_ecb, p_key, keybits);
 800c470:	6a3b      	ldr	r3, [r7, #32]
 800c472:	461a      	mov	r2, r3
 800c474:	68b9      	ldr	r1, [r7, #8]
 800c476:	6978      	ldr	r0, [r7, #20]
 800c478:	f7f4 fd24 	bl	8000ec4 <mbedtls_aes_setkey_dec>
 800c47c:	6278      	str	r0, [r7, #36]	@ 0x24
            }
            if (ret != 0)
 800c47e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c480:	2b00      	cmp	r3, #0
 800c482:	d007      	beq.n	800c494 <th_aes_init+0xc4>
            {
                th_printf("e-[Failed to set ECB DEC key: -0x%04x]\r\n", -ret);
 800c484:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c486:	425b      	negs	r3, r3
 800c488:	4619      	mov	r1, r3
 800c48a:	4833      	ldr	r0, [pc, #204]	@ (800c558 <th_aes_init+0x188>)
 800c48c:	f000 fc6c 	bl	800cd68 <th_printf>
                return EE_STATUS_ERROR;
 800c490:	2301      	movs	r3, #1
 800c492:	e056      	b.n	800c542 <th_aes_init+0x172>
            }
        }
        if (mode == EE_AES_CTR)
 800c494:	f897 3034 	ldrb.w	r3, [r7, #52]	@ 0x34
 800c498:	2b01      	cmp	r3, #1
 800c49a:	d151      	bne.n	800c540 <th_aes_init+0x170>
        {
            th_memcpy(((th_mbedtls_aes_context_t *)p_context)
                          ->additional_ctx.aes_ctr.nonce_counter,
 800c49c:	68fb      	ldr	r3, [r7, #12]
 800c49e:	f503 73cc 	add.w	r3, r3, #408	@ 0x198
            th_memcpy(((th_mbedtls_aes_context_t *)p_context)
 800c4a2:	2210      	movs	r2, #16
 800c4a4:	6839      	ldr	r1, [r7, #0]
 800c4a6:	4618      	mov	r0, r3
 800c4a8:	f000 fc80 	bl	800cdac <th_memcpy>
                      iv,
                      EE_AES_CTR_IVLEN);
            th_memset(((th_mbedtls_aes_context_t *)p_context)
                          ->additional_ctx.aes_ctr.stream_block,
 800c4ac:	68fb      	ldr	r3, [r7, #12]
 800c4ae:	f503 73d4 	add.w	r3, r3, #424	@ 0x1a8
            th_memset(((th_mbedtls_aes_context_t *)p_context)
 800c4b2:	2210      	movs	r2, #16
 800c4b4:	2100      	movs	r1, #0
 800c4b6:	4618      	mov	r0, r3
 800c4b8:	f000 fc68 	bl	800cd8c <th_memset>
                      0,
                      16);
            ((th_mbedtls_aes_context_t *)p_context)
                ->additional_ctx.aes_ctr.nc_off
                = 0;
 800c4bc:	68fb      	ldr	r3, [r7, #12]
 800c4be:	2200      	movs	r2, #0
 800c4c0:	f8c3 21b8 	str.w	r2, [r3, #440]	@ 0x1b8
        if (mode == EE_AES_CTR)
 800c4c4:	e03c      	b.n	800c540 <th_aes_init+0x170>
        }
    }
    else if (mode == EE_AES_CCM)
 800c4c6:	f897 3034 	ldrb.w	r3, [r7, #52]	@ 0x34
 800c4ca:	2b02      	cmp	r3, #2
 800c4cc:	d117      	bne.n	800c4fe <th_aes_init+0x12e>
    {
        p_ccm = &((th_mbedtls_aes_context_t *)p_context)->ctx.ccm_ctx;
 800c4ce:	68fb      	ldr	r3, [r7, #12]
 800c4d0:	3308      	adds	r3, #8
 800c4d2:	61bb      	str	r3, [r7, #24]
        mbedtls_ccm_init(p_ccm);
 800c4d4:	69b8      	ldr	r0, [r7, #24]
 800c4d6:	f7f6 f9f7 	bl	80028c8 <mbedtls_ccm_init>
        ret = mbedtls_ccm_setkey(p_ccm, MBEDTLS_CIPHER_ID_AES, p_key, keybits);
 800c4da:	6a3b      	ldr	r3, [r7, #32]
 800c4dc:	68ba      	ldr	r2, [r7, #8]
 800c4de:	2102      	movs	r1, #2
 800c4e0:	69b8      	ldr	r0, [r7, #24]
 800c4e2:	f7f6 f9fe 	bl	80028e2 <mbedtls_ccm_setkey>
 800c4e6:	6278      	str	r0, [r7, #36]	@ 0x24
        if (ret != 0)
 800c4e8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c4ea:	2b00      	cmp	r3, #0
 800c4ec:	d028      	beq.n	800c540 <th_aes_init+0x170>
        {
            th_printf("e-[Failed to set CCM key: -0x%04x]\r\n", -ret);
 800c4ee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c4f0:	425b      	negs	r3, r3
 800c4f2:	4619      	mov	r1, r3
 800c4f4:	4819      	ldr	r0, [pc, #100]	@ (800c55c <th_aes_init+0x18c>)
 800c4f6:	f000 fc37 	bl	800cd68 <th_printf>
            return EE_STATUS_ERROR;
 800c4fa:	2301      	movs	r3, #1
 800c4fc:	e021      	b.n	800c542 <th_aes_init+0x172>
        }
    }
    else if (mode == EE_AES_GCM)
 800c4fe:	f897 3034 	ldrb.w	r3, [r7, #52]	@ 0x34
 800c502:	2b03      	cmp	r3, #3
 800c504:	d117      	bne.n	800c536 <th_aes_init+0x166>
    {
        p_gcm = &((th_mbedtls_aes_context_t *)p_context)->ctx.gcm_ctx;
 800c506:	68fb      	ldr	r3, [r7, #12]
 800c508:	3308      	adds	r3, #8
 800c50a:	61fb      	str	r3, [r7, #28]
        mbedtls_gcm_init(p_gcm);
 800c50c:	69f8      	ldr	r0, [r7, #28]
 800c50e:	f7f8 fd35 	bl	8004f7c <mbedtls_gcm_init>
        ret = mbedtls_gcm_setkey(p_gcm, MBEDTLS_CIPHER_ID_AES, p_key, keybits);
 800c512:	6a3b      	ldr	r3, [r7, #32]
 800c514:	68ba      	ldr	r2, [r7, #8]
 800c516:	2102      	movs	r1, #2
 800c518:	69f8      	ldr	r0, [r7, #28]
 800c51a:	f7f8 feb7 	bl	800528c <mbedtls_gcm_setkey>
 800c51e:	6278      	str	r0, [r7, #36]	@ 0x24
        if (ret != 0)
 800c520:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c522:	2b00      	cmp	r3, #0
 800c524:	d00c      	beq.n	800c540 <th_aes_init+0x170>
        {
            th_printf("e-[Failed to set GCM key: -0x%04x]\r\n", -ret);
 800c526:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c528:	425b      	negs	r3, r3
 800c52a:	4619      	mov	r1, r3
 800c52c:	480c      	ldr	r0, [pc, #48]	@ (800c560 <th_aes_init+0x190>)
 800c52e:	f000 fc1b 	bl	800cd68 <th_printf>
            return EE_STATUS_ERROR;
 800c532:	2301      	movs	r3, #1
 800c534:	e005      	b.n	800c542 <th_aes_init+0x172>
        }
    }
    else
    {
        th_printf("e-[Unknown mode in th_aes128_init]\r\n");
 800c536:	480b      	ldr	r0, [pc, #44]	@ (800c564 <th_aes_init+0x194>)
 800c538:	f000 fc16 	bl	800cd68 <th_printf>
        return EE_STATUS_ERROR;
 800c53c:	2301      	movs	r3, #1
 800c53e:	e000      	b.n	800c542 <th_aes_init+0x172>
    }

    return EE_STATUS_OK;
 800c540:	2300      	movs	r3, #0
}
 800c542:	4618      	mov	r0, r3
 800c544:	3728      	adds	r7, #40	@ 0x28
 800c546:	46bd      	mov	sp, r7
 800c548:	bd80      	pop	{r7, pc}
 800c54a:	bf00      	nop
 800c54c:	08015fd8 	.word	0x08015fd8
 800c550:	0801605c 	.word	0x0801605c
 800c554:	08016080 	.word	0x08016080
 800c558:	080160ac 	.word	0x080160ac
 800c55c:	080160d8 	.word	0x080160d8
 800c560:	08016100 	.word	0x08016100
 800c564:	08016128 	.word	0x08016128

0800c568 <th_aes_deinit>:

void
th_aes_deinit(void *p_context)
{
 800c568:	b580      	push	{r7, lr}
 800c56a:	b082      	sub	sp, #8
 800c56c:	af00      	add	r7, sp, #0
 800c56e:	6078      	str	r0, [r7, #4]
    CHECK_NULL_CTX_NORET(p_context);
 800c570:	687b      	ldr	r3, [r7, #4]
 800c572:	2b00      	cmp	r3, #0
 800c574:	d105      	bne.n	800c582 <th_aes_deinit+0x1a>
 800c576:	22b6      	movs	r2, #182	@ 0xb6
 800c578:	490d      	ldr	r1, [pc, #52]	@ (800c5b0 <th_aes_deinit+0x48>)
 800c57a:	480e      	ldr	r0, [pc, #56]	@ (800c5b4 <th_aes_deinit+0x4c>)
 800c57c:	f000 fbf4 	bl	800cd68 <th_printf>
 800c580:	e012      	b.n	800c5a8 <th_aes_deinit+0x40>

    if (EE_AES_CCM == ((th_mbedtls_aes_context_t *)p_context)->aes_mode)
 800c582:	687b      	ldr	r3, [r7, #4]
 800c584:	781b      	ldrb	r3, [r3, #0]
 800c586:	2b02      	cmp	r3, #2
 800c588:	d105      	bne.n	800c596 <th_aes_deinit+0x2e>
    {
        mbedtls_ccm_free(&((th_mbedtls_aes_context_t *)p_context)->ctx.ccm_ctx);
 800c58a:	687b      	ldr	r3, [r7, #4]
 800c58c:	3308      	adds	r3, #8
 800c58e:	4618      	mov	r0, r3
 800c590:	f7f6 f9e6 	bl	8002960 <mbedtls_ccm_free>
 800c594:	e008      	b.n	800c5a8 <th_aes_deinit+0x40>
    }
    else if (EE_AES_GCM == ((th_mbedtls_aes_context_t *)p_context)->aes_mode)
 800c596:	687b      	ldr	r3, [r7, #4]
 800c598:	781b      	ldrb	r3, [r3, #0]
 800c59a:	2b03      	cmp	r3, #3
 800c59c:	d104      	bne.n	800c5a8 <th_aes_deinit+0x40>
    {
        mbedtls_gcm_free(&((th_mbedtls_aes_context_t *)p_context)->ctx.gcm_ctx);
 800c59e:	687b      	ldr	r3, [r7, #4]
 800c5a0:	3308      	adds	r3, #8
 800c5a2:	4618      	mov	r0, r3
 800c5a4:	f7f9 fe07 	bl	80061b6 <mbedtls_gcm_free>
    }
}
 800c5a8:	3708      	adds	r7, #8
 800c5aa:	46bd      	mov	sp, r7
 800c5ac:	bd80      	pop	{r7, pc}
 800c5ae:	bf00      	nop
 800c5b0:	08015fd8 	.word	0x08015fd8
 800c5b4:	0801605c 	.word	0x0801605c

0800c5b8 <th_aes_ecb_encrypt>:
ee_status_t
th_aes_ecb_encrypt(void          *p_context,
                   const uint8_t *p_pt,
                   uint32_t       ptlen,
                   uint8_t       *p_ct)
{
 800c5b8:	b580      	push	{r7, lr}
 800c5ba:	b08a      	sub	sp, #40	@ 0x28
 800c5bc:	af00      	add	r7, sp, #0
 800c5be:	60f8      	str	r0, [r7, #12]
 800c5c0:	60b9      	str	r1, [r7, #8]
 800c5c2:	607a      	str	r2, [r7, #4]
 800c5c4:	603b      	str	r3, [r7, #0]
    int            ret;
    uint32_t       numblocks = ptlen >> 4;
 800c5c6:	687b      	ldr	r3, [r7, #4]
 800c5c8:	091b      	lsrs	r3, r3, #4
 800c5ca:	61bb      	str	r3, [r7, #24]
    const uint8_t *in        = p_pt;
 800c5cc:	68bb      	ldr	r3, [r7, #8]
 800c5ce:	627b      	str	r3, [r7, #36]	@ 0x24
    uint8_t       *out       = p_ct;
 800c5d0:	683b      	ldr	r3, [r7, #0]
 800c5d2:	623b      	str	r3, [r7, #32]

    CHECK_NULL_CTX(p_context);
 800c5d4:	68fb      	ldr	r3, [r7, #12]
 800c5d6:	2b00      	cmp	r3, #0
 800c5d8:	d106      	bne.n	800c5e8 <th_aes_ecb_encrypt+0x30>
 800c5da:	22cd      	movs	r2, #205	@ 0xcd
 800c5dc:	4919      	ldr	r1, [pc, #100]	@ (800c644 <th_aes_ecb_encrypt+0x8c>)
 800c5de:	481a      	ldr	r0, [pc, #104]	@ (800c648 <th_aes_ecb_encrypt+0x90>)
 800c5e0:	f000 fbc2 	bl	800cd68 <th_printf>
 800c5e4:	2301      	movs	r3, #1
 800c5e6:	e028      	b.n	800c63a <th_aes_ecb_encrypt+0x82>

    if (EE_AES_ECB != ((th_mbedtls_aes_context_t *)p_context)->aes_mode)
 800c5e8:	68fb      	ldr	r3, [r7, #12]
 800c5ea:	781b      	ldrb	r3, [r3, #0]
 800c5ec:	2b00      	cmp	r3, #0
 800c5ee:	d001      	beq.n	800c5f4 <th_aes_ecb_encrypt+0x3c>
    {
        return EE_STATUS_ERROR;
 800c5f0:	2301      	movs	r3, #1
 800c5f2:	e022      	b.n	800c63a <th_aes_ecb_encrypt+0x82>
    }

    for (uint32_t i = 0; i < numblocks; ++i)
 800c5f4:	2300      	movs	r3, #0
 800c5f6:	61fb      	str	r3, [r7, #28]
 800c5f8:	e01a      	b.n	800c630 <th_aes_ecb_encrypt+0x78>
    {
        ret = mbedtls_aes_crypt_ecb(
 800c5fa:	68fb      	ldr	r3, [r7, #12]
 800c5fc:	f103 0008 	add.w	r0, r3, #8
 800c600:	683b      	ldr	r3, [r7, #0]
 800c602:	68ba      	ldr	r2, [r7, #8]
 800c604:	2101      	movs	r1, #1
 800c606:	f7f5 fbf7 	bl	8001df8 <mbedtls_aes_crypt_ecb>
 800c60a:	6178      	str	r0, [r7, #20]
            &((th_mbedtls_aes_context_t *)p_context)->ctx.aes_ctx,
            MBEDTLS_AES_ENCRYPT,
            p_pt,
            p_ct);
        if (ret != 0)
 800c60c:	697b      	ldr	r3, [r7, #20]
 800c60e:	2b00      	cmp	r3, #0
 800c610:	d005      	beq.n	800c61e <th_aes_ecb_encrypt+0x66>
        {
            th_printf("e-[mbedtls_aes_crypt_ecb: %d]\r\n", ret);
 800c612:	6979      	ldr	r1, [r7, #20]
 800c614:	480d      	ldr	r0, [pc, #52]	@ (800c64c <th_aes_ecb_encrypt+0x94>)
 800c616:	f000 fba7 	bl	800cd68 <th_printf>
            return EE_STATUS_ERROR;
 800c61a:	2301      	movs	r3, #1
 800c61c:	e00d      	b.n	800c63a <th_aes_ecb_encrypt+0x82>
        }
        in += 16;
 800c61e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c620:	3310      	adds	r3, #16
 800c622:	627b      	str	r3, [r7, #36]	@ 0x24
        out += 16;
 800c624:	6a3b      	ldr	r3, [r7, #32]
 800c626:	3310      	adds	r3, #16
 800c628:	623b      	str	r3, [r7, #32]
    for (uint32_t i = 0; i < numblocks; ++i)
 800c62a:	69fb      	ldr	r3, [r7, #28]
 800c62c:	3301      	adds	r3, #1
 800c62e:	61fb      	str	r3, [r7, #28]
 800c630:	69fa      	ldr	r2, [r7, #28]
 800c632:	69bb      	ldr	r3, [r7, #24]
 800c634:	429a      	cmp	r2, r3
 800c636:	d3e0      	bcc.n	800c5fa <th_aes_ecb_encrypt+0x42>
    }
    return EE_STATUS_OK;
 800c638:	2300      	movs	r3, #0
}
 800c63a:	4618      	mov	r0, r3
 800c63c:	3728      	adds	r7, #40	@ 0x28
 800c63e:	46bd      	mov	sp, r7
 800c640:	bd80      	pop	{r7, pc}
 800c642:	bf00      	nop
 800c644:	08015fd8 	.word	0x08015fd8
 800c648:	0801605c 	.word	0x0801605c
 800c64c:	08016150 	.word	0x08016150

0800c650 <th_aes_ecb_decrypt>:
ee_status_t
th_aes_ecb_decrypt(void          *p_context,
                   const uint8_t *p_ct,
                   uint32_t       ctlen,
                   uint8_t       *p_pt)
{
 800c650:	b580      	push	{r7, lr}
 800c652:	b08a      	sub	sp, #40	@ 0x28
 800c654:	af00      	add	r7, sp, #0
 800c656:	60f8      	str	r0, [r7, #12]
 800c658:	60b9      	str	r1, [r7, #8]
 800c65a:	607a      	str	r2, [r7, #4]
 800c65c:	603b      	str	r3, [r7, #0]
    int            ret;
    uint32_t       numblocks = ctlen / 16;
 800c65e:	687b      	ldr	r3, [r7, #4]
 800c660:	091b      	lsrs	r3, r3, #4
 800c662:	61bb      	str	r3, [r7, #24]
    const uint8_t *in        = p_ct;
 800c664:	68bb      	ldr	r3, [r7, #8]
 800c666:	627b      	str	r3, [r7, #36]	@ 0x24
    uint8_t       *out       = p_pt;
 800c668:	683b      	ldr	r3, [r7, #0]
 800c66a:	623b      	str	r3, [r7, #32]
    for (uint32_t i = 0; i < numblocks; ++i)
 800c66c:	2300      	movs	r3, #0
 800c66e:	61fb      	str	r3, [r7, #28]
 800c670:	e01a      	b.n	800c6a8 <th_aes_ecb_decrypt+0x58>
    {
        ret = mbedtls_aes_crypt_ecb(
 800c672:	68fb      	ldr	r3, [r7, #12]
 800c674:	f103 0008 	add.w	r0, r3, #8
 800c678:	683b      	ldr	r3, [r7, #0]
 800c67a:	68ba      	ldr	r2, [r7, #8]
 800c67c:	2100      	movs	r1, #0
 800c67e:	f7f5 fbbb 	bl	8001df8 <mbedtls_aes_crypt_ecb>
 800c682:	6178      	str	r0, [r7, #20]
            &((th_mbedtls_aes_context_t *)p_context)->ctx.aes_ctx,
            MBEDTLS_AES_DECRYPT,
            p_ct,
            p_pt);
        if (ret != 0)
 800c684:	697b      	ldr	r3, [r7, #20]
 800c686:	2b00      	cmp	r3, #0
 800c688:	d005      	beq.n	800c696 <th_aes_ecb_decrypt+0x46>
        {
            th_printf("e-[mbedtls_aes_crypt_ecb: %d]\r\n", ret);
 800c68a:	6979      	ldr	r1, [r7, #20]
 800c68c:	480b      	ldr	r0, [pc, #44]	@ (800c6bc <th_aes_ecb_decrypt+0x6c>)
 800c68e:	f000 fb6b 	bl	800cd68 <th_printf>
            return EE_STATUS_ERROR;
 800c692:	2301      	movs	r3, #1
 800c694:	e00d      	b.n	800c6b2 <th_aes_ecb_decrypt+0x62>
        }
        in += 16;
 800c696:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c698:	3310      	adds	r3, #16
 800c69a:	627b      	str	r3, [r7, #36]	@ 0x24
        out += 16;
 800c69c:	6a3b      	ldr	r3, [r7, #32]
 800c69e:	3310      	adds	r3, #16
 800c6a0:	623b      	str	r3, [r7, #32]
    for (uint32_t i = 0; i < numblocks; ++i)
 800c6a2:	69fb      	ldr	r3, [r7, #28]
 800c6a4:	3301      	adds	r3, #1
 800c6a6:	61fb      	str	r3, [r7, #28]
 800c6a8:	69fa      	ldr	r2, [r7, #28]
 800c6aa:	69bb      	ldr	r3, [r7, #24]
 800c6ac:	429a      	cmp	r2, r3
 800c6ae:	d3e0      	bcc.n	800c672 <th_aes_ecb_decrypt+0x22>
    }
    return EE_STATUS_OK;
 800c6b0:	2300      	movs	r3, #0
}
 800c6b2:	4618      	mov	r0, r3
 800c6b4:	3728      	adds	r7, #40	@ 0x28
 800c6b6:	46bd      	mov	sp, r7
 800c6b8:	bd80      	pop	{r7, pc}
 800c6ba:	bf00      	nop
 800c6bc:	08016150 	.word	0x08016150

0800c6c0 <th_aes_ctr_encrypt>:
ee_status_t
th_aes_ctr_encrypt(void          *p_context,
                   const uint8_t *p_pt,
                   uint32_t       ptlen,
                   uint8_t       *p_ct)
{
 800c6c0:	b590      	push	{r4, r7, lr}
 800c6c2:	b089      	sub	sp, #36	@ 0x24
 800c6c4:	af04      	add	r7, sp, #16
 800c6c6:	60f8      	str	r0, [r7, #12]
 800c6c8:	60b9      	str	r1, [r7, #8]
 800c6ca:	607a      	str	r2, [r7, #4]
 800c6cc:	603b      	str	r3, [r7, #0]
    CHECK_NULL_CTX(p_context);
 800c6ce:	68fb      	ldr	r3, [r7, #12]
 800c6d0:	2b00      	cmp	r3, #0
 800c6d2:	d107      	bne.n	800c6e4 <th_aes_ctr_encrypt+0x24>
 800c6d4:	f44f 7284 	mov.w	r2, #264	@ 0x108
 800c6d8:	4915      	ldr	r1, [pc, #84]	@ (800c730 <th_aes_ctr_encrypt+0x70>)
 800c6da:	4816      	ldr	r0, [pc, #88]	@ (800c734 <th_aes_ctr_encrypt+0x74>)
 800c6dc:	f000 fb44 	bl	800cd68 <th_printf>
 800c6e0:	2301      	movs	r3, #1
 800c6e2:	e021      	b.n	800c728 <th_aes_ctr_encrypt+0x68>

    if (EE_AES_CTR != ((th_mbedtls_aes_context_t *)p_context)->aes_mode)
 800c6e4:	68fb      	ldr	r3, [r7, #12]
 800c6e6:	781b      	ldrb	r3, [r3, #0]
 800c6e8:	2b01      	cmp	r3, #1
 800c6ea:	d001      	beq.n	800c6f0 <th_aes_ctr_encrypt+0x30>
    {
        return EE_STATUS_ERROR;
 800c6ec:	2301      	movs	r3, #1
 800c6ee:	e01b      	b.n	800c728 <th_aes_ctr_encrypt+0x68>
    }

    return mbedtls_aes_crypt_ctr(
 800c6f0:	68fb      	ldr	r3, [r7, #12]
 800c6f2:	f103 0008 	add.w	r0, r3, #8
 800c6f6:	68fb      	ldr	r3, [r7, #12]
 800c6f8:	f503 71dc 	add.w	r1, r3, #440	@ 0x1b8
               &((th_mbedtls_aes_context_t *)p_context)->ctx.aes_ctx,
               ptlen,
               &((th_mbedtls_aes_context_t *)p_context)
                    ->additional_ctx.aes_ctr.nc_off,
               ((th_mbedtls_aes_context_t *)p_context)
                   ->additional_ctx.aes_ctr.nonce_counter,
 800c6fc:	68fb      	ldr	r3, [r7, #12]
 800c6fe:	f503 74cc 	add.w	r4, r3, #408	@ 0x198
               ((th_mbedtls_aes_context_t *)p_context)
                   ->additional_ctx.aes_ctr.stream_block,
 800c702:	68fb      	ldr	r3, [r7, #12]
 800c704:	f503 73d4 	add.w	r3, r3, #424	@ 0x1a8
    return mbedtls_aes_crypt_ctr(
 800c708:	683a      	ldr	r2, [r7, #0]
 800c70a:	9202      	str	r2, [sp, #8]
 800c70c:	68ba      	ldr	r2, [r7, #8]
 800c70e:	9201      	str	r2, [sp, #4]
 800c710:	9300      	str	r3, [sp, #0]
 800c712:	4623      	mov	r3, r4
 800c714:	460a      	mov	r2, r1
 800c716:	6879      	ldr	r1, [r7, #4]
 800c718:	f7f6 f882 	bl	8002820 <mbedtls_aes_crypt_ctr>
 800c71c:	4603      	mov	r3, r0
               p_pt,
               p_ct)
                   == 0
               ? EE_STATUS_OK
               : EE_STATUS_ERROR;
 800c71e:	2b00      	cmp	r3, #0
 800c720:	bf14      	ite	ne
 800c722:	2301      	movne	r3, #1
 800c724:	2300      	moveq	r3, #0
 800c726:	b2db      	uxtb	r3, r3
}
 800c728:	4618      	mov	r0, r3
 800c72a:	3714      	adds	r7, #20
 800c72c:	46bd      	mov	sp, r7
 800c72e:	bd90      	pop	{r4, r7, pc}
 800c730:	08015fd8 	.word	0x08015fd8
 800c734:	0801605c 	.word	0x0801605c

0800c738 <th_aes_ctr_decrypt>:
ee_status_t
th_aes_ctr_decrypt(void          *p_context,
                   const uint8_t *p_ct,
                   uint32_t       ctlen,
                   uint8_t       *p_pt)
{
 800c738:	b590      	push	{r4, r7, lr}
 800c73a:	b089      	sub	sp, #36	@ 0x24
 800c73c:	af04      	add	r7, sp, #16
 800c73e:	60f8      	str	r0, [r7, #12]
 800c740:	60b9      	str	r1, [r7, #8]
 800c742:	607a      	str	r2, [r7, #4]
 800c744:	603b      	str	r3, [r7, #0]
    CHECK_NULL_CTX(p_context);
 800c746:	68fb      	ldr	r3, [r7, #12]
 800c748:	2b00      	cmp	r3, #0
 800c74a:	d107      	bne.n	800c75c <th_aes_ctr_decrypt+0x24>
 800c74c:	f240 1225 	movw	r2, #293	@ 0x125
 800c750:	4915      	ldr	r1, [pc, #84]	@ (800c7a8 <th_aes_ctr_decrypt+0x70>)
 800c752:	4816      	ldr	r0, [pc, #88]	@ (800c7ac <th_aes_ctr_decrypt+0x74>)
 800c754:	f000 fb08 	bl	800cd68 <th_printf>
 800c758:	2301      	movs	r3, #1
 800c75a:	e021      	b.n	800c7a0 <th_aes_ctr_decrypt+0x68>

    if (EE_AES_CTR != ((th_mbedtls_aes_context_t *)p_context)->aes_mode)
 800c75c:	68fb      	ldr	r3, [r7, #12]
 800c75e:	781b      	ldrb	r3, [r3, #0]
 800c760:	2b01      	cmp	r3, #1
 800c762:	d001      	beq.n	800c768 <th_aes_ctr_decrypt+0x30>
    {
        return EE_STATUS_ERROR;
 800c764:	2301      	movs	r3, #1
 800c766:	e01b      	b.n	800c7a0 <th_aes_ctr_decrypt+0x68>
    }

    return mbedtls_aes_crypt_ctr(
 800c768:	68fb      	ldr	r3, [r7, #12]
 800c76a:	f103 0008 	add.w	r0, r3, #8
 800c76e:	68fb      	ldr	r3, [r7, #12]
 800c770:	f503 71dc 	add.w	r1, r3, #440	@ 0x1b8
               &((th_mbedtls_aes_context_t *)p_context)->ctx.aes_ctx,
               ctlen,
               &((th_mbedtls_aes_context_t *)p_context)
                    ->additional_ctx.aes_ctr.nc_off,
               ((th_mbedtls_aes_context_t *)p_context)
                   ->additional_ctx.aes_ctr.nonce_counter,
 800c774:	68fb      	ldr	r3, [r7, #12]
 800c776:	f503 74cc 	add.w	r4, r3, #408	@ 0x198
               ((th_mbedtls_aes_context_t *)p_context)
                   ->additional_ctx.aes_ctr.stream_block,
 800c77a:	68fb      	ldr	r3, [r7, #12]
 800c77c:	f503 73d4 	add.w	r3, r3, #424	@ 0x1a8
    return mbedtls_aes_crypt_ctr(
 800c780:	683a      	ldr	r2, [r7, #0]
 800c782:	9202      	str	r2, [sp, #8]
 800c784:	68ba      	ldr	r2, [r7, #8]
 800c786:	9201      	str	r2, [sp, #4]
 800c788:	9300      	str	r3, [sp, #0]
 800c78a:	4623      	mov	r3, r4
 800c78c:	460a      	mov	r2, r1
 800c78e:	6879      	ldr	r1, [r7, #4]
 800c790:	f7f6 f846 	bl	8002820 <mbedtls_aes_crypt_ctr>
 800c794:	4603      	mov	r3, r0
               p_ct,
               p_pt)
                   == 0
               ? EE_STATUS_OK
               : EE_STATUS_ERROR;
 800c796:	2b00      	cmp	r3, #0
 800c798:	bf14      	ite	ne
 800c79a:	2301      	movne	r3, #1
 800c79c:	2300      	moveq	r3, #0
 800c79e:	b2db      	uxtb	r3, r3
}
 800c7a0:	4618      	mov	r0, r3
 800c7a2:	3714      	adds	r7, #20
 800c7a4:	46bd      	mov	sp, r7
 800c7a6:	bd90      	pop	{r4, r7, pc}
 800c7a8:	08015fd8 	.word	0x08015fd8
 800c7ac:	0801605c 	.word	0x0801605c

0800c7b0 <th_aes_ccm_encrypt>:
                   uint8_t       *p_ct,
                   uint8_t       *p_tag,
                   uint32_t       taglen,
                   const uint8_t *p_iv,
                   uint32_t       ivlen)
{
 800c7b0:	b580      	push	{r7, lr}
 800c7b2:	b08a      	sub	sp, #40	@ 0x28
 800c7b4:	af06      	add	r7, sp, #24
 800c7b6:	60f8      	str	r0, [r7, #12]
 800c7b8:	60b9      	str	r1, [r7, #8]
 800c7ba:	607a      	str	r2, [r7, #4]
 800c7bc:	603b      	str	r3, [r7, #0]
    CHECK_NULL_CTX(p_context);
 800c7be:	68fb      	ldr	r3, [r7, #12]
 800c7c0:	2b00      	cmp	r3, #0
 800c7c2:	d107      	bne.n	800c7d4 <th_aes_ccm_encrypt+0x24>
 800c7c4:	f44f 72a3 	mov.w	r2, #326	@ 0x146
 800c7c8:	4914      	ldr	r1, [pc, #80]	@ (800c81c <th_aes_ccm_encrypt+0x6c>)
 800c7ca:	4815      	ldr	r0, [pc, #84]	@ (800c820 <th_aes_ccm_encrypt+0x70>)
 800c7cc:	f000 facc 	bl	800cd68 <th_printf>
 800c7d0:	2301      	movs	r3, #1
 800c7d2:	e01f      	b.n	800c814 <th_aes_ccm_encrypt+0x64>

    if (EE_AES_CCM != ((th_mbedtls_aes_context_t *)p_context)->aes_mode)
 800c7d4:	68fb      	ldr	r3, [r7, #12]
 800c7d6:	781b      	ldrb	r3, [r3, #0]
 800c7d8:	2b02      	cmp	r3, #2
 800c7da:	d001      	beq.n	800c7e0 <th_aes_ccm_encrypt+0x30>
    {
        return EE_STATUS_ERROR;
 800c7dc:	2301      	movs	r3, #1
 800c7de:	e019      	b.n	800c814 <th_aes_ccm_encrypt+0x64>
    }

    return mbedtls_ccm_encrypt_and_tag(
 800c7e0:	68fb      	ldr	r3, [r7, #12]
 800c7e2:	f103 0008 	add.w	r0, r3, #8
 800c7e6:	69fb      	ldr	r3, [r7, #28]
 800c7e8:	9305      	str	r3, [sp, #20]
 800c7ea:	69bb      	ldr	r3, [r7, #24]
 800c7ec:	9304      	str	r3, [sp, #16]
 800c7ee:	683b      	ldr	r3, [r7, #0]
 800c7f0:	9303      	str	r3, [sp, #12]
 800c7f2:	68bb      	ldr	r3, [r7, #8]
 800c7f4:	9302      	str	r3, [sp, #8]
 800c7f6:	2300      	movs	r3, #0
 800c7f8:	9301      	str	r3, [sp, #4]
 800c7fa:	2300      	movs	r3, #0
 800c7fc:	9300      	str	r3, [sp, #0]
 800c7fe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c800:	6a3a      	ldr	r2, [r7, #32]
 800c802:	6879      	ldr	r1, [r7, #4]
 800c804:	f7f6 fbc5 	bl	8002f92 <mbedtls_ccm_encrypt_and_tag>
 800c808:	4603      	mov	r3, r0
               p_ct,
               p_tag,
               taglen)
                   == 0
               ? EE_STATUS_OK
               : EE_STATUS_ERROR;
 800c80a:	2b00      	cmp	r3, #0
 800c80c:	bf14      	ite	ne
 800c80e:	2301      	movne	r3, #1
 800c810:	2300      	moveq	r3, #0
 800c812:	b2db      	uxtb	r3, r3
}
 800c814:	4618      	mov	r0, r3
 800c816:	3710      	adds	r7, #16
 800c818:	46bd      	mov	sp, r7
 800c81a:	bd80      	pop	{r7, pc}
 800c81c:	08015fd8 	.word	0x08015fd8
 800c820:	0801605c 	.word	0x0801605c

0800c824 <th_aes_ccm_decrypt>:
                   uint8_t       *p_pt,
                   const uint8_t *p_tag,
                   uint32_t       taglen,
                   const uint8_t *p_iv,
                   uint32_t       ivlen)
{
 800c824:	b580      	push	{r7, lr}
 800c826:	b08a      	sub	sp, #40	@ 0x28
 800c828:	af06      	add	r7, sp, #24
 800c82a:	60f8      	str	r0, [r7, #12]
 800c82c:	60b9      	str	r1, [r7, #8]
 800c82e:	607a      	str	r2, [r7, #4]
 800c830:	603b      	str	r3, [r7, #0]
    CHECK_NULL_CTX(p_context);
 800c832:	68fb      	ldr	r3, [r7, #12]
 800c834:	2b00      	cmp	r3, #0
 800c836:	d107      	bne.n	800c848 <th_aes_ccm_decrypt+0x24>
 800c838:	f44f 72b6 	mov.w	r2, #364	@ 0x16c
 800c83c:	4914      	ldr	r1, [pc, #80]	@ (800c890 <th_aes_ccm_decrypt+0x6c>)
 800c83e:	4815      	ldr	r0, [pc, #84]	@ (800c894 <th_aes_ccm_decrypt+0x70>)
 800c840:	f000 fa92 	bl	800cd68 <th_printf>
 800c844:	2301      	movs	r3, #1
 800c846:	e01f      	b.n	800c888 <th_aes_ccm_decrypt+0x64>

    if (EE_AES_CCM != ((th_mbedtls_aes_context_t *)p_context)->aes_mode)
 800c848:	68fb      	ldr	r3, [r7, #12]
 800c84a:	781b      	ldrb	r3, [r3, #0]
 800c84c:	2b02      	cmp	r3, #2
 800c84e:	d001      	beq.n	800c854 <th_aes_ccm_decrypt+0x30>
    {
        return EE_STATUS_ERROR;
 800c850:	2301      	movs	r3, #1
 800c852:	e019      	b.n	800c888 <th_aes_ccm_decrypt+0x64>
    }

    return mbedtls_ccm_auth_decrypt(
 800c854:	68fb      	ldr	r3, [r7, #12]
 800c856:	f103 0008 	add.w	r0, r3, #8
 800c85a:	69fb      	ldr	r3, [r7, #28]
 800c85c:	9305      	str	r3, [sp, #20]
 800c85e:	69bb      	ldr	r3, [r7, #24]
 800c860:	9304      	str	r3, [sp, #16]
 800c862:	683b      	ldr	r3, [r7, #0]
 800c864:	9303      	str	r3, [sp, #12]
 800c866:	68bb      	ldr	r3, [r7, #8]
 800c868:	9302      	str	r3, [sp, #8]
 800c86a:	2300      	movs	r3, #0
 800c86c:	9301      	str	r3, [sp, #4]
 800c86e:	2300      	movs	r3, #0
 800c870:	9300      	str	r3, [sp, #0]
 800c872:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c874:	6a3a      	ldr	r2, [r7, #32]
 800c876:	6879      	ldr	r1, [r7, #4]
 800c878:	f7f6 fc04 	bl	8003084 <mbedtls_ccm_auth_decrypt>
 800c87c:	4603      	mov	r3, r0
               p_pt,
               p_tag,
               taglen)
                   == 0
               ? EE_STATUS_OK
               : EE_STATUS_ERROR;
 800c87e:	2b00      	cmp	r3, #0
 800c880:	bf14      	ite	ne
 800c882:	2301      	movne	r3, #1
 800c884:	2300      	moveq	r3, #0
 800c886:	b2db      	uxtb	r3, r3
}
 800c888:	4618      	mov	r0, r3
 800c88a:	3710      	adds	r7, #16
 800c88c:	46bd      	mov	sp, r7
 800c88e:	bd80      	pop	{r7, pc}
 800c890:	08015fd8 	.word	0x08015fd8
 800c894:	0801605c 	.word	0x0801605c

0800c898 <th_aes_gcm_encrypt>:
                   uint8_t       *p_ct,
                   uint8_t       *p_tag,
                   uint32_t       taglen,
                   const uint8_t *p_iv,
                   uint32_t       ivlen)
{
 800c898:	b580      	push	{r7, lr}
 800c89a:	b08c      	sub	sp, #48	@ 0x30
 800c89c:	af08      	add	r7, sp, #32
 800c89e:	60f8      	str	r0, [r7, #12]
 800c8a0:	60b9      	str	r1, [r7, #8]
 800c8a2:	607a      	str	r2, [r7, #4]
 800c8a4:	603b      	str	r3, [r7, #0]
    CHECK_NULL_CTX(p_context);
 800c8a6:	68fb      	ldr	r3, [r7, #12]
 800c8a8:	2b00      	cmp	r3, #0
 800c8aa:	d107      	bne.n	800c8bc <th_aes_gcm_encrypt+0x24>
 800c8ac:	f44f 72c9 	mov.w	r2, #402	@ 0x192
 800c8b0:	4915      	ldr	r1, [pc, #84]	@ (800c908 <th_aes_gcm_encrypt+0x70>)
 800c8b2:	4816      	ldr	r0, [pc, #88]	@ (800c90c <th_aes_gcm_encrypt+0x74>)
 800c8b4:	f000 fa58 	bl	800cd68 <th_printf>
 800c8b8:	2301      	movs	r3, #1
 800c8ba:	e021      	b.n	800c900 <th_aes_gcm_encrypt+0x68>

    if (EE_AES_GCM != ((th_mbedtls_aes_context_t *)p_context)->aes_mode)
 800c8bc:	68fb      	ldr	r3, [r7, #12]
 800c8be:	781b      	ldrb	r3, [r3, #0]
 800c8c0:	2b03      	cmp	r3, #3
 800c8c2:	d001      	beq.n	800c8c8 <th_aes_gcm_encrypt+0x30>
    {
        return EE_STATUS_ERROR;
 800c8c4:	2301      	movs	r3, #1
 800c8c6:	e01b      	b.n	800c900 <th_aes_gcm_encrypt+0x68>
    }

    return mbedtls_gcm_crypt_and_tag(
 800c8c8:	68fb      	ldr	r3, [r7, #12]
 800c8ca:	f103 0008 	add.w	r0, r3, #8
 800c8ce:	69bb      	ldr	r3, [r7, #24]
 800c8d0:	9306      	str	r3, [sp, #24]
 800c8d2:	69fb      	ldr	r3, [r7, #28]
 800c8d4:	9305      	str	r3, [sp, #20]
 800c8d6:	683b      	ldr	r3, [r7, #0]
 800c8d8:	9304      	str	r3, [sp, #16]
 800c8da:	68bb      	ldr	r3, [r7, #8]
 800c8dc:	9303      	str	r3, [sp, #12]
 800c8de:	2300      	movs	r3, #0
 800c8e0:	9302      	str	r3, [sp, #8]
 800c8e2:	2300      	movs	r3, #0
 800c8e4:	9301      	str	r3, [sp, #4]
 800c8e6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c8e8:	9300      	str	r3, [sp, #0]
 800c8ea:	6a3b      	ldr	r3, [r7, #32]
 800c8ec:	687a      	ldr	r2, [r7, #4]
 800c8ee:	2101      	movs	r1, #1
 800c8f0:	f7f9 fbc9 	bl	8006086 <mbedtls_gcm_crypt_and_tag>
 800c8f4:	4603      	mov	r3, r0
               p_ct,
               taglen,
               p_tag)
                   == 0
               ? EE_STATUS_OK
               : EE_STATUS_ERROR;
 800c8f6:	2b00      	cmp	r3, #0
 800c8f8:	bf14      	ite	ne
 800c8fa:	2301      	movne	r3, #1
 800c8fc:	2300      	moveq	r3, #0
 800c8fe:	b2db      	uxtb	r3, r3
}
 800c900:	4618      	mov	r0, r3
 800c902:	3710      	adds	r7, #16
 800c904:	46bd      	mov	sp, r7
 800c906:	bd80      	pop	{r7, pc}
 800c908:	08015fd8 	.word	0x08015fd8
 800c90c:	0801605c 	.word	0x0801605c

0800c910 <th_aes_gcm_decrypt>:
                   uint8_t       *p_pt,
                   const uint8_t *p_tag,
                   uint32_t       taglen,
                   const uint8_t *p_iv,
                   uint32_t       ivlen)
{
 800c910:	b580      	push	{r7, lr}
 800c912:	b08a      	sub	sp, #40	@ 0x28
 800c914:	af06      	add	r7, sp, #24
 800c916:	60f8      	str	r0, [r7, #12]
 800c918:	60b9      	str	r1, [r7, #8]
 800c91a:	607a      	str	r2, [r7, #4]
 800c91c:	603b      	str	r3, [r7, #0]
    CHECK_NULL_CTX(p_context);
 800c91e:	68fb      	ldr	r3, [r7, #12]
 800c920:	2b00      	cmp	r3, #0
 800c922:	d107      	bne.n	800c934 <th_aes_gcm_decrypt+0x24>
 800c924:	f44f 72da 	mov.w	r2, #436	@ 0x1b4
 800c928:	4914      	ldr	r1, [pc, #80]	@ (800c97c <th_aes_gcm_decrypt+0x6c>)
 800c92a:	4815      	ldr	r0, [pc, #84]	@ (800c980 <th_aes_gcm_decrypt+0x70>)
 800c92c:	f000 fa1c 	bl	800cd68 <th_printf>
 800c930:	2301      	movs	r3, #1
 800c932:	e01f      	b.n	800c974 <th_aes_gcm_decrypt+0x64>

    if (EE_AES_GCM != ((th_mbedtls_aes_context_t *)p_context)->aes_mode)
 800c934:	68fb      	ldr	r3, [r7, #12]
 800c936:	781b      	ldrb	r3, [r3, #0]
 800c938:	2b03      	cmp	r3, #3
 800c93a:	d001      	beq.n	800c940 <th_aes_gcm_decrypt+0x30>
    {
        return EE_STATUS_ERROR;
 800c93c:	2301      	movs	r3, #1
 800c93e:	e019      	b.n	800c974 <th_aes_gcm_decrypt+0x64>
    }

    return mbedtls_gcm_auth_decrypt(
 800c940:	68fb      	ldr	r3, [r7, #12]
 800c942:	f103 0008 	add.w	r0, r3, #8
 800c946:	683b      	ldr	r3, [r7, #0]
 800c948:	9305      	str	r3, [sp, #20]
 800c94a:	68bb      	ldr	r3, [r7, #8]
 800c94c:	9304      	str	r3, [sp, #16]
 800c94e:	69fb      	ldr	r3, [r7, #28]
 800c950:	9303      	str	r3, [sp, #12]
 800c952:	69bb      	ldr	r3, [r7, #24]
 800c954:	9302      	str	r3, [sp, #8]
 800c956:	2300      	movs	r3, #0
 800c958:	9301      	str	r3, [sp, #4]
 800c95a:	2300      	movs	r3, #0
 800c95c:	9300      	str	r3, [sp, #0]
 800c95e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c960:	6a3a      	ldr	r2, [r7, #32]
 800c962:	6879      	ldr	r1, [r7, #4]
 800c964:	f7f9 fbd8 	bl	8006118 <mbedtls_gcm_auth_decrypt>
 800c968:	4603      	mov	r3, r0
               taglen,
               p_ct,
               p_pt)
                   == 0
               ? EE_STATUS_OK
               : EE_STATUS_ERROR;
 800c96a:	2b00      	cmp	r3, #0
 800c96c:	bf14      	ite	ne
 800c96e:	2301      	movne	r3, #1
 800c970:	2300      	moveq	r3, #0
 800c972:	b2db      	uxtb	r3, r3
}
 800c974:	4618      	mov	r0, r3
 800c976:	3710      	adds	r7, #16
 800c978:	46bd      	mov	sp, r7
 800c97a:	bd80      	pop	{r7, pc}
 800c97c:	08015fd8 	.word	0x08015fd8
 800c980:	0801605c 	.word	0x0801605c

0800c984 <th_aes_destroy>:

void
th_aes_destroy(void *p_context)
{
 800c984:	b580      	push	{r7, lr}
 800c986:	b084      	sub	sp, #16
 800c988:	af00      	add	r7, sp, #0
 800c98a:	6078      	str	r0, [r7, #4]
    CHECK_NULL_CTX_NORET(p_context);
 800c98c:	687b      	ldr	r3, [r7, #4]
 800c98e:	2b00      	cmp	r3, #0
 800c990:	d106      	bne.n	800c9a0 <th_aes_destroy+0x1c>
 800c992:	f44f 72e7 	mov.w	r2, #462	@ 0x1ce
 800c996:	4917      	ldr	r1, [pc, #92]	@ (800c9f4 <th_aes_destroy+0x70>)
 800c998:	4817      	ldr	r0, [pc, #92]	@ (800c9f8 <th_aes_destroy+0x74>)
 800c99a:	f000 f9e5 	bl	800cd68 <th_printf>
 800c99e:	e025      	b.n	800c9ec <th_aes_destroy+0x68>

    th_mbedtls_aes_context_t *p_ctx = (th_mbedtls_aes_context_t *)p_context;
 800c9a0:	687b      	ldr	r3, [r7, #4]
 800c9a2:	60fb      	str	r3, [r7, #12]

    if (p_ctx->aes_mode == EE_AES_CCM || p_ctx->aes_mode == EE_AES_CTR)
 800c9a4:	68fb      	ldr	r3, [r7, #12]
 800c9a6:	781b      	ldrb	r3, [r3, #0]
 800c9a8:	2b02      	cmp	r3, #2
 800c9aa:	d003      	beq.n	800c9b4 <th_aes_destroy+0x30>
 800c9ac:	68fb      	ldr	r3, [r7, #12]
 800c9ae:	781b      	ldrb	r3, [r3, #0]
 800c9b0:	2b01      	cmp	r3, #1
 800c9b2:	d105      	bne.n	800c9c0 <th_aes_destroy+0x3c>
    {
        mbedtls_aes_free(&(p_ctx->ctx.aes_ctx));
 800c9b4:	68fb      	ldr	r3, [r7, #12]
 800c9b6:	3308      	adds	r3, #8
 800c9b8:	4618      	mov	r0, r3
 800c9ba:	f7f4 f869 	bl	8000a90 <mbedtls_aes_free>
 800c9be:	e012      	b.n	800c9e6 <th_aes_destroy+0x62>
    }
    else if (p_ctx->aes_mode == EE_AES_CCM)
 800c9c0:	68fb      	ldr	r3, [r7, #12]
 800c9c2:	781b      	ldrb	r3, [r3, #0]
 800c9c4:	2b02      	cmp	r3, #2
 800c9c6:	d105      	bne.n	800c9d4 <th_aes_destroy+0x50>
    {
        mbedtls_ccm_free(&(p_ctx->ctx.ccm_ctx));
 800c9c8:	68fb      	ldr	r3, [r7, #12]
 800c9ca:	3308      	adds	r3, #8
 800c9cc:	4618      	mov	r0, r3
 800c9ce:	f7f5 ffc7 	bl	8002960 <mbedtls_ccm_free>
 800c9d2:	e008      	b.n	800c9e6 <th_aes_destroy+0x62>
    }
    else if (p_ctx->aes_mode == EE_AES_GCM)
 800c9d4:	68fb      	ldr	r3, [r7, #12]
 800c9d6:	781b      	ldrb	r3, [r3, #0]
 800c9d8:	2b03      	cmp	r3, #3
 800c9da:	d104      	bne.n	800c9e6 <th_aes_destroy+0x62>
    {
        mbedtls_gcm_free(&(p_ctx->ctx.gcm_ctx));
 800c9dc:	68fb      	ldr	r3, [r7, #12]
 800c9de:	3308      	adds	r3, #8
 800c9e0:	4618      	mov	r0, r3
 800c9e2:	f7f9 fbe8 	bl	80061b6 <mbedtls_gcm_free>
    }
    th_free(p_context);
 800c9e6:	6878      	ldr	r0, [r7, #4]
 800c9e8:	f000 f9fc 	bl	800cde4 <th_free>
}
 800c9ec:	3710      	adds	r7, #16
 800c9ee:	46bd      	mov	sp, r7
 800c9f0:	bd80      	pop	{r7, pc}
 800c9f2:	bf00      	nop
 800c9f4:	08015fd8 	.word	0x08015fd8
 800c9f8:	0801605c 	.word	0x0801605c

0800c9fc <th_chachapoly_create>:
#include "mbedtls/chachapoly.h"
#include "ee_chachapoly.h"

ee_status_t
th_chachapoly_create(void **pp_context)
{
 800c9fc:	b580      	push	{r7, lr}
 800c9fe:	b082      	sub	sp, #8
 800ca00:	af00      	add	r7, sp, #0
 800ca02:	6078      	str	r0, [r7, #4]
    *pp_context = (mbedtls_chachapoly_context *)th_malloc(
 800ca04:	20e8      	movs	r0, #232	@ 0xe8
 800ca06:	f000 f9e1 	bl	800cdcc <th_malloc>
 800ca0a:	4602      	mov	r2, r0
 800ca0c:	687b      	ldr	r3, [r7, #4]
 800ca0e:	601a      	str	r2, [r3, #0]
        sizeof(mbedtls_chachapoly_context));
    return EE_STATUS_OK;
 800ca10:	2300      	movs	r3, #0
}
 800ca12:	4618      	mov	r0, r3
 800ca14:	3708      	adds	r7, #8
 800ca16:	46bd      	mov	sp, r7
 800ca18:	bd80      	pop	{r7, pc}
	...

0800ca1c <th_chachapoly_init>:

ee_status_t
th_chachapoly_init(void *p_context, const uint8_t *p_key, uint32_t keylen)
{
 800ca1c:	b580      	push	{r7, lr}
 800ca1e:	b086      	sub	sp, #24
 800ca20:	af00      	add	r7, sp, #0
 800ca22:	60f8      	str	r0, [r7, #12]
 800ca24:	60b9      	str	r1, [r7, #8]
 800ca26:	607a      	str	r2, [r7, #4]

    int                         ret;
    mbedtls_chachapoly_context *context
 800ca28:	68fb      	ldr	r3, [r7, #12]
 800ca2a:	617b      	str	r3, [r7, #20]
        = (mbedtls_chachapoly_context *)p_context;
    mbedtls_chachapoly_init(context);
 800ca2c:	6978      	ldr	r0, [r7, #20]
 800ca2e:	f7f6 ffd9 	bl	80039e4 <mbedtls_chachapoly_init>
    ret = mbedtls_chachapoly_setkey(p_context, p_key);
 800ca32:	68b9      	ldr	r1, [r7, #8]
 800ca34:	68f8      	ldr	r0, [r7, #12]
 800ca36:	f7f7 f827 	bl	8003a88 <mbedtls_chachapoly_setkey>
 800ca3a:	6138      	str	r0, [r7, #16]
    if (ret != 0)
 800ca3c:	693b      	ldr	r3, [r7, #16]
 800ca3e:	2b00      	cmp	r3, #0
 800ca40:	d005      	beq.n	800ca4e <th_chachapoly_init+0x32>
    {
        th_printf("e-[mbedtls failed to set ChaChaPoly key: %d]\r\n", ret);
 800ca42:	6939      	ldr	r1, [r7, #16]
 800ca44:	4804      	ldr	r0, [pc, #16]	@ (800ca58 <th_chachapoly_init+0x3c>)
 800ca46:	f000 f98f 	bl	800cd68 <th_printf>
        return EE_STATUS_ERROR;
 800ca4a:	2301      	movs	r3, #1
 800ca4c:	e000      	b.n	800ca50 <th_chachapoly_init+0x34>
    }
    return EE_STATUS_OK;
 800ca4e:	2300      	movs	r3, #0
}
 800ca50:	4618      	mov	r0, r3
 800ca52:	3718      	adds	r7, #24
 800ca54:	46bd      	mov	sp, r7
 800ca56:	bd80      	pop	{r7, pc}
 800ca58:	08016170 	.word	0x08016170

0800ca5c <th_chachapoly_deinit>:

void
th_chachapoly_deinit(void *p_context)
{
 800ca5c:	b580      	push	{r7, lr}
 800ca5e:	b082      	sub	sp, #8
 800ca60:	af00      	add	r7, sp, #0
 800ca62:	6078      	str	r0, [r7, #4]

    mbedtls_chachapoly_free((mbedtls_chachapoly_context *)p_context);
 800ca64:	6878      	ldr	r0, [r7, #4]
 800ca66:	f7f6 ffe4 	bl	8003a32 <mbedtls_chachapoly_free>
}
 800ca6a:	bf00      	nop
 800ca6c:	3708      	adds	r7, #8
 800ca6e:	46bd      	mov	sp, r7
 800ca70:	bd80      	pop	{r7, pc}

0800ca72 <th_chachapoly_encrypt>:
                      uint8_t       *p_ct,
                      uint8_t       *p_tag,
                      uint32_t       taglen,
                      uint8_t       *p_iv,
                      uint32_t       ivlen)
{
 800ca72:	b580      	push	{r7, lr}
 800ca74:	b088      	sub	sp, #32
 800ca76:	af04      	add	r7, sp, #16
 800ca78:	60f8      	str	r0, [r7, #12]
 800ca7a:	60b9      	str	r1, [r7, #8]
 800ca7c:	607a      	str	r2, [r7, #4]
 800ca7e:	603b      	str	r3, [r7, #0]
    return mbedtls_chachapoly_encrypt_and_tag(
 800ca80:	69bb      	ldr	r3, [r7, #24]
 800ca82:	9303      	str	r3, [sp, #12]
 800ca84:	683b      	ldr	r3, [r7, #0]
 800ca86:	9302      	str	r3, [sp, #8]
 800ca88:	68bb      	ldr	r3, [r7, #8]
 800ca8a:	9301      	str	r3, [sp, #4]
 800ca8c:	2300      	movs	r3, #0
 800ca8e:	9300      	str	r3, [sp, #0]
 800ca90:	2300      	movs	r3, #0
 800ca92:	6a3a      	ldr	r2, [r7, #32]
 800ca94:	6879      	ldr	r1, [r7, #4]
 800ca96:	68f8      	ldr	r0, [r7, #12]
 800ca98:	f7f7 fa34 	bl	8003f04 <mbedtls_chachapoly_encrypt_and_tag>
 800ca9c:	4603      	mov	r3, r0
               p_pt,
               p_ct,
               p_tag)
                   == 0
               ? EE_STATUS_OK
               : EE_STATUS_ERROR;
 800ca9e:	2b00      	cmp	r3, #0
 800caa0:	bf14      	ite	ne
 800caa2:	2301      	movne	r3, #1
 800caa4:	2300      	moveq	r3, #0
 800caa6:	b2db      	uxtb	r3, r3
}
 800caa8:	4618      	mov	r0, r3
 800caaa:	3710      	adds	r7, #16
 800caac:	46bd      	mov	sp, r7
 800caae:	bd80      	pop	{r7, pc}

0800cab0 <th_chachapoly_decrypt>:
                      uint8_t       *p_pt,
                      uint8_t       *p_tag,
                      uint32_t       taglen,
                      uint8_t       *p_iv,
                      uint32_t       ivlen)
{
 800cab0:	b580      	push	{r7, lr}
 800cab2:	b088      	sub	sp, #32
 800cab4:	af04      	add	r7, sp, #16
 800cab6:	60f8      	str	r0, [r7, #12]
 800cab8:	60b9      	str	r1, [r7, #8]
 800caba:	607a      	str	r2, [r7, #4]
 800cabc:	603b      	str	r3, [r7, #0]
    return mbedtls_chachapoly_auth_decrypt(
 800cabe:	683b      	ldr	r3, [r7, #0]
 800cac0:	9303      	str	r3, [sp, #12]
 800cac2:	68bb      	ldr	r3, [r7, #8]
 800cac4:	9302      	str	r3, [sp, #8]
 800cac6:	69bb      	ldr	r3, [r7, #24]
 800cac8:	9301      	str	r3, [sp, #4]
 800caca:	2300      	movs	r3, #0
 800cacc:	9300      	str	r3, [sp, #0]
 800cace:	2300      	movs	r3, #0
 800cad0:	6a3a      	ldr	r2, [r7, #32]
 800cad2:	6879      	ldr	r1, [r7, #4]
 800cad4:	68f8      	ldr	r0, [r7, #12]
 800cad6:	f7f7 fa31 	bl	8003f3c <mbedtls_chachapoly_auth_decrypt>
 800cada:	4603      	mov	r3, r0
               p_tag,
               p_ct,
               p_pt)
                   == 0
               ? EE_STATUS_OK
               : EE_STATUS_ERROR;
 800cadc:	2b00      	cmp	r3, #0
 800cade:	bf14      	ite	ne
 800cae0:	2301      	movne	r3, #1
 800cae2:	2300      	moveq	r3, #0
 800cae4:	b2db      	uxtb	r3, r3
}
 800cae6:	4618      	mov	r0, r3
 800cae8:	3710      	adds	r7, #16
 800caea:	46bd      	mov	sp, r7
 800caec:	bd80      	pop	{r7, pc}

0800caee <th_chachapoly_destroy>:

void
th_chachapoly_destroy(void *p_context)
{
 800caee:	b580      	push	{r7, lr}
 800caf0:	b082      	sub	sp, #8
 800caf2:	af00      	add	r7, sp, #0
 800caf4:	6078      	str	r0, [r7, #4]
    mbedtls_chachapoly_free((mbedtls_chachapoly_context *)p_context);
 800caf6:	6878      	ldr	r0, [r7, #4]
 800caf8:	f7f6 ff9b 	bl	8003a32 <mbedtls_chachapoly_free>
    th_free(p_context);
 800cafc:	6878      	ldr	r0, [r7, #4]
 800cafe:	f000 f971 	bl	800cde4 <th_free>
}
 800cb02:	bf00      	nop
 800cb04:	3708      	adds	r7, #8
 800cb06:	46bd      	mov	sp, r7
 800cb08:	bd80      	pop	{r7, pc}
	...

0800cb0c <th_sha_create>:
    } ctx;
} th_mbedtls_sha_context_t;

ee_status_t
th_sha_create(void **pp_context, ee_sha_size_t size)
{
 800cb0c:	b580      	push	{r7, lr}
 800cb0e:	b084      	sub	sp, #16
 800cb10:	af00      	add	r7, sp, #0
 800cb12:	6078      	str	r0, [r7, #4]
 800cb14:	460b      	mov	r3, r1
 800cb16:	807b      	strh	r3, [r7, #2]
    th_mbedtls_sha_context_t *ctx;

    if (size != EE_SHA256 && size != EE_SHA384)
 800cb18:	887b      	ldrh	r3, [r7, #2]
 800cb1a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800cb1e:	d008      	beq.n	800cb32 <th_sha_create+0x26>
 800cb20:	887b      	ldrh	r3, [r7, #2]
 800cb22:	f5b3 7fc0 	cmp.w	r3, #384	@ 0x180
 800cb26:	d004      	beq.n	800cb32 <th_sha_create+0x26>
    {
        th_printf("e-[th_sha_create unsupported size]\r\n");
 800cb28:	480d      	ldr	r0, [pc, #52]	@ (800cb60 <th_sha_create+0x54>)
 800cb2a:	f000 f91d 	bl	800cd68 <th_printf>
        return EE_STATUS_ERROR;
 800cb2e:	2301      	movs	r3, #1
 800cb30:	e012      	b.n	800cb58 <th_sha_create+0x4c>
    }
    ctx = th_malloc(sizeof(th_mbedtls_sha_context_t));
 800cb32:	20e0      	movs	r0, #224	@ 0xe0
 800cb34:	f000 f94a 	bl	800cdcc <th_malloc>
 800cb38:	60f8      	str	r0, [r7, #12]
    if (!ctx)
 800cb3a:	68fb      	ldr	r3, [r7, #12]
 800cb3c:	2b00      	cmp	r3, #0
 800cb3e:	d104      	bne.n	800cb4a <th_sha_create+0x3e>
    {
        th_printf("e-[th_sha_create malloc fail]\r\n");
 800cb40:	4808      	ldr	r0, [pc, #32]	@ (800cb64 <th_sha_create+0x58>)
 800cb42:	f000 f911 	bl	800cd68 <th_printf>
        return EE_STATUS_ERROR;
 800cb46:	2301      	movs	r3, #1
 800cb48:	e006      	b.n	800cb58 <th_sha_create+0x4c>
    }
    ctx->size   = size;
 800cb4a:	68fb      	ldr	r3, [r7, #12]
 800cb4c:	887a      	ldrh	r2, [r7, #2]
 800cb4e:	801a      	strh	r2, [r3, #0]
    *pp_context = (void *)ctx;
 800cb50:	687b      	ldr	r3, [r7, #4]
 800cb52:	68fa      	ldr	r2, [r7, #12]
 800cb54:	601a      	str	r2, [r3, #0]
    return EE_STATUS_OK;
 800cb56:	2300      	movs	r3, #0
}
 800cb58:	4618      	mov	r0, r3
 800cb5a:	3710      	adds	r7, #16
 800cb5c:	46bd      	mov	sp, r7
 800cb5e:	bd80      	pop	{r7, pc}
 800cb60:	080161a0 	.word	0x080161a0
 800cb64:	080161c8 	.word	0x080161c8

0800cb68 <th_sha_init>:

ee_status_t
th_sha_init(void *p_context)
{
 800cb68:	b580      	push	{r7, lr}
 800cb6a:	b084      	sub	sp, #16
 800cb6c:	af00      	add	r7, sp, #0
 800cb6e:	6078      	str	r0, [r7, #4]
    int ret;
    if (((th_mbedtls_sha_context_t *)(p_context))->size == EE_SHA256)
 800cb70:	687b      	ldr	r3, [r7, #4]
 800cb72:	881b      	ldrh	r3, [r3, #0]
 800cb74:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800cb78:	d10c      	bne.n	800cb94 <th_sha_init+0x2c>
    {
        mbedtls_sha256_init(
 800cb7a:	687b      	ldr	r3, [r7, #4]
 800cb7c:	3308      	adds	r3, #8
 800cb7e:	4618      	mov	r0, r3
 800cb80:	f7fa fb20 	bl	80071c4 <mbedtls_sha256_init>
            &((th_mbedtls_sha_context_t *)(p_context))->ctx.sha256);
        ret = mbedtls_sha256_starts(
 800cb84:	687b      	ldr	r3, [r7, #4]
 800cb86:	3308      	adds	r3, #8
 800cb88:	2100      	movs	r1, #0
 800cb8a:	4618      	mov	r0, r3
 800cb8c:	f7fa fb28 	bl	80071e0 <mbedtls_sha256_starts>
 800cb90:	60f8      	str	r0, [r7, #12]
 800cb92:	e016      	b.n	800cbc2 <th_sha_init+0x5a>
            &((th_mbedtls_sha_context_t *)(p_context))->ctx.sha256,
            0 /* 0 for SHA-256 */);
    }
    else if (((th_mbedtls_sha_context_t *)(p_context))->size == EE_SHA384)
 800cb94:	687b      	ldr	r3, [r7, #4]
 800cb96:	881b      	ldrh	r3, [r3, #0]
 800cb98:	f5b3 7fc0 	cmp.w	r3, #384	@ 0x180
 800cb9c:	d10c      	bne.n	800cbb8 <th_sha_init+0x50>
    {
        mbedtls_sha512_init(
 800cb9e:	687b      	ldr	r3, [r7, #4]
 800cba0:	3308      	adds	r3, #8
 800cba2:	4618      	mov	r0, r3
 800cba4:	f7fc fd34 	bl	8009610 <mbedtls_sha512_init>
            &((th_mbedtls_sha_context_t *)(p_context))->ctx.sha512);
        ret = mbedtls_sha512_starts(
 800cba8:	687b      	ldr	r3, [r7, #4]
 800cbaa:	3308      	adds	r3, #8
 800cbac:	2101      	movs	r1, #1
 800cbae:	4618      	mov	r0, r3
 800cbb0:	f7fc fd3e 	bl	8009630 <mbedtls_sha512_starts>
 800cbb4:	60f8      	str	r0, [r7, #12]
 800cbb6:	e004      	b.n	800cbc2 <th_sha_init+0x5a>
            &((th_mbedtls_sha_context_t *)(p_context))->ctx.sha512,
            1 /* 1 for SHA-384 */);
    }
    else
    {
        th_printf("e-[th_sha_init unsupported size]\r\n");
 800cbb8:	480a      	ldr	r0, [pc, #40]	@ (800cbe4 <th_sha_init+0x7c>)
 800cbba:	f000 f8d5 	bl	800cd68 <th_printf>
        return EE_STATUS_ERROR;
 800cbbe:	2301      	movs	r3, #1
 800cbc0:	e00b      	b.n	800cbda <th_sha_init+0x72>
    }

    if (ret != 0)
 800cbc2:	68fb      	ldr	r3, [r7, #12]
 800cbc4:	2b00      	cmp	r3, #0
 800cbc6:	d007      	beq.n	800cbd8 <th_sha_init+0x70>
    {
        th_printf("e-[th_sha_init: -0x%04x]\r\n", -ret);
 800cbc8:	68fb      	ldr	r3, [r7, #12]
 800cbca:	425b      	negs	r3, r3
 800cbcc:	4619      	mov	r1, r3
 800cbce:	4806      	ldr	r0, [pc, #24]	@ (800cbe8 <th_sha_init+0x80>)
 800cbd0:	f000 f8ca 	bl	800cd68 <th_printf>
        return EE_STATUS_ERROR;
 800cbd4:	2301      	movs	r3, #1
 800cbd6:	e000      	b.n	800cbda <th_sha_init+0x72>
    }

    return EE_STATUS_OK;
 800cbd8:	2300      	movs	r3, #0
}
 800cbda:	4618      	mov	r0, r3
 800cbdc:	3710      	adds	r7, #16
 800cbde:	46bd      	mov	sp, r7
 800cbe0:	bd80      	pop	{r7, pc}
 800cbe2:	bf00      	nop
 800cbe4:	080161e8 	.word	0x080161e8
 800cbe8:	0801620c 	.word	0x0801620c

0800cbec <th_sha_process>:

ee_status_t
th_sha_process(void *p_context, const uint8_t *p_in, uint32_t len)
{
 800cbec:	b580      	push	{r7, lr}
 800cbee:	b086      	sub	sp, #24
 800cbf0:	af00      	add	r7, sp, #0
 800cbf2:	60f8      	str	r0, [r7, #12]
 800cbf4:	60b9      	str	r1, [r7, #8]
 800cbf6:	607a      	str	r2, [r7, #4]
    int ret;
    if (((th_mbedtls_sha_context_t *)(p_context))->size == EE_SHA256)
 800cbf8:	68fb      	ldr	r3, [r7, #12]
 800cbfa:	881b      	ldrh	r3, [r3, #0]
 800cbfc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800cc00:	d108      	bne.n	800cc14 <th_sha_process+0x28>
    {
        ret = mbedtls_sha256_update(
 800cc02:	68fb      	ldr	r3, [r7, #12]
 800cc04:	3308      	adds	r3, #8
 800cc06:	687a      	ldr	r2, [r7, #4]
 800cc08:	68b9      	ldr	r1, [r7, #8]
 800cc0a:	4618      	mov	r0, r3
 800cc0c:	f7fc fb1e 	bl	800924c <mbedtls_sha256_update>
 800cc10:	6178      	str	r0, [r7, #20]
 800cc12:	e012      	b.n	800cc3a <th_sha_process+0x4e>
            &((th_mbedtls_sha_context_t *)(p_context))->ctx.sha256, p_in, len);
    }
    else if (((th_mbedtls_sha_context_t *)(p_context))->size == EE_SHA384)
 800cc14:	68fb      	ldr	r3, [r7, #12]
 800cc16:	881b      	ldrh	r3, [r3, #0]
 800cc18:	f5b3 7fc0 	cmp.w	r3, #384	@ 0x180
 800cc1c:	d108      	bne.n	800cc30 <th_sha_process+0x44>
    {
        ret = mbedtls_sha512_update(
 800cc1e:	68fb      	ldr	r3, [r7, #12]
 800cc20:	3308      	adds	r3, #8
 800cc22:	687a      	ldr	r2, [r7, #4]
 800cc24:	68b9      	ldr	r1, [r7, #8]
 800cc26:	4618      	mov	r0, r3
 800cc28:	f7fe fe88 	bl	800b93c <mbedtls_sha512_update>
 800cc2c:	6178      	str	r0, [r7, #20]
 800cc2e:	e004      	b.n	800cc3a <th_sha_process+0x4e>
            &((th_mbedtls_sha_context_t *)(p_context))->ctx.sha512, p_in, len);
    }
    else
    {
        th_printf("e-[th_sha_process unsupported size]\r\n");
 800cc30:	480a      	ldr	r0, [pc, #40]	@ (800cc5c <th_sha_process+0x70>)
 800cc32:	f000 f899 	bl	800cd68 <th_printf>
        return EE_STATUS_ERROR;
 800cc36:	2301      	movs	r3, #1
 800cc38:	e00b      	b.n	800cc52 <th_sha_process+0x66>
    }

    if (ret != 0)
 800cc3a:	697b      	ldr	r3, [r7, #20]
 800cc3c:	2b00      	cmp	r3, #0
 800cc3e:	d007      	beq.n	800cc50 <th_sha_process+0x64>
    {
        th_printf("e-[th_sha_process: -0x%04x]\r\n", -ret);
 800cc40:	697b      	ldr	r3, [r7, #20]
 800cc42:	425b      	negs	r3, r3
 800cc44:	4619      	mov	r1, r3
 800cc46:	4806      	ldr	r0, [pc, #24]	@ (800cc60 <th_sha_process+0x74>)
 800cc48:	f000 f88e 	bl	800cd68 <th_printf>
        return EE_STATUS_ERROR;
 800cc4c:	2301      	movs	r3, #1
 800cc4e:	e000      	b.n	800cc52 <th_sha_process+0x66>
    }

    return EE_STATUS_OK;
 800cc50:	2300      	movs	r3, #0
}
 800cc52:	4618      	mov	r0, r3
 800cc54:	3718      	adds	r7, #24
 800cc56:	46bd      	mov	sp, r7
 800cc58:	bd80      	pop	{r7, pc}
 800cc5a:	bf00      	nop
 800cc5c:	08016228 	.word	0x08016228
 800cc60:	08016250 	.word	0x08016250

0800cc64 <th_sha_done>:

ee_status_t
th_sha_done(void *p_context, uint8_t *p_result)
{
 800cc64:	b580      	push	{r7, lr}
 800cc66:	b084      	sub	sp, #16
 800cc68:	af00      	add	r7, sp, #0
 800cc6a:	6078      	str	r0, [r7, #4]
 800cc6c:	6039      	str	r1, [r7, #0]
    int ret;
    if (((th_mbedtls_sha_context_t *)(p_context))->size == EE_SHA256)
 800cc6e:	687b      	ldr	r3, [r7, #4]
 800cc70:	881b      	ldrh	r3, [r3, #0]
 800cc72:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800cc76:	d107      	bne.n	800cc88 <th_sha_done+0x24>
    {
        ret = mbedtls_sha256_finish(
 800cc78:	687b      	ldr	r3, [r7, #4]
 800cc7a:	3308      	adds	r3, #8
 800cc7c:	6839      	ldr	r1, [r7, #0]
 800cc7e:	4618      	mov	r0, r3
 800cc80:	f7fc fb5c 	bl	800933c <mbedtls_sha256_finish>
 800cc84:	60f8      	str	r0, [r7, #12]
 800cc86:	e011      	b.n	800ccac <th_sha_done+0x48>
            &((th_mbedtls_sha_context_t *)(p_context))->ctx.sha256, p_result);
    }
    else if (((th_mbedtls_sha_context_t *)(p_context))->size == EE_SHA384)
 800cc88:	687b      	ldr	r3, [r7, #4]
 800cc8a:	881b      	ldrh	r3, [r3, #0]
 800cc8c:	f5b3 7fc0 	cmp.w	r3, #384	@ 0x180
 800cc90:	d107      	bne.n	800cca2 <th_sha_done+0x3e>
    {
        ret = mbedtls_sha512_finish(
 800cc92:	687b      	ldr	r3, [r7, #4]
 800cc94:	3308      	adds	r3, #8
 800cc96:	6839      	ldr	r1, [r7, #0]
 800cc98:	4618      	mov	r0, r3
 800cc9a:	f7fe fedd 	bl	800ba58 <mbedtls_sha512_finish>
 800cc9e:	60f8      	str	r0, [r7, #12]
 800cca0:	e004      	b.n	800ccac <th_sha_done+0x48>
            &((th_mbedtls_sha_context_t *)(p_context))->ctx.sha512, p_result);
    }
    else
    {
        th_printf("e-[th_sha_done unsupported size]\r\n");
 800cca2:	480a      	ldr	r0, [pc, #40]	@ (800cccc <th_sha_done+0x68>)
 800cca4:	f000 f860 	bl	800cd68 <th_printf>
        return EE_STATUS_ERROR;
 800cca8:	2301      	movs	r3, #1
 800ccaa:	e00b      	b.n	800ccc4 <th_sha_done+0x60>
    }

    if (ret != 0)
 800ccac:	68fb      	ldr	r3, [r7, #12]
 800ccae:	2b00      	cmp	r3, #0
 800ccb0:	d007      	beq.n	800ccc2 <th_sha_done+0x5e>
    {
        th_printf("e-[th_sha_done: -0x%04x]\r\n", -ret);
 800ccb2:	68fb      	ldr	r3, [r7, #12]
 800ccb4:	425b      	negs	r3, r3
 800ccb6:	4619      	mov	r1, r3
 800ccb8:	4805      	ldr	r0, [pc, #20]	@ (800ccd0 <th_sha_done+0x6c>)
 800ccba:	f000 f855 	bl	800cd68 <th_printf>
        return EE_STATUS_ERROR;
 800ccbe:	2301      	movs	r3, #1
 800ccc0:	e000      	b.n	800ccc4 <th_sha_done+0x60>
    }

    return EE_STATUS_OK;
 800ccc2:	2300      	movs	r3, #0
}
 800ccc4:	4618      	mov	r0, r3
 800ccc6:	3710      	adds	r7, #16
 800ccc8:	46bd      	mov	sp, r7
 800ccca:	bd80      	pop	{r7, pc}
 800cccc:	08016270 	.word	0x08016270
 800ccd0:	08016294 	.word	0x08016294

0800ccd4 <th_sha_destroy>:

void
th_sha_destroy(void *p_context)
{
 800ccd4:	b580      	push	{r7, lr}
 800ccd6:	b082      	sub	sp, #8
 800ccd8:	af00      	add	r7, sp, #0
 800ccda:	6078      	str	r0, [r7, #4]
    th_free(p_context);
 800ccdc:	6878      	ldr	r0, [r7, #4]
 800ccde:	f000 f881 	bl	800cde4 <th_free>
}
 800cce2:	bf00      	nop
 800cce4:	3708      	adds	r7, #8
 800cce6:	46bd      	mov	sp, r7
 800cce8:	bd80      	pop	{r7, pc}

0800ccea <th_pre>:

static unsigned char g_generic_buffer[BUFFER_SIZE];

void
th_pre(void)
{
 800ccea:	b480      	push	{r7}
 800ccec:	af00      	add	r7, sp, #0
}
 800ccee:	bf00      	nop
 800ccf0:	46bd      	mov	sp, r7
 800ccf2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ccf6:	4770      	bx	lr

0800ccf8 <th_post>:

void
th_post(void)
{
 800ccf8:	b480      	push	{r7}
 800ccfa:	af00      	add	r7, sp, #0
}
 800ccfc:	bf00      	nop
 800ccfe:	46bd      	mov	sp, r7
 800cd00:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd04:	4770      	bx	lr
	...

0800cd08 <th_timestamp_initialize>:
 * PORTME: Set up an OPEN-DRAIN GPIO if it hasn't already been done,
 * otherwise it is OK to leave this alone.
 */
void
th_timestamp_initialize(void)
{
 800cd08:	b580      	push	{r7, lr}
 800cd0a:	af00      	add	r7, sp, #0
	  /* USER CODE 1 BEGIN */
			 /* Enable TRC */
			 CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800cd0c:	4b0a      	ldr	r3, [pc, #40]	@ (800cd38 <th_timestamp_initialize+0x30>)
 800cd0e:	68db      	ldr	r3, [r3, #12]
 800cd10:	4a09      	ldr	r2, [pc, #36]	@ (800cd38 <th_timestamp_initialize+0x30>)
 800cd12:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 800cd16:	60d3      	str	r3, [r2, #12]
			 /* Reset the clock cycle counter value */
			 DWT->CYCCNT = 0;
 800cd18:	4b08      	ldr	r3, [pc, #32]	@ (800cd3c <th_timestamp_initialize+0x34>)
 800cd1a:	2200      	movs	r2, #0
 800cd1c:	605a      	str	r2, [r3, #4]
			  /* Enable  clock cycle counter */
			 DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800cd1e:	4b07      	ldr	r3, [pc, #28]	@ (800cd3c <th_timestamp_initialize+0x34>)
 800cd20:	681b      	ldr	r3, [r3, #0]
 800cd22:	4a06      	ldr	r2, [pc, #24]	@ (800cd3c <th_timestamp_initialize+0x34>)
 800cd24:	f043 0301 	orr.w	r3, r3, #1
 800cd28:	6013      	str	r3, [r2, #0]
		    /* Some BSP/MSP/SDKs initialize the GPIO long before we even get here! */
		    /* USER CODE 1 END */
		    /* Always print this message, the host needs it. */
		    th_printf(EE_MSG_TIMESTAMP_MODE);
 800cd2a:	4805      	ldr	r0, [pc, #20]	@ (800cd40 <th_timestamp_initialize+0x38>)
 800cd2c:	f000 f81c 	bl	800cd68 <th_printf>
		    /* Always call the timestamp on initialize so that the open-drain output
		       is set to "1" (so that we catch a falling edge) */
		    th_timestamp();
 800cd30:	f000 f808 	bl	800cd44 <th_timestamp>
}
 800cd34:	bf00      	nop
 800cd36:	bd80      	pop	{r7, pc}
 800cd38:	e000edf0 	.word	0xe000edf0
 800cd3c:	e0001000 	.word	0xe0001000
 800cd40:	080162b0 	.word	0x080162b0

0800cd44 <th_timestamp>:
 *
 * PORTME: This function is essential.
 */
uint32_t
th_timestamp(void)
{
 800cd44:	b480      	push	{r7}
 800cd46:	af00      	add	r7, sp, #0
	// uint32_t elapsedMicroSeconds = 0;
	    /* USER CODE 1 BEGIN */

	    return DWT->CYCCNT / 250;
 800cd48:	4b05      	ldr	r3, [pc, #20]	@ (800cd60 <th_timestamp+0x1c>)
 800cd4a:	685b      	ldr	r3, [r3, #4]
 800cd4c:	4a05      	ldr	r2, [pc, #20]	@ (800cd64 <th_timestamp+0x20>)
 800cd4e:	fba2 2303 	umull	r2, r3, r2, r3
 800cd52:	091b      	lsrs	r3, r3, #4
	#endif
	    }*/



}
 800cd54:	4618      	mov	r0, r3
 800cd56:	46bd      	mov	sp, r7
 800cd58:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd5c:	4770      	bx	lr
 800cd5e:	bf00      	nop
 800cd60:	e0001000 	.word	0xe0001000
 800cd64:	10624dd3 	.word	0x10624dd3

0800cd68 <th_printf>:
 * It may only be necessary to comment out this function and define
 * th_printf as printf and just rerout fputc();
 */
void
th_printf(const char *p_fmt, ...)
{
 800cd68:	b40f      	push	{r0, r1, r2, r3}
 800cd6a:	b580      	push	{r7, lr}
 800cd6c:	b082      	sub	sp, #8
 800cd6e:	af00      	add	r7, sp, #0
    va_list args;
    va_start(args, p_fmt);
 800cd70:	f107 0314 	add.w	r3, r7, #20
 800cd74:	607b      	str	r3, [r7, #4]
    (void)th_vprintf(p_fmt, args);
 800cd76:	6879      	ldr	r1, [r7, #4]
 800cd78:	6938      	ldr	r0, [r7, #16]
 800cd7a:	f000 f83e 	bl	800cdfa <th_vprintf>
    va_end(args);
}
 800cd7e:	bf00      	nop
 800cd80:	3708      	adds	r7, #8
 800cd82:	46bd      	mov	sp, r7
 800cd84:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800cd88:	b004      	add	sp, #16
 800cd8a:	4770      	bx	lr

0800cd8c <th_memset>:
    return atoi(str);
}

void *
th_memset(void *b, int c, size_t len)
{
 800cd8c:	b580      	push	{r7, lr}
 800cd8e:	b084      	sub	sp, #16
 800cd90:	af00      	add	r7, sp, #0
 800cd92:	60f8      	str	r0, [r7, #12]
 800cd94:	60b9      	str	r1, [r7, #8]
 800cd96:	607a      	str	r2, [r7, #4]
    return memset(b, c, len);
 800cd98:	687a      	ldr	r2, [r7, #4]
 800cd9a:	68b9      	ldr	r1, [r7, #8]
 800cd9c:	68f8      	ldr	r0, [r7, #12]
 800cd9e:	f008 fb53 	bl	8015448 <memset>
 800cda2:	4603      	mov	r3, r0
}
 800cda4:	4618      	mov	r0, r3
 800cda6:	3710      	adds	r7, #16
 800cda8:	46bd      	mov	sp, r7
 800cdaa:	bd80      	pop	{r7, pc}

0800cdac <th_memcpy>:

void *
th_memcpy(void *dst, const void *src, size_t n)
{
 800cdac:	b580      	push	{r7, lr}
 800cdae:	b084      	sub	sp, #16
 800cdb0:	af00      	add	r7, sp, #0
 800cdb2:	60f8      	str	r0, [r7, #12]
 800cdb4:	60b9      	str	r1, [r7, #8]
 800cdb6:	607a      	str	r2, [r7, #4]
    return memcpy(dst, src, n);
 800cdb8:	687a      	ldr	r2, [r7, #4]
 800cdba:	68b9      	ldr	r1, [r7, #8]
 800cdbc:	68f8      	ldr	r0, [r7, #12]
 800cdbe:	f008 fbce 	bl	801555e <memcpy>
 800cdc2:	4603      	mov	r3, r0
}
 800cdc4:	4618      	mov	r0, r3
 800cdc6:	3710      	adds	r7, #16
 800cdc8:	46bd      	mov	sp, r7
 800cdca:	bd80      	pop	{r7, pc}

0800cdcc <th_malloc>:
    return memmove(dst, src, n);
}

void *
th_malloc(size_t size)
{
 800cdcc:	b580      	push	{r7, lr}
 800cdce:	b082      	sub	sp, #8
 800cdd0:	af00      	add	r7, sp, #0
 800cdd2:	6078      	str	r0, [r7, #4]
    return malloc(size);
 800cdd4:	6878      	ldr	r0, [r7, #4]
 800cdd6:	f008 f8c3 	bl	8014f60 <malloc>
 800cdda:	4603      	mov	r3, r0
}
 800cddc:	4618      	mov	r0, r3
 800cdde:	3708      	adds	r7, #8
 800cde0:	46bd      	mov	sp, r7
 800cde2:	bd80      	pop	{r7, pc}

0800cde4 <th_free>:
    return calloc(count, size);
}

void
th_free(void *ptr)
{
 800cde4:	b580      	push	{r7, lr}
 800cde6:	b082      	sub	sp, #8
 800cde8:	af00      	add	r7, sp, #0
 800cdea:	6078      	str	r0, [r7, #4]
    free(ptr);
 800cdec:	6878      	ldr	r0, [r7, #4]
 800cdee:	f008 f8bf 	bl	8014f70 <free>
}
 800cdf2:	bf00      	nop
 800cdf4:	3708      	adds	r7, #8
 800cdf6:	46bd      	mov	sp, r7
 800cdf8:	bd80      	pop	{r7, pc}

0800cdfa <th_vprintf>:

int
th_vprintf(const char *format, va_list ap)
{
 800cdfa:	b580      	push	{r7, lr}
 800cdfc:	b082      	sub	sp, #8
 800cdfe:	af00      	add	r7, sp, #0
 800ce00:	6078      	str	r0, [r7, #4]
 800ce02:	6039      	str	r1, [r7, #0]
    return vprintf(format, ap);
 800ce04:	6839      	ldr	r1, [r7, #0]
 800ce06:	6878      	ldr	r0, [r7, #4]
 800ce08:	f008 fa80 	bl	801530c <viprintf>
 800ce0c:	4603      	mov	r3, r0
}
 800ce0e:	4618      	mov	r0, r3
 800ce10:	3708      	adds	r7, #8
 800ce12:	46bd      	mov	sp, r7
 800ce14:	bd80      	pop	{r7, pc}
	...

0800ce18 <ee_aes>:
       uint32_t       keylen,
       const uint8_t *p_iv,
       const uint32_t count,
       void          *p_message_list, /* see ee_aes.h for details */
       uint32_t       iter)
{
 800ce18:	b580      	push	{r7, lr}
 800ce1a:	b096      	sub	sp, #88	@ 0x58
 800ce1c:	af04      	add	r7, sp, #16
 800ce1e:	60ba      	str	r2, [r7, #8]
 800ce20:	607b      	str	r3, [r7, #4]
 800ce22:	4603      	mov	r3, r0
 800ce24:	73fb      	strb	r3, [r7, #15]
 800ce26:	460b      	mov	r3, r1
 800ce28:	73bb      	strb	r3, [r7, #14]
    uint8_t    *p_out;
    uint8_t    *p_tag;
    uint32_t   *p32;
    uint8_t    *p8;
    uint32_t    len;
    uint32_t    t0   = 0;
 800ce2a:	2300      	movs	r3, #0
 800ce2c:	643b      	str	r3, [r7, #64]	@ 0x40
    uint32_t    t1   = 0;
 800ce2e:	2300      	movs	r3, #0
 800ce30:	63fb      	str	r3, [r7, #60]	@ 0x3c
    uint16_t    bits = keylen * 8;
 800ce32:	687b      	ldr	r3, [r7, #4]
 800ce34:	b29b      	uxth	r3, r3
 800ce36:	00db      	lsls	r3, r3, #3
 800ce38:	867b      	strh	r3, [r7, #50]	@ 0x32
    const char *m    = aes_cipher_mode_text[mode];
 800ce3a:	7bfb      	ldrb	r3, [r7, #15]
 800ce3c:	4a9d      	ldr	r2, [pc, #628]	@ (800d0b4 <ee_aes+0x29c>)
 800ce3e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800ce42:	62fb      	str	r3, [r7, #44]	@ 0x2c
    ee_status_t ret;
    uint32_t    x;

    if (th_aes_create(&p_context, mode) != EE_STATUS_OK)
 800ce44:	7bfa      	ldrb	r2, [r7, #15]
 800ce46:	f107 0314 	add.w	r3, r7, #20
 800ce4a:	4611      	mov	r1, r2
 800ce4c:	4618      	mov	r0, r3
 800ce4e:	f7ff fa85 	bl	800c35c <th_aes_create>
 800ce52:	4603      	mov	r3, r0
 800ce54:	2b00      	cmp	r3, #0
 800ce56:	d007      	beq.n	800ce68 <ee_aes+0x50>
    {
        th_printf("e-aes%d_%s-[Failed to create context]\r\n", bits, m);
 800ce58:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 800ce5a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800ce5c:	4619      	mov	r1, r3
 800ce5e:	4896      	ldr	r0, [pc, #600]	@ (800d0b8 <ee_aes+0x2a0>)
 800ce60:	f7ff ff82 	bl	800cd68 <th_printf>
        return 0;
 800ce64:	2300      	movs	r3, #0
 800ce66:	e1c5      	b.n	800d1f4 <ee_aes+0x3dc>
    }
    th_printf("m-aes%d_%s-iter[%d]\r\n", bits, m, iter);
 800ce68:	8e79      	ldrh	r1, [r7, #50]	@ 0x32
 800ce6a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800ce6c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800ce6e:	4893      	ldr	r0, [pc, #588]	@ (800d0bc <ee_aes+0x2a4>)
 800ce70:	f7ff ff7a 	bl	800cd68 <th_printf>
    th_printf("m-aes%d_%s-count[%d]\r\n", bits, m, count);
 800ce74:	8e79      	ldrh	r1, [r7, #50]	@ 0x32
 800ce76:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800ce78:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800ce7a:	4891      	ldr	r0, [pc, #580]	@ (800d0c0 <ee_aes+0x2a8>)
 800ce7c:	f7ff ff74 	bl	800cd68 <th_printf>
    if (func == EE_AES_ENC)
 800ce80:	7bbb      	ldrb	r3, [r7, #14]
 800ce82:	2b00      	cmp	r3, #0
 800ce84:	f040 80c3 	bne.w	800d00e <ee_aes+0x1f6>
    {
        th_printf("m-aes%d_%s-encrypt-start\r\n", bits, m);
 800ce88:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 800ce8a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800ce8c:	4619      	mov	r1, r3
 800ce8e:	488d      	ldr	r0, [pc, #564]	@ (800d0c4 <ee_aes+0x2ac>)
 800ce90:	f7ff ff6a 	bl	800cd68 <th_printf>
        t0 = th_timestamp();
 800ce94:	f7ff ff56 	bl	800cd44 <th_timestamp>
 800ce98:	6438      	str	r0, [r7, #64]	@ 0x40
        th_pre();
 800ce9a:	f7ff ff26 	bl	800ccea <th_pre>
        while (iter-- > 0)
 800ce9e:	e0a4      	b.n	800cfea <ee_aes+0x1d2>
        {
            ret = EE_STATUS_OK;
 800cea0:	2300      	movs	r3, #0
 800cea2:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
            if (th_aes_init(p_context, p_key, keylen, p_iv, func, mode)
 800cea6:	6978      	ldr	r0, [r7, #20]
 800cea8:	7bfb      	ldrb	r3, [r7, #15]
 800ceaa:	9301      	str	r3, [sp, #4]
 800ceac:	7bbb      	ldrb	r3, [r7, #14]
 800ceae:	9300      	str	r3, [sp, #0]
 800ceb0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800ceb2:	687a      	ldr	r2, [r7, #4]
 800ceb4:	68b9      	ldr	r1, [r7, #8]
 800ceb6:	f7ff fa8b 	bl	800c3d0 <th_aes_init>
 800ceba:	4603      	mov	r3, r0
 800cebc:	2b00      	cmp	r3, #0
 800cebe:	d008      	beq.n	800ced2 <ee_aes+0xba>
                != EE_STATUS_OK)
            {
                th_post();
 800cec0:	f7ff ff1a 	bl	800ccf8 <th_post>
                th_printf("e-aes%d_%s-[Failed to initialize]\r\n", bits, m);
 800cec4:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 800cec6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800cec8:	4619      	mov	r1, r3
 800ceca:	487f      	ldr	r0, [pc, #508]	@ (800d0c8 <ee_aes+0x2b0>)
 800cecc:	f7ff ff4c 	bl	800cd68 <th_printf>
                goto exit;
 800ced0:	e189      	b.n	800d1e6 <ee_aes+0x3ce>
            }
            /* Work through the list of messages for this context */
            p32 = (uint32_t *)p_message_list;
 800ced2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800ced4:	647b      	str	r3, [r7, #68]	@ 0x44
            /* Perform multiple en/decrypts in the same context */
            for (x = 0; x < count; ++x)
 800ced6:	2300      	movs	r3, #0
 800ced8:	637b      	str	r3, [r7, #52]	@ 0x34
 800ceda:	e079      	b.n	800cfd0 <ee_aes+0x1b8>
            {
                /* Set up the data pointers */
                len  = *p32++;
 800cedc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800cede:	1d1a      	adds	r2, r3, #4
 800cee0:	647a      	str	r2, [r7, #68]	@ 0x44
 800cee2:	681b      	ldr	r3, [r3, #0]
 800cee4:	62bb      	str	r3, [r7, #40]	@ 0x28
                p8   = (uint8_t *)p32;
 800cee6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800cee8:	627b      	str	r3, [r7, #36]	@ 0x24
                p_in = p8;
 800ceea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ceec:	623b      	str	r3, [r7, #32]
                p8 += len;
 800ceee:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800cef0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800cef2:	4413      	add	r3, r2
 800cef4:	627b      	str	r3, [r7, #36]	@ 0x24
                p_out = p8;
 800cef6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cef8:	61fb      	str	r3, [r7, #28]
                p8 += len;
 800cefa:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800cefc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800cefe:	4413      	add	r3, r2
 800cf00:	627b      	str	r3, [r7, #36]	@ 0x24
                p_tag = p8;
 800cf02:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cf04:	61bb      	str	r3, [r7, #24]
                p8 += EE_AES_TAGLEN;
 800cf06:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cf08:	3310      	adds	r3, #16
 800cf0a:	627b      	str	r3, [r7, #36]	@ 0x24
                p32 = (uint32_t *)p8;
 800cf0c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cf0e:	647b      	str	r3, [r7, #68]	@ 0x44

                switch (mode)
 800cf10:	7bfb      	ldrb	r3, [r7, #15]
 800cf12:	2b03      	cmp	r3, #3
 800cf14:	d850      	bhi.n	800cfb8 <ee_aes+0x1a0>
 800cf16:	a201      	add	r2, pc, #4	@ (adr r2, 800cf1c <ee_aes+0x104>)
 800cf18:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800cf1c:	0800cf2d 	.word	0x0800cf2d
 800cf20:	0800cf5d 	.word	0x0800cf5d
 800cf24:	0800cf71 	.word	0x0800cf71
 800cf28:	0800cf95 	.word	0x0800cf95
                {
                    case EE_AES_ECB:
                        if (len % EE_AES_BLOCKLEN != 0)
 800cf2c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800cf2e:	f003 030f 	and.w	r3, r3, #15
 800cf32:	2b00      	cmp	r3, #0
 800cf34:	d008      	beq.n	800cf48 <ee_aes+0x130>
                        {
                            th_post();
 800cf36:	f7ff fedf 	bl	800ccf8 <th_post>
                            th_printf("e-aes%d_%s-[non mod-16]\r\n", bits, m);
 800cf3a:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 800cf3c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800cf3e:	4619      	mov	r1, r3
 800cf40:	4862      	ldr	r0, [pc, #392]	@ (800d0cc <ee_aes+0x2b4>)
 800cf42:	f7ff ff11 	bl	800cd68 <th_printf>
                            goto exit;
 800cf46:	e14e      	b.n	800d1e6 <ee_aes+0x3ce>
                        }
                        ret = th_aes_ecb_encrypt(p_context, p_in, len, p_out);
 800cf48:	6978      	ldr	r0, [r7, #20]
 800cf4a:	69fb      	ldr	r3, [r7, #28]
 800cf4c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800cf4e:	6a39      	ldr	r1, [r7, #32]
 800cf50:	f7ff fb32 	bl	800c5b8 <th_aes_ecb_encrypt>
 800cf54:	4603      	mov	r3, r0
 800cf56:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
                        break;
 800cf5a:	e036      	b.n	800cfca <ee_aes+0x1b2>
                    case EE_AES_CTR:
                        ret = th_aes_ctr_encrypt(p_context, p_in, len, p_out);
 800cf5c:	6978      	ldr	r0, [r7, #20]
 800cf5e:	69fb      	ldr	r3, [r7, #28]
 800cf60:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800cf62:	6a39      	ldr	r1, [r7, #32]
 800cf64:	f7ff fbac 	bl	800c6c0 <th_aes_ctr_encrypt>
 800cf68:	4603      	mov	r3, r0
 800cf6a:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
                        break;
 800cf6e:	e02c      	b.n	800cfca <ee_aes+0x1b2>
                    case EE_AES_CCM:
                        ret = th_aes_ccm_encrypt(p_context,
 800cf70:	6978      	ldr	r0, [r7, #20]
 800cf72:	230c      	movs	r3, #12
 800cf74:	9303      	str	r3, [sp, #12]
 800cf76:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800cf78:	9302      	str	r3, [sp, #8]
 800cf7a:	2310      	movs	r3, #16
 800cf7c:	9301      	str	r3, [sp, #4]
 800cf7e:	69bb      	ldr	r3, [r7, #24]
 800cf80:	9300      	str	r3, [sp, #0]
 800cf82:	69fb      	ldr	r3, [r7, #28]
 800cf84:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800cf86:	6a39      	ldr	r1, [r7, #32]
 800cf88:	f7ff fc12 	bl	800c7b0 <th_aes_ccm_encrypt>
 800cf8c:	4603      	mov	r3, r0
 800cf8e:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
                                                 p_out,
                                                 p_tag,
                                                 EE_AES_TAGLEN,
                                                 p_iv,
                                                 EE_AES_AEAD_IVLEN);
                        break;
 800cf92:	e01a      	b.n	800cfca <ee_aes+0x1b2>
                    case EE_AES_GCM:
                        ret = th_aes_gcm_encrypt(p_context,
 800cf94:	6978      	ldr	r0, [r7, #20]
 800cf96:	230c      	movs	r3, #12
 800cf98:	9303      	str	r3, [sp, #12]
 800cf9a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800cf9c:	9302      	str	r3, [sp, #8]
 800cf9e:	2310      	movs	r3, #16
 800cfa0:	9301      	str	r3, [sp, #4]
 800cfa2:	69bb      	ldr	r3, [r7, #24]
 800cfa4:	9300      	str	r3, [sp, #0]
 800cfa6:	69fb      	ldr	r3, [r7, #28]
 800cfa8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800cfaa:	6a39      	ldr	r1, [r7, #32]
 800cfac:	f7ff fc74 	bl	800c898 <th_aes_gcm_encrypt>
 800cfb0:	4603      	mov	r3, r0
 800cfb2:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
                                                 p_out,
                                                 p_tag,
                                                 EE_AES_TAGLEN,
                                                 p_iv,
                                                 EE_AES_AEAD_IVLEN);
                        break;
 800cfb6:	e008      	b.n	800cfca <ee_aes+0x1b2>
                    default:
                        th_post();
 800cfb8:	f7ff fe9e 	bl	800ccf8 <th_post>
                        th_printf("e-aes%d_%s-[Invalid AES enum: %d]\r\n",
 800cfbc:	8e79      	ldrh	r1, [r7, #50]	@ 0x32
 800cfbe:	7bfb      	ldrb	r3, [r7, #15]
 800cfc0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800cfc2:	4843      	ldr	r0, [pc, #268]	@ (800d0d0 <ee_aes+0x2b8>)
 800cfc4:	f7ff fed0 	bl	800cd68 <th_printf>
                                  bits,
                                  m,
                                  mode);
                        goto exit;
 800cfc8:	e10d      	b.n	800d1e6 <ee_aes+0x3ce>
            for (x = 0; x < count; ++x)
 800cfca:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800cfcc:	3301      	adds	r3, #1
 800cfce:	637b      	str	r3, [r7, #52]	@ 0x34
 800cfd0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800cfd2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800cfd4:	429a      	cmp	r2, r3
 800cfd6:	d381      	bcc.n	800cedc <ee_aes+0xc4>
                }
            }
            th_aes_deinit(p_context);
 800cfd8:	697b      	ldr	r3, [r7, #20]
 800cfda:	4618      	mov	r0, r3
 800cfdc:	f7ff fac4 	bl	800c568 <th_aes_deinit>
            if (ret != EE_STATUS_OK)
 800cfe0:	f897 303b 	ldrb.w	r3, [r7, #59]	@ 0x3b
 800cfe4:	2b00      	cmp	r3, #0
 800cfe6:	f040 80ea 	bne.w	800d1be <ee_aes+0x3a6>
        while (iter-- > 0)
 800cfea:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800cfec:	1e5a      	subs	r2, r3, #1
 800cfee:	65fa      	str	r2, [r7, #92]	@ 0x5c
 800cff0:	2b00      	cmp	r3, #0
 800cff2:	f47f af55 	bne.w	800cea0 <ee_aes+0x88>
            {
                goto err_enc_exit;
            }
        }
        th_post();
 800cff6:	f7ff fe7f 	bl	800ccf8 <th_post>
        t1 = th_timestamp();
 800cffa:	f7ff fea3 	bl	800cd44 <th_timestamp>
 800cffe:	63f8      	str	r0, [r7, #60]	@ 0x3c
        th_printf("m-aes%d_%s-encrypt-finish\r\n", bits, m);
 800d000:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 800d002:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800d004:	4619      	mov	r1, r3
 800d006:	4833      	ldr	r0, [pc, #204]	@ (800d0d4 <ee_aes+0x2bc>)
 800d008:	f7ff feae 	bl	800cd68 <th_printf>
        }
        th_post();
        t1 = th_timestamp();
        th_printf("m-aes%d_%s-decrypt-finish\r\n", bits, m);
    }
    goto exit;
 800d00c:	e0eb      	b.n	800d1e6 <ee_aes+0x3ce>
        th_printf("m-aes%d_%s-decrypt-start\r\n", bits, m);
 800d00e:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 800d010:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800d012:	4619      	mov	r1, r3
 800d014:	4830      	ldr	r0, [pc, #192]	@ (800d0d8 <ee_aes+0x2c0>)
 800d016:	f7ff fea7 	bl	800cd68 <th_printf>
        t0 = th_timestamp();
 800d01a:	f7ff fe93 	bl	800cd44 <th_timestamp>
 800d01e:	6438      	str	r0, [r7, #64]	@ 0x40
        th_pre();
 800d020:	f7ff fe63 	bl	800ccea <th_pre>
        while (iter-- > 0)
 800d024:	e0b9      	b.n	800d19a <ee_aes+0x382>
            ret = EE_STATUS_OK;
 800d026:	2300      	movs	r3, #0
 800d028:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
            if (th_aes_init(p_context, p_key, keylen, p_iv, func, mode)
 800d02c:	6978      	ldr	r0, [r7, #20]
 800d02e:	7bfb      	ldrb	r3, [r7, #15]
 800d030:	9301      	str	r3, [sp, #4]
 800d032:	7bbb      	ldrb	r3, [r7, #14]
 800d034:	9300      	str	r3, [sp, #0]
 800d036:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800d038:	687a      	ldr	r2, [r7, #4]
 800d03a:	68b9      	ldr	r1, [r7, #8]
 800d03c:	f7ff f9c8 	bl	800c3d0 <th_aes_init>
 800d040:	4603      	mov	r3, r0
 800d042:	2b00      	cmp	r3, #0
 800d044:	d008      	beq.n	800d058 <ee_aes+0x240>
                th_post();
 800d046:	f7ff fe57 	bl	800ccf8 <th_post>
                th_printf("e-aes%d_%s-[Failed to initialize]\r\n", bits, m);
 800d04a:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 800d04c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800d04e:	4619      	mov	r1, r3
 800d050:	481d      	ldr	r0, [pc, #116]	@ (800d0c8 <ee_aes+0x2b0>)
 800d052:	f7ff fe89 	bl	800cd68 <th_printf>
                goto exit;
 800d056:	e0c6      	b.n	800d1e6 <ee_aes+0x3ce>
            p32 = (uint32_t *)p_message_list;
 800d058:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800d05a:	647b      	str	r3, [r7, #68]	@ 0x44
            for (x = 0; x < count; ++x)
 800d05c:	2300      	movs	r3, #0
 800d05e:	637b      	str	r3, [r7, #52]	@ 0x34
 800d060:	e08e      	b.n	800d180 <ee_aes+0x368>
                len  = *p32++;
 800d062:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800d064:	1d1a      	adds	r2, r3, #4
 800d066:	647a      	str	r2, [r7, #68]	@ 0x44
 800d068:	681b      	ldr	r3, [r3, #0]
 800d06a:	62bb      	str	r3, [r7, #40]	@ 0x28
                p8   = (uint8_t *)p32;
 800d06c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800d06e:	627b      	str	r3, [r7, #36]	@ 0x24
                p_in = p8;
 800d070:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d072:	623b      	str	r3, [r7, #32]
                p8 += len;
 800d074:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800d076:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d078:	4413      	add	r3, r2
 800d07a:	627b      	str	r3, [r7, #36]	@ 0x24
                p_out = p8;
 800d07c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d07e:	61fb      	str	r3, [r7, #28]
                p8 += len;
 800d080:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800d082:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d084:	4413      	add	r3, r2
 800d086:	627b      	str	r3, [r7, #36]	@ 0x24
                p_tag = p8;
 800d088:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d08a:	61bb      	str	r3, [r7, #24]
                p8 += EE_AES_TAGLEN;
 800d08c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d08e:	3310      	adds	r3, #16
 800d090:	627b      	str	r3, [r7, #36]	@ 0x24
                p32 = (uint32_t *)p8;
 800d092:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d094:	647b      	str	r3, [r7, #68]	@ 0x44
                switch (mode)
 800d096:	7bfb      	ldrb	r3, [r7, #15]
 800d098:	2b03      	cmp	r3, #3
 800d09a:	d865      	bhi.n	800d168 <ee_aes+0x350>
 800d09c:	a201      	add	r2, pc, #4	@ (adr r2, 800d0a4 <ee_aes+0x28c>)
 800d09e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800d0a2:	bf00      	nop
 800d0a4:	0800d0dd 	.word	0x0800d0dd
 800d0a8:	0800d10d 	.word	0x0800d10d
 800d0ac:	0800d121 	.word	0x0800d121
 800d0b0:	0800d145 	.word	0x0800d145
 800d0b4:	20000000 	.word	0x20000000
 800d0b8:	080162e0 	.word	0x080162e0
 800d0bc:	08016308 	.word	0x08016308
 800d0c0:	08016320 	.word	0x08016320
 800d0c4:	08016338 	.word	0x08016338
 800d0c8:	08016354 	.word	0x08016354
 800d0cc:	08016378 	.word	0x08016378
 800d0d0:	08016394 	.word	0x08016394
 800d0d4:	080163b8 	.word	0x080163b8
 800d0d8:	080163d4 	.word	0x080163d4
                        if (len % EE_AES_BLOCKLEN != 0)
 800d0dc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d0de:	f003 030f 	and.w	r3, r3, #15
 800d0e2:	2b00      	cmp	r3, #0
 800d0e4:	d008      	beq.n	800d0f8 <ee_aes+0x2e0>
                            th_post();
 800d0e6:	f7ff fe07 	bl	800ccf8 <th_post>
                            th_printf("e-aes%d_%s-[non mod-16]\r\n", bits, m);
 800d0ea:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 800d0ec:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800d0ee:	4619      	mov	r1, r3
 800d0f0:	4842      	ldr	r0, [pc, #264]	@ (800d1fc <ee_aes+0x3e4>)
 800d0f2:	f7ff fe39 	bl	800cd68 <th_printf>
                            goto exit;
 800d0f6:	e076      	b.n	800d1e6 <ee_aes+0x3ce>
                        ret = th_aes_ecb_decrypt(p_context, p_in, len, p_out);
 800d0f8:	6978      	ldr	r0, [r7, #20]
 800d0fa:	69fb      	ldr	r3, [r7, #28]
 800d0fc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800d0fe:	6a39      	ldr	r1, [r7, #32]
 800d100:	f7ff faa6 	bl	800c650 <th_aes_ecb_decrypt>
 800d104:	4603      	mov	r3, r0
 800d106:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
                        break;
 800d10a:	e036      	b.n	800d17a <ee_aes+0x362>
                        ret = th_aes_ctr_decrypt(p_context, p_in, len, p_out);
 800d10c:	6978      	ldr	r0, [r7, #20]
 800d10e:	69fb      	ldr	r3, [r7, #28]
 800d110:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800d112:	6a39      	ldr	r1, [r7, #32]
 800d114:	f7ff fb10 	bl	800c738 <th_aes_ctr_decrypt>
 800d118:	4603      	mov	r3, r0
 800d11a:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
                        break;
 800d11e:	e02c      	b.n	800d17a <ee_aes+0x362>
                        ret = th_aes_ccm_decrypt(p_context,
 800d120:	6978      	ldr	r0, [r7, #20]
 800d122:	230c      	movs	r3, #12
 800d124:	9303      	str	r3, [sp, #12]
 800d126:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800d128:	9302      	str	r3, [sp, #8]
 800d12a:	2310      	movs	r3, #16
 800d12c:	9301      	str	r3, [sp, #4]
 800d12e:	69bb      	ldr	r3, [r7, #24]
 800d130:	9300      	str	r3, [sp, #0]
 800d132:	69fb      	ldr	r3, [r7, #28]
 800d134:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800d136:	6a39      	ldr	r1, [r7, #32]
 800d138:	f7ff fb74 	bl	800c824 <th_aes_ccm_decrypt>
 800d13c:	4603      	mov	r3, r0
 800d13e:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
                        break;
 800d142:	e01a      	b.n	800d17a <ee_aes+0x362>
                        ret = th_aes_gcm_decrypt(p_context,
 800d144:	6978      	ldr	r0, [r7, #20]
 800d146:	230c      	movs	r3, #12
 800d148:	9303      	str	r3, [sp, #12]
 800d14a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800d14c:	9302      	str	r3, [sp, #8]
 800d14e:	2310      	movs	r3, #16
 800d150:	9301      	str	r3, [sp, #4]
 800d152:	69bb      	ldr	r3, [r7, #24]
 800d154:	9300      	str	r3, [sp, #0]
 800d156:	69fb      	ldr	r3, [r7, #28]
 800d158:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800d15a:	6a39      	ldr	r1, [r7, #32]
 800d15c:	f7ff fbd8 	bl	800c910 <th_aes_gcm_decrypt>
 800d160:	4603      	mov	r3, r0
 800d162:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
                        break;
 800d166:	e008      	b.n	800d17a <ee_aes+0x362>
                        th_post();
 800d168:	f7ff fdc6 	bl	800ccf8 <th_post>
                        th_printf("e-aes%d_%s-[Invalid AES enum: %d]\r\n",
 800d16c:	8e79      	ldrh	r1, [r7, #50]	@ 0x32
 800d16e:	7bfb      	ldrb	r3, [r7, #15]
 800d170:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800d172:	4823      	ldr	r0, [pc, #140]	@ (800d200 <ee_aes+0x3e8>)
 800d174:	f7ff fdf8 	bl	800cd68 <th_printf>
                        goto exit;
 800d178:	e035      	b.n	800d1e6 <ee_aes+0x3ce>
            for (x = 0; x < count; ++x)
 800d17a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d17c:	3301      	adds	r3, #1
 800d17e:	637b      	str	r3, [r7, #52]	@ 0x34
 800d180:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800d182:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800d184:	429a      	cmp	r2, r3
 800d186:	f4ff af6c 	bcc.w	800d062 <ee_aes+0x24a>
            th_aes_deinit(p_context);
 800d18a:	697b      	ldr	r3, [r7, #20]
 800d18c:	4618      	mov	r0, r3
 800d18e:	f7ff f9eb 	bl	800c568 <th_aes_deinit>
            if (ret != EE_STATUS_OK)
 800d192:	f897 303b 	ldrb.w	r3, [r7, #59]	@ 0x3b
 800d196:	2b00      	cmp	r3, #0
 800d198:	d11b      	bne.n	800d1d2 <ee_aes+0x3ba>
        while (iter-- > 0)
 800d19a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800d19c:	1e5a      	subs	r2, r3, #1
 800d19e:	65fa      	str	r2, [r7, #92]	@ 0x5c
 800d1a0:	2b00      	cmp	r3, #0
 800d1a2:	f47f af40 	bne.w	800d026 <ee_aes+0x20e>
        th_post();
 800d1a6:	f7ff fda7 	bl	800ccf8 <th_post>
        t1 = th_timestamp();
 800d1aa:	f7ff fdcb 	bl	800cd44 <th_timestamp>
 800d1ae:	63f8      	str	r0, [r7, #60]	@ 0x3c
        th_printf("m-aes%d_%s-decrypt-finish\r\n", bits, m);
 800d1b0:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 800d1b2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800d1b4:	4619      	mov	r1, r3
 800d1b6:	4813      	ldr	r0, [pc, #76]	@ (800d204 <ee_aes+0x3ec>)
 800d1b8:	f7ff fdd6 	bl	800cd68 <th_printf>
    goto exit;
 800d1bc:	e013      	b.n	800d1e6 <ee_aes+0x3ce>
                goto err_enc_exit;
 800d1be:	bf00      	nop
err_enc_exit:
    th_post();
 800d1c0:	f7ff fd9a 	bl	800ccf8 <th_post>
    th_printf("e-aes%d_%s-[Failed to encrypt]\r\n", bits, m);
 800d1c4:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 800d1c6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800d1c8:	4619      	mov	r1, r3
 800d1ca:	480f      	ldr	r0, [pc, #60]	@ (800d208 <ee_aes+0x3f0>)
 800d1cc:	f7ff fdcc 	bl	800cd68 <th_printf>
    goto exit;
 800d1d0:	e009      	b.n	800d1e6 <ee_aes+0x3ce>
                goto err_dec_exit;
 800d1d2:	bf00      	nop
err_dec_exit:
    th_post();
 800d1d4:	f7ff fd90 	bl	800ccf8 <th_post>
    th_printf("e-aes%d_%s-[Failed to decrypt]\r\n", bits, m);
 800d1d8:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 800d1da:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800d1dc:	4619      	mov	r1, r3
 800d1de:	480b      	ldr	r0, [pc, #44]	@ (800d20c <ee_aes+0x3f4>)
 800d1e0:	f7ff fdc2 	bl	800cd68 <th_printf>
    goto exit;
 800d1e4:	bf00      	nop
exit:
    th_aes_destroy(p_context);
 800d1e6:	697b      	ldr	r3, [r7, #20]
 800d1e8:	4618      	mov	r0, r3
 800d1ea:	f7ff fbcb 	bl	800c984 <th_aes_destroy>
    return t1 - t0;
 800d1ee:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800d1f0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d1f2:	1ad3      	subs	r3, r2, r3
}
 800d1f4:	4618      	mov	r0, r3
 800d1f6:	3748      	adds	r7, #72	@ 0x48
 800d1f8:	46bd      	mov	sp, r7
 800d1fa:	bd80      	pop	{r7, pc}
 800d1fc:	08016378 	.word	0x08016378
 800d200:	08016394 	.word	0x08016394
 800d204:	080163f0 	.word	0x080163f0
 800d208:	0801640c 	.word	0x0801640c
 800d20c:	08016430 	.word	0x08016430

0800d210 <ee_chachapoly>:
              uint8_t             *p_key,
              uint8_t             *p_iv,
              uint32_t             count,
              void                *p_message_list,
              uint32_t             iter)
{
 800d210:	b580      	push	{r7, lr}
 800d212:	b092      	sub	sp, #72	@ 0x48
 800d214:	af04      	add	r7, sp, #16
 800d216:	60b9      	str	r1, [r7, #8]
 800d218:	607a      	str	r2, [r7, #4]
 800d21a:	603b      	str	r3, [r7, #0]
 800d21c:	4603      	mov	r3, r0
 800d21e:	73fb      	strb	r3, [r7, #15]
    uint8_t  *p_out;
    uint8_t  *p_tag;
    uint32_t *p32;
    uint8_t  *p8;
    uint32_t  len;
    uint32_t  t0 = 0;
 800d220:	2300      	movs	r3, #0
 800d222:	633b      	str	r3, [r7, #48]	@ 0x30
    uint32_t  t1 = 0;
 800d224:	2300      	movs	r3, #0
 800d226:	62fb      	str	r3, [r7, #44]	@ 0x2c
    uint32_t  x;

    if (th_chachapoly_create(&p_context) != EE_STATUS_OK)
 800d228:	f107 0310 	add.w	r3, r7, #16
 800d22c:	4618      	mov	r0, r3
 800d22e:	f7ff fbe5 	bl	800c9fc <th_chachapoly_create>
 800d232:	4603      	mov	r3, r0
 800d234:	2b00      	cmp	r3, #0
 800d236:	d004      	beq.n	800d242 <ee_chachapoly+0x32>
    {
        th_printf("e-chachapoly-[Failed to create context]\r\n");
 800d238:	4873      	ldr	r0, [pc, #460]	@ (800d408 <ee_chachapoly+0x1f8>)
 800d23a:	f7ff fd95 	bl	800cd68 <th_printf>
        return 0;
 800d23e:	2300      	movs	r3, #0
 800d240:	e0de      	b.n	800d400 <ee_chachapoly+0x1f0>
    }
    th_printf("m-chachapoly-iter[%d]\r\n", iter);
 800d242:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800d244:	4871      	ldr	r0, [pc, #452]	@ (800d40c <ee_chachapoly+0x1fc>)
 800d246:	f7ff fd8f 	bl	800cd68 <th_printf>
    th_printf("m-chachapoly-count[%d]\r\n", count);
 800d24a:	6839      	ldr	r1, [r7, #0]
 800d24c:	4870      	ldr	r0, [pc, #448]	@ (800d410 <ee_chachapoly+0x200>)
 800d24e:	f7ff fd8b 	bl	800cd68 <th_printf>
    if (func == EE_CHACHAPOLY_ENC)
 800d252:	7bfb      	ldrb	r3, [r7, #15]
 800d254:	2b00      	cmp	r3, #0
 800d256:	d166      	bne.n	800d326 <ee_chachapoly+0x116>
    {
        th_printf("m-chachapoly-encrypt-start\r\n");
 800d258:	486e      	ldr	r0, [pc, #440]	@ (800d414 <ee_chachapoly+0x204>)
 800d25a:	f7ff fd85 	bl	800cd68 <th_printf>
        t0 = th_timestamp();
 800d25e:	f7ff fd71 	bl	800cd44 <th_timestamp>
 800d262:	6338      	str	r0, [r7, #48]	@ 0x30
        th_pre();
 800d264:	f7ff fd41 	bl	800ccea <th_pre>
        while (iter-- > 0)
 800d268:	e04f      	b.n	800d30a <ee_chachapoly+0xfa>
        {
            if (th_chachapoly_init(p_context, p_key, EE_CHACHAPOLY_KEYLEN)
 800d26a:	693b      	ldr	r3, [r7, #16]
 800d26c:	2220      	movs	r2, #32
 800d26e:	68b9      	ldr	r1, [r7, #8]
 800d270:	4618      	mov	r0, r3
 800d272:	f7ff fbd3 	bl	800ca1c <th_chachapoly_init>
 800d276:	4603      	mov	r3, r0
 800d278:	2b00      	cmp	r3, #0
 800d27a:	d005      	beq.n	800d288 <ee_chachapoly+0x78>
                != EE_STATUS_OK)
            {
                th_post();
 800d27c:	f7ff fd3c 	bl	800ccf8 <th_post>
                th_printf("e-chachapoly-[Failed to initialize]\r\n");
 800d280:	4865      	ldr	r0, [pc, #404]	@ (800d418 <ee_chachapoly+0x208>)
 800d282:	f7ff fd71 	bl	800cd68 <th_printf>
                goto exit;
 800d286:	e0b4      	b.n	800d3f2 <ee_chachapoly+0x1e2>
            }
            /* Work through the list of messages for this context */
            p32 = (uint32_t *)p_message_list;
 800d288:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d28a:	637b      	str	r3, [r7, #52]	@ 0x34
            /* Perform multiple en/decrypts in the same context */
            for (x = 0; x < count; ++x)
 800d28c:	2300      	movs	r3, #0
 800d28e:	62bb      	str	r3, [r7, #40]	@ 0x28
 800d290:	e033      	b.n	800d2fa <ee_chachapoly+0xea>
            {
                /* Set up the data pointers */
                len  = *p32++;
 800d292:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d294:	1d1a      	adds	r2, r3, #4
 800d296:	637a      	str	r2, [r7, #52]	@ 0x34
 800d298:	681b      	ldr	r3, [r3, #0]
 800d29a:	627b      	str	r3, [r7, #36]	@ 0x24
                p8   = (uint8_t *)p32;
 800d29c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d29e:	623b      	str	r3, [r7, #32]
                p_in = p8;
 800d2a0:	6a3b      	ldr	r3, [r7, #32]
 800d2a2:	61fb      	str	r3, [r7, #28]
                p8 += len;
 800d2a4:	6a3a      	ldr	r2, [r7, #32]
 800d2a6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d2a8:	4413      	add	r3, r2
 800d2aa:	623b      	str	r3, [r7, #32]
                p_out = p8;
 800d2ac:	6a3b      	ldr	r3, [r7, #32]
 800d2ae:	61bb      	str	r3, [r7, #24]
                p8 += len;
 800d2b0:	6a3a      	ldr	r2, [r7, #32]
 800d2b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d2b4:	4413      	add	r3, r2
 800d2b6:	623b      	str	r3, [r7, #32]
                p_tag = p8;
 800d2b8:	6a3b      	ldr	r3, [r7, #32]
 800d2ba:	617b      	str	r3, [r7, #20]
                p8 += EE_CHACHAPOLY_TAGLEN;
 800d2bc:	6a3b      	ldr	r3, [r7, #32]
 800d2be:	3310      	adds	r3, #16
 800d2c0:	623b      	str	r3, [r7, #32]
                p32 = (uint32_t *)p8;
 800d2c2:	6a3b      	ldr	r3, [r7, #32]
 800d2c4:	637b      	str	r3, [r7, #52]	@ 0x34
                if (th_chachapoly_encrypt(p_context,
 800d2c6:	6938      	ldr	r0, [r7, #16]
 800d2c8:	230c      	movs	r3, #12
 800d2ca:	9303      	str	r3, [sp, #12]
 800d2cc:	687b      	ldr	r3, [r7, #4]
 800d2ce:	9302      	str	r3, [sp, #8]
 800d2d0:	2310      	movs	r3, #16
 800d2d2:	9301      	str	r3, [sp, #4]
 800d2d4:	697b      	ldr	r3, [r7, #20]
 800d2d6:	9300      	str	r3, [sp, #0]
 800d2d8:	69bb      	ldr	r3, [r7, #24]
 800d2da:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800d2dc:	69f9      	ldr	r1, [r7, #28]
 800d2de:	f7ff fbc8 	bl	800ca72 <th_chachapoly_encrypt>
 800d2e2:	4603      	mov	r3, r0
 800d2e4:	2b00      	cmp	r3, #0
 800d2e6:	d005      	beq.n	800d2f4 <ee_chachapoly+0xe4>
                                          EE_CHACHAPOLY_TAGLEN,
                                          p_iv,
                                          EE_CHACHAPOLY_IVLEN)
                    != EE_STATUS_OK)
                {
                    th_post();
 800d2e8:	f7ff fd06 	bl	800ccf8 <th_post>
                    th_printf("e-chachapoly-[Failed to encrypt]\r\n");
 800d2ec:	484b      	ldr	r0, [pc, #300]	@ (800d41c <ee_chachapoly+0x20c>)
 800d2ee:	f7ff fd3b 	bl	800cd68 <th_printf>
                    goto exit;
 800d2f2:	e07e      	b.n	800d3f2 <ee_chachapoly+0x1e2>
            for (x = 0; x < count; ++x)
 800d2f4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d2f6:	3301      	adds	r3, #1
 800d2f8:	62bb      	str	r3, [r7, #40]	@ 0x28
 800d2fa:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800d2fc:	683b      	ldr	r3, [r7, #0]
 800d2fe:	429a      	cmp	r2, r3
 800d300:	d3c7      	bcc.n	800d292 <ee_chachapoly+0x82>
                }
            }
            th_chachapoly_deinit(p_context);
 800d302:	693b      	ldr	r3, [r7, #16]
 800d304:	4618      	mov	r0, r3
 800d306:	f7ff fba9 	bl	800ca5c <th_chachapoly_deinit>
        while (iter-- > 0)
 800d30a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800d30c:	1e5a      	subs	r2, r3, #1
 800d30e:	647a      	str	r2, [r7, #68]	@ 0x44
 800d310:	2b00      	cmp	r3, #0
 800d312:	d1aa      	bne.n	800d26a <ee_chachapoly+0x5a>
        }
        th_post();
 800d314:	f7ff fcf0 	bl	800ccf8 <th_post>
        t1 = th_timestamp();
 800d318:	f7ff fd14 	bl	800cd44 <th_timestamp>
 800d31c:	62f8      	str	r0, [r7, #44]	@ 0x2c
        th_printf("m-chachapoly-encrypt-finish\r\n");
 800d31e:	4840      	ldr	r0, [pc, #256]	@ (800d420 <ee_chachapoly+0x210>)
 800d320:	f7ff fd22 	bl	800cd68 <th_printf>
 800d324:	e065      	b.n	800d3f2 <ee_chachapoly+0x1e2>
    }
    else
    {
        th_printf("m-chachapoly-decrypt-start\r\n");
 800d326:	483f      	ldr	r0, [pc, #252]	@ (800d424 <ee_chachapoly+0x214>)
 800d328:	f7ff fd1e 	bl	800cd68 <th_printf>
        t0 = th_timestamp();
 800d32c:	f7ff fd0a 	bl	800cd44 <th_timestamp>
 800d330:	6338      	str	r0, [r7, #48]	@ 0x30
        th_pre();
 800d332:	f7ff fcda 	bl	800ccea <th_pre>
        while (iter-- > 0)
 800d336:	e04f      	b.n	800d3d8 <ee_chachapoly+0x1c8>
        {
            if (th_chachapoly_init(p_context, p_key, EE_CHACHAPOLY_KEYLEN)
 800d338:	693b      	ldr	r3, [r7, #16]
 800d33a:	2220      	movs	r2, #32
 800d33c:	68b9      	ldr	r1, [r7, #8]
 800d33e:	4618      	mov	r0, r3
 800d340:	f7ff fb6c 	bl	800ca1c <th_chachapoly_init>
 800d344:	4603      	mov	r3, r0
 800d346:	2b00      	cmp	r3, #0
 800d348:	d005      	beq.n	800d356 <ee_chachapoly+0x146>
                != EE_STATUS_OK)
            {
                th_post();
 800d34a:	f7ff fcd5 	bl	800ccf8 <th_post>
                th_printf("e-chachapoly-[Failed to initialize]\r\n");
 800d34e:	4832      	ldr	r0, [pc, #200]	@ (800d418 <ee_chachapoly+0x208>)
 800d350:	f7ff fd0a 	bl	800cd68 <th_printf>
                goto exit;
 800d354:	e04d      	b.n	800d3f2 <ee_chachapoly+0x1e2>
            }
            /* Work through the list of messages for this context */
            p32 = (uint32_t *)p_message_list;
 800d356:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d358:	637b      	str	r3, [r7, #52]	@ 0x34
            /* Perform multiple en/decrypts in the same context */
            for (x = 0; x < count; ++x)
 800d35a:	2300      	movs	r3, #0
 800d35c:	62bb      	str	r3, [r7, #40]	@ 0x28
 800d35e:	e033      	b.n	800d3c8 <ee_chachapoly+0x1b8>
            {
                /* Set up the data pointers */
                len  = *p32++;
 800d360:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d362:	1d1a      	adds	r2, r3, #4
 800d364:	637a      	str	r2, [r7, #52]	@ 0x34
 800d366:	681b      	ldr	r3, [r3, #0]
 800d368:	627b      	str	r3, [r7, #36]	@ 0x24
                p8   = (uint8_t *)p32;
 800d36a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d36c:	623b      	str	r3, [r7, #32]
                p_in = p8;
 800d36e:	6a3b      	ldr	r3, [r7, #32]
 800d370:	61fb      	str	r3, [r7, #28]
                p8 += len;
 800d372:	6a3a      	ldr	r2, [r7, #32]
 800d374:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d376:	4413      	add	r3, r2
 800d378:	623b      	str	r3, [r7, #32]
                p_out = p8;
 800d37a:	6a3b      	ldr	r3, [r7, #32]
 800d37c:	61bb      	str	r3, [r7, #24]
                p8 += len;
 800d37e:	6a3a      	ldr	r2, [r7, #32]
 800d380:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d382:	4413      	add	r3, r2
 800d384:	623b      	str	r3, [r7, #32]
                p_tag = p8;
 800d386:	6a3b      	ldr	r3, [r7, #32]
 800d388:	617b      	str	r3, [r7, #20]
                p8 += EE_CHACHAPOLY_TAGLEN;
 800d38a:	6a3b      	ldr	r3, [r7, #32]
 800d38c:	3310      	adds	r3, #16
 800d38e:	623b      	str	r3, [r7, #32]
                p32 = (uint32_t *)p8;
 800d390:	6a3b      	ldr	r3, [r7, #32]
 800d392:	637b      	str	r3, [r7, #52]	@ 0x34
                if (th_chachapoly_decrypt(p_context,
 800d394:	6938      	ldr	r0, [r7, #16]
 800d396:	230c      	movs	r3, #12
 800d398:	9303      	str	r3, [sp, #12]
 800d39a:	687b      	ldr	r3, [r7, #4]
 800d39c:	9302      	str	r3, [sp, #8]
 800d39e:	2310      	movs	r3, #16
 800d3a0:	9301      	str	r3, [sp, #4]
 800d3a2:	697b      	ldr	r3, [r7, #20]
 800d3a4:	9300      	str	r3, [sp, #0]
 800d3a6:	69bb      	ldr	r3, [r7, #24]
 800d3a8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800d3aa:	69f9      	ldr	r1, [r7, #28]
 800d3ac:	f7ff fb80 	bl	800cab0 <th_chachapoly_decrypt>
 800d3b0:	4603      	mov	r3, r0
 800d3b2:	2b00      	cmp	r3, #0
 800d3b4:	d005      	beq.n	800d3c2 <ee_chachapoly+0x1b2>
                                          EE_CHACHAPOLY_TAGLEN,
                                          p_iv,
                                          EE_CHACHAPOLY_IVLEN)
                    != EE_STATUS_OK)
                {
                    th_post();
 800d3b6:	f7ff fc9f 	bl	800ccf8 <th_post>
                    th_printf("e-chachapoly-[Failed to decrypt]\r\n");
 800d3ba:	481b      	ldr	r0, [pc, #108]	@ (800d428 <ee_chachapoly+0x218>)
 800d3bc:	f7ff fcd4 	bl	800cd68 <th_printf>
                    goto exit;
 800d3c0:	e017      	b.n	800d3f2 <ee_chachapoly+0x1e2>
            for (x = 0; x < count; ++x)
 800d3c2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d3c4:	3301      	adds	r3, #1
 800d3c6:	62bb      	str	r3, [r7, #40]	@ 0x28
 800d3c8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800d3ca:	683b      	ldr	r3, [r7, #0]
 800d3cc:	429a      	cmp	r2, r3
 800d3ce:	d3c7      	bcc.n	800d360 <ee_chachapoly+0x150>
                }
            }
            th_chachapoly_deinit(p_context);
 800d3d0:	693b      	ldr	r3, [r7, #16]
 800d3d2:	4618      	mov	r0, r3
 800d3d4:	f7ff fb42 	bl	800ca5c <th_chachapoly_deinit>
        while (iter-- > 0)
 800d3d8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800d3da:	1e5a      	subs	r2, r3, #1
 800d3dc:	647a      	str	r2, [r7, #68]	@ 0x44
 800d3de:	2b00      	cmp	r3, #0
 800d3e0:	d1aa      	bne.n	800d338 <ee_chachapoly+0x128>
        }
        th_post();
 800d3e2:	f7ff fc89 	bl	800ccf8 <th_post>
        t1 = th_timestamp();
 800d3e6:	f7ff fcad 	bl	800cd44 <th_timestamp>
 800d3ea:	62f8      	str	r0, [r7, #44]	@ 0x2c
        th_printf("m-chachapoly-decrypt-finish\r\n");
 800d3ec:	480f      	ldr	r0, [pc, #60]	@ (800d42c <ee_chachapoly+0x21c>)
 800d3ee:	f7ff fcbb 	bl	800cd68 <th_printf>
    }
exit:
    th_chachapoly_destroy(p_context);
 800d3f2:	693b      	ldr	r3, [r7, #16]
 800d3f4:	4618      	mov	r0, r3
 800d3f6:	f7ff fb7a 	bl	800caee <th_chachapoly_destroy>
    return t1 - t0;
 800d3fa:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800d3fc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d3fe:	1ad3      	subs	r3, r2, r3
}
 800d400:	4618      	mov	r0, r3
 800d402:	3738      	adds	r7, #56	@ 0x38
 800d404:	46bd      	mov	sp, r7
 800d406:	bd80      	pop	{r7, pc}
 800d408:	08016454 	.word	0x08016454
 800d40c:	08016480 	.word	0x08016480
 800d410:	08016498 	.word	0x08016498
 800d414:	080164b4 	.word	0x080164b4
 800d418:	080164d4 	.word	0x080164d4
 800d41c:	080164fc 	.word	0x080164fc
 800d420:	08016520 	.word	0x08016520
 800d424:	08016540 	.word	0x08016540
 800d428:	08016560 	.word	0x08016560
 800d42c:	08016584 	.word	0x08016584

0800d430 <ee_sha>:

#include "ee_sha.h"

uint32_t
ee_sha(ee_sha_size_t size, uint32_t count, void *p_message_list, uint32_t iter)
{
 800d430:	b580      	push	{r7, lr}
 800d432:	b08c      	sub	sp, #48	@ 0x30
 800d434:	af00      	add	r7, sp, #0
 800d436:	60b9      	str	r1, [r7, #8]
 800d438:	607a      	str	r2, [r7, #4]
 800d43a:	603b      	str	r3, [r7, #0]
 800d43c:	4603      	mov	r3, r0
 800d43e:	81fb      	strh	r3, [r7, #14]
    void     *p_context; /* The generic context */
    uint32_t *p32;       /* Helper construction pointer */
    uint8_t  *p8;        /* Helper construction pointer */
    uint32_t  length;    /* Length of the input message */
    uint32_t  t0 = 0;    /* Start time */
 800d440:	2300      	movs	r3, #0
 800d442:	61fb      	str	r3, [r7, #28]
    uint32_t  t1 = 0;    /* Stop time */
 800d444:	2300      	movs	r3, #0
 800d446:	627b      	str	r3, [r7, #36]	@ 0x24
    uint32_t  i;         /* Generic loop index */

    if (th_sha_create(&p_context, size) != EE_STATUS_OK)
 800d448:	89fa      	ldrh	r2, [r7, #14]
 800d44a:	f107 0314 	add.w	r3, r7, #20
 800d44e:	4611      	mov	r1, r2
 800d450:	4618      	mov	r0, r3
 800d452:	f7ff fb5b 	bl	800cb0c <th_sha_create>
 800d456:	4603      	mov	r3, r0
 800d458:	2b00      	cmp	r3, #0
 800d45a:	d006      	beq.n	800d46a <ee_sha+0x3a>
    {
        th_printf("e-sha%d-[Failed to create context]\r\n", size);
 800d45c:	89fb      	ldrh	r3, [r7, #14]
 800d45e:	4619      	mov	r1, r3
 800d460:	483f      	ldr	r0, [pc, #252]	@ (800d560 <ee_sha+0x130>)
 800d462:	f7ff fc81 	bl	800cd68 <th_printf>
        return 0;
 800d466:	2300      	movs	r3, #0
 800d468:	e075      	b.n	800d556 <ee_sha+0x126>
    }
    th_printf("m-sha%d-iter[%d]\r\n", size, iter);
 800d46a:	89fb      	ldrh	r3, [r7, #14]
 800d46c:	683a      	ldr	r2, [r7, #0]
 800d46e:	4619      	mov	r1, r3
 800d470:	483c      	ldr	r0, [pc, #240]	@ (800d564 <ee_sha+0x134>)
 800d472:	f7ff fc79 	bl	800cd68 <th_printf>
    th_printf("m-sha%d-count[%d]\r\n", size, count);
 800d476:	89fb      	ldrh	r3, [r7, #14]
 800d478:	68ba      	ldr	r2, [r7, #8]
 800d47a:	4619      	mov	r1, r3
 800d47c:	483a      	ldr	r0, [pc, #232]	@ (800d568 <ee_sha+0x138>)
 800d47e:	f7ff fc73 	bl	800cd68 <th_printf>
    th_printf("m-sha%d-start\r\n", size);
 800d482:	89fb      	ldrh	r3, [r7, #14]
 800d484:	4619      	mov	r1, r3
 800d486:	4839      	ldr	r0, [pc, #228]	@ (800d56c <ee_sha+0x13c>)
 800d488:	f7ff fc6e 	bl	800cd68 <th_printf>
    t0 = th_timestamp();
 800d48c:	f7ff fc5a 	bl	800cd44 <th_timestamp>
 800d490:	61f8      	str	r0, [r7, #28]
    th_pre();
 800d492:	f7ff fc2a 	bl	800ccea <th_pre>
    while (iter-- > 0)
 800d496:	e048      	b.n	800d52a <ee_sha+0xfa>
    {
        if (th_sha_init(p_context) != EE_STATUS_OK)
 800d498:	697b      	ldr	r3, [r7, #20]
 800d49a:	4618      	mov	r0, r3
 800d49c:	f7ff fb64 	bl	800cb68 <th_sha_init>
 800d4a0:	4603      	mov	r3, r0
 800d4a2:	2b00      	cmp	r3, #0
 800d4a4:	d007      	beq.n	800d4b6 <ee_sha+0x86>
        {
            th_post();
 800d4a6:	f7ff fc27 	bl	800ccf8 <th_post>
            th_printf("e-sha%d-[Failed to initialize]\r\n", size);
 800d4aa:	89fb      	ldrh	r3, [r7, #14]
 800d4ac:	4619      	mov	r1, r3
 800d4ae:	4830      	ldr	r0, [pc, #192]	@ (800d570 <ee_sha+0x140>)
 800d4b0:	f7ff fc5a 	bl	800cd68 <th_printf>
            goto exit;
 800d4b4:	e048      	b.n	800d548 <ee_sha+0x118>
        }
        /* Work through the list of messages for this context */
        p32 = (uint32_t *)p_message_list;
 800d4b6:	687b      	ldr	r3, [r7, #4]
 800d4b8:	62fb      	str	r3, [r7, #44]	@ 0x2c
        for (i = 0; i < count; ++i)
 800d4ba:	2300      	movs	r3, #0
 800d4bc:	623b      	str	r3, [r7, #32]
 800d4be:	e020      	b.n	800d502 <ee_sha+0xd2>
        {
            length = *p32++;
 800d4c0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d4c2:	1d1a      	adds	r2, r3, #4
 800d4c4:	62fa      	str	r2, [r7, #44]	@ 0x2c
 800d4c6:	681b      	ldr	r3, [r3, #0]
 800d4c8:	61bb      	str	r3, [r7, #24]
            p8     = (uint8_t *)p32;
 800d4ca:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d4cc:	62bb      	str	r3, [r7, #40]	@ 0x28
            if (th_sha_process(p_context, p8, length) != EE_STATUS_OK)
 800d4ce:	697b      	ldr	r3, [r7, #20]
 800d4d0:	69ba      	ldr	r2, [r7, #24]
 800d4d2:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800d4d4:	4618      	mov	r0, r3
 800d4d6:	f7ff fb89 	bl	800cbec <th_sha_process>
 800d4da:	4603      	mov	r3, r0
 800d4dc:	2b00      	cmp	r3, #0
 800d4de:	d007      	beq.n	800d4f0 <ee_sha+0xc0>
            {
                th_post();
 800d4e0:	f7ff fc0a 	bl	800ccf8 <th_post>
                th_printf("e-sha%d-[Failed to process bytes]\r\n", size);
 800d4e4:	89fb      	ldrh	r3, [r7, #14]
 800d4e6:	4619      	mov	r1, r3
 800d4e8:	4822      	ldr	r0, [pc, #136]	@ (800d574 <ee_sha+0x144>)
 800d4ea:	f7ff fc3d 	bl	800cd68 <th_printf>
                goto exit;
 800d4ee:	e02b      	b.n	800d548 <ee_sha+0x118>
            }
            p8 += length;
 800d4f0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800d4f2:	69bb      	ldr	r3, [r7, #24]
 800d4f4:	4413      	add	r3, r2
 800d4f6:	62bb      	str	r3, [r7, #40]	@ 0x28
            p32 = (uint32_t *)p8;
 800d4f8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d4fa:	62fb      	str	r3, [r7, #44]	@ 0x2c
        for (i = 0; i < count; ++i)
 800d4fc:	6a3b      	ldr	r3, [r7, #32]
 800d4fe:	3301      	adds	r3, #1
 800d500:	623b      	str	r3, [r7, #32]
 800d502:	6a3a      	ldr	r2, [r7, #32]
 800d504:	68bb      	ldr	r3, [r7, #8]
 800d506:	429a      	cmp	r2, r3
 800d508:	d3da      	bcc.n	800d4c0 <ee_sha+0x90>
        }
        /* p8 now points to the end of the message list, and is the digest */
        if (th_sha_done(p_context, p8) != EE_STATUS_OK)
 800d50a:	697b      	ldr	r3, [r7, #20]
 800d50c:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800d50e:	4618      	mov	r0, r3
 800d510:	f7ff fba8 	bl	800cc64 <th_sha_done>
 800d514:	4603      	mov	r3, r0
 800d516:	2b00      	cmp	r3, #0
 800d518:	d007      	beq.n	800d52a <ee_sha+0xfa>
        {
            th_post();
 800d51a:	f7ff fbed 	bl	800ccf8 <th_post>
            th_printf("e-sha%d-[Failed to complete]\r\n", size);
 800d51e:	89fb      	ldrh	r3, [r7, #14]
 800d520:	4619      	mov	r1, r3
 800d522:	4815      	ldr	r0, [pc, #84]	@ (800d578 <ee_sha+0x148>)
 800d524:	f7ff fc20 	bl	800cd68 <th_printf>
            goto exit;
 800d528:	e00e      	b.n	800d548 <ee_sha+0x118>
    while (iter-- > 0)
 800d52a:	683b      	ldr	r3, [r7, #0]
 800d52c:	1e5a      	subs	r2, r3, #1
 800d52e:	603a      	str	r2, [r7, #0]
 800d530:	2b00      	cmp	r3, #0
 800d532:	d1b1      	bne.n	800d498 <ee_sha+0x68>
        }
    }
    th_post();
 800d534:	f7ff fbe0 	bl	800ccf8 <th_post>
    t1 = th_timestamp();
 800d538:	f7ff fc04 	bl	800cd44 <th_timestamp>
 800d53c:	6278      	str	r0, [r7, #36]	@ 0x24
    th_printf("m-sha%d-finish\r\n", size);
 800d53e:	89fb      	ldrh	r3, [r7, #14]
 800d540:	4619      	mov	r1, r3
 800d542:	480e      	ldr	r0, [pc, #56]	@ (800d57c <ee_sha+0x14c>)
 800d544:	f7ff fc10 	bl	800cd68 <th_printf>
exit:
    th_sha_destroy(p_context);
 800d548:	697b      	ldr	r3, [r7, #20]
 800d54a:	4618      	mov	r0, r3
 800d54c:	f7ff fbc2 	bl	800ccd4 <th_sha_destroy>
    return t1 - t0;
 800d550:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800d552:	69fb      	ldr	r3, [r7, #28]
 800d554:	1ad3      	subs	r3, r2, r3
}
 800d556:	4618      	mov	r0, r3
 800d558:	3730      	adds	r7, #48	@ 0x30
 800d55a:	46bd      	mov	sp, r7
 800d55c:	bd80      	pop	{r7, pc}
 800d55e:	bf00      	nop
 800d560:	080165a4 	.word	0x080165a4
 800d564:	080165cc 	.word	0x080165cc
 800d568:	080165e0 	.word	0x080165e0
 800d56c:	080165f4 	.word	0x080165f4
 800d570:	08016604 	.word	0x08016604
 800d574:	08016628 	.word	0x08016628
 800d578:	0801664c 	.word	0x0801664c
 800d57c:	0801666c 	.word	0x0801666c

0800d580 <MX_GPIO_Init>:

/** Configure pins
     PH0-OSC_IN(PH0)   ------> RCC_OSC_IN
*/
void MX_GPIO_Init(void)
{
 800d580:	b480      	push	{r7}
 800d582:	b083      	sub	sp, #12
 800d584:	af00      	add	r7, sp, #0

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800d586:	4b12      	ldr	r3, [pc, #72]	@ (800d5d0 <MX_GPIO_Init+0x50>)
 800d588:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800d58c:	4a10      	ldr	r2, [pc, #64]	@ (800d5d0 <MX_GPIO_Init+0x50>)
 800d58e:	f043 0301 	orr.w	r3, r3, #1
 800d592:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 800d596:	4b0e      	ldr	r3, [pc, #56]	@ (800d5d0 <MX_GPIO_Init+0x50>)
 800d598:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800d59c:	f003 0301 	and.w	r3, r3, #1
 800d5a0:	607b      	str	r3, [r7, #4]
 800d5a2:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 800d5a4:	4b0a      	ldr	r3, [pc, #40]	@ (800d5d0 <MX_GPIO_Init+0x50>)
 800d5a6:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800d5aa:	4a09      	ldr	r2, [pc, #36]	@ (800d5d0 <MX_GPIO_Init+0x50>)
 800d5ac:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800d5b0:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 800d5b4:	4b06      	ldr	r3, [pc, #24]	@ (800d5d0 <MX_GPIO_Init+0x50>)
 800d5b6:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800d5ba:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800d5be:	603b      	str	r3, [r7, #0]
 800d5c0:	683b      	ldr	r3, [r7, #0]

}
 800d5c2:	bf00      	nop
 800d5c4:	370c      	adds	r7, #12
 800d5c6:	46bd      	mov	sp, r7
 800d5c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d5cc:	4770      	bx	lr
 800d5ce:	bf00      	nop
 800d5d0:	44020c00 	.word	0x44020c00

0800d5d4 <MX_ICACHE_Init>:

/* USER CODE END 0 */

/* ICACHE init function */
void MX_ICACHE_Init(void)
{
 800d5d4:	b580      	push	{r7, lr}
 800d5d6:	af00      	add	r7, sp, #0

  /* USER CODE END ICACHE_Init 1 */

  /** Enable instruction cache (default 2-ways set associative cache)
  */
  if (HAL_ICACHE_Enable() != HAL_OK)
 800d5d8:	f000 fec6 	bl	800e368 <HAL_ICACHE_Enable>
 800d5dc:	4603      	mov	r3, r0
 800d5de:	2b00      	cmp	r3, #0
 800d5e0:	d001      	beq.n	800d5e6 <MX_ICACHE_Init+0x12>
  {
    Error_Handler();
 800d5e2:	f000 f8e1 	bl	800d7a8 <Error_Handler>
  }
  /* USER CODE BEGIN ICACHE_Init 2 */

  /* USER CODE END ICACHE_Init 2 */

}
 800d5e6:	bf00      	nop
 800d5e8:	bd80      	pop	{r7, pc}
	...

0800d5ec <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 800d5ec:	b580      	push	{r7, lr}
 800d5ee:	b094      	sub	sp, #80	@ 0x50
 800d5f0:	af04      	add	r7, sp, #16
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 800d5f2:	f000 fb39 	bl	800dc68 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 800d5f6:	f000 f853 	bl	800d6a0 <SystemClock_Config>

  /* USER CODE BEGIN SysInit */
  th_timestamp_initialize();
 800d5fa:	f7ff fb85 	bl	800cd08 <th_timestamp_initialize>
  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 800d5fe:	f7ff ffbf 	bl	800d580 <MX_GPIO_Init>
  MX_ICACHE_Init();
 800d602:	f7ff ffe7 	bl	800d5d4 <MX_ICACHE_Init>
  MX_USART1_UART_Init();
 800d606:	f000 f9af 	bl	800d968 <MX_USART1_UART_Init>
  /* USER CODE BEGIN 2 */
  uint32_t aes_time_sw = ee_aes(EE_AES_ECB, EE_AES_ENC, key, 16, iv, 1, message_list, 1);
 800d60a:	2301      	movs	r3, #1
 800d60c:	9303      	str	r3, [sp, #12]
 800d60e:	4b1e      	ldr	r3, [pc, #120]	@ (800d688 <main+0x9c>)
 800d610:	9302      	str	r3, [sp, #8]
 800d612:	2301      	movs	r3, #1
 800d614:	9301      	str	r3, [sp, #4]
 800d616:	4b1d      	ldr	r3, [pc, #116]	@ (800d68c <main+0xa0>)
 800d618:	9300      	str	r3, [sp, #0]
 800d61a:	2310      	movs	r3, #16
 800d61c:	4a1c      	ldr	r2, [pc, #112]	@ (800d690 <main+0xa4>)
 800d61e:	2100      	movs	r1, #0
 800d620:	2000      	movs	r0, #0
 800d622:	f7ff fbf9 	bl	800ce18 <ee_aes>
 800d626:	63f8      	str	r0, [r7, #60]	@ 0x3c
  printf("AES encryption SW took %lu microseconds\n", aes_time_sw);
 800d628:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 800d62a:	481a      	ldr	r0, [pc, #104]	@ (800d694 <main+0xa8>)
 800d62c:	f007 fe18 	bl	8015260 <iprintf>

  __attribute__((aligned(4))) uint8_t message_list[4 + 16 + 32] = {
 800d630:	2310      	movs	r3, #16
 800d632:	603b      	str	r3, [r7, #0]
 800d634:	1d3b      	adds	r3, r7, #4
 800d636:	2230      	movs	r2, #48	@ 0x30
 800d638:	2100      	movs	r1, #0
 800d63a:	4618      	mov	r0, r3
 800d63c:	f007 ff04 	bl	8015448 <memset>
      0x10, 0x00, 0x00, 0x00, // longueur = 16


  };

  uint32_t sha_time_sw = ee_sha(256,1,message_list,1);
 800d640:	463a      	mov	r2, r7
 800d642:	2301      	movs	r3, #1
 800d644:	2101      	movs	r1, #1
 800d646:	f44f 7080 	mov.w	r0, #256	@ 0x100
 800d64a:	f7ff fef1 	bl	800d430 <ee_sha>
 800d64e:	63b8      	str	r0, [r7, #56]	@ 0x38
  printf("SHA-256 SW execution time: %lu microseconds\n", sha_time_sw);
 800d650:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 800d652:	4811      	ldr	r0, [pc, #68]	@ (800d698 <main+0xac>)
 800d654:	f007 fe04 	bl	8015260 <iprintf>

  memset(message_list, 0, sizeof(message_list));
 800d658:	463b      	mov	r3, r7
 800d65a:	2234      	movs	r2, #52	@ 0x34
 800d65c:	2100      	movs	r1, #0
 800d65e:	4618      	mov	r0, r3
 800d660:	f007 fef2 	bl	8015448 <memset>

  uint32_t chacha_poly_time = ee_chachapoly(EE_CHACHAPOLY_ENC,key,iv,1,message_list,1);
 800d664:	2301      	movs	r3, #1
 800d666:	9301      	str	r3, [sp, #4]
 800d668:	463b      	mov	r3, r7
 800d66a:	9300      	str	r3, [sp, #0]
 800d66c:	2301      	movs	r3, #1
 800d66e:	4a07      	ldr	r2, [pc, #28]	@ (800d68c <main+0xa0>)
 800d670:	4907      	ldr	r1, [pc, #28]	@ (800d690 <main+0xa4>)
 800d672:	2000      	movs	r0, #0
 800d674:	f7ff fdcc 	bl	800d210 <ee_chachapoly>
 800d678:	6378      	str	r0, [r7, #52]	@ 0x34
  printf("CHACHA-POLY encryption execution time: %lu microseconds\n",chacha_poly_time);
 800d67a:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 800d67c:	4807      	ldr	r0, [pc, #28]	@ (800d69c <main+0xb0>)
 800d67e:	f007 fdef 	bl	8015260 <iprintf>
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */

  while (1)
 800d682:	bf00      	nop
 800d684:	e7fd      	b.n	800d682 <main+0x96>
 800d686:	bf00      	nop
 800d688:	200022e0 	.word	0x200022e0
 800d68c:	20000020 	.word	0x20000020
 800d690:	20000010 	.word	0x20000010
 800d694:	08016680 	.word	0x08016680
 800d698:	080166ac 	.word	0x080166ac
 800d69c:	080166dc 	.word	0x080166dc

0800d6a0 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 800d6a0:	b580      	push	{r7, lr}
 800d6a2:	b09c      	sub	sp, #112	@ 0x70
 800d6a4:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800d6a6:	f107 0320 	add.w	r3, r7, #32
 800d6aa:	2250      	movs	r2, #80	@ 0x50
 800d6ac:	2100      	movs	r1, #0
 800d6ae:	4618      	mov	r0, r3
 800d6b0:	f007 feca 	bl	8015448 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800d6b4:	f107 0308 	add.w	r3, r7, #8
 800d6b8:	2200      	movs	r2, #0
 800d6ba:	601a      	str	r2, [r3, #0]
 800d6bc:	605a      	str	r2, [r3, #4]
 800d6be:	609a      	str	r2, [r3, #8]
 800d6c0:	60da      	str	r2, [r3, #12]
 800d6c2:	611a      	str	r2, [r3, #16]
 800d6c4:	615a      	str	r2, [r3, #20]

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
 800d6c6:	4b2d      	ldr	r3, [pc, #180]	@ (800d77c <SystemClock_Config+0xdc>)
 800d6c8:	691b      	ldr	r3, [r3, #16]
 800d6ca:	4a2c      	ldr	r2, [pc, #176]	@ (800d77c <SystemClock_Config+0xdc>)
 800d6cc:	f043 0330 	orr.w	r3, r3, #48	@ 0x30
 800d6d0:	6113      	str	r3, [r2, #16]
 800d6d2:	4b2a      	ldr	r3, [pc, #168]	@ (800d77c <SystemClock_Config+0xdc>)
 800d6d4:	691b      	ldr	r3, [r3, #16]
 800d6d6:	f003 0330 	and.w	r3, r3, #48	@ 0x30
 800d6da:	607b      	str	r3, [r7, #4]
 800d6dc:	687b      	ldr	r3, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
 800d6de:	bf00      	nop
 800d6e0:	4b26      	ldr	r3, [pc, #152]	@ (800d77c <SystemClock_Config+0xdc>)
 800d6e2:	695b      	ldr	r3, [r3, #20]
 800d6e4:	f003 0308 	and.w	r3, r3, #8
 800d6e8:	2b08      	cmp	r3, #8
 800d6ea:	d1f9      	bne.n	800d6e0 <SystemClock_Config+0x40>

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_CSI;
 800d6ec:	2310      	movs	r3, #16
 800d6ee:	623b      	str	r3, [r7, #32]
  RCC_OscInitStruct.CSIState = RCC_CSI_ON;
 800d6f0:	f44f 7380 	mov.w	r3, #256	@ 0x100
 800d6f4:	63fb      	str	r3, [r7, #60]	@ 0x3c
  RCC_OscInitStruct.CSICalibrationValue = RCC_CSICALIBRATION_DEFAULT;
 800d6f6:	2320      	movs	r3, #32
 800d6f8:	643b      	str	r3, [r7, #64]	@ 0x40
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800d6fa:	2302      	movs	r3, #2
 800d6fc:	64bb      	str	r3, [r7, #72]	@ 0x48
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLL1_SOURCE_CSI;
 800d6fe:	2302      	movs	r3, #2
 800d700:	64fb      	str	r3, [r7, #76]	@ 0x4c
  RCC_OscInitStruct.PLL.PLLM = 1;
 800d702:	2301      	movs	r3, #1
 800d704:	653b      	str	r3, [r7, #80]	@ 0x50
  RCC_OscInitStruct.PLL.PLLN = 125;
 800d706:	237d      	movs	r3, #125	@ 0x7d
 800d708:	657b      	str	r3, [r7, #84]	@ 0x54
  RCC_OscInitStruct.PLL.PLLP = 2;
 800d70a:	2302      	movs	r3, #2
 800d70c:	65bb      	str	r3, [r7, #88]	@ 0x58
  RCC_OscInitStruct.PLL.PLLQ = 2;
 800d70e:	2302      	movs	r3, #2
 800d710:	65fb      	str	r3, [r7, #92]	@ 0x5c
  RCC_OscInitStruct.PLL.PLLR = 2;
 800d712:	2302      	movs	r3, #2
 800d714:	663b      	str	r3, [r7, #96]	@ 0x60
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1_VCIRANGE_2;
 800d716:	2308      	movs	r3, #8
 800d718:	667b      	str	r3, [r7, #100]	@ 0x64
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1_VCORANGE_WIDE;
 800d71a:	2300      	movs	r3, #0
 800d71c:	66bb      	str	r3, [r7, #104]	@ 0x68
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
 800d71e:	2300      	movs	r3, #0
 800d720:	66fb      	str	r3, [r7, #108]	@ 0x6c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800d722:	f107 0320 	add.w	r3, r7, #32
 800d726:	4618      	mov	r0, r3
 800d728:	f000 fe2e 	bl	800e388 <HAL_RCC_OscConfig>
 800d72c:	4603      	mov	r3, r0
 800d72e:	2b00      	cmp	r3, #0
 800d730:	d001      	beq.n	800d736 <SystemClock_Config+0x96>
  {
    Error_Handler();
 800d732:	f000 f839 	bl	800d7a8 <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800d736:	231f      	movs	r3, #31
 800d738:	60bb      	str	r3, [r7, #8]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_PCLK3;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800d73a:	2303      	movs	r3, #3
 800d73c:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800d73e:	2300      	movs	r3, #0
 800d740:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 800d742:	2300      	movs	r3, #0
 800d744:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 800d746:	2300      	movs	r3, #0
 800d748:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB3CLKDivider = RCC_HCLK_DIV1;
 800d74a:	2300      	movs	r3, #0
 800d74c:	61fb      	str	r3, [r7, #28]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 800d74e:	f107 0308 	add.w	r3, r7, #8
 800d752:	2105      	movs	r1, #5
 800d754:	4618      	mov	r0, r3
 800d756:	f001 fa4f 	bl	800ebf8 <HAL_RCC_ClockConfig>
 800d75a:	4603      	mov	r3, r0
 800d75c:	2b00      	cmp	r3, #0
 800d75e:	d001      	beq.n	800d764 <SystemClock_Config+0xc4>
  {
    Error_Handler();
 800d760:	f000 f822 	bl	800d7a8 <Error_Handler>
  }

  /** Configure the programming delay
  */
  __HAL_FLASH_SET_PROGRAM_DELAY(FLASH_PROGRAMMING_DELAY_2);
 800d764:	4b06      	ldr	r3, [pc, #24]	@ (800d780 <SystemClock_Config+0xe0>)
 800d766:	681b      	ldr	r3, [r3, #0]
 800d768:	f023 0330 	bic.w	r3, r3, #48	@ 0x30
 800d76c:	4a04      	ldr	r2, [pc, #16]	@ (800d780 <SystemClock_Config+0xe0>)
 800d76e:	f043 0320 	orr.w	r3, r3, #32
 800d772:	6013      	str	r3, [r2, #0]
}
 800d774:	bf00      	nop
 800d776:	3770      	adds	r7, #112	@ 0x70
 800d778:	46bd      	mov	sp, r7
 800d77a:	bd80      	pop	{r7, pc}
 800d77c:	44020800 	.word	0x44020800
 800d780:	40022000 	.word	0x40022000

0800d784 <__io_putchar>:

/* USER CODE BEGIN 4 */
PUTCHAR_PROTOTYPE{
 800d784:	b580      	push	{r7, lr}
 800d786:	b082      	sub	sp, #8
 800d788:	af00      	add	r7, sp, #0
 800d78a:	6078      	str	r0, [r7, #4]
 /* Place your implementation of fputc here */
 /* e.g. write a character to USART3 and Loop until the end of transmission */
 HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF);
 800d78c:	1d39      	adds	r1, r7, #4
 800d78e:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 800d792:	2201      	movs	r2, #1
 800d794:	4803      	ldr	r0, [pc, #12]	@ (800d7a4 <__io_putchar+0x20>)
 800d796:	f006 fe19 	bl	80143cc <HAL_UART_Transmit>

 return ch;
 800d79a:	687b      	ldr	r3, [r7, #4]
}
 800d79c:	4618      	mov	r0, r3
 800d79e:	3708      	adds	r7, #8
 800d7a0:	46bd      	mov	sp, r7
 800d7a2:	bd80      	pop	{r7, pc}
 800d7a4:	200022e8 	.word	0x200022e8

0800d7a8 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 800d7a8:	b480      	push	{r7}
 800d7aa:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d7ac:	b672      	cpsid	i
}
 800d7ae:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 800d7b0:	bf00      	nop
 800d7b2:	e7fd      	b.n	800d7b0 <Error_Handler+0x8>

0800d7b4 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800d7b4:	b480      	push	{r7}
 800d7b6:	af00      	add	r7, sp, #0
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800d7b8:	bf00      	nop
 800d7ba:	46bd      	mov	sp, r7
 800d7bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d7c0:	4770      	bx	lr

0800d7c2 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 800d7c2:	b480      	push	{r7}
 800d7c4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 800d7c6:	bf00      	nop
 800d7c8:	e7fd      	b.n	800d7c6 <NMI_Handler+0x4>

0800d7ca <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 800d7ca:	b480      	push	{r7}
 800d7cc:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800d7ce:	bf00      	nop
 800d7d0:	e7fd      	b.n	800d7ce <HardFault_Handler+0x4>

0800d7d2 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 800d7d2:	b480      	push	{r7}
 800d7d4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 800d7d6:	bf00      	nop
 800d7d8:	e7fd      	b.n	800d7d6 <MemManage_Handler+0x4>

0800d7da <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 800d7da:	b480      	push	{r7}
 800d7dc:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 800d7de:	bf00      	nop
 800d7e0:	e7fd      	b.n	800d7de <BusFault_Handler+0x4>

0800d7e2 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 800d7e2:	b480      	push	{r7}
 800d7e4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 800d7e6:	bf00      	nop
 800d7e8:	e7fd      	b.n	800d7e6 <UsageFault_Handler+0x4>

0800d7ea <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 800d7ea:	b480      	push	{r7}
 800d7ec:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 800d7ee:	bf00      	nop
 800d7f0:	46bd      	mov	sp, r7
 800d7f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d7f6:	4770      	bx	lr

0800d7f8 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 800d7f8:	b480      	push	{r7}
 800d7fa:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800d7fc:	bf00      	nop
 800d7fe:	46bd      	mov	sp, r7
 800d800:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d804:	4770      	bx	lr

0800d806 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 800d806:	b480      	push	{r7}
 800d808:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 800d80a:	bf00      	nop
 800d80c:	46bd      	mov	sp, r7
 800d80e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d812:	4770      	bx	lr

0800d814 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 800d814:	b580      	push	{r7, lr}
 800d816:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800d818:	f000 fac4 	bl	800dda4 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 800d81c:	bf00      	nop
 800d81e:	bd80      	pop	{r7, pc}

0800d820 <_read>:
  _kill(status, -1);
  while (1) {}    /* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 800d820:	b580      	push	{r7, lr}
 800d822:	b086      	sub	sp, #24
 800d824:	af00      	add	r7, sp, #0
 800d826:	60f8      	str	r0, [r7, #12]
 800d828:	60b9      	str	r1, [r7, #8]
 800d82a:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 800d82c:	2300      	movs	r3, #0
 800d82e:	617b      	str	r3, [r7, #20]
 800d830:	e00a      	b.n	800d848 <_read+0x28>
  {
    *ptr++ = __io_getchar();
 800d832:	f3af 8000 	nop.w
 800d836:	4601      	mov	r1, r0
 800d838:	68bb      	ldr	r3, [r7, #8]
 800d83a:	1c5a      	adds	r2, r3, #1
 800d83c:	60ba      	str	r2, [r7, #8]
 800d83e:	b2ca      	uxtb	r2, r1
 800d840:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 800d842:	697b      	ldr	r3, [r7, #20]
 800d844:	3301      	adds	r3, #1
 800d846:	617b      	str	r3, [r7, #20]
 800d848:	697a      	ldr	r2, [r7, #20]
 800d84a:	687b      	ldr	r3, [r7, #4]
 800d84c:	429a      	cmp	r2, r3
 800d84e:	dbf0      	blt.n	800d832 <_read+0x12>
  }

  return len;
 800d850:	687b      	ldr	r3, [r7, #4]
}
 800d852:	4618      	mov	r0, r3
 800d854:	3718      	adds	r7, #24
 800d856:	46bd      	mov	sp, r7
 800d858:	bd80      	pop	{r7, pc}

0800d85a <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 800d85a:	b580      	push	{r7, lr}
 800d85c:	b086      	sub	sp, #24
 800d85e:	af00      	add	r7, sp, #0
 800d860:	60f8      	str	r0, [r7, #12]
 800d862:	60b9      	str	r1, [r7, #8]
 800d864:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 800d866:	2300      	movs	r3, #0
 800d868:	617b      	str	r3, [r7, #20]
 800d86a:	e009      	b.n	800d880 <_write+0x26>
  {
    __io_putchar(*ptr++);
 800d86c:	68bb      	ldr	r3, [r7, #8]
 800d86e:	1c5a      	adds	r2, r3, #1
 800d870:	60ba      	str	r2, [r7, #8]
 800d872:	781b      	ldrb	r3, [r3, #0]
 800d874:	4618      	mov	r0, r3
 800d876:	f7ff ff85 	bl	800d784 <__io_putchar>
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 800d87a:	697b      	ldr	r3, [r7, #20]
 800d87c:	3301      	adds	r3, #1
 800d87e:	617b      	str	r3, [r7, #20]
 800d880:	697a      	ldr	r2, [r7, #20]
 800d882:	687b      	ldr	r3, [r7, #4]
 800d884:	429a      	cmp	r2, r3
 800d886:	dbf1      	blt.n	800d86c <_write+0x12>
  }
  return len;
 800d888:	687b      	ldr	r3, [r7, #4]
}
 800d88a:	4618      	mov	r0, r3
 800d88c:	3718      	adds	r7, #24
 800d88e:	46bd      	mov	sp, r7
 800d890:	bd80      	pop	{r7, pc}

0800d892 <_close>:

int _close(int file)
{
 800d892:	b480      	push	{r7}
 800d894:	b083      	sub	sp, #12
 800d896:	af00      	add	r7, sp, #0
 800d898:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
 800d89a:	f04f 33ff 	mov.w	r3, #4294967295
}
 800d89e:	4618      	mov	r0, r3
 800d8a0:	370c      	adds	r7, #12
 800d8a2:	46bd      	mov	sp, r7
 800d8a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d8a8:	4770      	bx	lr

0800d8aa <_fstat>:


int _fstat(int file, struct stat *st)
{
 800d8aa:	b480      	push	{r7}
 800d8ac:	b083      	sub	sp, #12
 800d8ae:	af00      	add	r7, sp, #0
 800d8b0:	6078      	str	r0, [r7, #4]
 800d8b2:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
 800d8b4:	683b      	ldr	r3, [r7, #0]
 800d8b6:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 800d8ba:	605a      	str	r2, [r3, #4]
  return 0;
 800d8bc:	2300      	movs	r3, #0
}
 800d8be:	4618      	mov	r0, r3
 800d8c0:	370c      	adds	r7, #12
 800d8c2:	46bd      	mov	sp, r7
 800d8c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d8c8:	4770      	bx	lr

0800d8ca <_isatty>:

int _isatty(int file)
{
 800d8ca:	b480      	push	{r7}
 800d8cc:	b083      	sub	sp, #12
 800d8ce:	af00      	add	r7, sp, #0
 800d8d0:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
 800d8d2:	2301      	movs	r3, #1
}
 800d8d4:	4618      	mov	r0, r3
 800d8d6:	370c      	adds	r7, #12
 800d8d8:	46bd      	mov	sp, r7
 800d8da:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d8de:	4770      	bx	lr

0800d8e0 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 800d8e0:	b480      	push	{r7}
 800d8e2:	b085      	sub	sp, #20
 800d8e4:	af00      	add	r7, sp, #0
 800d8e6:	60f8      	str	r0, [r7, #12]
 800d8e8:	60b9      	str	r1, [r7, #8]
 800d8ea:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
 800d8ec:	2300      	movs	r3, #0
}
 800d8ee:	4618      	mov	r0, r3
 800d8f0:	3714      	adds	r7, #20
 800d8f2:	46bd      	mov	sp, r7
 800d8f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d8f8:	4770      	bx	lr
	...

0800d8fc <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 800d8fc:	b580      	push	{r7, lr}
 800d8fe:	b086      	sub	sp, #24
 800d900:	af00      	add	r7, sp, #0
 800d902:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 800d904:	4a14      	ldr	r2, [pc, #80]	@ (800d958 <_sbrk+0x5c>)
 800d906:	4b15      	ldr	r3, [pc, #84]	@ (800d95c <_sbrk+0x60>)
 800d908:	1ad3      	subs	r3, r2, r3
 800d90a:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 800d90c:	697b      	ldr	r3, [r7, #20]
 800d90e:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 800d910:	4b13      	ldr	r3, [pc, #76]	@ (800d960 <_sbrk+0x64>)
 800d912:	681b      	ldr	r3, [r3, #0]
 800d914:	2b00      	cmp	r3, #0
 800d916:	d102      	bne.n	800d91e <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 800d918:	4b11      	ldr	r3, [pc, #68]	@ (800d960 <_sbrk+0x64>)
 800d91a:	4a12      	ldr	r2, [pc, #72]	@ (800d964 <_sbrk+0x68>)
 800d91c:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 800d91e:	4b10      	ldr	r3, [pc, #64]	@ (800d960 <_sbrk+0x64>)
 800d920:	681a      	ldr	r2, [r3, #0]
 800d922:	687b      	ldr	r3, [r7, #4]
 800d924:	4413      	add	r3, r2
 800d926:	693a      	ldr	r2, [r7, #16]
 800d928:	429a      	cmp	r2, r3
 800d92a:	d207      	bcs.n	800d93c <_sbrk+0x40>
  {
    errno = ENOMEM;
 800d92c:	f007 fdea 	bl	8015504 <__errno>
 800d930:	4603      	mov	r3, r0
 800d932:	220c      	movs	r2, #12
 800d934:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 800d936:	f04f 33ff 	mov.w	r3, #4294967295
 800d93a:	e009      	b.n	800d950 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 800d93c:	4b08      	ldr	r3, [pc, #32]	@ (800d960 <_sbrk+0x64>)
 800d93e:	681b      	ldr	r3, [r3, #0]
 800d940:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 800d942:	4b07      	ldr	r3, [pc, #28]	@ (800d960 <_sbrk+0x64>)
 800d944:	681a      	ldr	r2, [r3, #0]
 800d946:	687b      	ldr	r3, [r7, #4]
 800d948:	4413      	add	r3, r2
 800d94a:	4a05      	ldr	r2, [pc, #20]	@ (800d960 <_sbrk+0x64>)
 800d94c:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 800d94e:	68fb      	ldr	r3, [r7, #12]
}
 800d950:	4618      	mov	r0, r3
 800d952:	3718      	adds	r7, #24
 800d954:	46bd      	mov	sp, r7
 800d956:	bd80      	pop	{r7, pc}
 800d958:	200a0000 	.word	0x200a0000
 800d95c:	00000400 	.word	0x00000400
 800d960:	200022e4 	.word	0x200022e4
 800d964:	200024d0 	.word	0x200024d0

0800d968 <MX_USART1_UART_Init>:
UART_HandleTypeDef huart1;

/* USART1 init function */

void MX_USART1_UART_Init(void)
{
 800d968:	b580      	push	{r7, lr}
 800d96a:	af00      	add	r7, sp, #0
  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
 800d96c:	4b22      	ldr	r3, [pc, #136]	@ (800d9f8 <MX_USART1_UART_Init+0x90>)
 800d96e:	4a23      	ldr	r2, [pc, #140]	@ (800d9fc <MX_USART1_UART_Init+0x94>)
 800d970:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
 800d972:	4b21      	ldr	r3, [pc, #132]	@ (800d9f8 <MX_USART1_UART_Init+0x90>)
 800d974:	f44f 32e1 	mov.w	r2, #115200	@ 0x1c200
 800d978:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 800d97a:	4b1f      	ldr	r3, [pc, #124]	@ (800d9f8 <MX_USART1_UART_Init+0x90>)
 800d97c:	2200      	movs	r2, #0
 800d97e:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 800d980:	4b1d      	ldr	r3, [pc, #116]	@ (800d9f8 <MX_USART1_UART_Init+0x90>)
 800d982:	2200      	movs	r2, #0
 800d984:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 800d986:	4b1c      	ldr	r3, [pc, #112]	@ (800d9f8 <MX_USART1_UART_Init+0x90>)
 800d988:	2200      	movs	r2, #0
 800d98a:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 800d98c:	4b1a      	ldr	r3, [pc, #104]	@ (800d9f8 <MX_USART1_UART_Init+0x90>)
 800d98e:	220c      	movs	r2, #12
 800d990:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800d992:	4b19      	ldr	r3, [pc, #100]	@ (800d9f8 <MX_USART1_UART_Init+0x90>)
 800d994:	2200      	movs	r2, #0
 800d996:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 800d998:	4b17      	ldr	r3, [pc, #92]	@ (800d9f8 <MX_USART1_UART_Init+0x90>)
 800d99a:	2200      	movs	r2, #0
 800d99c:	61da      	str	r2, [r3, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800d99e:	4b16      	ldr	r3, [pc, #88]	@ (800d9f8 <MX_USART1_UART_Init+0x90>)
 800d9a0:	2200      	movs	r2, #0
 800d9a2:	621a      	str	r2, [r3, #32]
  huart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 800d9a4:	4b14      	ldr	r3, [pc, #80]	@ (800d9f8 <MX_USART1_UART_Init+0x90>)
 800d9a6:	2200      	movs	r2, #0
 800d9a8:	625a      	str	r2, [r3, #36]	@ 0x24
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800d9aa:	4b13      	ldr	r3, [pc, #76]	@ (800d9f8 <MX_USART1_UART_Init+0x90>)
 800d9ac:	2200      	movs	r2, #0
 800d9ae:	629a      	str	r2, [r3, #40]	@ 0x28
  if (HAL_UART_Init(&huart1) != HAL_OK)
 800d9b0:	4811      	ldr	r0, [pc, #68]	@ (800d9f8 <MX_USART1_UART_Init+0x90>)
 800d9b2:	f006 fcbb 	bl	801432c <HAL_UART_Init>
 800d9b6:	4603      	mov	r3, r0
 800d9b8:	2b00      	cmp	r3, #0
 800d9ba:	d001      	beq.n	800d9c0 <MX_USART1_UART_Init+0x58>
  {
    Error_Handler();
 800d9bc:	f7ff fef4 	bl	800d7a8 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 800d9c0:	2100      	movs	r1, #0
 800d9c2:	480d      	ldr	r0, [pc, #52]	@ (800d9f8 <MX_USART1_UART_Init+0x90>)
 800d9c4:	f007 f9e6 	bl	8014d94 <HAL_UARTEx_SetTxFifoThreshold>
 800d9c8:	4603      	mov	r3, r0
 800d9ca:	2b00      	cmp	r3, #0
 800d9cc:	d001      	beq.n	800d9d2 <MX_USART1_UART_Init+0x6a>
  {
    Error_Handler();
 800d9ce:	f7ff feeb 	bl	800d7a8 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 800d9d2:	2100      	movs	r1, #0
 800d9d4:	4808      	ldr	r0, [pc, #32]	@ (800d9f8 <MX_USART1_UART_Init+0x90>)
 800d9d6:	f007 fa1b 	bl	8014e10 <HAL_UARTEx_SetRxFifoThreshold>
 800d9da:	4603      	mov	r3, r0
 800d9dc:	2b00      	cmp	r3, #0
 800d9de:	d001      	beq.n	800d9e4 <MX_USART1_UART_Init+0x7c>
  {
    Error_Handler();
 800d9e0:	f7ff fee2 	bl	800d7a8 <Error_Handler>
  }
  if (HAL_UARTEx_DisableFifoMode(&huart1) != HAL_OK)
 800d9e4:	4804      	ldr	r0, [pc, #16]	@ (800d9f8 <MX_USART1_UART_Init+0x90>)
 800d9e6:	f007 f99c 	bl	8014d22 <HAL_UARTEx_DisableFifoMode>
 800d9ea:	4603      	mov	r3, r0
 800d9ec:	2b00      	cmp	r3, #0
 800d9ee:	d001      	beq.n	800d9f4 <MX_USART1_UART_Init+0x8c>
  {
    Error_Handler();
 800d9f0:	f7ff feda 	bl	800d7a8 <Error_Handler>
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}
 800d9f4:	bf00      	nop
 800d9f6:	bd80      	pop	{r7, pc}
 800d9f8:	200022e8 	.word	0x200022e8
 800d9fc:	40013800 	.word	0x40013800

0800da00 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 800da00:	b580      	push	{r7, lr}
 800da02:	b0cc      	sub	sp, #304	@ 0x130
 800da04:	af00      	add	r7, sp, #0
 800da06:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 800da0a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800da0e:	6018      	str	r0, [r3, #0]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800da10:	f507 738e 	add.w	r3, r7, #284	@ 0x11c
 800da14:	2200      	movs	r2, #0
 800da16:	601a      	str	r2, [r3, #0]
 800da18:	605a      	str	r2, [r3, #4]
 800da1a:	609a      	str	r2, [r3, #8]
 800da1c:	60da      	str	r2, [r3, #12]
 800da1e:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 800da20:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 800da24:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 800da28:	4618      	mov	r0, r3
 800da2a:	f44f 7384 	mov.w	r3, #264	@ 0x108
 800da2e:	461a      	mov	r2, r3
 800da30:	2100      	movs	r1, #0
 800da32:	f007 fd09 	bl	8015448 <memset>
  if(uartHandle->Instance==USART1)
 800da36:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 800da3a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800da3e:	681b      	ldr	r3, [r3, #0]
 800da40:	681b      	ldr	r3, [r3, #0]
 800da42:	4a33      	ldr	r2, [pc, #204]	@ (800db10 <HAL_UART_MspInit+0x110>)
 800da44:	4293      	cmp	r3, r2
 800da46:	d15d      	bne.n	800db04 <HAL_UART_MspInit+0x104>

  /* USER CODE END USART1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1;
 800da48:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 800da4c:	f5a3 7190 	sub.w	r1, r3, #288	@ 0x120
 800da50:	f04f 0201 	mov.w	r2, #1
 800da54:	f04f 0300 	mov.w	r3, #0
 800da58:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
 800da5c:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 800da60:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 800da64:	2200      	movs	r2, #0
 800da66:	65da      	str	r2, [r3, #92]	@ 0x5c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800da68:	f107 0310 	add.w	r3, r7, #16
 800da6c:	4618      	mov	r0, r3
 800da6e:	f001 fc05 	bl	800f27c <HAL_RCCEx_PeriphCLKConfig>
 800da72:	4603      	mov	r3, r0
 800da74:	2b00      	cmp	r3, #0
 800da76:	d001      	beq.n	800da7c <HAL_UART_MspInit+0x7c>
    {
      Error_Handler();
 800da78:	f7ff fe96 	bl	800d7a8 <Error_Handler>
    }

    /* USART1 clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 800da7c:	4b25      	ldr	r3, [pc, #148]	@ (800db14 <HAL_UART_MspInit+0x114>)
 800da7e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 800da82:	4a24      	ldr	r2, [pc, #144]	@ (800db14 <HAL_UART_MspInit+0x114>)
 800da84:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 800da88:	f8c2 30a4 	str.w	r3, [r2, #164]	@ 0xa4
 800da8c:	4b21      	ldr	r3, [pc, #132]	@ (800db14 <HAL_UART_MspInit+0x114>)
 800da8e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 800da92:	f403 4280 	and.w	r2, r3, #16384	@ 0x4000
 800da96:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 800da9a:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 800da9e:	601a      	str	r2, [r3, #0]
 800daa0:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 800daa4:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 800daa8:	681b      	ldr	r3, [r3, #0]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 800daaa:	4b1a      	ldr	r3, [pc, #104]	@ (800db14 <HAL_UART_MspInit+0x114>)
 800daac:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800dab0:	4a18      	ldr	r2, [pc, #96]	@ (800db14 <HAL_UART_MspInit+0x114>)
 800dab2:	f043 0301 	orr.w	r3, r3, #1
 800dab6:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 800daba:	4b16      	ldr	r3, [pc, #88]	@ (800db14 <HAL_UART_MspInit+0x114>)
 800dabc:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800dac0:	f003 0201 	and.w	r2, r3, #1
 800dac4:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 800dac8:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 800dacc:	601a      	str	r2, [r3, #0]
 800dace:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 800dad2:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 800dad6:	681b      	ldr	r3, [r3, #0]
    /**USART1 GPIO Configuration
    PA10     ------> USART1_RX
    PA9     ------> USART1_TX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_9;
 800dad8:	f44f 63c0 	mov.w	r3, #1536	@ 0x600
 800dadc:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800dae0:	2302      	movs	r3, #2
 800dae2:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800dae6:	2300      	movs	r3, #0
 800dae8:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800daec:	2300      	movs	r3, #0
 800daee:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 800daf2:	2307      	movs	r3, #7
 800daf4:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800daf8:	f507 738e 	add.w	r3, r7, #284	@ 0x11c
 800dafc:	4619      	mov	r1, r3
 800dafe:	4806      	ldr	r0, [pc, #24]	@ (800db18 <HAL_UART_MspInit+0x118>)
 800db00:	f000 fad4 	bl	800e0ac <HAL_GPIO_Init>

  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }
}
 800db04:	bf00      	nop
 800db06:	f507 7798 	add.w	r7, r7, #304	@ 0x130
 800db0a:	46bd      	mov	sp, r7
 800db0c:	bd80      	pop	{r7, pc}
 800db0e:	bf00      	nop
 800db10:	40013800 	.word	0x40013800
 800db14:	44020c00 	.word	0x44020c00
 800db18:	42020000 	.word	0x42020000

0800db1c <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 800db1c:	480d      	ldr	r0, [pc, #52]	@ (800db54 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 800db1e:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 800db20:	f000 f826 	bl	800db70 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 800db24:	480c      	ldr	r0, [pc, #48]	@ (800db58 <LoopForever+0x6>)
  ldr r1, =_edata
 800db26:	490d      	ldr	r1, [pc, #52]	@ (800db5c <LoopForever+0xa>)
  ldr r2, =_sidata
 800db28:	4a0d      	ldr	r2, [pc, #52]	@ (800db60 <LoopForever+0xe>)
  movs r3, #0
 800db2a:	2300      	movs	r3, #0
  b LoopCopyDataInit
 800db2c:	e002      	b.n	800db34 <LoopCopyDataInit>

0800db2e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800db2e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 800db30:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800db32:	3304      	adds	r3, #4

0800db34 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 800db34:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800db36:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800db38:	d3f9      	bcc.n	800db2e <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800db3a:	4a0a      	ldr	r2, [pc, #40]	@ (800db64 <LoopForever+0x12>)
  ldr r4, =_ebss
 800db3c:	4c0a      	ldr	r4, [pc, #40]	@ (800db68 <LoopForever+0x16>)
  movs r3, #0
 800db3e:	2300      	movs	r3, #0
  b LoopFillZerobss
 800db40:	e001      	b.n	800db46 <LoopFillZerobss>

0800db42 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800db42:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800db44:	3204      	adds	r2, #4

0800db46 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800db46:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800db48:	d3fb      	bcc.n	800db42 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 800db4a:	f007 fce1 	bl	8015510 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 800db4e:	f7ff fd4d 	bl	800d5ec <main>

0800db52 <LoopForever>:

LoopForever:
    b LoopForever
 800db52:	e7fe      	b.n	800db52 <LoopForever>
  ldr   r0, =_estack
 800db54:	200a0000 	.word	0x200a0000
  ldr r0, =_sdata
 800db58:	20000000 	.word	0x20000000
  ldr r1, =_edata
 800db5c:	20000098 	.word	0x20000098
  ldr r2, =_sidata
 800db60:	08017054 	.word	0x08017054
  ldr r2, =_sbss
 800db64:	20000098 	.word	0x20000098
  ldr r4, =_ebss
 800db68:	200024cc 	.word	0x200024cc

0800db6c <ADC1_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 800db6c:	e7fe      	b.n	800db6c <ADC1_IRQHandler>
	...

0800db70 <SystemInit>:
  * @param  None
  * @retval None
  */

void SystemInit(void)
{
 800db70:	b480      	push	{r7}
 800db72:	b083      	sub	sp, #12
 800db74:	af00      	add	r7, sp, #0
  uint32_t reg_opsr;

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
   SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 800db76:	4b35      	ldr	r3, [pc, #212]	@ (800dc4c <SystemInit+0xdc>)
 800db78:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800db7c:	4a33      	ldr	r2, [pc, #204]	@ (800dc4c <SystemInit+0xdc>)
 800db7e:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 800db82:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR = RCC_CR_HSION;
 800db86:	4b32      	ldr	r3, [pc, #200]	@ (800dc50 <SystemInit+0xe0>)
 800db88:	2201      	movs	r2, #1
 800db8a:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR1 = 0U;
 800db8c:	4b30      	ldr	r3, [pc, #192]	@ (800dc50 <SystemInit+0xe0>)
 800db8e:	2200      	movs	r2, #0
 800db90:	61da      	str	r2, [r3, #28]
  RCC->CFGR2 = 0U;
 800db92:	4b2f      	ldr	r3, [pc, #188]	@ (800dc50 <SystemInit+0xe0>)
 800db94:	2200      	movs	r2, #0
 800db96:	621a      	str	r2, [r3, #32]

  /* Reset HSEON, HSECSSON, HSEBYP, HSEEXT, HSIDIV, HSIKERON, CSION, CSIKERON, HSI48 and PLLxON bits */
#if defined(RCC_CR_PLL3ON)
  RCC->CR &= ~(RCC_CR_HSEON | RCC_CR_HSECSSON | RCC_CR_HSEBYP | RCC_CR_HSEEXT | RCC_CR_HSIDIV | RCC_CR_HSIKERON | \
 800db98:	4b2d      	ldr	r3, [pc, #180]	@ (800dc50 <SystemInit+0xe0>)
 800db9a:	681a      	ldr	r2, [r3, #0]
 800db9c:	492c      	ldr	r1, [pc, #176]	@ (800dc50 <SystemInit+0xe0>)
 800db9e:	4b2d      	ldr	r3, [pc, #180]	@ (800dc54 <SystemInit+0xe4>)
 800dba0:	4013      	ands	r3, r2
 800dba2:	600b      	str	r3, [r1, #0]
  RCC->CR &= ~(RCC_CR_HSEON | RCC_CR_HSECSSON | RCC_CR_HSEBYP | RCC_CR_HSEEXT | RCC_CR_HSIDIV | RCC_CR_HSIKERON | \
               RCC_CR_CSION | RCC_CR_CSIKERON |RCC_CR_HSI48ON | RCC_CR_PLL1ON | RCC_CR_PLL2ON);
#endif

  /* Reset PLLxCFGR register */
  RCC->PLL1CFGR = 0U;
 800dba4:	4b2a      	ldr	r3, [pc, #168]	@ (800dc50 <SystemInit+0xe0>)
 800dba6:	2200      	movs	r2, #0
 800dba8:	629a      	str	r2, [r3, #40]	@ 0x28
  RCC->PLL2CFGR = 0U;
 800dbaa:	4b29      	ldr	r3, [pc, #164]	@ (800dc50 <SystemInit+0xe0>)
 800dbac:	2200      	movs	r2, #0
 800dbae:	62da      	str	r2, [r3, #44]	@ 0x2c
#if defined(RCC_CR_PLL3ON)
  RCC->PLL3CFGR = 0U;
 800dbb0:	4b27      	ldr	r3, [pc, #156]	@ (800dc50 <SystemInit+0xe0>)
 800dbb2:	2200      	movs	r2, #0
 800dbb4:	631a      	str	r2, [r3, #48]	@ 0x30
#endif /* RCC_CR_PLL3ON */

  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x01010280U;
 800dbb6:	4b26      	ldr	r3, [pc, #152]	@ (800dc50 <SystemInit+0xe0>)
 800dbb8:	4a27      	ldr	r2, [pc, #156]	@ (800dc58 <SystemInit+0xe8>)
 800dbba:	635a      	str	r2, [r3, #52]	@ 0x34
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000U;
 800dbbc:	4b24      	ldr	r3, [pc, #144]	@ (800dc50 <SystemInit+0xe0>)
 800dbbe:	2200      	movs	r2, #0
 800dbc0:	639a      	str	r2, [r3, #56]	@ 0x38
  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x01010280U;
 800dbc2:	4b23      	ldr	r3, [pc, #140]	@ (800dc50 <SystemInit+0xe0>)
 800dbc4:	4a24      	ldr	r2, [pc, #144]	@ (800dc58 <SystemInit+0xe8>)
 800dbc6:	63da      	str	r2, [r3, #60]	@ 0x3c
  /* Reset PLL2FRACR register */
  RCC->PLL2FRACR = 0x00000000U;
 800dbc8:	4b21      	ldr	r3, [pc, #132]	@ (800dc50 <SystemInit+0xe0>)
 800dbca:	2200      	movs	r2, #0
 800dbcc:	641a      	str	r2, [r3, #64]	@ 0x40
#if defined(RCC_CR_PLL3ON)
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x01010280U;
 800dbce:	4b20      	ldr	r3, [pc, #128]	@ (800dc50 <SystemInit+0xe0>)
 800dbd0:	4a21      	ldr	r2, [pc, #132]	@ (800dc58 <SystemInit+0xe8>)
 800dbd2:	645a      	str	r2, [r3, #68]	@ 0x44
  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000U;
 800dbd4:	4b1e      	ldr	r3, [pc, #120]	@ (800dc50 <SystemInit+0xe0>)
 800dbd6:	2200      	movs	r2, #0
 800dbd8:	649a      	str	r2, [r3, #72]	@ 0x48
#endif /* RCC_CR_PLL3ON */

  /* Reset HSEBYP bit */
  RCC->CR &= ~(RCC_CR_HSEBYP);
 800dbda:	4b1d      	ldr	r3, [pc, #116]	@ (800dc50 <SystemInit+0xe0>)
 800dbdc:	681b      	ldr	r3, [r3, #0]
 800dbde:	4a1c      	ldr	r2, [pc, #112]	@ (800dc50 <SystemInit+0xe0>)
 800dbe0:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 800dbe4:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0U;
 800dbe6:	4b1a      	ldr	r3, [pc, #104]	@ (800dc50 <SystemInit+0xe0>)
 800dbe8:	2200      	movs	r2, #0
 800dbea:	651a      	str	r2, [r3, #80]	@ 0x50

  /* Configure the Vector Table location add offset address ------------------*/
  #ifdef VECT_TAB_SRAM
    SCB->VTOR = SRAM1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
  #else
    SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800dbec:	4b17      	ldr	r3, [pc, #92]	@ (800dc4c <SystemInit+0xdc>)
 800dbee:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
 800dbf2:	609a      	str	r2, [r3, #8]
  #endif /* VECT_TAB_SRAM */

  /* Check OPSR register to verify if there is an ongoing swap or option bytes update interrupted by a reset */
  reg_opsr = FLASH->OPSR & FLASH_OPSR_CODE_OP;
 800dbf4:	4b19      	ldr	r3, [pc, #100]	@ (800dc5c <SystemInit+0xec>)
 800dbf6:	699b      	ldr	r3, [r3, #24]
 800dbf8:	f003 4360 	and.w	r3, r3, #3758096384	@ 0xe0000000
 800dbfc:	607b      	str	r3, [r7, #4]
  if ((reg_opsr == FLASH_OPSR_CODE_OP) || (reg_opsr == (FLASH_OPSR_CODE_OP_2 | FLASH_OPSR_CODE_OP_1)))
 800dbfe:	687b      	ldr	r3, [r7, #4]
 800dc00:	f1b3 4f60 	cmp.w	r3, #3758096384	@ 0xe0000000
 800dc04:	d003      	beq.n	800dc0e <SystemInit+0x9e>
 800dc06:	687b      	ldr	r3, [r7, #4]
 800dc08:	f1b3 4f40 	cmp.w	r3, #3221225472	@ 0xc0000000
 800dc0c:	d117      	bne.n	800dc3e <SystemInit+0xce>
  {
    /* Check FLASH Option Control Register access */
    if ((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != 0U)
 800dc0e:	4b13      	ldr	r3, [pc, #76]	@ (800dc5c <SystemInit+0xec>)
 800dc10:	69db      	ldr	r3, [r3, #28]
 800dc12:	f003 0301 	and.w	r3, r3, #1
 800dc16:	2b00      	cmp	r3, #0
 800dc18:	d005      	beq.n	800dc26 <SystemInit+0xb6>
    {
      /* Authorizes the Option Byte registers programming */
      FLASH->OPTKEYR = 0x08192A3BU;
 800dc1a:	4b10      	ldr	r3, [pc, #64]	@ (800dc5c <SystemInit+0xec>)
 800dc1c:	4a10      	ldr	r2, [pc, #64]	@ (800dc60 <SystemInit+0xf0>)
 800dc1e:	60da      	str	r2, [r3, #12]
      FLASH->OPTKEYR = 0x4C5D6E7FU;
 800dc20:	4b0e      	ldr	r3, [pc, #56]	@ (800dc5c <SystemInit+0xec>)
 800dc22:	4a10      	ldr	r2, [pc, #64]	@ (800dc64 <SystemInit+0xf4>)
 800dc24:	60da      	str	r2, [r3, #12]
    }
    /* Launch the option bytes change operation */
    FLASH->OPTCR |= FLASH_OPTCR_OPTSTART;
 800dc26:	4b0d      	ldr	r3, [pc, #52]	@ (800dc5c <SystemInit+0xec>)
 800dc28:	69db      	ldr	r3, [r3, #28]
 800dc2a:	4a0c      	ldr	r2, [pc, #48]	@ (800dc5c <SystemInit+0xec>)
 800dc2c:	f043 0302 	orr.w	r3, r3, #2
 800dc30:	61d3      	str	r3, [r2, #28]

    /* Lock the FLASH Option Control Register access */
    FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
 800dc32:	4b0a      	ldr	r3, [pc, #40]	@ (800dc5c <SystemInit+0xec>)
 800dc34:	69db      	ldr	r3, [r3, #28]
 800dc36:	4a09      	ldr	r2, [pc, #36]	@ (800dc5c <SystemInit+0xec>)
 800dc38:	f043 0301 	orr.w	r3, r3, #1
 800dc3c:	61d3      	str	r3, [r2, #28]
  }
}
 800dc3e:	bf00      	nop
 800dc40:	370c      	adds	r7, #12
 800dc42:	46bd      	mov	sp, r7
 800dc44:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dc48:	4770      	bx	lr
 800dc4a:	bf00      	nop
 800dc4c:	e000ed00 	.word	0xe000ed00
 800dc50:	44020c00 	.word	0x44020c00
 800dc54:	eae2eae3 	.word	0xeae2eae3
 800dc58:	01010280 	.word	0x01010280
 800dc5c:	40022000 	.word	0x40022000
 800dc60:	08192a3b 	.word	0x08192a3b
 800dc64:	4c5d6e7f 	.word	0x4c5d6e7f

0800dc68 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800dc68:	b580      	push	{r7, lr}
 800dc6a:	af00      	add	r7, sp, #0
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800dc6c:	2003      	movs	r0, #3
 800dc6e:	f000 f948 	bl	800df02 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
 800dc72:	f001 f979 	bl	800ef68 <HAL_RCC_GetSysClockFreq>
 800dc76:	4602      	mov	r2, r0
 800dc78:	4b0c      	ldr	r3, [pc, #48]	@ (800dcac <HAL_Init+0x44>)
 800dc7a:	6a1b      	ldr	r3, [r3, #32]
 800dc7c:	f003 030f 	and.w	r3, r3, #15
 800dc80:	490b      	ldr	r1, [pc, #44]	@ (800dcb0 <HAL_Init+0x48>)
 800dc82:	5ccb      	ldrb	r3, [r1, r3]
 800dc84:	fa22 f303 	lsr.w	r3, r2, r3
 800dc88:	4a0a      	ldr	r2, [pc, #40]	@ (800dcb4 <HAL_Init+0x4c>)
 800dc8a:	6013      	str	r3, [r2, #0]

  /* Select HCLK as SysTick clock source */
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 800dc8c:	2004      	movs	r0, #4
 800dc8e:	f000 f97f 	bl	800df90 <HAL_SYSTICK_CLKSourceConfig>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 800dc92:	200f      	movs	r0, #15
 800dc94:	f000 f810 	bl	800dcb8 <HAL_InitTick>
 800dc98:	4603      	mov	r3, r0
 800dc9a:	2b00      	cmp	r3, #0
 800dc9c:	d001      	beq.n	800dca2 <HAL_Init+0x3a>
  {
    return HAL_ERROR;
 800dc9e:	2301      	movs	r3, #1
 800dca0:	e002      	b.n	800dca8 <HAL_Init+0x40>
  }

  /* Init the low level hardware */
  HAL_MspInit();
 800dca2:	f7ff fd87 	bl	800d7b4 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 800dca6:	2300      	movs	r3, #0
}
 800dca8:	4618      	mov	r0, r3
 800dcaa:	bd80      	pop	{r7, pc}
 800dcac:	44020c00 	.word	0x44020c00
 800dcb0:	08016fd0 	.word	0x08016fd0
 800dcb4:	20000030 	.word	0x20000030

0800dcb8 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800dcb8:	b580      	push	{r7, lr}
 800dcba:	b084      	sub	sp, #16
 800dcbc:	af00      	add	r7, sp, #0
 800dcbe:	6078      	str	r0, [r7, #4]
  uint32_t ticknumber = 0U;
 800dcc0:	2300      	movs	r3, #0
 800dcc2:	60fb      	str	r3, [r7, #12]
  uint32_t systicksel;

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq == 0UL)
 800dcc4:	4b33      	ldr	r3, [pc, #204]	@ (800dd94 <HAL_InitTick+0xdc>)
 800dcc6:	781b      	ldrb	r3, [r3, #0]
 800dcc8:	2b00      	cmp	r3, #0
 800dcca:	d101      	bne.n	800dcd0 <HAL_InitTick+0x18>
  {
    return HAL_ERROR;
 800dccc:	2301      	movs	r3, #1
 800dcce:	e05c      	b.n	800dd8a <HAL_InitTick+0xd2>
  }

  /* Check Clock source to calculate the tickNumber */
  if (READ_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk) == SysTick_CTRL_CLKSOURCE_Msk)
 800dcd0:	4b31      	ldr	r3, [pc, #196]	@ (800dd98 <HAL_InitTick+0xe0>)
 800dcd2:	681b      	ldr	r3, [r3, #0]
 800dcd4:	f003 0304 	and.w	r3, r3, #4
 800dcd8:	2b04      	cmp	r3, #4
 800dcda:	d10c      	bne.n	800dcf6 <HAL_InitTick+0x3e>
  {
    /* HCLK selected as SysTick clock source */
    ticknumber = SystemCoreClock / (1000UL / (uint32_t)uwTickFreq);
 800dcdc:	4b2f      	ldr	r3, [pc, #188]	@ (800dd9c <HAL_InitTick+0xe4>)
 800dcde:	681a      	ldr	r2, [r3, #0]
 800dce0:	4b2c      	ldr	r3, [pc, #176]	@ (800dd94 <HAL_InitTick+0xdc>)
 800dce2:	781b      	ldrb	r3, [r3, #0]
 800dce4:	4619      	mov	r1, r3
 800dce6:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 800dcea:	fbb3 f3f1 	udiv	r3, r3, r1
 800dcee:	fbb2 f3f3 	udiv	r3, r2, r3
 800dcf2:	60fb      	str	r3, [r7, #12]
 800dcf4:	e037      	b.n	800dd66 <HAL_InitTick+0xae>
  }
  else
  {
    systicksel = HAL_SYSTICK_GetCLKSourceConfig();
 800dcf6:	f000 f9a3 	bl	800e040 <HAL_SYSTICK_GetCLKSourceConfig>
 800dcfa:	60b8      	str	r0, [r7, #8]
    switch (systicksel)
 800dcfc:	68bb      	ldr	r3, [r7, #8]
 800dcfe:	2b02      	cmp	r3, #2
 800dd00:	d023      	beq.n	800dd4a <HAL_InitTick+0x92>
 800dd02:	68bb      	ldr	r3, [r7, #8]
 800dd04:	2b02      	cmp	r3, #2
 800dd06:	d82d      	bhi.n	800dd64 <HAL_InitTick+0xac>
 800dd08:	68bb      	ldr	r3, [r7, #8]
 800dd0a:	2b00      	cmp	r3, #0
 800dd0c:	d003      	beq.n	800dd16 <HAL_InitTick+0x5e>
 800dd0e:	68bb      	ldr	r3, [r7, #8]
 800dd10:	2b01      	cmp	r3, #1
 800dd12:	d00d      	beq.n	800dd30 <HAL_InitTick+0x78>
        /* Calculate tick value */
        ticknumber = (LSE_VALUE / (1000UL / (uint32_t)uwTickFreq));
        break;
      default:
        /* Nothing to do */
        break;
 800dd14:	e026      	b.n	800dd64 <HAL_InitTick+0xac>
        ticknumber = (SystemCoreClock / (8000UL / (uint32_t)uwTickFreq));
 800dd16:	4b21      	ldr	r3, [pc, #132]	@ (800dd9c <HAL_InitTick+0xe4>)
 800dd18:	681a      	ldr	r2, [r3, #0]
 800dd1a:	4b1e      	ldr	r3, [pc, #120]	@ (800dd94 <HAL_InitTick+0xdc>)
 800dd1c:	781b      	ldrb	r3, [r3, #0]
 800dd1e:	4619      	mov	r1, r3
 800dd20:	f44f 53fa 	mov.w	r3, #8000	@ 0x1f40
 800dd24:	fbb3 f3f1 	udiv	r3, r3, r1
 800dd28:	fbb2 f3f3 	udiv	r3, r2, r3
 800dd2c:	60fb      	str	r3, [r7, #12]
        break;
 800dd2e:	e01a      	b.n	800dd66 <HAL_InitTick+0xae>
        ticknumber = (LSI_VALUE / (1000UL / (uint32_t)uwTickFreq));
 800dd30:	4b18      	ldr	r3, [pc, #96]	@ (800dd94 <HAL_InitTick+0xdc>)
 800dd32:	781b      	ldrb	r3, [r3, #0]
 800dd34:	461a      	mov	r2, r3
 800dd36:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 800dd3a:	fbb3 f3f2 	udiv	r3, r3, r2
 800dd3e:	f44f 42fa 	mov.w	r2, #32000	@ 0x7d00
 800dd42:	fbb2 f3f3 	udiv	r3, r2, r3
 800dd46:	60fb      	str	r3, [r7, #12]
        break;
 800dd48:	e00d      	b.n	800dd66 <HAL_InitTick+0xae>
        ticknumber = (LSE_VALUE / (1000UL / (uint32_t)uwTickFreq));
 800dd4a:	4b12      	ldr	r3, [pc, #72]	@ (800dd94 <HAL_InitTick+0xdc>)
 800dd4c:	781b      	ldrb	r3, [r3, #0]
 800dd4e:	461a      	mov	r2, r3
 800dd50:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 800dd54:	fbb3 f3f2 	udiv	r3, r3, r2
 800dd58:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
 800dd5c:	fbb2 f3f3 	udiv	r3, r2, r3
 800dd60:	60fb      	str	r3, [r7, #12]
        break;
 800dd62:	e000      	b.n	800dd66 <HAL_InitTick+0xae>
        break;
 800dd64:	bf00      	nop
    }
  }

  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(ticknumber) > 0U)
 800dd66:	68f8      	ldr	r0, [r7, #12]
 800dd68:	f000 f8f0 	bl	800df4c <HAL_SYSTICK_Config>
 800dd6c:	4603      	mov	r3, r0
 800dd6e:	2b00      	cmp	r3, #0
 800dd70:	d001      	beq.n	800dd76 <HAL_InitTick+0xbe>
  {
    return HAL_ERROR;
 800dd72:	2301      	movs	r3, #1
 800dd74:	e009      	b.n	800dd8a <HAL_InitTick+0xd2>
  }

  /* Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800dd76:	2200      	movs	r2, #0
 800dd78:	6879      	ldr	r1, [r7, #4]
 800dd7a:	f04f 30ff 	mov.w	r0, #4294967295
 800dd7e:	f000 f8cb 	bl	800df18 <HAL_NVIC_SetPriority>
  uwTickPrio = TickPriority;
 800dd82:	4a07      	ldr	r2, [pc, #28]	@ (800dda0 <HAL_InitTick+0xe8>)
 800dd84:	687b      	ldr	r3, [r7, #4]
 800dd86:	6013      	str	r3, [r2, #0]

  /* Return function status */
  return HAL_OK;
 800dd88:	2300      	movs	r3, #0
}
 800dd8a:	4618      	mov	r0, r3
 800dd8c:	3710      	adds	r7, #16
 800dd8e:	46bd      	mov	sp, r7
 800dd90:	bd80      	pop	{r7, pc}
 800dd92:	bf00      	nop
 800dd94:	20000038 	.word	0x20000038
 800dd98:	e000e010 	.word	0xe000e010
 800dd9c:	20000030 	.word	0x20000030
 800dda0:	20000034 	.word	0x20000034

0800dda4 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 800dda4:	b480      	push	{r7}
 800dda6:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 800dda8:	4b06      	ldr	r3, [pc, #24]	@ (800ddc4 <HAL_IncTick+0x20>)
 800ddaa:	781b      	ldrb	r3, [r3, #0]
 800ddac:	461a      	mov	r2, r3
 800ddae:	4b06      	ldr	r3, [pc, #24]	@ (800ddc8 <HAL_IncTick+0x24>)
 800ddb0:	681b      	ldr	r3, [r3, #0]
 800ddb2:	4413      	add	r3, r2
 800ddb4:	4a04      	ldr	r2, [pc, #16]	@ (800ddc8 <HAL_IncTick+0x24>)
 800ddb6:	6013      	str	r3, [r2, #0]
}
 800ddb8:	bf00      	nop
 800ddba:	46bd      	mov	sp, r7
 800ddbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ddc0:	4770      	bx	lr
 800ddc2:	bf00      	nop
 800ddc4:	20000038 	.word	0x20000038
 800ddc8:	2000237c 	.word	0x2000237c

0800ddcc <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 800ddcc:	b480      	push	{r7}
 800ddce:	af00      	add	r7, sp, #0
  return uwTick;
 800ddd0:	4b03      	ldr	r3, [pc, #12]	@ (800dde0 <HAL_GetTick+0x14>)
 800ddd2:	681b      	ldr	r3, [r3, #0]
}
 800ddd4:	4618      	mov	r0, r3
 800ddd6:	46bd      	mov	sp, r7
 800ddd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dddc:	4770      	bx	lr
 800ddde:	bf00      	nop
 800dde0:	2000237c 	.word	0x2000237c

0800dde4 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800dde4:	b480      	push	{r7}
 800dde6:	b085      	sub	sp, #20
 800dde8:	af00      	add	r7, sp, #0
 800ddea:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800ddec:	687b      	ldr	r3, [r7, #4]
 800ddee:	f003 0307 	and.w	r3, r3, #7
 800ddf2:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800ddf4:	4b0c      	ldr	r3, [pc, #48]	@ (800de28 <__NVIC_SetPriorityGrouping+0x44>)
 800ddf6:	68db      	ldr	r3, [r3, #12]
 800ddf8:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800ddfa:	68ba      	ldr	r2, [r7, #8]
 800ddfc:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 800de00:	4013      	ands	r3, r2
 800de02:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800de04:	68fb      	ldr	r3, [r7, #12]
 800de06:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800de08:	68bb      	ldr	r3, [r7, #8]
 800de0a:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800de0c:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 800de10:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800de14:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 800de16:	4a04      	ldr	r2, [pc, #16]	@ (800de28 <__NVIC_SetPriorityGrouping+0x44>)
 800de18:	68bb      	ldr	r3, [r7, #8]
 800de1a:	60d3      	str	r3, [r2, #12]
}
 800de1c:	bf00      	nop
 800de1e:	3714      	adds	r7, #20
 800de20:	46bd      	mov	sp, r7
 800de22:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de26:	4770      	bx	lr
 800de28:	e000ed00 	.word	0xe000ed00

0800de2c <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 800de2c:	b480      	push	{r7}
 800de2e:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800de30:	4b04      	ldr	r3, [pc, #16]	@ (800de44 <__NVIC_GetPriorityGrouping+0x18>)
 800de32:	68db      	ldr	r3, [r3, #12]
 800de34:	0a1b      	lsrs	r3, r3, #8
 800de36:	f003 0307 	and.w	r3, r3, #7
}
 800de3a:	4618      	mov	r0, r3
 800de3c:	46bd      	mov	sp, r7
 800de3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de42:	4770      	bx	lr
 800de44:	e000ed00 	.word	0xe000ed00

0800de48 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800de48:	b480      	push	{r7}
 800de4a:	b083      	sub	sp, #12
 800de4c:	af00      	add	r7, sp, #0
 800de4e:	4603      	mov	r3, r0
 800de50:	6039      	str	r1, [r7, #0]
 800de52:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 800de54:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800de58:	2b00      	cmp	r3, #0
 800de5a:	db0a      	blt.n	800de72 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800de5c:	683b      	ldr	r3, [r7, #0]
 800de5e:	b2da      	uxtb	r2, r3
 800de60:	490c      	ldr	r1, [pc, #48]	@ (800de94 <__NVIC_SetPriority+0x4c>)
 800de62:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800de66:	0112      	lsls	r2, r2, #4
 800de68:	b2d2      	uxtb	r2, r2
 800de6a:	440b      	add	r3, r1
 800de6c:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 800de70:	e00a      	b.n	800de88 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800de72:	683b      	ldr	r3, [r7, #0]
 800de74:	b2da      	uxtb	r2, r3
 800de76:	4908      	ldr	r1, [pc, #32]	@ (800de98 <__NVIC_SetPriority+0x50>)
 800de78:	88fb      	ldrh	r3, [r7, #6]
 800de7a:	f003 030f 	and.w	r3, r3, #15
 800de7e:	3b04      	subs	r3, #4
 800de80:	0112      	lsls	r2, r2, #4
 800de82:	b2d2      	uxtb	r2, r2
 800de84:	440b      	add	r3, r1
 800de86:	761a      	strb	r2, [r3, #24]
}
 800de88:	bf00      	nop
 800de8a:	370c      	adds	r7, #12
 800de8c:	46bd      	mov	sp, r7
 800de8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de92:	4770      	bx	lr
 800de94:	e000e100 	.word	0xe000e100
 800de98:	e000ed00 	.word	0xe000ed00

0800de9c <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800de9c:	b480      	push	{r7}
 800de9e:	b089      	sub	sp, #36	@ 0x24
 800dea0:	af00      	add	r7, sp, #0
 800dea2:	60f8      	str	r0, [r7, #12]
 800dea4:	60b9      	str	r1, [r7, #8]
 800dea6:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800dea8:	68fb      	ldr	r3, [r7, #12]
 800deaa:	f003 0307 	and.w	r3, r3, #7
 800deae:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800deb0:	69fb      	ldr	r3, [r7, #28]
 800deb2:	f1c3 0307 	rsb	r3, r3, #7
 800deb6:	2b04      	cmp	r3, #4
 800deb8:	bf28      	it	cs
 800deba:	2304      	movcs	r3, #4
 800debc:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800debe:	69fb      	ldr	r3, [r7, #28]
 800dec0:	3304      	adds	r3, #4
 800dec2:	2b06      	cmp	r3, #6
 800dec4:	d902      	bls.n	800decc <NVIC_EncodePriority+0x30>
 800dec6:	69fb      	ldr	r3, [r7, #28]
 800dec8:	3b03      	subs	r3, #3
 800deca:	e000      	b.n	800dece <NVIC_EncodePriority+0x32>
 800decc:	2300      	movs	r3, #0
 800dece:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800ded0:	f04f 32ff 	mov.w	r2, #4294967295
 800ded4:	69bb      	ldr	r3, [r7, #24]
 800ded6:	fa02 f303 	lsl.w	r3, r2, r3
 800deda:	43da      	mvns	r2, r3
 800dedc:	68bb      	ldr	r3, [r7, #8]
 800dede:	401a      	ands	r2, r3
 800dee0:	697b      	ldr	r3, [r7, #20]
 800dee2:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800dee4:	f04f 31ff 	mov.w	r1, #4294967295
 800dee8:	697b      	ldr	r3, [r7, #20]
 800deea:	fa01 f303 	lsl.w	r3, r1, r3
 800deee:	43d9      	mvns	r1, r3
 800def0:	687b      	ldr	r3, [r7, #4]
 800def2:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800def4:	4313      	orrs	r3, r2
         );
}
 800def6:	4618      	mov	r0, r3
 800def8:	3724      	adds	r7, #36	@ 0x24
 800defa:	46bd      	mov	sp, r7
 800defc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800df00:	4770      	bx	lr

0800df02 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PRIORITYGROUP_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800df02:	b580      	push	{r7, lr}
 800df04:	b082      	sub	sp, #8
 800df06:	af00      	add	r7, sp, #0
 800df08:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 800df0a:	6878      	ldr	r0, [r7, #4]
 800df0c:	f7ff ff6a 	bl	800dde4 <__NVIC_SetPriorityGrouping>
}
 800df10:	bf00      	nop
 800df12:	3708      	adds	r7, #8
 800df14:	46bd      	mov	sp, r7
 800df16:	bd80      	pop	{r7, pc}

0800df18 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800df18:	b580      	push	{r7, lr}
 800df1a:	b086      	sub	sp, #24
 800df1c:	af00      	add	r7, sp, #0
 800df1e:	4603      	mov	r3, r0
 800df20:	60b9      	str	r1, [r7, #8]
 800df22:	607a      	str	r2, [r7, #4]
 800df24:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 800df26:	f7ff ff81 	bl	800de2c <__NVIC_GetPriorityGrouping>
 800df2a:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 800df2c:	687a      	ldr	r2, [r7, #4]
 800df2e:	68b9      	ldr	r1, [r7, #8]
 800df30:	6978      	ldr	r0, [r7, #20]
 800df32:	f7ff ffb3 	bl	800de9c <NVIC_EncodePriority>
 800df36:	4602      	mov	r2, r0
 800df38:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800df3c:	4611      	mov	r1, r2
 800df3e:	4618      	mov	r0, r3
 800df40:	f7ff ff82 	bl	800de48 <__NVIC_SetPriority>
}
 800df44:	bf00      	nop
 800df46:	3718      	adds	r7, #24
 800df48:	46bd      	mov	sp, r7
 800df4a:	bd80      	pop	{r7, pc}

0800df4c <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800df4c:	b480      	push	{r7}
 800df4e:	b083      	sub	sp, #12
 800df50:	af00      	add	r7, sp, #0
 800df52:	6078      	str	r0, [r7, #4]
  if ((TicksNumb - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800df54:	687b      	ldr	r3, [r7, #4]
 800df56:	3b01      	subs	r3, #1
 800df58:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 800df5c:	d301      	bcc.n	800df62 <HAL_SYSTICK_Config+0x16>
  {
    /* Reload value impossible */
    return (1UL);
 800df5e:	2301      	movs	r3, #1
 800df60:	e00d      	b.n	800df7e <HAL_SYSTICK_Config+0x32>
  }

  /* Set reload register */
  WRITE_REG(SysTick->LOAD, (uint32_t)(TicksNumb - 1UL));
 800df62:	4a0a      	ldr	r2, [pc, #40]	@ (800df8c <HAL_SYSTICK_Config+0x40>)
 800df64:	687b      	ldr	r3, [r7, #4]
 800df66:	3b01      	subs	r3, #1
 800df68:	6053      	str	r3, [r2, #4]

  /* Load the SysTick Counter Value */
  WRITE_REG(SysTick->VAL, 0UL);
 800df6a:	4b08      	ldr	r3, [pc, #32]	@ (800df8c <HAL_SYSTICK_Config+0x40>)
 800df6c:	2200      	movs	r2, #0
 800df6e:	609a      	str	r2, [r3, #8]

  /* Enable SysTick IRQ and SysTick Timer */
  SET_BIT(SysTick->CTRL, (SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk));
 800df70:	4b06      	ldr	r3, [pc, #24]	@ (800df8c <HAL_SYSTICK_Config+0x40>)
 800df72:	681b      	ldr	r3, [r3, #0]
 800df74:	4a05      	ldr	r2, [pc, #20]	@ (800df8c <HAL_SYSTICK_Config+0x40>)
 800df76:	f043 0303 	orr.w	r3, r3, #3
 800df7a:	6013      	str	r3, [r2, #0]

  /* Function successful */
  return (0UL);
 800df7c:	2300      	movs	r3, #0
}
 800df7e:	4618      	mov	r0, r3
 800df80:	370c      	adds	r7, #12
 800df82:	46bd      	mov	sp, r7
 800df84:	f85d 7b04 	ldr.w	r7, [sp], #4
 800df88:	4770      	bx	lr
 800df8a:	bf00      	nop
 800df8c:	e000e010 	.word	0xe000e010

0800df90 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 800df90:	b480      	push	{r7}
 800df92:	b083      	sub	sp, #12
 800df94:	af00      	add	r7, sp, #0
 800df96:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  switch (CLKSource)
 800df98:	687b      	ldr	r3, [r7, #4]
 800df9a:	2b04      	cmp	r3, #4
 800df9c:	d844      	bhi.n	800e028 <HAL_SYSTICK_CLKSourceConfig+0x98>
 800df9e:	a201      	add	r2, pc, #4	@ (adr r2, 800dfa4 <HAL_SYSTICK_CLKSourceConfig+0x14>)
 800dfa0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800dfa4:	0800dfc7 	.word	0x0800dfc7
 800dfa8:	0800dfe5 	.word	0x0800dfe5
 800dfac:	0800e007 	.word	0x0800e007
 800dfb0:	0800e029 	.word	0x0800e029
 800dfb4:	0800dfb9 	.word	0x0800dfb9
  {
    /* Select HCLK as Systick clock source */
    case SYSTICK_CLKSOURCE_HCLK:
      SET_BIT(SysTick->CTRL, SYSTICK_CLKSOURCE_HCLK);
 800dfb8:	4b1f      	ldr	r3, [pc, #124]	@ (800e038 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800dfba:	681b      	ldr	r3, [r3, #0]
 800dfbc:	4a1e      	ldr	r2, [pc, #120]	@ (800e038 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800dfbe:	f043 0304 	orr.w	r3, r3, #4
 800dfc2:	6013      	str	r3, [r2, #0]
      break;
 800dfc4:	e031      	b.n	800e02a <HAL_SYSTICK_CLKSourceConfig+0x9a>
    /* Select HCLK_DIV8 as Systick clock source */
    case SYSTICK_CLKSOURCE_HCLK_DIV8:
      CLEAR_BIT(SysTick->CTRL, SYSTICK_CLKSOURCE_HCLK);
 800dfc6:	4b1c      	ldr	r3, [pc, #112]	@ (800e038 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800dfc8:	681b      	ldr	r3, [r3, #0]
 800dfca:	4a1b      	ldr	r2, [pc, #108]	@ (800e038 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800dfcc:	f023 0304 	bic.w	r3, r3, #4
 800dfd0:	6013      	str	r3, [r2, #0]
      MODIFY_REG(RCC->CCIPR4, RCC_CCIPR4_SYSTICKSEL, (0x00000000U));
 800dfd2:	4b1a      	ldr	r3, [pc, #104]	@ (800e03c <HAL_SYSTICK_CLKSourceConfig+0xac>)
 800dfd4:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 800dfd8:	4a18      	ldr	r2, [pc, #96]	@ (800e03c <HAL_SYSTICK_CLKSourceConfig+0xac>)
 800dfda:	f023 030c 	bic.w	r3, r3, #12
 800dfde:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
      break;
 800dfe2:	e022      	b.n	800e02a <HAL_SYSTICK_CLKSourceConfig+0x9a>
    /* Select LSI as Systick clock source */
    case SYSTICK_CLKSOURCE_LSI:
      CLEAR_BIT(SysTick->CTRL, SYSTICK_CLKSOURCE_HCLK);
 800dfe4:	4b14      	ldr	r3, [pc, #80]	@ (800e038 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800dfe6:	681b      	ldr	r3, [r3, #0]
 800dfe8:	4a13      	ldr	r2, [pc, #76]	@ (800e038 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800dfea:	f023 0304 	bic.w	r3, r3, #4
 800dfee:	6013      	str	r3, [r2, #0]
      MODIFY_REG(RCC->CCIPR4, RCC_CCIPR4_SYSTICKSEL, RCC_CCIPR4_SYSTICKSEL_0);
 800dff0:	4b12      	ldr	r3, [pc, #72]	@ (800e03c <HAL_SYSTICK_CLKSourceConfig+0xac>)
 800dff2:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 800dff6:	f023 030c 	bic.w	r3, r3, #12
 800dffa:	4a10      	ldr	r2, [pc, #64]	@ (800e03c <HAL_SYSTICK_CLKSourceConfig+0xac>)
 800dffc:	f043 0304 	orr.w	r3, r3, #4
 800e000:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
      break;
 800e004:	e011      	b.n	800e02a <HAL_SYSTICK_CLKSourceConfig+0x9a>
    /* Select LSE as Systick clock source */
    case SYSTICK_CLKSOURCE_LSE:
      CLEAR_BIT(SysTick->CTRL, SYSTICK_CLKSOURCE_HCLK);
 800e006:	4b0c      	ldr	r3, [pc, #48]	@ (800e038 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800e008:	681b      	ldr	r3, [r3, #0]
 800e00a:	4a0b      	ldr	r2, [pc, #44]	@ (800e038 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800e00c:	f023 0304 	bic.w	r3, r3, #4
 800e010:	6013      	str	r3, [r2, #0]
      MODIFY_REG(RCC->CCIPR4, RCC_CCIPR4_SYSTICKSEL, RCC_CCIPR4_SYSTICKSEL_1);
 800e012:	4b0a      	ldr	r3, [pc, #40]	@ (800e03c <HAL_SYSTICK_CLKSourceConfig+0xac>)
 800e014:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 800e018:	f023 030c 	bic.w	r3, r3, #12
 800e01c:	4a07      	ldr	r2, [pc, #28]	@ (800e03c <HAL_SYSTICK_CLKSourceConfig+0xac>)
 800e01e:	f043 0308 	orr.w	r3, r3, #8
 800e022:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
      break;
 800e026:	e000      	b.n	800e02a <HAL_SYSTICK_CLKSourceConfig+0x9a>
    default:
      /* Nothing to do */
      break;
 800e028:	bf00      	nop
  }
}
 800e02a:	bf00      	nop
 800e02c:	370c      	adds	r7, #12
 800e02e:	46bd      	mov	sp, r7
 800e030:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e034:	4770      	bx	lr
 800e036:	bf00      	nop
 800e038:	e000e010 	.word	0xe000e010
 800e03c:	44020c00 	.word	0x44020c00

0800e040 <HAL_SYSTICK_GetCLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_LSE: LSE clock selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  */
uint32_t HAL_SYSTICK_GetCLKSourceConfig(void)
{
 800e040:	b480      	push	{r7}
 800e042:	b083      	sub	sp, #12
 800e044:	af00      	add	r7, sp, #0
  uint32_t systick_source;
  uint32_t systick_rcc_source;

  /* Read SysTick->CTRL register for internal or external clock source */
  if (READ_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk) != 0U)
 800e046:	4b17      	ldr	r3, [pc, #92]	@ (800e0a4 <HAL_SYSTICK_GetCLKSourceConfig+0x64>)
 800e048:	681b      	ldr	r3, [r3, #0]
 800e04a:	f003 0304 	and.w	r3, r3, #4
 800e04e:	2b00      	cmp	r3, #0
 800e050:	d002      	beq.n	800e058 <HAL_SYSTICK_GetCLKSourceConfig+0x18>
  {
    /* Internal clock source */
    systick_source = SYSTICK_CLKSOURCE_HCLK;
 800e052:	2304      	movs	r3, #4
 800e054:	607b      	str	r3, [r7, #4]
 800e056:	e01e      	b.n	800e096 <HAL_SYSTICK_GetCLKSourceConfig+0x56>
  }
  else
  {
    /* External clock source, check the selected one in RCC */
    systick_rcc_source = READ_BIT(RCC->CCIPR4, RCC_CCIPR4_SYSTICKSEL);
 800e058:	4b13      	ldr	r3, [pc, #76]	@ (800e0a8 <HAL_SYSTICK_GetCLKSourceConfig+0x68>)
 800e05a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 800e05e:	f003 030c 	and.w	r3, r3, #12
 800e062:	603b      	str	r3, [r7, #0]

    switch (systick_rcc_source)
 800e064:	683b      	ldr	r3, [r7, #0]
 800e066:	2b08      	cmp	r3, #8
 800e068:	d00f      	beq.n	800e08a <HAL_SYSTICK_GetCLKSourceConfig+0x4a>
 800e06a:	683b      	ldr	r3, [r7, #0]
 800e06c:	2b08      	cmp	r3, #8
 800e06e:	d80f      	bhi.n	800e090 <HAL_SYSTICK_GetCLKSourceConfig+0x50>
 800e070:	683b      	ldr	r3, [r7, #0]
 800e072:	2b00      	cmp	r3, #0
 800e074:	d003      	beq.n	800e07e <HAL_SYSTICK_GetCLKSourceConfig+0x3e>
 800e076:	683b      	ldr	r3, [r7, #0]
 800e078:	2b04      	cmp	r3, #4
 800e07a:	d003      	beq.n	800e084 <HAL_SYSTICK_GetCLKSourceConfig+0x44>
 800e07c:	e008      	b.n	800e090 <HAL_SYSTICK_GetCLKSourceConfig+0x50>
    {
      case (0x00000000U):
        systick_source = SYSTICK_CLKSOURCE_HCLK_DIV8;
 800e07e:	2300      	movs	r3, #0
 800e080:	607b      	str	r3, [r7, #4]
        break;
 800e082:	e008      	b.n	800e096 <HAL_SYSTICK_GetCLKSourceConfig+0x56>

      case (RCC_CCIPR4_SYSTICKSEL_0):
        systick_source = SYSTICK_CLKSOURCE_LSI;
 800e084:	2301      	movs	r3, #1
 800e086:	607b      	str	r3, [r7, #4]
        break;
 800e088:	e005      	b.n	800e096 <HAL_SYSTICK_GetCLKSourceConfig+0x56>

      case (RCC_CCIPR4_SYSTICKSEL_1):
        systick_source = SYSTICK_CLKSOURCE_LSE;
 800e08a:	2302      	movs	r3, #2
 800e08c:	607b      	str	r3, [r7, #4]
        break;
 800e08e:	e002      	b.n	800e096 <HAL_SYSTICK_GetCLKSourceConfig+0x56>

      default:
        systick_source = SYSTICK_CLKSOURCE_HCLK_DIV8;
 800e090:	2300      	movs	r3, #0
 800e092:	607b      	str	r3, [r7, #4]
        break;
 800e094:	bf00      	nop
    }
  }
  return systick_source;
 800e096:	687b      	ldr	r3, [r7, #4]
}
 800e098:	4618      	mov	r0, r3
 800e09a:	370c      	adds	r7, #12
 800e09c:	46bd      	mov	sp, r7
 800e09e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e0a2:	4770      	bx	lr
 800e0a4:	e000e010 	.word	0xe000e010
 800e0a8:	44020c00 	.word	0x44020c00

0800e0ac <HAL_GPIO_Init>:
  * @param  pGPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *pGPIO_Init)
{
 800e0ac:	b480      	push	{r7}
 800e0ae:	b087      	sub	sp, #28
 800e0b0:	af00      	add	r7, sp, #0
 800e0b2:	6078      	str	r0, [r7, #4]
 800e0b4:	6039      	str	r1, [r7, #0]
  uint32_t tmp;
  uint32_t iocurrent;
  uint32_t position = 0U;
 800e0b6:	2300      	movs	r3, #0
 800e0b8:	613b      	str	r3, [r7, #16]
  assert_param(IS_GPIO_PIN(pGPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(pGPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(pGPIO_Init->Pull));

  /* Configure the port pins */
  while (((pGPIO_Init->Pin) >> position) != 0U)
 800e0ba:	e142      	b.n	800e342 <HAL_GPIO_Init+0x296>
  {
    /* Get current io position */
    iocurrent = (pGPIO_Init->Pin) & (1UL << position);
 800e0bc:	683b      	ldr	r3, [r7, #0]
 800e0be:	681a      	ldr	r2, [r3, #0]
 800e0c0:	2101      	movs	r1, #1
 800e0c2:	693b      	ldr	r3, [r7, #16]
 800e0c4:	fa01 f303 	lsl.w	r3, r1, r3
 800e0c8:	4013      	ands	r3, r2
 800e0ca:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0U)
 800e0cc:	68fb      	ldr	r3, [r7, #12]
 800e0ce:	2b00      	cmp	r3, #0
 800e0d0:	f000 8134 	beq.w	800e33c <HAL_GPIO_Init+0x290>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if ((pGPIO_Init->Mode == GPIO_MODE_AF_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 800e0d4:	683b      	ldr	r3, [r7, #0]
 800e0d6:	685b      	ldr	r3, [r3, #4]
 800e0d8:	2b02      	cmp	r3, #2
 800e0da:	d003      	beq.n	800e0e4 <HAL_GPIO_Init+0x38>
 800e0dc:	683b      	ldr	r3, [r7, #0]
 800e0de:	685b      	ldr	r3, [r3, #4]
 800e0e0:	2b12      	cmp	r3, #18
 800e0e2:	d125      	bne.n	800e130 <HAL_GPIO_Init+0x84>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(pGPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        tmp = GPIOx->AFR[position >> 3U];
 800e0e4:	693b      	ldr	r3, [r7, #16]
 800e0e6:	08da      	lsrs	r2, r3, #3
 800e0e8:	687b      	ldr	r3, [r7, #4]
 800e0ea:	3208      	adds	r2, #8
 800e0ec:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800e0f0:	617b      	str	r3, [r7, #20]
        tmp &= ~(0x0FUL << ((position & 0x07U) * GPIO_AFRL_AFSEL1_Pos));
 800e0f2:	693b      	ldr	r3, [r7, #16]
 800e0f4:	f003 0307 	and.w	r3, r3, #7
 800e0f8:	009b      	lsls	r3, r3, #2
 800e0fa:	220f      	movs	r2, #15
 800e0fc:	fa02 f303 	lsl.w	r3, r2, r3
 800e100:	43db      	mvns	r3, r3
 800e102:	697a      	ldr	r2, [r7, #20]
 800e104:	4013      	ands	r3, r2
 800e106:	617b      	str	r3, [r7, #20]
        tmp |= ((pGPIO_Init->Alternate & 0x0FUL) << ((position & 0x07U) * GPIO_AFRL_AFSEL1_Pos));
 800e108:	683b      	ldr	r3, [r7, #0]
 800e10a:	691b      	ldr	r3, [r3, #16]
 800e10c:	f003 020f 	and.w	r2, r3, #15
 800e110:	693b      	ldr	r3, [r7, #16]
 800e112:	f003 0307 	and.w	r3, r3, #7
 800e116:	009b      	lsls	r3, r3, #2
 800e118:	fa02 f303 	lsl.w	r3, r2, r3
 800e11c:	697a      	ldr	r2, [r7, #20]
 800e11e:	4313      	orrs	r3, r2
 800e120:	617b      	str	r3, [r7, #20]
        GPIOx->AFR[position >> 3U] = tmp;
 800e122:	693b      	ldr	r3, [r7, #16]
 800e124:	08da      	lsrs	r2, r3, #3
 800e126:	687b      	ldr	r3, [r7, #4]
 800e128:	3208      	adds	r2, #8
 800e12a:	6979      	ldr	r1, [r7, #20]
 800e12c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      tmp = GPIOx->MODER;
 800e130:	687b      	ldr	r3, [r7, #4]
 800e132:	681b      	ldr	r3, [r3, #0]
 800e134:	617b      	str	r3, [r7, #20]
      tmp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
 800e136:	693b      	ldr	r3, [r7, #16]
 800e138:	005b      	lsls	r3, r3, #1
 800e13a:	2203      	movs	r2, #3
 800e13c:	fa02 f303 	lsl.w	r3, r2, r3
 800e140:	43db      	mvns	r3, r3
 800e142:	697a      	ldr	r2, [r7, #20]
 800e144:	4013      	ands	r3, r2
 800e146:	617b      	str	r3, [r7, #20]
      tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
 800e148:	683b      	ldr	r3, [r7, #0]
 800e14a:	685b      	ldr	r3, [r3, #4]
 800e14c:	f003 0203 	and.w	r2, r3, #3
 800e150:	693b      	ldr	r3, [r7, #16]
 800e152:	005b      	lsls	r3, r3, #1
 800e154:	fa02 f303 	lsl.w	r3, r2, r3
 800e158:	697a      	ldr	r2, [r7, #20]
 800e15a:	4313      	orrs	r3, r2
 800e15c:	617b      	str	r3, [r7, #20]
      GPIOx->MODER = tmp;
 800e15e:	687b      	ldr	r3, [r7, #4]
 800e160:	697a      	ldr	r2, [r7, #20]
 800e162:	601a      	str	r2, [r3, #0]

      /* In case of Output or Alternate function mode selection */
      if ((pGPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800e164:	683b      	ldr	r3, [r7, #0]
 800e166:	685b      	ldr	r3, [r3, #4]
 800e168:	2b01      	cmp	r3, #1
 800e16a:	d00b      	beq.n	800e184 <HAL_GPIO_Init+0xd8>
 800e16c:	683b      	ldr	r3, [r7, #0]
 800e16e:	685b      	ldr	r3, [r3, #4]
 800e170:	2b02      	cmp	r3, #2
 800e172:	d007      	beq.n	800e184 <HAL_GPIO_Init+0xd8>
          (pGPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 800e174:	683b      	ldr	r3, [r7, #0]
 800e176:	685b      	ldr	r3, [r3, #4]
      if ((pGPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800e178:	2b11      	cmp	r3, #17
 800e17a:	d003      	beq.n	800e184 <HAL_GPIO_Init+0xd8>
          (pGPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 800e17c:	683b      	ldr	r3, [r7, #0]
 800e17e:	685b      	ldr	r3, [r3, #4]
 800e180:	2b12      	cmp	r3, #18
 800e182:	d130      	bne.n	800e1e6 <HAL_GPIO_Init+0x13a>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(pGPIO_Init->Speed));

        /* Configure the IO Speed */
        tmp = GPIOx->OSPEEDR;
 800e184:	687b      	ldr	r3, [r7, #4]
 800e186:	689b      	ldr	r3, [r3, #8]
 800e188:	617b      	str	r3, [r7, #20]
        tmp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
 800e18a:	693b      	ldr	r3, [r7, #16]
 800e18c:	005b      	lsls	r3, r3, #1
 800e18e:	2203      	movs	r2, #3
 800e190:	fa02 f303 	lsl.w	r3, r2, r3
 800e194:	43db      	mvns	r3, r3
 800e196:	697a      	ldr	r2, [r7, #20]
 800e198:	4013      	ands	r3, r2
 800e19a:	617b      	str	r3, [r7, #20]
        tmp |= (pGPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
 800e19c:	683b      	ldr	r3, [r7, #0]
 800e19e:	68da      	ldr	r2, [r3, #12]
 800e1a0:	693b      	ldr	r3, [r7, #16]
 800e1a2:	005b      	lsls	r3, r3, #1
 800e1a4:	fa02 f303 	lsl.w	r3, r2, r3
 800e1a8:	697a      	ldr	r2, [r7, #20]
 800e1aa:	4313      	orrs	r3, r2
 800e1ac:	617b      	str	r3, [r7, #20]
        GPIOx->OSPEEDR = tmp;
 800e1ae:	687b      	ldr	r3, [r7, #4]
 800e1b0:	697a      	ldr	r2, [r7, #20]
 800e1b2:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        tmp = GPIOx->OTYPER;
 800e1b4:	687b      	ldr	r3, [r7, #4]
 800e1b6:	685b      	ldr	r3, [r3, #4]
 800e1b8:	617b      	str	r3, [r7, #20]
        tmp &= ~(GPIO_OTYPER_OT0 << position) ;
 800e1ba:	2201      	movs	r2, #1
 800e1bc:	693b      	ldr	r3, [r7, #16]
 800e1be:	fa02 f303 	lsl.w	r3, r2, r3
 800e1c2:	43db      	mvns	r3, r3
 800e1c4:	697a      	ldr	r2, [r7, #20]
 800e1c6:	4013      	ands	r3, r2
 800e1c8:	617b      	str	r3, [r7, #20]
        tmp |= (((pGPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 800e1ca:	683b      	ldr	r3, [r7, #0]
 800e1cc:	685b      	ldr	r3, [r3, #4]
 800e1ce:	091b      	lsrs	r3, r3, #4
 800e1d0:	f003 0201 	and.w	r2, r3, #1
 800e1d4:	693b      	ldr	r3, [r7, #16]
 800e1d6:	fa02 f303 	lsl.w	r3, r2, r3
 800e1da:	697a      	ldr	r2, [r7, #20]
 800e1dc:	4313      	orrs	r3, r2
 800e1de:	617b      	str	r3, [r7, #20]
        GPIOx->OTYPER = tmp;
 800e1e0:	687b      	ldr	r3, [r7, #4]
 800e1e2:	697a      	ldr	r2, [r7, #20]
 800e1e4:	605a      	str	r2, [r3, #4]
      }

      if (((pGPIO_Init->Mode & GPIO_MODE) != GPIO_MODE_ANALOG) ||
 800e1e6:	683b      	ldr	r3, [r7, #0]
 800e1e8:	685b      	ldr	r3, [r3, #4]
 800e1ea:	f003 0303 	and.w	r3, r3, #3
 800e1ee:	2b03      	cmp	r3, #3
 800e1f0:	d109      	bne.n	800e206 <HAL_GPIO_Init+0x15a>
          (((pGPIO_Init->Mode & GPIO_MODE) == GPIO_MODE_ANALOG) && (pGPIO_Init->Pull != GPIO_PULLUP)))
 800e1f2:	683b      	ldr	r3, [r7, #0]
 800e1f4:	685b      	ldr	r3, [r3, #4]
 800e1f6:	f003 0303 	and.w	r3, r3, #3
      if (((pGPIO_Init->Mode & GPIO_MODE) != GPIO_MODE_ANALOG) ||
 800e1fa:	2b03      	cmp	r3, #3
 800e1fc:	d11b      	bne.n	800e236 <HAL_GPIO_Init+0x18a>
          (((pGPIO_Init->Mode & GPIO_MODE) == GPIO_MODE_ANALOG) && (pGPIO_Init->Pull != GPIO_PULLUP)))
 800e1fe:	683b      	ldr	r3, [r7, #0]
 800e200:	689b      	ldr	r3, [r3, #8]
 800e202:	2b01      	cmp	r3, #1
 800e204:	d017      	beq.n	800e236 <HAL_GPIO_Init+0x18a>
      {
        /* Check the Pull parameters */
        assert_param(IS_GPIO_PULL(pGPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        tmp = GPIOx->PUPDR;
 800e206:	687b      	ldr	r3, [r7, #4]
 800e208:	68db      	ldr	r3, [r3, #12]
 800e20a:	617b      	str	r3, [r7, #20]
        tmp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
 800e20c:	693b      	ldr	r3, [r7, #16]
 800e20e:	005b      	lsls	r3, r3, #1
 800e210:	2203      	movs	r2, #3
 800e212:	fa02 f303 	lsl.w	r3, r2, r3
 800e216:	43db      	mvns	r3, r3
 800e218:	697a      	ldr	r2, [r7, #20]
 800e21a:	4013      	ands	r3, r2
 800e21c:	617b      	str	r3, [r7, #20]
        tmp |= ((pGPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
 800e21e:	683b      	ldr	r3, [r7, #0]
 800e220:	689a      	ldr	r2, [r3, #8]
 800e222:	693b      	ldr	r3, [r7, #16]
 800e224:	005b      	lsls	r3, r3, #1
 800e226:	fa02 f303 	lsl.w	r3, r2, r3
 800e22a:	697a      	ldr	r2, [r7, #20]
 800e22c:	4313      	orrs	r3, r2
 800e22e:	617b      	str	r3, [r7, #20]
        GPIOx->PUPDR = tmp;
 800e230:	687b      	ldr	r3, [r7, #4]
 800e232:	697a      	ldr	r2, [r7, #20]
 800e234:	60da      	str	r2, [r3, #12]
      }

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((pGPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800e236:	683b      	ldr	r3, [r7, #0]
 800e238:	685b      	ldr	r3, [r3, #4]
 800e23a:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 800e23e:	2b00      	cmp	r3, #0
 800e240:	d07c      	beq.n	800e33c <HAL_GPIO_Init+0x290>
      {
        tmp = EXTI->EXTICR[position >> 2U];
 800e242:	4a47      	ldr	r2, [pc, #284]	@ (800e360 <HAL_GPIO_Init+0x2b4>)
 800e244:	693b      	ldr	r3, [r7, #16]
 800e246:	089b      	lsrs	r3, r3, #2
 800e248:	3318      	adds	r3, #24
 800e24a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800e24e:	617b      	str	r3, [r7, #20]
        tmp &= ~((0x0FUL) << ((position & 0x03U) * EXTI_EXTICR1_EXTI1_Pos));
 800e250:	693b      	ldr	r3, [r7, #16]
 800e252:	f003 0303 	and.w	r3, r3, #3
 800e256:	00db      	lsls	r3, r3, #3
 800e258:	220f      	movs	r2, #15
 800e25a:	fa02 f303 	lsl.w	r3, r2, r3
 800e25e:	43db      	mvns	r3, r3
 800e260:	697a      	ldr	r2, [r7, #20]
 800e262:	4013      	ands	r3, r2
 800e264:	617b      	str	r3, [r7, #20]
        tmp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03U) * EXTI_EXTICR1_EXTI1_Pos));
 800e266:	687b      	ldr	r3, [r7, #4]
 800e268:	0a9a      	lsrs	r2, r3, #10
 800e26a:	4b3e      	ldr	r3, [pc, #248]	@ (800e364 <HAL_GPIO_Init+0x2b8>)
 800e26c:	4013      	ands	r3, r2
 800e26e:	693a      	ldr	r2, [r7, #16]
 800e270:	f002 0203 	and.w	r2, r2, #3
 800e274:	00d2      	lsls	r2, r2, #3
 800e276:	4093      	lsls	r3, r2
 800e278:	697a      	ldr	r2, [r7, #20]
 800e27a:	4313      	orrs	r3, r2
 800e27c:	617b      	str	r3, [r7, #20]
        EXTI->EXTICR[position >> 2U] = tmp;
 800e27e:	4938      	ldr	r1, [pc, #224]	@ (800e360 <HAL_GPIO_Init+0x2b4>)
 800e280:	693b      	ldr	r3, [r7, #16]
 800e282:	089b      	lsrs	r3, r3, #2
 800e284:	3318      	adds	r3, #24
 800e286:	697a      	ldr	r2, [r7, #20]
 800e288:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        tmp = EXTI->RTSR1;
 800e28c:	4b34      	ldr	r3, [pc, #208]	@ (800e360 <HAL_GPIO_Init+0x2b4>)
 800e28e:	681b      	ldr	r3, [r3, #0]
 800e290:	617b      	str	r3, [r7, #20]
        tmp &= ~((uint32_t)iocurrent);
 800e292:	68fb      	ldr	r3, [r7, #12]
 800e294:	43db      	mvns	r3, r3
 800e296:	697a      	ldr	r2, [r7, #20]
 800e298:	4013      	ands	r3, r2
 800e29a:	617b      	str	r3, [r7, #20]
        if ((pGPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800e29c:	683b      	ldr	r3, [r7, #0]
 800e29e:	685b      	ldr	r3, [r3, #4]
 800e2a0:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 800e2a4:	2b00      	cmp	r3, #0
 800e2a6:	d003      	beq.n	800e2b0 <HAL_GPIO_Init+0x204>
        {
          tmp |= iocurrent;
 800e2a8:	697a      	ldr	r2, [r7, #20]
 800e2aa:	68fb      	ldr	r3, [r7, #12]
 800e2ac:	4313      	orrs	r3, r2
 800e2ae:	617b      	str	r3, [r7, #20]
        }
        EXTI->RTSR1 = tmp;
 800e2b0:	4a2b      	ldr	r2, [pc, #172]	@ (800e360 <HAL_GPIO_Init+0x2b4>)
 800e2b2:	697b      	ldr	r3, [r7, #20]
 800e2b4:	6013      	str	r3, [r2, #0]

        tmp = EXTI->FTSR1;
 800e2b6:	4b2a      	ldr	r3, [pc, #168]	@ (800e360 <HAL_GPIO_Init+0x2b4>)
 800e2b8:	685b      	ldr	r3, [r3, #4]
 800e2ba:	617b      	str	r3, [r7, #20]
        tmp &= ~((uint32_t)iocurrent);
 800e2bc:	68fb      	ldr	r3, [r7, #12]
 800e2be:	43db      	mvns	r3, r3
 800e2c0:	697a      	ldr	r2, [r7, #20]
 800e2c2:	4013      	ands	r3, r2
 800e2c4:	617b      	str	r3, [r7, #20]
        if ((pGPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800e2c6:	683b      	ldr	r3, [r7, #0]
 800e2c8:	685b      	ldr	r3, [r3, #4]
 800e2ca:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 800e2ce:	2b00      	cmp	r3, #0
 800e2d0:	d003      	beq.n	800e2da <HAL_GPIO_Init+0x22e>
        {
          tmp |= iocurrent;
 800e2d2:	697a      	ldr	r2, [r7, #20]
 800e2d4:	68fb      	ldr	r3, [r7, #12]
 800e2d6:	4313      	orrs	r3, r2
 800e2d8:	617b      	str	r3, [r7, #20]
        }
        EXTI->FTSR1 = tmp;
 800e2da:	4a21      	ldr	r2, [pc, #132]	@ (800e360 <HAL_GPIO_Init+0x2b4>)
 800e2dc:	697b      	ldr	r3, [r7, #20]
 800e2de:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        tmp = EXTI->EMR1;
 800e2e0:	4b1f      	ldr	r3, [pc, #124]	@ (800e360 <HAL_GPIO_Init+0x2b4>)
 800e2e2:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800e2e6:	617b      	str	r3, [r7, #20]
        tmp &= ~((uint32_t)iocurrent);
 800e2e8:	68fb      	ldr	r3, [r7, #12]
 800e2ea:	43db      	mvns	r3, r3
 800e2ec:	697a      	ldr	r2, [r7, #20]
 800e2ee:	4013      	ands	r3, r2
 800e2f0:	617b      	str	r3, [r7, #20]
        if ((pGPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800e2f2:	683b      	ldr	r3, [r7, #0]
 800e2f4:	685b      	ldr	r3, [r3, #4]
 800e2f6:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800e2fa:	2b00      	cmp	r3, #0
 800e2fc:	d003      	beq.n	800e306 <HAL_GPIO_Init+0x25a>
        {
          tmp |= iocurrent;
 800e2fe:	697a      	ldr	r2, [r7, #20]
 800e300:	68fb      	ldr	r3, [r7, #12]
 800e302:	4313      	orrs	r3, r2
 800e304:	617b      	str	r3, [r7, #20]
        }
        EXTI->EMR1 = tmp;
 800e306:	4a16      	ldr	r2, [pc, #88]	@ (800e360 <HAL_GPIO_Init+0x2b4>)
 800e308:	697b      	ldr	r3, [r7, #20]
 800e30a:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        tmp = EXTI->IMR1;
 800e30e:	4b14      	ldr	r3, [pc, #80]	@ (800e360 <HAL_GPIO_Init+0x2b4>)
 800e310:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800e314:	617b      	str	r3, [r7, #20]
        tmp &= ~((uint32_t)iocurrent);
 800e316:	68fb      	ldr	r3, [r7, #12]
 800e318:	43db      	mvns	r3, r3
 800e31a:	697a      	ldr	r2, [r7, #20]
 800e31c:	4013      	ands	r3, r2
 800e31e:	617b      	str	r3, [r7, #20]
        if ((pGPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800e320:	683b      	ldr	r3, [r7, #0]
 800e322:	685b      	ldr	r3, [r3, #4]
 800e324:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800e328:	2b00      	cmp	r3, #0
 800e32a:	d003      	beq.n	800e334 <HAL_GPIO_Init+0x288>
        {
          tmp |= iocurrent;
 800e32c:	697a      	ldr	r2, [r7, #20]
 800e32e:	68fb      	ldr	r3, [r7, #12]
 800e330:	4313      	orrs	r3, r2
 800e332:	617b      	str	r3, [r7, #20]
        }
        EXTI->IMR1 = tmp;
 800e334:	4a0a      	ldr	r2, [pc, #40]	@ (800e360 <HAL_GPIO_Init+0x2b4>)
 800e336:	697b      	ldr	r3, [r7, #20]
 800e338:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
      }
    }

    position++;
 800e33c:	693b      	ldr	r3, [r7, #16]
 800e33e:	3301      	adds	r3, #1
 800e340:	613b      	str	r3, [r7, #16]
  while (((pGPIO_Init->Pin) >> position) != 0U)
 800e342:	683b      	ldr	r3, [r7, #0]
 800e344:	681a      	ldr	r2, [r3, #0]
 800e346:	693b      	ldr	r3, [r7, #16]
 800e348:	fa22 f303 	lsr.w	r3, r2, r3
 800e34c:	2b00      	cmp	r3, #0
 800e34e:	f47f aeb5 	bne.w	800e0bc <HAL_GPIO_Init+0x10>
  }
}
 800e352:	bf00      	nop
 800e354:	bf00      	nop
 800e356:	371c      	adds	r7, #28
 800e358:	46bd      	mov	sp, r7
 800e35a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e35e:	4770      	bx	lr
 800e360:	44022000 	.word	0x44022000
 800e364:	002f7f7f 	.word	0x002f7f7f

0800e368 <HAL_ICACHE_Enable>:
  *         cache operation. The Instruction Cache is bypassed until the
  *         cache operation completes.
  * @retval HAL status (HAL_OK)
  */
HAL_StatusTypeDef HAL_ICACHE_Enable(void)
{
 800e368:	b480      	push	{r7}
 800e36a:	af00      	add	r7, sp, #0
  SET_BIT(ICACHE->CR, ICACHE_CR_EN);
 800e36c:	4b05      	ldr	r3, [pc, #20]	@ (800e384 <HAL_ICACHE_Enable+0x1c>)
 800e36e:	681b      	ldr	r3, [r3, #0]
 800e370:	4a04      	ldr	r2, [pc, #16]	@ (800e384 <HAL_ICACHE_Enable+0x1c>)
 800e372:	f043 0301 	orr.w	r3, r3, #1
 800e376:	6013      	str	r3, [r2, #0]

  return HAL_OK;
 800e378:	2300      	movs	r3, #0
}
 800e37a:	4618      	mov	r0, r3
 800e37c:	46bd      	mov	sp, r7
 800e37e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e382:	4770      	bx	lr
 800e384:	40030400 	.word	0x40030400

0800e388 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(const RCC_OscInitTypeDef  *pOscInitStruct)
{
 800e388:	b580      	push	{r7, lr}
 800e38a:	b088      	sub	sp, #32
 800e38c:	af00      	add	r7, sp, #0
 800e38e:	6078      	str	r0, [r7, #4]
  uint32_t temp_pllckselr;
  uint32_t temp1_pllckcfg;
  uint32_t temp2_pllckcfg;

  /* Check Null pointer */
  if (pOscInitStruct == NULL)
 800e390:	687b      	ldr	r3, [r7, #4]
 800e392:	2b00      	cmp	r3, #0
 800e394:	d102      	bne.n	800e39c <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
 800e396:	2301      	movs	r3, #1
 800e398:	f000 bc28 	b.w	800ebec <HAL_RCC_OscConfig+0x864>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(pOscInitStruct->OscillatorType));
  temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800e39c:	4b94      	ldr	r3, [pc, #592]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e39e:	69db      	ldr	r3, [r3, #28]
 800e3a0:	f003 0318 	and.w	r3, r3, #24
 800e3a4:	61fb      	str	r3, [r7, #28]
  temp_pllckselr = __HAL_RCC_GET_PLL1_OSCSOURCE();
 800e3a6:	4b92      	ldr	r3, [pc, #584]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e3a8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800e3aa:	f003 0303 	and.w	r3, r3, #3
 800e3ae:	61bb      	str	r3, [r7, #24]

  /*----------------------------- CSI Configuration --------------------------*/
  if (((pOscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
 800e3b0:	687b      	ldr	r3, [r7, #4]
 800e3b2:	681b      	ldr	r3, [r3, #0]
 800e3b4:	f003 0310 	and.w	r3, r3, #16
 800e3b8:	2b00      	cmp	r3, #0
 800e3ba:	d05b      	beq.n	800e474 <HAL_RCC_OscConfig+0xec>
    /* Check the parameters */
    assert_param(IS_RCC_CSI(pOscInitStruct->CSIState));
    assert_param(IS_RCC_CSICALIBRATION_VALUE(pOscInitStruct->CSICalibrationValue));

    /* When the CSI is used as system clock it will not be disabled */
    if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_CSI) ||
 800e3bc:	69fb      	ldr	r3, [r7, #28]
 800e3be:	2b08      	cmp	r3, #8
 800e3c0:	d005      	beq.n	800e3ce <HAL_RCC_OscConfig+0x46>
 800e3c2:	69fb      	ldr	r3, [r7, #28]
 800e3c4:	2b18      	cmp	r3, #24
 800e3c6:	d114      	bne.n	800e3f2 <HAL_RCC_OscConfig+0x6a>
        ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_pllckselr == RCC_PLL1_SOURCE_CSI)))
 800e3c8:	69bb      	ldr	r3, [r7, #24]
 800e3ca:	2b02      	cmp	r3, #2
 800e3cc:	d111      	bne.n	800e3f2 <HAL_RCC_OscConfig+0x6a>
    {
      if (pOscInitStruct->CSIState == RCC_CSI_OFF)
 800e3ce:	687b      	ldr	r3, [r7, #4]
 800e3d0:	69db      	ldr	r3, [r3, #28]
 800e3d2:	2b00      	cmp	r3, #0
 800e3d4:	d102      	bne.n	800e3dc <HAL_RCC_OscConfig+0x54>
      {
        return HAL_ERROR;
 800e3d6:	2301      	movs	r3, #1
 800e3d8:	f000 bc08 	b.w	800ebec <HAL_RCC_OscConfig+0x864>

      /* Otherwise, just the calibration and CSI is allowed */
      else
      {
        /* Adjusts the Internal Low-power oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(pOscInitStruct->CSICalibrationValue);
 800e3dc:	4b84      	ldr	r3, [pc, #528]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e3de:	699b      	ldr	r3, [r3, #24]
 800e3e0:	f423 127c 	bic.w	r2, r3, #4128768	@ 0x3f0000
 800e3e4:	687b      	ldr	r3, [r7, #4]
 800e3e6:	6a1b      	ldr	r3, [r3, #32]
 800e3e8:	041b      	lsls	r3, r3, #16
 800e3ea:	4981      	ldr	r1, [pc, #516]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e3ec:	4313      	orrs	r3, r2
 800e3ee:	618b      	str	r3, [r1, #24]
      if (pOscInitStruct->CSIState == RCC_CSI_OFF)
 800e3f0:	e040      	b.n	800e474 <HAL_RCC_OscConfig+0xec>
      }
    }
    else
    {
      /* Check the CSI State */
      if ((pOscInitStruct->CSIState) != RCC_CSI_OFF)
 800e3f2:	687b      	ldr	r3, [r7, #4]
 800e3f4:	69db      	ldr	r3, [r3, #28]
 800e3f6:	2b00      	cmp	r3, #0
 800e3f8:	d023      	beq.n	800e442 <HAL_RCC_OscConfig+0xba>
      {
        /* Enable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_ENABLE();
 800e3fa:	4b7d      	ldr	r3, [pc, #500]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e3fc:	681b      	ldr	r3, [r3, #0]
 800e3fe:	4a7c      	ldr	r2, [pc, #496]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e400:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800e404:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800e406:	f7ff fce1 	bl	800ddcc <HAL_GetTick>
 800e40a:	6178      	str	r0, [r7, #20]

        /* Wait till CSI is ready */
        while (READ_BIT(RCC->CR, RCC_CR_CSIRDY) == 0U)
 800e40c:	e008      	b.n	800e420 <HAL_RCC_OscConfig+0x98>
        {
          if ((HAL_GetTick() - tickstart) > RCC_CSI_TIMEOUT_VALUE)
 800e40e:	f7ff fcdd 	bl	800ddcc <HAL_GetTick>
 800e412:	4602      	mov	r2, r0
 800e414:	697b      	ldr	r3, [r7, #20]
 800e416:	1ad3      	subs	r3, r2, r3
 800e418:	2b02      	cmp	r3, #2
 800e41a:	d901      	bls.n	800e420 <HAL_RCC_OscConfig+0x98>
          {
            return HAL_TIMEOUT;
 800e41c:	2303      	movs	r3, #3
 800e41e:	e3e5      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
        while (READ_BIT(RCC->CR, RCC_CR_CSIRDY) == 0U)
 800e420:	4b73      	ldr	r3, [pc, #460]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e422:	681b      	ldr	r3, [r3, #0]
 800e424:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800e428:	2b00      	cmp	r3, #0
 800e42a:	d0f0      	beq.n	800e40e <HAL_RCC_OscConfig+0x86>
          }
        }

        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(pOscInitStruct->CSICalibrationValue);
 800e42c:	4b70      	ldr	r3, [pc, #448]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e42e:	699b      	ldr	r3, [r3, #24]
 800e430:	f423 127c 	bic.w	r2, r3, #4128768	@ 0x3f0000
 800e434:	687b      	ldr	r3, [r7, #4]
 800e436:	6a1b      	ldr	r3, [r3, #32]
 800e438:	041b      	lsls	r3, r3, #16
 800e43a:	496d      	ldr	r1, [pc, #436]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e43c:	4313      	orrs	r3, r2
 800e43e:	618b      	str	r3, [r1, #24]
 800e440:	e018      	b.n	800e474 <HAL_RCC_OscConfig+0xec>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_DISABLE();
 800e442:	4b6b      	ldr	r3, [pc, #428]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e444:	681b      	ldr	r3, [r3, #0]
 800e446:	4a6a      	ldr	r2, [pc, #424]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e448:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 800e44c:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800e44e:	f7ff fcbd 	bl	800ddcc <HAL_GetTick>
 800e452:	6178      	str	r0, [r7, #20]

        /* Wait till CSI is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
 800e454:	e008      	b.n	800e468 <HAL_RCC_OscConfig+0xe0>
        {
          if ((HAL_GetTick() - tickstart) > RCC_CSI_TIMEOUT_VALUE)
 800e456:	f7ff fcb9 	bl	800ddcc <HAL_GetTick>
 800e45a:	4602      	mov	r2, r0
 800e45c:	697b      	ldr	r3, [r7, #20]
 800e45e:	1ad3      	subs	r3, r2, r3
 800e460:	2b02      	cmp	r3, #2
 800e462:	d901      	bls.n	800e468 <HAL_RCC_OscConfig+0xe0>
          {
            return HAL_TIMEOUT;
 800e464:	2303      	movs	r3, #3
 800e466:	e3c1      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
        while (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
 800e468:	4b61      	ldr	r3, [pc, #388]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e46a:	681b      	ldr	r3, [r3, #0]
 800e46c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800e470:	2b00      	cmp	r3, #0
 800e472:	d1f0      	bne.n	800e456 <HAL_RCC_OscConfig+0xce>
        }
      }
    }
  }
  /*------------------------------- HSE Configuration ------------------------*/
  if (((pOscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800e474:	687b      	ldr	r3, [r7, #4]
 800e476:	681b      	ldr	r3, [r3, #0]
 800e478:	f003 0301 	and.w	r3, r3, #1
 800e47c:	2b00      	cmp	r3, #0
 800e47e:	f000 80a0 	beq.w	800e5c2 <HAL_RCC_OscConfig+0x23a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(pOscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 800e482:	69fb      	ldr	r3, [r7, #28]
 800e484:	2b10      	cmp	r3, #16
 800e486:	d005      	beq.n	800e494 <HAL_RCC_OscConfig+0x10c>
 800e488:	69fb      	ldr	r3, [r7, #28]
 800e48a:	2b18      	cmp	r3, #24
 800e48c:	d109      	bne.n	800e4a2 <HAL_RCC_OscConfig+0x11a>
        ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_pllckselr == RCC_PLL1_SOURCE_HSE)))
 800e48e:	69bb      	ldr	r3, [r7, #24]
 800e490:	2b03      	cmp	r3, #3
 800e492:	d106      	bne.n	800e4a2 <HAL_RCC_OscConfig+0x11a>
    {
      if (pOscInitStruct->HSEState == RCC_HSE_OFF)
 800e494:	687b      	ldr	r3, [r7, #4]
 800e496:	685b      	ldr	r3, [r3, #4]
 800e498:	2b00      	cmp	r3, #0
 800e49a:	f040 8092 	bne.w	800e5c2 <HAL_RCC_OscConfig+0x23a>
      {
        return HAL_ERROR;
 800e49e:	2301      	movs	r3, #1
 800e4a0:	e3a4      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(pOscInitStruct->HSEState);
 800e4a2:	687b      	ldr	r3, [r7, #4]
 800e4a4:	685b      	ldr	r3, [r3, #4]
 800e4a6:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800e4aa:	d106      	bne.n	800e4ba <HAL_RCC_OscConfig+0x132>
 800e4ac:	4b50      	ldr	r3, [pc, #320]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e4ae:	681b      	ldr	r3, [r3, #0]
 800e4b0:	4a4f      	ldr	r2, [pc, #316]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e4b2:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800e4b6:	6013      	str	r3, [r2, #0]
 800e4b8:	e058      	b.n	800e56c <HAL_RCC_OscConfig+0x1e4>
 800e4ba:	687b      	ldr	r3, [r7, #4]
 800e4bc:	685b      	ldr	r3, [r3, #4]
 800e4be:	2b00      	cmp	r3, #0
 800e4c0:	d112      	bne.n	800e4e8 <HAL_RCC_OscConfig+0x160>
 800e4c2:	4b4b      	ldr	r3, [pc, #300]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e4c4:	681b      	ldr	r3, [r3, #0]
 800e4c6:	4a4a      	ldr	r2, [pc, #296]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e4c8:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 800e4cc:	6013      	str	r3, [r2, #0]
 800e4ce:	4b48      	ldr	r3, [pc, #288]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e4d0:	681b      	ldr	r3, [r3, #0]
 800e4d2:	4a47      	ldr	r2, [pc, #284]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e4d4:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
 800e4d8:	6013      	str	r3, [r2, #0]
 800e4da:	4b45      	ldr	r3, [pc, #276]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e4dc:	681b      	ldr	r3, [r3, #0]
 800e4de:	4a44      	ldr	r2, [pc, #272]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e4e0:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 800e4e4:	6013      	str	r3, [r2, #0]
 800e4e6:	e041      	b.n	800e56c <HAL_RCC_OscConfig+0x1e4>
 800e4e8:	687b      	ldr	r3, [r7, #4]
 800e4ea:	685b      	ldr	r3, [r3, #4]
 800e4ec:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 800e4f0:	d112      	bne.n	800e518 <HAL_RCC_OscConfig+0x190>
 800e4f2:	4b3f      	ldr	r3, [pc, #252]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e4f4:	681b      	ldr	r3, [r3, #0]
 800e4f6:	4a3e      	ldr	r2, [pc, #248]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e4f8:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 800e4fc:	6013      	str	r3, [r2, #0]
 800e4fe:	4b3c      	ldr	r3, [pc, #240]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e500:	681b      	ldr	r3, [r3, #0]
 800e502:	4a3b      	ldr	r2, [pc, #236]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e504:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
 800e508:	6013      	str	r3, [r2, #0]
 800e50a:	4b39      	ldr	r3, [pc, #228]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e50c:	681b      	ldr	r3, [r3, #0]
 800e50e:	4a38      	ldr	r2, [pc, #224]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e510:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800e514:	6013      	str	r3, [r2, #0]
 800e516:	e029      	b.n	800e56c <HAL_RCC_OscConfig+0x1e4>
 800e518:	687b      	ldr	r3, [r7, #4]
 800e51a:	685b      	ldr	r3, [r3, #4]
 800e51c:	f5b3 1fa8 	cmp.w	r3, #1376256	@ 0x150000
 800e520:	d112      	bne.n	800e548 <HAL_RCC_OscConfig+0x1c0>
 800e522:	4b33      	ldr	r3, [pc, #204]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e524:	681b      	ldr	r3, [r3, #0]
 800e526:	4a32      	ldr	r2, [pc, #200]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e528:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 800e52c:	6013      	str	r3, [r2, #0]
 800e52e:	4b30      	ldr	r3, [pc, #192]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e530:	681b      	ldr	r3, [r3, #0]
 800e532:	4a2f      	ldr	r2, [pc, #188]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e534:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 800e538:	6013      	str	r3, [r2, #0]
 800e53a:	4b2d      	ldr	r3, [pc, #180]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e53c:	681b      	ldr	r3, [r3, #0]
 800e53e:	4a2c      	ldr	r2, [pc, #176]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e540:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800e544:	6013      	str	r3, [r2, #0]
 800e546:	e011      	b.n	800e56c <HAL_RCC_OscConfig+0x1e4>
 800e548:	4b29      	ldr	r3, [pc, #164]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e54a:	681b      	ldr	r3, [r3, #0]
 800e54c:	4a28      	ldr	r2, [pc, #160]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e54e:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 800e552:	6013      	str	r3, [r2, #0]
 800e554:	4b26      	ldr	r3, [pc, #152]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e556:	681b      	ldr	r3, [r3, #0]
 800e558:	4a25      	ldr	r2, [pc, #148]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e55a:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 800e55e:	6013      	str	r3, [r2, #0]
 800e560:	4b23      	ldr	r3, [pc, #140]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e562:	681b      	ldr	r3, [r3, #0]
 800e564:	4a22      	ldr	r2, [pc, #136]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e566:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
 800e56a:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (pOscInitStruct->HSEState != RCC_HSE_OFF)
 800e56c:	687b      	ldr	r3, [r7, #4]
 800e56e:	685b      	ldr	r3, [r3, #4]
 800e570:	2b00      	cmp	r3, #0
 800e572:	d013      	beq.n	800e59c <HAL_RCC_OscConfig+0x214>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800e574:	f7ff fc2a 	bl	800ddcc <HAL_GetTick>
 800e578:	6178      	str	r0, [r7, #20]

        /* Wait till HSE is ready */
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 800e57a:	e008      	b.n	800e58e <HAL_RCC_OscConfig+0x206>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
 800e57c:	f7ff fc26 	bl	800ddcc <HAL_GetTick>
 800e580:	4602      	mov	r2, r0
 800e582:	697b      	ldr	r3, [r7, #20]
 800e584:	1ad3      	subs	r3, r2, r3
 800e586:	2b64      	cmp	r3, #100	@ 0x64
 800e588:	d901      	bls.n	800e58e <HAL_RCC_OscConfig+0x206>
          {
            return HAL_TIMEOUT;
 800e58a:	2303      	movs	r3, #3
 800e58c:	e32e      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 800e58e:	4b18      	ldr	r3, [pc, #96]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e590:	681b      	ldr	r3, [r3, #0]
 800e592:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800e596:	2b00      	cmp	r3, #0
 800e598:	d0f0      	beq.n	800e57c <HAL_RCC_OscConfig+0x1f4>
 800e59a:	e012      	b.n	800e5c2 <HAL_RCC_OscConfig+0x23a>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800e59c:	f7ff fc16 	bl	800ddcc <HAL_GetTick>
 800e5a0:	6178      	str	r0, [r7, #20]

        /* Wait till HSE is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 800e5a2:	e008      	b.n	800e5b6 <HAL_RCC_OscConfig+0x22e>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
 800e5a4:	f7ff fc12 	bl	800ddcc <HAL_GetTick>
 800e5a8:	4602      	mov	r2, r0
 800e5aa:	697b      	ldr	r3, [r7, #20]
 800e5ac:	1ad3      	subs	r3, r2, r3
 800e5ae:	2b64      	cmp	r3, #100	@ 0x64
 800e5b0:	d901      	bls.n	800e5b6 <HAL_RCC_OscConfig+0x22e>
          {
            return HAL_TIMEOUT;
 800e5b2:	2303      	movs	r3, #3
 800e5b4:	e31a      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 800e5b6:	4b0e      	ldr	r3, [pc, #56]	@ (800e5f0 <HAL_RCC_OscConfig+0x268>)
 800e5b8:	681b      	ldr	r3, [r3, #0]
 800e5ba:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800e5be:	2b00      	cmp	r3, #0
 800e5c0:	d1f0      	bne.n	800e5a4 <HAL_RCC_OscConfig+0x21c>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((pOscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800e5c2:	687b      	ldr	r3, [r7, #4]
 800e5c4:	681b      	ldr	r3, [r3, #0]
 800e5c6:	f003 0302 	and.w	r3, r3, #2
 800e5ca:	2b00      	cmp	r3, #0
 800e5cc:	f000 809a 	beq.w	800e704 <HAL_RCC_OscConfig+0x37c>
    assert_param(IS_RCC_HSI(pOscInitStruct->HSIState));
    assert_param(IS_RCC_HSIDIV(pOscInitStruct->HSIDiv));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pOscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 800e5d0:	69fb      	ldr	r3, [r7, #28]
 800e5d2:	2b00      	cmp	r3, #0
 800e5d4:	d005      	beq.n	800e5e2 <HAL_RCC_OscConfig+0x25a>
 800e5d6:	69fb      	ldr	r3, [r7, #28]
 800e5d8:	2b18      	cmp	r3, #24
 800e5da:	d149      	bne.n	800e670 <HAL_RCC_OscConfig+0x2e8>
        ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_pllckselr == RCC_PLL1_SOURCE_HSI)))
 800e5dc:	69bb      	ldr	r3, [r7, #24]
 800e5de:	2b01      	cmp	r3, #1
 800e5e0:	d146      	bne.n	800e670 <HAL_RCC_OscConfig+0x2e8>
    {
      /* When HSI is used as system clock it will not be disabled */
      if (pOscInitStruct->HSIState == RCC_HSI_OFF)
 800e5e2:	687b      	ldr	r3, [r7, #4]
 800e5e4:	68db      	ldr	r3, [r3, #12]
 800e5e6:	2b00      	cmp	r3, #0
 800e5e8:	d104      	bne.n	800e5f4 <HAL_RCC_OscConfig+0x26c>
      {
        return HAL_ERROR;
 800e5ea:	2301      	movs	r3, #1
 800e5ec:	e2fe      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
 800e5ee:	bf00      	nop
 800e5f0:	44020c00 	.word	0x44020c00
      /* Otherwise, HSI calibration and division may be allowed */
      else
      {

        /* HSI division is allowed if HSI is used as system clock */
        if (temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI)
 800e5f4:	69fb      	ldr	r3, [r7, #28]
 800e5f6:	2b00      	cmp	r3, #0
 800e5f8:	d11c      	bne.n	800e634 <HAL_RCC_OscConfig+0x2ac>
        {
          if (__HAL_RCC_GET_HSI_DIVIDER() != (pOscInitStruct->HSIDiv))
 800e5fa:	4b9a      	ldr	r3, [pc, #616]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e5fc:	681b      	ldr	r3, [r3, #0]
 800e5fe:	f003 0218 	and.w	r2, r3, #24
 800e602:	687b      	ldr	r3, [r7, #4]
 800e604:	691b      	ldr	r3, [r3, #16]
 800e606:	429a      	cmp	r2, r3
 800e608:	d014      	beq.n	800e634 <HAL_RCC_OscConfig+0x2ac>
          {
            /* Adjust the HSI division factor */
            __HAL_RCC_HSI_DIVIDER_CONFIG(pOscInitStruct->HSIDiv);
 800e60a:	4b96      	ldr	r3, [pc, #600]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e60c:	681b      	ldr	r3, [r3, #0]
 800e60e:	f023 0218 	bic.w	r2, r3, #24
 800e612:	687b      	ldr	r3, [r7, #4]
 800e614:	691b      	ldr	r3, [r3, #16]
 800e616:	4993      	ldr	r1, [pc, #588]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e618:	4313      	orrs	r3, r2
 800e61a:	600b      	str	r3, [r1, #0]

            /* Update the SystemCoreClock global variable with new HSI value  */
            (void) HAL_RCC_GetHCLKFreq();
 800e61c:	f000 fdd0 	bl	800f1c0 <HAL_RCC_GetHCLKFreq>

            /* Configure the source of time base considering new system clocks settings*/
            if (HAL_InitTick(uwTickPrio) != HAL_OK)
 800e620:	4b91      	ldr	r3, [pc, #580]	@ (800e868 <HAL_RCC_OscConfig+0x4e0>)
 800e622:	681b      	ldr	r3, [r3, #0]
 800e624:	4618      	mov	r0, r3
 800e626:	f7ff fb47 	bl	800dcb8 <HAL_InitTick>
 800e62a:	4603      	mov	r3, r0
 800e62c:	2b00      	cmp	r3, #0
 800e62e:	d001      	beq.n	800e634 <HAL_RCC_OscConfig+0x2ac>
            {
              return HAL_ERROR;
 800e630:	2301      	movs	r3, #1
 800e632:	e2db      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
            }
          }
        }

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800e634:	f7ff fbca 	bl	800ddcc <HAL_GetTick>
 800e638:	6178      	str	r0, [r7, #20]

        /* Wait till HSI is ready */
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 800e63a:	e008      	b.n	800e64e <HAL_RCC_OscConfig+0x2c6>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
 800e63c:	f7ff fbc6 	bl	800ddcc <HAL_GetTick>
 800e640:	4602      	mov	r2, r0
 800e642:	697b      	ldr	r3, [r7, #20]
 800e644:	1ad3      	subs	r3, r2, r3
 800e646:	2b02      	cmp	r3, #2
 800e648:	d901      	bls.n	800e64e <HAL_RCC_OscConfig+0x2c6>
          {
            return HAL_TIMEOUT;
 800e64a:	2303      	movs	r3, #3
 800e64c:	e2ce      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 800e64e:	4b85      	ldr	r3, [pc, #532]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e650:	681b      	ldr	r3, [r3, #0]
 800e652:	f003 0302 	and.w	r3, r3, #2
 800e656:	2b00      	cmp	r3, #0
 800e658:	d0f0      	beq.n	800e63c <HAL_RCC_OscConfig+0x2b4>
          }
        }
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pOscInitStruct->HSICalibrationValue);
 800e65a:	4b82      	ldr	r3, [pc, #520]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e65c:	691b      	ldr	r3, [r3, #16]
 800e65e:	f423 02fe 	bic.w	r2, r3, #8323072	@ 0x7f0000
 800e662:	687b      	ldr	r3, [r7, #4]
 800e664:	695b      	ldr	r3, [r3, #20]
 800e666:	041b      	lsls	r3, r3, #16
 800e668:	497e      	ldr	r1, [pc, #504]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e66a:	4313      	orrs	r3, r2
 800e66c:	610b      	str	r3, [r1, #16]
      if (pOscInitStruct->HSIState == RCC_HSI_OFF)
 800e66e:	e049      	b.n	800e704 <HAL_RCC_OscConfig+0x37c>
      }
    }
    else
    {
      /* Check the HSI State */
      if (pOscInitStruct->HSIState != RCC_HSI_OFF)
 800e670:	687b      	ldr	r3, [r7, #4]
 800e672:	68db      	ldr	r3, [r3, #12]
 800e674:	2b00      	cmp	r3, #0
 800e676:	d02c      	beq.n	800e6d2 <HAL_RCC_OscConfig+0x34a>
      {
        /* Adjust the HSI division factor */
        __HAL_RCC_HSI_DIVIDER_CONFIG(pOscInitStruct->HSIDiv);
 800e678:	4b7a      	ldr	r3, [pc, #488]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e67a:	681b      	ldr	r3, [r3, #0]
 800e67c:	f023 0218 	bic.w	r2, r3, #24
 800e680:	687b      	ldr	r3, [r7, #4]
 800e682:	691b      	ldr	r3, [r3, #16]
 800e684:	4977      	ldr	r1, [pc, #476]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e686:	4313      	orrs	r3, r2
 800e688:	600b      	str	r3, [r1, #0]

        /* Enable the HSI oscillator */
        __HAL_RCC_HSI_ENABLE();
 800e68a:	4b76      	ldr	r3, [pc, #472]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e68c:	681b      	ldr	r3, [r3, #0]
 800e68e:	4a75      	ldr	r2, [pc, #468]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e690:	f043 0301 	orr.w	r3, r3, #1
 800e694:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800e696:	f7ff fb99 	bl	800ddcc <HAL_GetTick>
 800e69a:	6178      	str	r0, [r7, #20]

        /* Wait till HSI is ready */
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 800e69c:	e008      	b.n	800e6b0 <HAL_RCC_OscConfig+0x328>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
 800e69e:	f7ff fb95 	bl	800ddcc <HAL_GetTick>
 800e6a2:	4602      	mov	r2, r0
 800e6a4:	697b      	ldr	r3, [r7, #20]
 800e6a6:	1ad3      	subs	r3, r2, r3
 800e6a8:	2b02      	cmp	r3, #2
 800e6aa:	d901      	bls.n	800e6b0 <HAL_RCC_OscConfig+0x328>
          {
            return HAL_TIMEOUT;
 800e6ac:	2303      	movs	r3, #3
 800e6ae:	e29d      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 800e6b0:	4b6c      	ldr	r3, [pc, #432]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e6b2:	681b      	ldr	r3, [r3, #0]
 800e6b4:	f003 0302 	and.w	r3, r3, #2
 800e6b8:	2b00      	cmp	r3, #0
 800e6ba:	d0f0      	beq.n	800e69e <HAL_RCC_OscConfig+0x316>
          }
        }

        /* Adjust the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pOscInitStruct->HSICalibrationValue);
 800e6bc:	4b69      	ldr	r3, [pc, #420]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e6be:	691b      	ldr	r3, [r3, #16]
 800e6c0:	f423 02fe 	bic.w	r2, r3, #8323072	@ 0x7f0000
 800e6c4:	687b      	ldr	r3, [r7, #4]
 800e6c6:	695b      	ldr	r3, [r3, #20]
 800e6c8:	041b      	lsls	r3, r3, #16
 800e6ca:	4966      	ldr	r1, [pc, #408]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e6cc:	4313      	orrs	r3, r2
 800e6ce:	610b      	str	r3, [r1, #16]
 800e6d0:	e018      	b.n	800e704 <HAL_RCC_OscConfig+0x37c>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800e6d2:	4b64      	ldr	r3, [pc, #400]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e6d4:	681b      	ldr	r3, [r3, #0]
 800e6d6:	4a63      	ldr	r2, [pc, #396]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e6d8:	f023 0301 	bic.w	r3, r3, #1
 800e6dc:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800e6de:	f7ff fb75 	bl	800ddcc <HAL_GetTick>
 800e6e2:	6178      	str	r0, [r7, #20]

        /* Wait till HSI is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 800e6e4:	e008      	b.n	800e6f8 <HAL_RCC_OscConfig+0x370>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
 800e6e6:	f7ff fb71 	bl	800ddcc <HAL_GetTick>
 800e6ea:	4602      	mov	r2, r0
 800e6ec:	697b      	ldr	r3, [r7, #20]
 800e6ee:	1ad3      	subs	r3, r2, r3
 800e6f0:	2b02      	cmp	r3, #2
 800e6f2:	d901      	bls.n	800e6f8 <HAL_RCC_OscConfig+0x370>
          {
            return HAL_TIMEOUT;
 800e6f4:	2303      	movs	r3, #3
 800e6f6:	e279      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 800e6f8:	4b5a      	ldr	r3, [pc, #360]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e6fa:	681b      	ldr	r3, [r3, #0]
 800e6fc:	f003 0302 	and.w	r3, r3, #2
 800e700:	2b00      	cmp	r3, #0
 800e702:	d1f0      	bne.n	800e6e6 <HAL_RCC_OscConfig+0x35e>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((pOscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800e704:	687b      	ldr	r3, [r7, #4]
 800e706:	681b      	ldr	r3, [r3, #0]
 800e708:	f003 0308 	and.w	r3, r3, #8
 800e70c:	2b00      	cmp	r3, #0
 800e70e:	d03c      	beq.n	800e78a <HAL_RCC_OscConfig+0x402>
    assert_param(IS_RCC_LSI(pOscInitStruct->LSIState));

    /* Update LSI configuration in Backup Domain control register    */

    /* Check the LSI State */
    if (pOscInitStruct->LSIState != RCC_LSI_OFF)
 800e710:	687b      	ldr	r3, [r7, #4]
 800e712:	699b      	ldr	r3, [r3, #24]
 800e714:	2b00      	cmp	r3, #0
 800e716:	d01c      	beq.n	800e752 <HAL_RCC_OscConfig+0x3ca>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800e718:	4b52      	ldr	r3, [pc, #328]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e71a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800e71e:	4a51      	ldr	r2, [pc, #324]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e720:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 800e724:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800e728:	f7ff fb50 	bl	800ddcc <HAL_GetTick>
 800e72c:	6178      	str	r0, [r7, #20]

      /* Wait till LSI is ready */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) == 0U)
 800e72e:	e008      	b.n	800e742 <HAL_RCC_OscConfig+0x3ba>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
 800e730:	f7ff fb4c 	bl	800ddcc <HAL_GetTick>
 800e734:	4602      	mov	r2, r0
 800e736:	697b      	ldr	r3, [r7, #20]
 800e738:	1ad3      	subs	r3, r2, r3
 800e73a:	2b02      	cmp	r3, #2
 800e73c:	d901      	bls.n	800e742 <HAL_RCC_OscConfig+0x3ba>
        {
          return HAL_TIMEOUT;
 800e73e:	2303      	movs	r3, #3
 800e740:	e254      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) == 0U)
 800e742:	4b48      	ldr	r3, [pc, #288]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e744:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800e748:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800e74c:	2b00      	cmp	r3, #0
 800e74e:	d0ef      	beq.n	800e730 <HAL_RCC_OscConfig+0x3a8>
 800e750:	e01b      	b.n	800e78a <HAL_RCC_OscConfig+0x402>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800e752:	4b44      	ldr	r3, [pc, #272]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e754:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800e758:	4a42      	ldr	r2, [pc, #264]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e75a:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
 800e75e:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800e762:	f7ff fb33 	bl	800ddcc <HAL_GetTick>
 800e766:	6178      	str	r0, [r7, #20]

      /* Wait till LSI is disabled */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) != 0U)
 800e768:	e008      	b.n	800e77c <HAL_RCC_OscConfig+0x3f4>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
 800e76a:	f7ff fb2f 	bl	800ddcc <HAL_GetTick>
 800e76e:	4602      	mov	r2, r0
 800e770:	697b      	ldr	r3, [r7, #20]
 800e772:	1ad3      	subs	r3, r2, r3
 800e774:	2b02      	cmp	r3, #2
 800e776:	d901      	bls.n	800e77c <HAL_RCC_OscConfig+0x3f4>
        {
          return HAL_TIMEOUT;
 800e778:	2303      	movs	r3, #3
 800e77a:	e237      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) != 0U)
 800e77c:	4b39      	ldr	r3, [pc, #228]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e77e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800e782:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800e786:	2b00      	cmp	r3, #0
 800e788:	d1ef      	bne.n	800e76a <HAL_RCC_OscConfig+0x3e2>
      }
    }

  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((pOscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800e78a:	687b      	ldr	r3, [r7, #4]
 800e78c:	681b      	ldr	r3, [r3, #0]
 800e78e:	f003 0304 	and.w	r3, r3, #4
 800e792:	2b00      	cmp	r3, #0
 800e794:	f000 80d2 	beq.w	800e93c <HAL_RCC_OscConfig+0x5b4>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(pOscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain */
    if (HAL_IS_BIT_CLR(PWR->DBPCR, PWR_DBPCR_DBP))
 800e798:	4b34      	ldr	r3, [pc, #208]	@ (800e86c <HAL_RCC_OscConfig+0x4e4>)
 800e79a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800e79c:	f003 0301 	and.w	r3, r3, #1
 800e7a0:	2b00      	cmp	r3, #0
 800e7a2:	d118      	bne.n	800e7d6 <HAL_RCC_OscConfig+0x44e>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->DBPCR, PWR_DBPCR_DBP);
 800e7a4:	4b31      	ldr	r3, [pc, #196]	@ (800e86c <HAL_RCC_OscConfig+0x4e4>)
 800e7a6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800e7a8:	4a30      	ldr	r2, [pc, #192]	@ (800e86c <HAL_RCC_OscConfig+0x4e4>)
 800e7aa:	f043 0301 	orr.w	r3, r3, #1
 800e7ae:	6253      	str	r3, [r2, #36]	@ 0x24

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800e7b0:	f7ff fb0c 	bl	800ddcc <HAL_GetTick>
 800e7b4:	6178      	str	r0, [r7, #20]

      while (HAL_IS_BIT_CLR(PWR->DBPCR, PWR_DBPCR_DBP))
 800e7b6:	e008      	b.n	800e7ca <HAL_RCC_OscConfig+0x442>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800e7b8:	f7ff fb08 	bl	800ddcc <HAL_GetTick>
 800e7bc:	4602      	mov	r2, r0
 800e7be:	697b      	ldr	r3, [r7, #20]
 800e7c0:	1ad3      	subs	r3, r2, r3
 800e7c2:	2b02      	cmp	r3, #2
 800e7c4:	d901      	bls.n	800e7ca <HAL_RCC_OscConfig+0x442>
        {
          return HAL_TIMEOUT;
 800e7c6:	2303      	movs	r3, #3
 800e7c8:	e210      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
      while (HAL_IS_BIT_CLR(PWR->DBPCR, PWR_DBPCR_DBP))
 800e7ca:	4b28      	ldr	r3, [pc, #160]	@ (800e86c <HAL_RCC_OscConfig+0x4e4>)
 800e7cc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800e7ce:	f003 0301 	and.w	r3, r3, #1
 800e7d2:	2b00      	cmp	r3, #0
 800e7d4:	d0f0      	beq.n	800e7b8 <HAL_RCC_OscConfig+0x430>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(pOscInitStruct->LSEState);
 800e7d6:	687b      	ldr	r3, [r7, #4]
 800e7d8:	689b      	ldr	r3, [r3, #8]
 800e7da:	2b01      	cmp	r3, #1
 800e7dc:	d108      	bne.n	800e7f0 <HAL_RCC_OscConfig+0x468>
 800e7de:	4b21      	ldr	r3, [pc, #132]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e7e0:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800e7e4:	4a1f      	ldr	r2, [pc, #124]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e7e6:	f043 0301 	orr.w	r3, r3, #1
 800e7ea:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 800e7ee:	e074      	b.n	800e8da <HAL_RCC_OscConfig+0x552>
 800e7f0:	687b      	ldr	r3, [r7, #4]
 800e7f2:	689b      	ldr	r3, [r3, #8]
 800e7f4:	2b00      	cmp	r3, #0
 800e7f6:	d118      	bne.n	800e82a <HAL_RCC_OscConfig+0x4a2>
 800e7f8:	4b1a      	ldr	r3, [pc, #104]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e7fa:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800e7fe:	4a19      	ldr	r2, [pc, #100]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e800:	f023 0301 	bic.w	r3, r3, #1
 800e804:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 800e808:	4b16      	ldr	r3, [pc, #88]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e80a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800e80e:	4a15      	ldr	r2, [pc, #84]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e810:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 800e814:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 800e818:	4b12      	ldr	r3, [pc, #72]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e81a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800e81e:	4a11      	ldr	r2, [pc, #68]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e820:	f023 0304 	bic.w	r3, r3, #4
 800e824:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 800e828:	e057      	b.n	800e8da <HAL_RCC_OscConfig+0x552>
 800e82a:	687b      	ldr	r3, [r7, #4]
 800e82c:	689b      	ldr	r3, [r3, #8]
 800e82e:	2b05      	cmp	r3, #5
 800e830:	d11e      	bne.n	800e870 <HAL_RCC_OscConfig+0x4e8>
 800e832:	4b0c      	ldr	r3, [pc, #48]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e834:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800e838:	4a0a      	ldr	r2, [pc, #40]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e83a:	f043 0304 	orr.w	r3, r3, #4
 800e83e:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 800e842:	4b08      	ldr	r3, [pc, #32]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e844:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800e848:	4a06      	ldr	r2, [pc, #24]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e84a:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 800e84e:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 800e852:	4b04      	ldr	r3, [pc, #16]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e854:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800e858:	4a02      	ldr	r2, [pc, #8]	@ (800e864 <HAL_RCC_OscConfig+0x4dc>)
 800e85a:	f043 0301 	orr.w	r3, r3, #1
 800e85e:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 800e862:	e03a      	b.n	800e8da <HAL_RCC_OscConfig+0x552>
 800e864:	44020c00 	.word	0x44020c00
 800e868:	20000034 	.word	0x20000034
 800e86c:	44020800 	.word	0x44020800
 800e870:	687b      	ldr	r3, [r7, #4]
 800e872:	689b      	ldr	r3, [r3, #8]
 800e874:	2b85      	cmp	r3, #133	@ 0x85
 800e876:	d118      	bne.n	800e8aa <HAL_RCC_OscConfig+0x522>
 800e878:	4ba2      	ldr	r3, [pc, #648]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e87a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800e87e:	4aa1      	ldr	r2, [pc, #644]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e880:	f043 0304 	orr.w	r3, r3, #4
 800e884:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 800e888:	4b9e      	ldr	r3, [pc, #632]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e88a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800e88e:	4a9d      	ldr	r2, [pc, #628]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e890:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800e894:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 800e898:	4b9a      	ldr	r3, [pc, #616]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e89a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800e89e:	4a99      	ldr	r2, [pc, #612]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e8a0:	f043 0301 	orr.w	r3, r3, #1
 800e8a4:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 800e8a8:	e017      	b.n	800e8da <HAL_RCC_OscConfig+0x552>
 800e8aa:	4b96      	ldr	r3, [pc, #600]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e8ac:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800e8b0:	4a94      	ldr	r2, [pc, #592]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e8b2:	f023 0301 	bic.w	r3, r3, #1
 800e8b6:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 800e8ba:	4b92      	ldr	r3, [pc, #584]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e8bc:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800e8c0:	4a90      	ldr	r2, [pc, #576]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e8c2:	f023 0304 	bic.w	r3, r3, #4
 800e8c6:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 800e8ca:	4b8e      	ldr	r3, [pc, #568]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e8cc:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800e8d0:	4a8c      	ldr	r2, [pc, #560]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e8d2:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 800e8d6:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0

    /* Check the LSE State */
    if (pOscInitStruct->LSEState != RCC_LSE_OFF)
 800e8da:	687b      	ldr	r3, [r7, #4]
 800e8dc:	689b      	ldr	r3, [r3, #8]
 800e8de:	2b00      	cmp	r3, #0
 800e8e0:	d016      	beq.n	800e910 <HAL_RCC_OscConfig+0x588>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800e8e2:	f7ff fa73 	bl	800ddcc <HAL_GetTick>
 800e8e6:	6178      	str	r0, [r7, #20]

      /* Wait till LSE is ready */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 800e8e8:	e00a      	b.n	800e900 <HAL_RCC_OscConfig+0x578>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800e8ea:	f7ff fa6f 	bl	800ddcc <HAL_GetTick>
 800e8ee:	4602      	mov	r2, r0
 800e8f0:	697b      	ldr	r3, [r7, #20]
 800e8f2:	1ad3      	subs	r3, r2, r3
 800e8f4:	f241 3288 	movw	r2, #5000	@ 0x1388
 800e8f8:	4293      	cmp	r3, r2
 800e8fa:	d901      	bls.n	800e900 <HAL_RCC_OscConfig+0x578>
        {
          return HAL_TIMEOUT;
 800e8fc:	2303      	movs	r3, #3
 800e8fe:	e175      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 800e900:	4b80      	ldr	r3, [pc, #512]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e902:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800e906:	f003 0302 	and.w	r3, r3, #2
 800e90a:	2b00      	cmp	r3, #0
 800e90c:	d0ed      	beq.n	800e8ea <HAL_RCC_OscConfig+0x562>
 800e90e:	e015      	b.n	800e93c <HAL_RCC_OscConfig+0x5b4>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800e910:	f7ff fa5c 	bl	800ddcc <HAL_GetTick>
 800e914:	6178      	str	r0, [r7, #20]

      /* Wait till LSE is disabled */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 800e916:	e00a      	b.n	800e92e <HAL_RCC_OscConfig+0x5a6>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800e918:	f7ff fa58 	bl	800ddcc <HAL_GetTick>
 800e91c:	4602      	mov	r2, r0
 800e91e:	697b      	ldr	r3, [r7, #20]
 800e920:	1ad3      	subs	r3, r2, r3
 800e922:	f241 3288 	movw	r2, #5000	@ 0x1388
 800e926:	4293      	cmp	r3, r2
 800e928:	d901      	bls.n	800e92e <HAL_RCC_OscConfig+0x5a6>
        {
          return HAL_TIMEOUT;
 800e92a:	2303      	movs	r3, #3
 800e92c:	e15e      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 800e92e:	4b75      	ldr	r3, [pc, #468]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e930:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800e934:	f003 0302 	and.w	r3, r3, #2
 800e938:	2b00      	cmp	r3, #0
 800e93a:	d1ed      	bne.n	800e918 <HAL_RCC_OscConfig+0x590>
      }
    }

  }
  /*------------------------------ HSI48 Configuration -----------------------*/
  if (((pOscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 800e93c:	687b      	ldr	r3, [r7, #4]
 800e93e:	681b      	ldr	r3, [r3, #0]
 800e940:	f003 0320 	and.w	r3, r3, #32
 800e944:	2b00      	cmp	r3, #0
 800e946:	d036      	beq.n	800e9b6 <HAL_RCC_OscConfig+0x62e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(pOscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if (pOscInitStruct->HSI48State != RCC_HSI48_OFF)
 800e948:	687b      	ldr	r3, [r7, #4]
 800e94a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800e94c:	2b00      	cmp	r3, #0
 800e94e:	d019      	beq.n	800e984 <HAL_RCC_OscConfig+0x5fc>
    {
      /* Enable the Internal High Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 800e950:	4b6c      	ldr	r3, [pc, #432]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e952:	681b      	ldr	r3, [r3, #0]
 800e954:	4a6b      	ldr	r2, [pc, #428]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e956:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 800e95a:	6013      	str	r3, [r2, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800e95c:	f7ff fa36 	bl	800ddcc <HAL_GetTick>
 800e960:	6178      	str	r0, [r7, #20]

      /* Wait till HSI48 is ready */
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) == 0U)
 800e962:	e008      	b.n	800e976 <HAL_RCC_OscConfig+0x5ee>
      {
        if ((HAL_GetTick() - tickstart) > RCC_HSI48_TIMEOUT_VALUE)
 800e964:	f7ff fa32 	bl	800ddcc <HAL_GetTick>
 800e968:	4602      	mov	r2, r0
 800e96a:	697b      	ldr	r3, [r7, #20]
 800e96c:	1ad3      	subs	r3, r2, r3
 800e96e:	2b02      	cmp	r3, #2
 800e970:	d901      	bls.n	800e976 <HAL_RCC_OscConfig+0x5ee>
        {
          return HAL_TIMEOUT;
 800e972:	2303      	movs	r3, #3
 800e974:	e13a      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) == 0U)
 800e976:	4b63      	ldr	r3, [pc, #396]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e978:	681b      	ldr	r3, [r3, #0]
 800e97a:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 800e97e:	2b00      	cmp	r3, #0
 800e980:	d0f0      	beq.n	800e964 <HAL_RCC_OscConfig+0x5dc>
 800e982:	e018      	b.n	800e9b6 <HAL_RCC_OscConfig+0x62e>
      }
    }
    else
    {
      /* Disable the Internal High Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
 800e984:	4b5f      	ldr	r3, [pc, #380]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e986:	681b      	ldr	r3, [r3, #0]
 800e988:	4a5e      	ldr	r2, [pc, #376]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e98a:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 800e98e:	6013      	str	r3, [r2, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800e990:	f7ff fa1c 	bl	800ddcc <HAL_GetTick>
 800e994:	6178      	str	r0, [r7, #20]

      /* Wait till HSI48 is disabled */
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) != 0U)
 800e996:	e008      	b.n	800e9aa <HAL_RCC_OscConfig+0x622>
      {
        if ((HAL_GetTick() - tickstart) > RCC_HSI48_TIMEOUT_VALUE)
 800e998:	f7ff fa18 	bl	800ddcc <HAL_GetTick>
 800e99c:	4602      	mov	r2, r0
 800e99e:	697b      	ldr	r3, [r7, #20]
 800e9a0:	1ad3      	subs	r3, r2, r3
 800e9a2:	2b02      	cmp	r3, #2
 800e9a4:	d901      	bls.n	800e9aa <HAL_RCC_OscConfig+0x622>
        {
          return HAL_TIMEOUT;
 800e9a6:	2303      	movs	r3, #3
 800e9a8:	e120      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) != 0U)
 800e9aa:	4b56      	ldr	r3, [pc, #344]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e9ac:	681b      	ldr	r3, [r3, #0]
 800e9ae:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 800e9b2:	2b00      	cmp	r3, #0
 800e9b4:	d1f0      	bne.n	800e998 <HAL_RCC_OscConfig+0x610>

  /*-------------------------------- PLL1 Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pOscInitStruct->PLL.PLLState));

  if ((pOscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800e9b6:	687b      	ldr	r3, [r7, #4]
 800e9b8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800e9ba:	2b00      	cmp	r3, #0
 800e9bc:	f000 8115 	beq.w	800ebea <HAL_RCC_OscConfig+0x862>
  {
    /* Check if the PLL1 is used as system clock or not */
    if (temp_sysclksrc != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800e9c0:	69fb      	ldr	r3, [r7, #28]
 800e9c2:	2b18      	cmp	r3, #24
 800e9c4:	f000 80af 	beq.w	800eb26 <HAL_RCC_OscConfig+0x79e>
    {
      if ((pOscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800e9c8:	687b      	ldr	r3, [r7, #4]
 800e9ca:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800e9cc:	2b02      	cmp	r3, #2
 800e9ce:	f040 8086 	bne.w	800eade <HAL_RCC_OscConfig+0x756>
        assert_param(IS_RCC_PLL1_DIVP_VALUE(pOscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLL1_DIVQ_VALUE(pOscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLL1_DIVR_VALUE(pOscInitStruct->PLL.PLLR));

        /* Disable the PLL1. */
        __HAL_RCC_PLL1_DISABLE();
 800e9d2:	4b4c      	ldr	r3, [pc, #304]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e9d4:	681b      	ldr	r3, [r3, #0]
 800e9d6:	4a4b      	ldr	r2, [pc, #300]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e9d8:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 800e9dc:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800e9de:	f7ff f9f5 	bl	800ddcc <HAL_GetTick>
 800e9e2:	6178      	str	r0, [r7, #20]

        /* Wait till PLL1 is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 800e9e4:	e008      	b.n	800e9f8 <HAL_RCC_OscConfig+0x670>
        {
          if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
 800e9e6:	f7ff f9f1 	bl	800ddcc <HAL_GetTick>
 800e9ea:	4602      	mov	r2, r0
 800e9ec:	697b      	ldr	r3, [r7, #20]
 800e9ee:	1ad3      	subs	r3, r2, r3
 800e9f0:	2b02      	cmp	r3, #2
 800e9f2:	d901      	bls.n	800e9f8 <HAL_RCC_OscConfig+0x670>
          {
            return HAL_TIMEOUT;
 800e9f4:	2303      	movs	r3, #3
 800e9f6:	e0f9      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 800e9f8:	4b42      	ldr	r3, [pc, #264]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800e9fa:	681b      	ldr	r3, [r3, #0]
 800e9fc:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800ea00:	2b00      	cmp	r3, #0
 800ea02:	d1f0      	bne.n	800e9e6 <HAL_RCC_OscConfig+0x65e>
          }
        }

        /* Configure the PLL1 clock source, multiplication and division factors. */
        __HAL_RCC_PLL1_CONFIG(pOscInitStruct->PLL.PLLSource,
 800ea04:	4b3f      	ldr	r3, [pc, #252]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800ea06:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800ea08:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
 800ea0c:	f023 0303 	bic.w	r3, r3, #3
 800ea10:	687a      	ldr	r2, [r7, #4]
 800ea12:	6ad1      	ldr	r1, [r2, #44]	@ 0x2c
 800ea14:	687a      	ldr	r2, [r7, #4]
 800ea16:	6b12      	ldr	r2, [r2, #48]	@ 0x30
 800ea18:	0212      	lsls	r2, r2, #8
 800ea1a:	430a      	orrs	r2, r1
 800ea1c:	4939      	ldr	r1, [pc, #228]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800ea1e:	4313      	orrs	r3, r2
 800ea20:	628b      	str	r3, [r1, #40]	@ 0x28
 800ea22:	687b      	ldr	r3, [r7, #4]
 800ea24:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800ea26:	3b01      	subs	r3, #1
 800ea28:	f3c3 0208 	ubfx	r2, r3, #0, #9
 800ea2c:	687b      	ldr	r3, [r7, #4]
 800ea2e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800ea30:	3b01      	subs	r3, #1
 800ea32:	025b      	lsls	r3, r3, #9
 800ea34:	b29b      	uxth	r3, r3
 800ea36:	431a      	orrs	r2, r3
 800ea38:	687b      	ldr	r3, [r7, #4]
 800ea3a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800ea3c:	3b01      	subs	r3, #1
 800ea3e:	041b      	lsls	r3, r3, #16
 800ea40:	f403 03fe 	and.w	r3, r3, #8323072	@ 0x7f0000
 800ea44:	431a      	orrs	r2, r3
 800ea46:	687b      	ldr	r3, [r7, #4]
 800ea48:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800ea4a:	3b01      	subs	r3, #1
 800ea4c:	061b      	lsls	r3, r3, #24
 800ea4e:	f003 43fe 	and.w	r3, r3, #2130706432	@ 0x7f000000
 800ea52:	492c      	ldr	r1, [pc, #176]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800ea54:	4313      	orrs	r3, r2
 800ea56:	634b      	str	r3, [r1, #52]	@ 0x34
                              pOscInitStruct->PLL.PLLR);

        assert_param(IS_RCC_PLL1_FRACN_VALUE(pOscInitStruct->PLL.PLLFRACN));

        /* Disable PLL1FRACN . */
        __HAL_RCC_PLL1_FRACN_DISABLE();
 800ea58:	4b2a      	ldr	r3, [pc, #168]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800ea5a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800ea5c:	4a29      	ldr	r2, [pc, #164]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800ea5e:	f023 0310 	bic.w	r3, r3, #16
 800ea62:	6293      	str	r3, [r2, #40]	@ 0x28

        /* Configure PLL  PLL1FRACN */
        __HAL_RCC_PLL1_FRACN_CONFIG(pOscInitStruct->PLL.PLLFRACN);
 800ea64:	687b      	ldr	r3, [r7, #4]
 800ea66:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800ea68:	4a26      	ldr	r2, [pc, #152]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800ea6a:	00db      	lsls	r3, r3, #3
 800ea6c:	6393      	str	r3, [r2, #56]	@ 0x38

        /* Enable PLL1FRACN . */
        __HAL_RCC_PLL1_FRACN_ENABLE();
 800ea6e:	4b25      	ldr	r3, [pc, #148]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800ea70:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800ea72:	4a24      	ldr	r2, [pc, #144]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800ea74:	f043 0310 	orr.w	r3, r3, #16
 800ea78:	6293      	str	r3, [r2, #40]	@ 0x28

        assert_param(IS_RCC_PLL1_VCIRGE_VALUE(pOscInitStruct->PLL.PLLRGE));

        /* Select PLL1 input reference frequency range: VCI */
        __HAL_RCC_PLL1_VCIRANGE(pOscInitStruct->PLL.PLLRGE) ;
 800ea7a:	4b22      	ldr	r3, [pc, #136]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800ea7c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800ea7e:	f023 020c 	bic.w	r2, r3, #12
 800ea82:	687b      	ldr	r3, [r7, #4]
 800ea84:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800ea86:	491f      	ldr	r1, [pc, #124]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800ea88:	4313      	orrs	r3, r2
 800ea8a:	628b      	str	r3, [r1, #40]	@ 0x28

        assert_param(IS_RCC_PLL1_VCORGE_VALUE(pOscInitStruct->PLL.PLLVCOSEL));

        /* Select PLL1 output frequency range : VCO */
        __HAL_RCC_PLL1_VCORANGE(pOscInitStruct->PLL.PLLVCOSEL) ;
 800ea8c:	4b1d      	ldr	r3, [pc, #116]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800ea8e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800ea90:	f023 0220 	bic.w	r2, r3, #32
 800ea94:	687b      	ldr	r3, [r7, #4]
 800ea96:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800ea98:	491a      	ldr	r1, [pc, #104]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800ea9a:	4313      	orrs	r3, r2
 800ea9c:	628b      	str	r3, [r1, #40]	@ 0x28

        /* Enable PLL1 System Clock output. */
        __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVP);
 800ea9e:	4b19      	ldr	r3, [pc, #100]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800eaa0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800eaa2:	4a18      	ldr	r2, [pc, #96]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800eaa4:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800eaa8:	6293      	str	r3, [r2, #40]	@ 0x28

        /* Enable the PLL1. */
        __HAL_RCC_PLL1_ENABLE();
 800eaaa:	4b16      	ldr	r3, [pc, #88]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800eaac:	681b      	ldr	r3, [r3, #0]
 800eaae:	4a15      	ldr	r2, [pc, #84]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800eab0:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 800eab4:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800eab6:	f7ff f989 	bl	800ddcc <HAL_GetTick>
 800eaba:	6178      	str	r0, [r7, #20]

        /* Wait till PLL1 is ready */
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == 0U)
 800eabc:	e008      	b.n	800ead0 <HAL_RCC_OscConfig+0x748>
        {
          if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
 800eabe:	f7ff f985 	bl	800ddcc <HAL_GetTick>
 800eac2:	4602      	mov	r2, r0
 800eac4:	697b      	ldr	r3, [r7, #20]
 800eac6:	1ad3      	subs	r3, r2, r3
 800eac8:	2b02      	cmp	r3, #2
 800eaca:	d901      	bls.n	800ead0 <HAL_RCC_OscConfig+0x748>
          {
            return HAL_TIMEOUT;
 800eacc:	2303      	movs	r3, #3
 800eace:	e08d      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == 0U)
 800ead0:	4b0c      	ldr	r3, [pc, #48]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800ead2:	681b      	ldr	r3, [r3, #0]
 800ead4:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800ead8:	2b00      	cmp	r3, #0
 800eada:	d0f0      	beq.n	800eabe <HAL_RCC_OscConfig+0x736>
 800eadc:	e085      	b.n	800ebea <HAL_RCC_OscConfig+0x862>
        }
      }
      else
      {
        /* Disable the PLL1. */
        __HAL_RCC_PLL1_DISABLE();
 800eade:	4b09      	ldr	r3, [pc, #36]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800eae0:	681b      	ldr	r3, [r3, #0]
 800eae2:	4a08      	ldr	r2, [pc, #32]	@ (800eb04 <HAL_RCC_OscConfig+0x77c>)
 800eae4:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 800eae8:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800eaea:	f7ff f96f 	bl	800ddcc <HAL_GetTick>
 800eaee:	6178      	str	r0, [r7, #20]

        /* Wait till PLL1 is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 800eaf0:	e00a      	b.n	800eb08 <HAL_RCC_OscConfig+0x780>
        {
          if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
 800eaf2:	f7ff f96b 	bl	800ddcc <HAL_GetTick>
 800eaf6:	4602      	mov	r2, r0
 800eaf8:	697b      	ldr	r3, [r7, #20]
 800eafa:	1ad3      	subs	r3, r2, r3
 800eafc:	2b02      	cmp	r3, #2
 800eafe:	d903      	bls.n	800eb08 <HAL_RCC_OscConfig+0x780>
          {
            return HAL_TIMEOUT;
 800eb00:	2303      	movs	r3, #3
 800eb02:	e073      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
 800eb04:	44020c00 	.word	0x44020c00
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 800eb08:	4b3a      	ldr	r3, [pc, #232]	@ (800ebf4 <HAL_RCC_OscConfig+0x86c>)
 800eb0a:	681b      	ldr	r3, [r3, #0]
 800eb0c:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800eb10:	2b00      	cmp	r3, #0
 800eb12:	d1ee      	bne.n	800eaf2 <HAL_RCC_OscConfig+0x76a>
          }
        }

        /* Unselect PLL1 clock source and disable all PLL1 outputs to save power */
        RCC->PLL1CFGR &= ~(RCC_PLL1CFGR_PLL1SRC | RCC_PLL1CFGR_PLL1PEN | RCC_PLL1CFGR_PLL1QEN | RCC_PLL1CFGR_PLL1REN);
 800eb14:	4b37      	ldr	r3, [pc, #220]	@ (800ebf4 <HAL_RCC_OscConfig+0x86c>)
 800eb16:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800eb18:	4a36      	ldr	r2, [pc, #216]	@ (800ebf4 <HAL_RCC_OscConfig+0x86c>)
 800eb1a:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
 800eb1e:	f023 0303 	bic.w	r3, r3, #3
 800eb22:	6293      	str	r3, [r2, #40]	@ 0x28
 800eb24:	e061      	b.n	800ebea <HAL_RCC_OscConfig+0x862>
      }
    }
    else
    {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      temp1_pllckcfg = RCC->PLL1CFGR;
 800eb26:	4b33      	ldr	r3, [pc, #204]	@ (800ebf4 <HAL_RCC_OscConfig+0x86c>)
 800eb28:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800eb2a:	613b      	str	r3, [r7, #16]
      temp2_pllckcfg = RCC->PLL1DIVR;
 800eb2c:	4b31      	ldr	r3, [pc, #196]	@ (800ebf4 <HAL_RCC_OscConfig+0x86c>)
 800eb2e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800eb30:	60fb      	str	r3, [r7, #12]
      if (((pOscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800eb32:	687b      	ldr	r3, [r7, #4]
 800eb34:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800eb36:	2b01      	cmp	r3, #1
 800eb38:	d031      	beq.n	800eb9e <HAL_RCC_OscConfig+0x816>
          (READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1SRC) != pOscInitStruct->PLL.PLLSource) ||
 800eb3a:	693b      	ldr	r3, [r7, #16]
 800eb3c:	f003 0203 	and.w	r2, r3, #3
 800eb40:	687b      	ldr	r3, [r7, #4]
 800eb42:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
      if (((pOscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800eb44:	429a      	cmp	r2, r3
 800eb46:	d12a      	bne.n	800eb9e <HAL_RCC_OscConfig+0x816>
          ((READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1M) >> \
 800eb48:	693b      	ldr	r3, [r7, #16]
 800eb4a:	0a1b      	lsrs	r3, r3, #8
 800eb4c:	f003 023f 	and.w	r2, r3, #63	@ 0x3f
            RCC_PLL1CFGR_PLL1M_Pos) != (pOscInitStruct->PLL.PLLM)) ||
 800eb50:	687b      	ldr	r3, [r7, #4]
 800eb52:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
          (READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1SRC) != pOscInitStruct->PLL.PLLSource) ||
 800eb54:	429a      	cmp	r2, r3
 800eb56:	d122      	bne.n	800eb9e <HAL_RCC_OscConfig+0x816>
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1N) != (pOscInitStruct->PLL.PLLN - 1U)) ||
 800eb58:	68fb      	ldr	r3, [r7, #12]
 800eb5a:	f3c3 0208 	ubfx	r2, r3, #0, #9
 800eb5e:	687b      	ldr	r3, [r7, #4]
 800eb60:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800eb62:	3b01      	subs	r3, #1
            RCC_PLL1CFGR_PLL1M_Pos) != (pOscInitStruct->PLL.PLLM)) ||
 800eb64:	429a      	cmp	r2, r3
 800eb66:	d11a      	bne.n	800eb9e <HAL_RCC_OscConfig+0x816>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1P) >> \
 800eb68:	68fb      	ldr	r3, [r7, #12]
 800eb6a:	0a5b      	lsrs	r3, r3, #9
 800eb6c:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
            RCC_PLL1DIVR_PLL1P_Pos) != (pOscInitStruct->PLL.PLLP - 1U)) ||
 800eb70:	687b      	ldr	r3, [r7, #4]
 800eb72:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800eb74:	3b01      	subs	r3, #1
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1N) != (pOscInitStruct->PLL.PLLN - 1U)) ||
 800eb76:	429a      	cmp	r2, r3
 800eb78:	d111      	bne.n	800eb9e <HAL_RCC_OscConfig+0x816>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1Q) >> \
 800eb7a:	68fb      	ldr	r3, [r7, #12]
 800eb7c:	0c1b      	lsrs	r3, r3, #16
 800eb7e:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
            RCC_PLL1DIVR_PLL1Q_Pos) != (pOscInitStruct->PLL.PLLQ - 1U)) ||
 800eb82:	687b      	ldr	r3, [r7, #4]
 800eb84:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800eb86:	3b01      	subs	r3, #1
            RCC_PLL1DIVR_PLL1P_Pos) != (pOscInitStruct->PLL.PLLP - 1U)) ||
 800eb88:	429a      	cmp	r2, r3
 800eb8a:	d108      	bne.n	800eb9e <HAL_RCC_OscConfig+0x816>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1R) >> \
 800eb8c:	68fb      	ldr	r3, [r7, #12]
 800eb8e:	0e1b      	lsrs	r3, r3, #24
 800eb90:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
            RCC_PLL1DIVR_PLL1R_Pos) != (pOscInitStruct->PLL.PLLR - 1U)))
 800eb94:	687b      	ldr	r3, [r7, #4]
 800eb96:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800eb98:	3b01      	subs	r3, #1
            RCC_PLL1DIVR_PLL1Q_Pos) != (pOscInitStruct->PLL.PLLQ - 1U)) ||
 800eb9a:	429a      	cmp	r2, r3
 800eb9c:	d001      	beq.n	800eba2 <HAL_RCC_OscConfig+0x81a>
      {
        return HAL_ERROR;
 800eb9e:	2301      	movs	r3, #1
 800eba0:	e024      	b.n	800ebec <HAL_RCC_OscConfig+0x864>
      }

      /* FRACN1 on-the-fly value update */
      if ((READ_BIT(RCC->PLL1FRACR, RCC_PLL1FRACR_PLL1FRACN) >> \
 800eba2:	4b14      	ldr	r3, [pc, #80]	@ (800ebf4 <HAL_RCC_OscConfig+0x86c>)
 800eba4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800eba6:	08db      	lsrs	r3, r3, #3
 800eba8:	f3c3 020c 	ubfx	r2, r3, #0, #13
           RCC_PLL1FRACR_PLL1FRACN_Pos) != (pOscInitStruct->PLL.PLLFRACN))
 800ebac:	687b      	ldr	r3, [r7, #4]
 800ebae:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
      if ((READ_BIT(RCC->PLL1FRACR, RCC_PLL1FRACR_PLL1FRACN) >> \
 800ebb0:	429a      	cmp	r2, r3
 800ebb2:	d01a      	beq.n	800ebea <HAL_RCC_OscConfig+0x862>
      {
        assert_param(IS_RCC_PLL1_FRACN_VALUE(pOscInitStruct->PLL.PLLFRACN));

        /* Disable PLL1FRACN . */
        __HAL_RCC_PLL1_FRACN_DISABLE();
 800ebb4:	4b0f      	ldr	r3, [pc, #60]	@ (800ebf4 <HAL_RCC_OscConfig+0x86c>)
 800ebb6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800ebb8:	4a0e      	ldr	r2, [pc, #56]	@ (800ebf4 <HAL_RCC_OscConfig+0x86c>)
 800ebba:	f023 0310 	bic.w	r3, r3, #16
 800ebbe:	6293      	str	r3, [r2, #40]	@ 0x28

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800ebc0:	f7ff f904 	bl	800ddcc <HAL_GetTick>
 800ebc4:	6178      	str	r0, [r7, #20]

        /* Wait at least 2 CK_REF (PLL input source divided by M) period to make sure next latched value
           will be taken into account. */
        while ((HAL_GetTick() - tickstart) < RCC_PLL_FRAC_WAIT_VALUE)
 800ebc6:	bf00      	nop
 800ebc8:	f7ff f900 	bl	800ddcc <HAL_GetTick>
 800ebcc:	4602      	mov	r2, r0
 800ebce:	697b      	ldr	r3, [r7, #20]
 800ebd0:	4293      	cmp	r3, r2
 800ebd2:	d0f9      	beq.n	800ebc8 <HAL_RCC_OscConfig+0x840>
        {
        }

        /* Configure PLL PLL1FRACN */
        __HAL_RCC_PLL1_FRACN_CONFIG(pOscInitStruct->PLL.PLLFRACN);
 800ebd4:	687b      	ldr	r3, [r7, #4]
 800ebd6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800ebd8:	4a06      	ldr	r2, [pc, #24]	@ (800ebf4 <HAL_RCC_OscConfig+0x86c>)
 800ebda:	00db      	lsls	r3, r3, #3
 800ebdc:	6393      	str	r3, [r2, #56]	@ 0x38

        /* Enable PLL1FRACN to latch the new value. */
        __HAL_RCC_PLL1_FRACN_ENABLE();
 800ebde:	4b05      	ldr	r3, [pc, #20]	@ (800ebf4 <HAL_RCC_OscConfig+0x86c>)
 800ebe0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800ebe2:	4a04      	ldr	r2, [pc, #16]	@ (800ebf4 <HAL_RCC_OscConfig+0x86c>)
 800ebe4:	f043 0310 	orr.w	r3, r3, #16
 800ebe8:	6293      	str	r3, [r2, #40]	@ 0x28
      }

    }
  }
  return HAL_OK;
 800ebea:	2300      	movs	r3, #0
}
 800ebec:	4618      	mov	r0, r3
 800ebee:	3720      	adds	r7, #32
 800ebf0:	46bd      	mov	sp, r7
 800ebf2:	bd80      	pop	{r7, pc}
 800ebf4:	44020c00 	.word	0x44020c00

0800ebf8 <HAL_RCC_ClockConfig>:
  *         currently used as system clock source.
  *
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(const RCC_ClkInitTypeDef  *pClkInitStruct, uint32_t FLatency)
{
 800ebf8:	b580      	push	{r7, lr}
 800ebfa:	b084      	sub	sp, #16
 800ebfc:	af00      	add	r7, sp, #0
 800ebfe:	6078      	str	r0, [r7, #4]
 800ec00:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halstatus;
  uint32_t tickstart;

  /* Check Null pointer */
  if (pClkInitStruct == NULL)
 800ec02:	687b      	ldr	r3, [r7, #4]
 800ec04:	2b00      	cmp	r3, #0
 800ec06:	d101      	bne.n	800ec0c <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 800ec08:	2301      	movs	r3, #1
 800ec0a:	e19e      	b.n	800ef4a <HAL_RCC_ClockConfig+0x352>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 800ec0c:	4b83      	ldr	r3, [pc, #524]	@ (800ee1c <HAL_RCC_ClockConfig+0x224>)
 800ec0e:	681b      	ldr	r3, [r3, #0]
 800ec10:	f003 030f 	and.w	r3, r3, #15
 800ec14:	683a      	ldr	r2, [r7, #0]
 800ec16:	429a      	cmp	r2, r3
 800ec18:	d910      	bls.n	800ec3c <HAL_RCC_ClockConfig+0x44>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800ec1a:	4b80      	ldr	r3, [pc, #512]	@ (800ee1c <HAL_RCC_ClockConfig+0x224>)
 800ec1c:	681b      	ldr	r3, [r3, #0]
 800ec1e:	f023 020f 	bic.w	r2, r3, #15
 800ec22:	497e      	ldr	r1, [pc, #504]	@ (800ee1c <HAL_RCC_ClockConfig+0x224>)
 800ec24:	683b      	ldr	r3, [r7, #0]
 800ec26:	4313      	orrs	r3, r2
 800ec28:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800ec2a:	4b7c      	ldr	r3, [pc, #496]	@ (800ee1c <HAL_RCC_ClockConfig+0x224>)
 800ec2c:	681b      	ldr	r3, [r3, #0]
 800ec2e:	f003 030f 	and.w	r3, r3, #15
 800ec32:	683a      	ldr	r2, [r7, #0]
 800ec34:	429a      	cmp	r2, r3
 800ec36:	d001      	beq.n	800ec3c <HAL_RCC_ClockConfig+0x44>
    {
      return HAL_ERROR;
 800ec38:	2301      	movs	r3, #1
 800ec3a:	e186      	b.n	800ef4a <HAL_RCC_ClockConfig+0x352>
    }
  }

  /* Increasing the BUS frequency divider */
  /*-------------------------- PCLK3 Configuration ---------------------------*/
  if (((pClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK3) == RCC_CLOCKTYPE_PCLK3)
 800ec3c:	687b      	ldr	r3, [r7, #4]
 800ec3e:	681b      	ldr	r3, [r3, #0]
 800ec40:	f003 0310 	and.w	r3, r3, #16
 800ec44:	2b00      	cmp	r3, #0
 800ec46:	d012      	beq.n	800ec6e <HAL_RCC_ClockConfig+0x76>
  {
    if ((pClkInitStruct->APB3CLKDivider) > ((RCC->CFGR2 & RCC_CFGR2_PPRE3) >> 8))
 800ec48:	687b      	ldr	r3, [r7, #4]
 800ec4a:	695a      	ldr	r2, [r3, #20]
 800ec4c:	4b74      	ldr	r3, [pc, #464]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800ec4e:	6a1b      	ldr	r3, [r3, #32]
 800ec50:	0a1b      	lsrs	r3, r3, #8
 800ec52:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 800ec56:	429a      	cmp	r2, r3
 800ec58:	d909      	bls.n	800ec6e <HAL_RCC_ClockConfig+0x76>
    {
      assert_param(IS_RCC_PCLK(pClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE3, ((pClkInitStruct->APB3CLKDivider) << 8));
 800ec5a:	4b71      	ldr	r3, [pc, #452]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800ec5c:	6a1b      	ldr	r3, [r3, #32]
 800ec5e:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
 800ec62:	687b      	ldr	r3, [r7, #4]
 800ec64:	695b      	ldr	r3, [r3, #20]
 800ec66:	021b      	lsls	r3, r3, #8
 800ec68:	496d      	ldr	r1, [pc, #436]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800ec6a:	4313      	orrs	r3, r2
 800ec6c:	620b      	str	r3, [r1, #32]
    }
  }
  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800ec6e:	687b      	ldr	r3, [r7, #4]
 800ec70:	681b      	ldr	r3, [r3, #0]
 800ec72:	f003 0308 	and.w	r3, r3, #8
 800ec76:	2b00      	cmp	r3, #0
 800ec78:	d012      	beq.n	800eca0 <HAL_RCC_ClockConfig+0xa8>
  {
    if ((pClkInitStruct->APB2CLKDivider) > ((RCC->CFGR2 & RCC_CFGR2_PPRE2) >> 4))
 800ec7a:	687b      	ldr	r3, [r7, #4]
 800ec7c:	691a      	ldr	r2, [r3, #16]
 800ec7e:	4b68      	ldr	r3, [pc, #416]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800ec80:	6a1b      	ldr	r3, [r3, #32]
 800ec82:	091b      	lsrs	r3, r3, #4
 800ec84:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 800ec88:	429a      	cmp	r2, r3
 800ec8a:	d909      	bls.n	800eca0 <HAL_RCC_ClockConfig+0xa8>
    {
      assert_param(IS_RCC_PCLK(pClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, ((pClkInitStruct->APB2CLKDivider) << 4));
 800ec8c:	4b64      	ldr	r3, [pc, #400]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800ec8e:	6a1b      	ldr	r3, [r3, #32]
 800ec90:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
 800ec94:	687b      	ldr	r3, [r7, #4]
 800ec96:	691b      	ldr	r3, [r3, #16]
 800ec98:	011b      	lsls	r3, r3, #4
 800ec9a:	4961      	ldr	r1, [pc, #388]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800ec9c:	4313      	orrs	r3, r2
 800ec9e:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800eca0:	687b      	ldr	r3, [r7, #4]
 800eca2:	681b      	ldr	r3, [r3, #0]
 800eca4:	f003 0304 	and.w	r3, r3, #4
 800eca8:	2b00      	cmp	r3, #0
 800ecaa:	d010      	beq.n	800ecce <HAL_RCC_ClockConfig+0xd6>
  {
    if ((pClkInitStruct->APB1CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE1))
 800ecac:	687b      	ldr	r3, [r7, #4]
 800ecae:	68da      	ldr	r2, [r3, #12]
 800ecb0:	4b5b      	ldr	r3, [pc, #364]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800ecb2:	6a1b      	ldr	r3, [r3, #32]
 800ecb4:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 800ecb8:	429a      	cmp	r2, r3
 800ecba:	d908      	bls.n	800ecce <HAL_RCC_ClockConfig+0xd6>
    {
      assert_param(IS_RCC_PCLK(pClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, pClkInitStruct->APB1CLKDivider);
 800ecbc:	4b58      	ldr	r3, [pc, #352]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800ecbe:	6a1b      	ldr	r3, [r3, #32]
 800ecc0:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 800ecc4:	687b      	ldr	r3, [r7, #4]
 800ecc6:	68db      	ldr	r3, [r3, #12]
 800ecc8:	4955      	ldr	r1, [pc, #340]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800ecca:	4313      	orrs	r3, r2
 800eccc:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800ecce:	687b      	ldr	r3, [r7, #4]
 800ecd0:	681b      	ldr	r3, [r3, #0]
 800ecd2:	f003 0302 	and.w	r3, r3, #2
 800ecd6:	2b00      	cmp	r3, #0
 800ecd8:	d010      	beq.n	800ecfc <HAL_RCC_ClockConfig+0x104>
  {
    if ((pClkInitStruct->AHBCLKDivider) > (RCC->CFGR2 & RCC_CFGR2_HPRE))
 800ecda:	687b      	ldr	r3, [r7, #4]
 800ecdc:	689a      	ldr	r2, [r3, #8]
 800ecde:	4b50      	ldr	r3, [pc, #320]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800ece0:	6a1b      	ldr	r3, [r3, #32]
 800ece2:	f003 030f 	and.w	r3, r3, #15
 800ece6:	429a      	cmp	r2, r3
 800ece8:	d908      	bls.n	800ecfc <HAL_RCC_ClockConfig+0x104>
    {
      assert_param(IS_RCC_HCLK(pClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pClkInitStruct->AHBCLKDivider);
 800ecea:	4b4d      	ldr	r3, [pc, #308]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800ecec:	6a1b      	ldr	r3, [r3, #32]
 800ecee:	f023 020f 	bic.w	r2, r3, #15
 800ecf2:	687b      	ldr	r3, [r7, #4]
 800ecf4:	689b      	ldr	r3, [r3, #8]
 800ecf6:	494a      	ldr	r1, [pc, #296]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800ecf8:	4313      	orrs	r3, r2
 800ecfa:	620b      	str	r3, [r1, #32]
    }
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((pClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800ecfc:	687b      	ldr	r3, [r7, #4]
 800ecfe:	681b      	ldr	r3, [r3, #0]
 800ed00:	f003 0301 	and.w	r3, r3, #1
 800ed04:	2b00      	cmp	r3, #0
 800ed06:	f000 8093 	beq.w	800ee30 <HAL_RCC_ClockConfig+0x238>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(pClkInitStruct->SYSCLKSource));

    /* PLL is selected as System Clock Source */
    if (pClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800ed0a:	687b      	ldr	r3, [r7, #4]
 800ed0c:	685b      	ldr	r3, [r3, #4]
 800ed0e:	2b03      	cmp	r3, #3
 800ed10:	d107      	bne.n	800ed22 <HAL_RCC_ClockConfig+0x12a>
    {
      /* Check the PLL ready flag */
      if (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == 0U)
 800ed12:	4b43      	ldr	r3, [pc, #268]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800ed14:	681b      	ldr	r3, [r3, #0]
 800ed16:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800ed1a:	2b00      	cmp	r3, #0
 800ed1c:	d121      	bne.n	800ed62 <HAL_RCC_ClockConfig+0x16a>
      {
        return HAL_ERROR;
 800ed1e:	2301      	movs	r3, #1
 800ed20:	e113      	b.n	800ef4a <HAL_RCC_ClockConfig+0x352>
      }
    }
    else
    {
      /* HSE is selected as System Clock Source */
      if (pClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800ed22:	687b      	ldr	r3, [r7, #4]
 800ed24:	685b      	ldr	r3, [r3, #4]
 800ed26:	2b02      	cmp	r3, #2
 800ed28:	d107      	bne.n	800ed3a <HAL_RCC_ClockConfig+0x142>
      {
        /* Check the HSE ready flag */
        if (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 800ed2a:	4b3d      	ldr	r3, [pc, #244]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800ed2c:	681b      	ldr	r3, [r3, #0]
 800ed2e:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800ed32:	2b00      	cmp	r3, #0
 800ed34:	d115      	bne.n	800ed62 <HAL_RCC_ClockConfig+0x16a>
        {
          return HAL_ERROR;
 800ed36:	2301      	movs	r3, #1
 800ed38:	e107      	b.n	800ef4a <HAL_RCC_ClockConfig+0x352>
        }
      }
      /* CSI is selected as System Clock Source */
      else if (pClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
 800ed3a:	687b      	ldr	r3, [r7, #4]
 800ed3c:	685b      	ldr	r3, [r3, #4]
 800ed3e:	2b01      	cmp	r3, #1
 800ed40:	d107      	bne.n	800ed52 <HAL_RCC_ClockConfig+0x15a>
      {
        /* Check the CSI ready flag */
        if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) == 0U)
 800ed42:	4b37      	ldr	r3, [pc, #220]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800ed44:	681b      	ldr	r3, [r3, #0]
 800ed46:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800ed4a:	2b00      	cmp	r3, #0
 800ed4c:	d109      	bne.n	800ed62 <HAL_RCC_ClockConfig+0x16a>
        {
          return HAL_ERROR;
 800ed4e:	2301      	movs	r3, #1
 800ed50:	e0fb      	b.n	800ef4a <HAL_RCC_ClockConfig+0x352>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 800ed52:	4b33      	ldr	r3, [pc, #204]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800ed54:	681b      	ldr	r3, [r3, #0]
 800ed56:	f003 0302 	and.w	r3, r3, #2
 800ed5a:	2b00      	cmp	r3, #0
 800ed5c:	d101      	bne.n	800ed62 <HAL_RCC_ClockConfig+0x16a>
        {
          return HAL_ERROR;
 800ed5e:	2301      	movs	r3, #1
 800ed60:	e0f3      	b.n	800ef4a <HAL_RCC_ClockConfig+0x352>
        }
      }
    }

    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SW, pClkInitStruct->SYSCLKSource);
 800ed62:	4b2f      	ldr	r3, [pc, #188]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800ed64:	69db      	ldr	r3, [r3, #28]
 800ed66:	f023 0203 	bic.w	r2, r3, #3
 800ed6a:	687b      	ldr	r3, [r7, #4]
 800ed6c:	685b      	ldr	r3, [r3, #4]
 800ed6e:	492c      	ldr	r1, [pc, #176]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800ed70:	4313      	orrs	r3, r2
 800ed72:	61cb      	str	r3, [r1, #28]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800ed74:	f7ff f82a 	bl	800ddcc <HAL_GetTick>
 800ed78:	60f8      	str	r0, [r7, #12]

    if (pClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800ed7a:	687b      	ldr	r3, [r7, #4]
 800ed7c:	685b      	ldr	r3, [r3, #4]
 800ed7e:	2b03      	cmp	r3, #3
 800ed80:	d112      	bne.n	800eda8 <HAL_RCC_ClockConfig+0x1b0>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800ed82:	e00a      	b.n	800ed9a <HAL_RCC_ClockConfig+0x1a2>
      {
        if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
 800ed84:	f7ff f822 	bl	800ddcc <HAL_GetTick>
 800ed88:	4602      	mov	r2, r0
 800ed8a:	68fb      	ldr	r3, [r7, #12]
 800ed8c:	1ad3      	subs	r3, r2, r3
 800ed8e:	f241 3288 	movw	r2, #5000	@ 0x1388
 800ed92:	4293      	cmp	r3, r2
 800ed94:	d901      	bls.n	800ed9a <HAL_RCC_ClockConfig+0x1a2>
        {
          return HAL_TIMEOUT;
 800ed96:	2303      	movs	r3, #3
 800ed98:	e0d7      	b.n	800ef4a <HAL_RCC_ClockConfig+0x352>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800ed9a:	4b21      	ldr	r3, [pc, #132]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800ed9c:	69db      	ldr	r3, [r3, #28]
 800ed9e:	f003 0318 	and.w	r3, r3, #24
 800eda2:	2b18      	cmp	r3, #24
 800eda4:	d1ee      	bne.n	800ed84 <HAL_RCC_ClockConfig+0x18c>
 800eda6:	e043      	b.n	800ee30 <HAL_RCC_ClockConfig+0x238>
        }
      }
    }
    else
    {
      if (pClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800eda8:	687b      	ldr	r3, [r7, #4]
 800edaa:	685b      	ldr	r3, [r3, #4]
 800edac:	2b02      	cmp	r3, #2
 800edae:	d112      	bne.n	800edd6 <HAL_RCC_ClockConfig+0x1de>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800edb0:	e00a      	b.n	800edc8 <HAL_RCC_ClockConfig+0x1d0>
        {
          if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
 800edb2:	f7ff f80b 	bl	800ddcc <HAL_GetTick>
 800edb6:	4602      	mov	r2, r0
 800edb8:	68fb      	ldr	r3, [r7, #12]
 800edba:	1ad3      	subs	r3, r2, r3
 800edbc:	f241 3288 	movw	r2, #5000	@ 0x1388
 800edc0:	4293      	cmp	r3, r2
 800edc2:	d901      	bls.n	800edc8 <HAL_RCC_ClockConfig+0x1d0>
          {
            return HAL_TIMEOUT;
 800edc4:	2303      	movs	r3, #3
 800edc6:	e0c0      	b.n	800ef4a <HAL_RCC_ClockConfig+0x352>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800edc8:	4b15      	ldr	r3, [pc, #84]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800edca:	69db      	ldr	r3, [r3, #28]
 800edcc:	f003 0318 	and.w	r3, r3, #24
 800edd0:	2b10      	cmp	r3, #16
 800edd2:	d1ee      	bne.n	800edb2 <HAL_RCC_ClockConfig+0x1ba>
 800edd4:	e02c      	b.n	800ee30 <HAL_RCC_ClockConfig+0x238>
          }
        }
      }
      else if (pClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
 800edd6:	687b      	ldr	r3, [r7, #4]
 800edd8:	685b      	ldr	r3, [r3, #4]
 800edda:	2b01      	cmp	r3, #1
 800eddc:	d122      	bne.n	800ee24 <HAL_RCC_ClockConfig+0x22c>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_CSI)
 800edde:	e00a      	b.n	800edf6 <HAL_RCC_ClockConfig+0x1fe>
        {
          if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
 800ede0:	f7fe fff4 	bl	800ddcc <HAL_GetTick>
 800ede4:	4602      	mov	r2, r0
 800ede6:	68fb      	ldr	r3, [r7, #12]
 800ede8:	1ad3      	subs	r3, r2, r3
 800edea:	f241 3288 	movw	r2, #5000	@ 0x1388
 800edee:	4293      	cmp	r3, r2
 800edf0:	d901      	bls.n	800edf6 <HAL_RCC_ClockConfig+0x1fe>
          {
            return HAL_TIMEOUT;
 800edf2:	2303      	movs	r3, #3
 800edf4:	e0a9      	b.n	800ef4a <HAL_RCC_ClockConfig+0x352>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_CSI)
 800edf6:	4b0a      	ldr	r3, [pc, #40]	@ (800ee20 <HAL_RCC_ClockConfig+0x228>)
 800edf8:	69db      	ldr	r3, [r3, #28]
 800edfa:	f003 0318 	and.w	r3, r3, #24
 800edfe:	2b08      	cmp	r3, #8
 800ee00:	d1ee      	bne.n	800ede0 <HAL_RCC_ClockConfig+0x1e8>
 800ee02:	e015      	b.n	800ee30 <HAL_RCC_ClockConfig+0x238>
      }
      else
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
        {
          if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
 800ee04:	f7fe ffe2 	bl	800ddcc <HAL_GetTick>
 800ee08:	4602      	mov	r2, r0
 800ee0a:	68fb      	ldr	r3, [r7, #12]
 800ee0c:	1ad3      	subs	r3, r2, r3
 800ee0e:	f241 3288 	movw	r2, #5000	@ 0x1388
 800ee12:	4293      	cmp	r3, r2
 800ee14:	d906      	bls.n	800ee24 <HAL_RCC_ClockConfig+0x22c>
          {
            return HAL_TIMEOUT;
 800ee16:	2303      	movs	r3, #3
 800ee18:	e097      	b.n	800ef4a <HAL_RCC_ClockConfig+0x352>
 800ee1a:	bf00      	nop
 800ee1c:	40022000 	.word	0x40022000
 800ee20:	44020c00 	.word	0x44020c00
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800ee24:	4b4b      	ldr	r3, [pc, #300]	@ (800ef54 <HAL_RCC_ClockConfig+0x35c>)
 800ee26:	69db      	ldr	r3, [r3, #28]
 800ee28:	f003 0318 	and.w	r3, r3, #24
 800ee2c:	2b00      	cmp	r3, #0
 800ee2e:	d1e9      	bne.n	800ee04 <HAL_RCC_ClockConfig+0x20c>
    }
  }

  /* Decreasing the BUS frequency divider */
  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800ee30:	687b      	ldr	r3, [r7, #4]
 800ee32:	681b      	ldr	r3, [r3, #0]
 800ee34:	f003 0302 	and.w	r3, r3, #2
 800ee38:	2b00      	cmp	r3, #0
 800ee3a:	d010      	beq.n	800ee5e <HAL_RCC_ClockConfig+0x266>
  {
    if ((pClkInitStruct->AHBCLKDivider) < (RCC->CFGR2 & RCC_CFGR2_HPRE))
 800ee3c:	687b      	ldr	r3, [r7, #4]
 800ee3e:	689a      	ldr	r2, [r3, #8]
 800ee40:	4b44      	ldr	r3, [pc, #272]	@ (800ef54 <HAL_RCC_ClockConfig+0x35c>)
 800ee42:	6a1b      	ldr	r3, [r3, #32]
 800ee44:	f003 030f 	and.w	r3, r3, #15
 800ee48:	429a      	cmp	r2, r3
 800ee4a:	d208      	bcs.n	800ee5e <HAL_RCC_ClockConfig+0x266>
    {
      assert_param(IS_RCC_HCLK(pClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pClkInitStruct->AHBCLKDivider);
 800ee4c:	4b41      	ldr	r3, [pc, #260]	@ (800ef54 <HAL_RCC_ClockConfig+0x35c>)
 800ee4e:	6a1b      	ldr	r3, [r3, #32]
 800ee50:	f023 020f 	bic.w	r2, r3, #15
 800ee54:	687b      	ldr	r3, [r7, #4]
 800ee56:	689b      	ldr	r3, [r3, #8]
 800ee58:	493e      	ldr	r1, [pc, #248]	@ (800ef54 <HAL_RCC_ClockConfig+0x35c>)
 800ee5a:	4313      	orrs	r3, r2
 800ee5c:	620b      	str	r3, [r1, #32]
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 800ee5e:	4b3e      	ldr	r3, [pc, #248]	@ (800ef58 <HAL_RCC_ClockConfig+0x360>)
 800ee60:	681b      	ldr	r3, [r3, #0]
 800ee62:	f003 030f 	and.w	r3, r3, #15
 800ee66:	683a      	ldr	r2, [r7, #0]
 800ee68:	429a      	cmp	r2, r3
 800ee6a:	d210      	bcs.n	800ee8e <HAL_RCC_ClockConfig+0x296>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800ee6c:	4b3a      	ldr	r3, [pc, #232]	@ (800ef58 <HAL_RCC_ClockConfig+0x360>)
 800ee6e:	681b      	ldr	r3, [r3, #0]
 800ee70:	f023 020f 	bic.w	r2, r3, #15
 800ee74:	4938      	ldr	r1, [pc, #224]	@ (800ef58 <HAL_RCC_ClockConfig+0x360>)
 800ee76:	683b      	ldr	r3, [r7, #0]
 800ee78:	4313      	orrs	r3, r2
 800ee7a:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800ee7c:	4b36      	ldr	r3, [pc, #216]	@ (800ef58 <HAL_RCC_ClockConfig+0x360>)
 800ee7e:	681b      	ldr	r3, [r3, #0]
 800ee80:	f003 030f 	and.w	r3, r3, #15
 800ee84:	683a      	ldr	r2, [r7, #0]
 800ee86:	429a      	cmp	r2, r3
 800ee88:	d001      	beq.n	800ee8e <HAL_RCC_ClockConfig+0x296>
    {
      return HAL_ERROR;
 800ee8a:	2301      	movs	r3, #1
 800ee8c:	e05d      	b.n	800ef4a <HAL_RCC_ClockConfig+0x352>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800ee8e:	687b      	ldr	r3, [r7, #4]
 800ee90:	681b      	ldr	r3, [r3, #0]
 800ee92:	f003 0304 	and.w	r3, r3, #4
 800ee96:	2b00      	cmp	r3, #0
 800ee98:	d010      	beq.n	800eebc <HAL_RCC_ClockConfig+0x2c4>
  {
    if ((pClkInitStruct->APB1CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE1))
 800ee9a:	687b      	ldr	r3, [r7, #4]
 800ee9c:	68da      	ldr	r2, [r3, #12]
 800ee9e:	4b2d      	ldr	r3, [pc, #180]	@ (800ef54 <HAL_RCC_ClockConfig+0x35c>)
 800eea0:	6a1b      	ldr	r3, [r3, #32]
 800eea2:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 800eea6:	429a      	cmp	r2, r3
 800eea8:	d208      	bcs.n	800eebc <HAL_RCC_ClockConfig+0x2c4>
    {
      assert_param(IS_RCC_PCLK(pClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, pClkInitStruct->APB1CLKDivider);
 800eeaa:	4b2a      	ldr	r3, [pc, #168]	@ (800ef54 <HAL_RCC_ClockConfig+0x35c>)
 800eeac:	6a1b      	ldr	r3, [r3, #32]
 800eeae:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 800eeb2:	687b      	ldr	r3, [r7, #4]
 800eeb4:	68db      	ldr	r3, [r3, #12]
 800eeb6:	4927      	ldr	r1, [pc, #156]	@ (800ef54 <HAL_RCC_ClockConfig+0x35c>)
 800eeb8:	4313      	orrs	r3, r2
 800eeba:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800eebc:	687b      	ldr	r3, [r7, #4]
 800eebe:	681b      	ldr	r3, [r3, #0]
 800eec0:	f003 0308 	and.w	r3, r3, #8
 800eec4:	2b00      	cmp	r3, #0
 800eec6:	d012      	beq.n	800eeee <HAL_RCC_ClockConfig+0x2f6>
  {
    if ((pClkInitStruct->APB2CLKDivider) < ((RCC->CFGR2 & RCC_CFGR2_PPRE2) >> 4))
 800eec8:	687b      	ldr	r3, [r7, #4]
 800eeca:	691a      	ldr	r2, [r3, #16]
 800eecc:	4b21      	ldr	r3, [pc, #132]	@ (800ef54 <HAL_RCC_ClockConfig+0x35c>)
 800eece:	6a1b      	ldr	r3, [r3, #32]
 800eed0:	091b      	lsrs	r3, r3, #4
 800eed2:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 800eed6:	429a      	cmp	r2, r3
 800eed8:	d209      	bcs.n	800eeee <HAL_RCC_ClockConfig+0x2f6>
    {
      assert_param(IS_RCC_PCLK(pClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, ((pClkInitStruct->APB2CLKDivider) << 4));
 800eeda:	4b1e      	ldr	r3, [pc, #120]	@ (800ef54 <HAL_RCC_ClockConfig+0x35c>)
 800eedc:	6a1b      	ldr	r3, [r3, #32]
 800eede:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
 800eee2:	687b      	ldr	r3, [r7, #4]
 800eee4:	691b      	ldr	r3, [r3, #16]
 800eee6:	011b      	lsls	r3, r3, #4
 800eee8:	491a      	ldr	r1, [pc, #104]	@ (800ef54 <HAL_RCC_ClockConfig+0x35c>)
 800eeea:	4313      	orrs	r3, r2
 800eeec:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- PCLK3 Configuration ---------------------------*/
  if (((pClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK3) == RCC_CLOCKTYPE_PCLK3)
 800eeee:	687b      	ldr	r3, [r7, #4]
 800eef0:	681b      	ldr	r3, [r3, #0]
 800eef2:	f003 0310 	and.w	r3, r3, #16
 800eef6:	2b00      	cmp	r3, #0
 800eef8:	d012      	beq.n	800ef20 <HAL_RCC_ClockConfig+0x328>
  {
    if ((pClkInitStruct->APB3CLKDivider) < ((RCC->CFGR2 & RCC_CFGR2_PPRE3) >> 8))
 800eefa:	687b      	ldr	r3, [r7, #4]
 800eefc:	695a      	ldr	r2, [r3, #20]
 800eefe:	4b15      	ldr	r3, [pc, #84]	@ (800ef54 <HAL_RCC_ClockConfig+0x35c>)
 800ef00:	6a1b      	ldr	r3, [r3, #32]
 800ef02:	0a1b      	lsrs	r3, r3, #8
 800ef04:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 800ef08:	429a      	cmp	r2, r3
 800ef0a:	d209      	bcs.n	800ef20 <HAL_RCC_ClockConfig+0x328>
    {
      assert_param(IS_RCC_PCLK(pClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE3, ((pClkInitStruct->APB3CLKDivider) << 8));
 800ef0c:	4b11      	ldr	r3, [pc, #68]	@ (800ef54 <HAL_RCC_ClockConfig+0x35c>)
 800ef0e:	6a1b      	ldr	r3, [r3, #32]
 800ef10:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
 800ef14:	687b      	ldr	r3, [r7, #4]
 800ef16:	695b      	ldr	r3, [r3, #20]
 800ef18:	021b      	lsls	r3, r3, #8
 800ef1a:	490e      	ldr	r1, [pc, #56]	@ (800ef54 <HAL_RCC_ClockConfig+0x35c>)
 800ef1c:	4313      	orrs	r3, r2
 800ef1e:	620b      	str	r3, [r1, #32]
    }
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
 800ef20:	f000 f822 	bl	800ef68 <HAL_RCC_GetSysClockFreq>
 800ef24:	4602      	mov	r2, r0
 800ef26:	4b0b      	ldr	r3, [pc, #44]	@ (800ef54 <HAL_RCC_ClockConfig+0x35c>)
 800ef28:	6a1b      	ldr	r3, [r3, #32]
 800ef2a:	f003 030f 	and.w	r3, r3, #15
 800ef2e:	490b      	ldr	r1, [pc, #44]	@ (800ef5c <HAL_RCC_ClockConfig+0x364>)
 800ef30:	5ccb      	ldrb	r3, [r1, r3]
 800ef32:	fa22 f303 	lsr.w	r3, r2, r3
 800ef36:	4a0a      	ldr	r2, [pc, #40]	@ (800ef60 <HAL_RCC_ClockConfig+0x368>)
 800ef38:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  halstatus = HAL_InitTick(uwTickPrio);
 800ef3a:	4b0a      	ldr	r3, [pc, #40]	@ (800ef64 <HAL_RCC_ClockConfig+0x36c>)
 800ef3c:	681b      	ldr	r3, [r3, #0]
 800ef3e:	4618      	mov	r0, r3
 800ef40:	f7fe feba 	bl	800dcb8 <HAL_InitTick>
 800ef44:	4603      	mov	r3, r0
 800ef46:	72fb      	strb	r3, [r7, #11]

  return halstatus;
 800ef48:	7afb      	ldrb	r3, [r7, #11]
}
 800ef4a:	4618      	mov	r0, r3
 800ef4c:	3710      	adds	r7, #16
 800ef4e:	46bd      	mov	sp, r7
 800ef50:	bd80      	pop	{r7, pc}
 800ef52:	bf00      	nop
 800ef54:	44020c00 	.word	0x44020c00
 800ef58:	40022000 	.word	0x40022000
 800ef5c:	08016fd0 	.word	0x08016fd0
 800ef60:	20000030 	.word	0x20000030
 800ef64:	20000034 	.word	0x20000034

0800ef68 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800ef68:	b480      	push	{r7}
 800ef6a:	b089      	sub	sp, #36	@ 0x24
 800ef6c:	af00      	add	r7, sp, #0
  uint32_t sysclockfreq;
  uint32_t hsivalue;
  float_t fracn1;
  float_t pllvco;

  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_CSI)
 800ef6e:	4b8c      	ldr	r3, [pc, #560]	@ (800f1a0 <HAL_RCC_GetSysClockFreq+0x238>)
 800ef70:	69db      	ldr	r3, [r3, #28]
 800ef72:	f003 0318 	and.w	r3, r3, #24
 800ef76:	2b08      	cmp	r3, #8
 800ef78:	d102      	bne.n	800ef80 <HAL_RCC_GetSysClockFreq+0x18>
  {
    /* CSI used as system clock  source */
    sysclockfreq = CSI_VALUE;
 800ef7a:	4b8a      	ldr	r3, [pc, #552]	@ (800f1a4 <HAL_RCC_GetSysClockFreq+0x23c>)
 800ef7c:	61fb      	str	r3, [r7, #28]
 800ef7e:	e107      	b.n	800f190 <HAL_RCC_GetSysClockFreq+0x228>
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 800ef80:	4b87      	ldr	r3, [pc, #540]	@ (800f1a0 <HAL_RCC_GetSysClockFreq+0x238>)
 800ef82:	69db      	ldr	r3, [r3, #28]
 800ef84:	f003 0318 	and.w	r3, r3, #24
 800ef88:	2b00      	cmp	r3, #0
 800ef8a:	d112      	bne.n	800efb2 <HAL_RCC_GetSysClockFreq+0x4a>
  {
    /* HSI used as system clock source */
    if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIVF) != 0U)
 800ef8c:	4b84      	ldr	r3, [pc, #528]	@ (800f1a0 <HAL_RCC_GetSysClockFreq+0x238>)
 800ef8e:	681b      	ldr	r3, [r3, #0]
 800ef90:	f003 0320 	and.w	r3, r3, #32
 800ef94:	2b00      	cmp	r3, #0
 800ef96:	d009      	beq.n	800efac <HAL_RCC_GetSysClockFreq+0x44>
    {
      sysclockfreq = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 800ef98:	4b81      	ldr	r3, [pc, #516]	@ (800f1a0 <HAL_RCC_GetSysClockFreq+0x238>)
 800ef9a:	681b      	ldr	r3, [r3, #0]
 800ef9c:	08db      	lsrs	r3, r3, #3
 800ef9e:	f003 0303 	and.w	r3, r3, #3
 800efa2:	4a81      	ldr	r2, [pc, #516]	@ (800f1a8 <HAL_RCC_GetSysClockFreq+0x240>)
 800efa4:	fa22 f303 	lsr.w	r3, r2, r3
 800efa8:	61fb      	str	r3, [r7, #28]
 800efaa:	e0f1      	b.n	800f190 <HAL_RCC_GetSysClockFreq+0x228>
    }
    else
    {
      sysclockfreq = (uint32_t) HSI_VALUE;
 800efac:	4b7e      	ldr	r3, [pc, #504]	@ (800f1a8 <HAL_RCC_GetSysClockFreq+0x240>)
 800efae:	61fb      	str	r3, [r7, #28]
 800efb0:	e0ee      	b.n	800f190 <HAL_RCC_GetSysClockFreq+0x228>
    }
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 800efb2:	4b7b      	ldr	r3, [pc, #492]	@ (800f1a0 <HAL_RCC_GetSysClockFreq+0x238>)
 800efb4:	69db      	ldr	r3, [r3, #28]
 800efb6:	f003 0318 	and.w	r3, r3, #24
 800efba:	2b10      	cmp	r3, #16
 800efbc:	d102      	bne.n	800efc4 <HAL_RCC_GetSysClockFreq+0x5c>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
 800efbe:	4b7b      	ldr	r3, [pc, #492]	@ (800f1ac <HAL_RCC_GetSysClockFreq+0x244>)
 800efc0:	61fb      	str	r3, [r7, #28]
 800efc2:	e0e5      	b.n	800f190 <HAL_RCC_GetSysClockFreq+0x228>
  }

  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800efc4:	4b76      	ldr	r3, [pc, #472]	@ (800f1a0 <HAL_RCC_GetSysClockFreq+0x238>)
 800efc6:	69db      	ldr	r3, [r3, #28]
 800efc8:	f003 0318 	and.w	r3, r3, #24
 800efcc:	2b18      	cmp	r3, #24
 800efce:	f040 80dd 	bne.w	800f18c <HAL_RCC_GetSysClockFreq+0x224>
    /* PLL used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1SRC);
 800efd2:	4b73      	ldr	r3, [pc, #460]	@ (800f1a0 <HAL_RCC_GetSysClockFreq+0x238>)
 800efd4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800efd6:	f003 0303 	and.w	r3, r3, #3
 800efda:	617b      	str	r3, [r7, #20]
    pllm = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos);
 800efdc:	4b70      	ldr	r3, [pc, #448]	@ (800f1a0 <HAL_RCC_GetSysClockFreq+0x238>)
 800efde:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800efe0:	0a1b      	lsrs	r3, r3, #8
 800efe2:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800efe6:	613b      	str	r3, [r7, #16]
    pllfracen = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1FRACEN) >> RCC_PLL1CFGR_PLL1FRACEN_Pos);
 800efe8:	4b6d      	ldr	r3, [pc, #436]	@ (800f1a0 <HAL_RCC_GetSysClockFreq+0x238>)
 800efea:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800efec:	091b      	lsrs	r3, r3, #4
 800efee:	f003 0301 	and.w	r3, r3, #1
 800eff2:	60fb      	str	r3, [r7, #12]
    fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & \
 800eff4:	4b6a      	ldr	r3, [pc, #424]	@ (800f1a0 <HAL_RCC_GetSysClockFreq+0x238>)
 800eff6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
                                               RCC_PLL1FRACR_PLL1FRACN) >> RCC_PLL1FRACR_PLL1FRACN_Pos));
 800eff8:	08db      	lsrs	r3, r3, #3
 800effa:	f3c3 030c 	ubfx	r3, r3, #0, #13
    fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & \
 800effe:	68fa      	ldr	r2, [r7, #12]
 800f000:	fb02 f303 	mul.w	r3, r2, r3
 800f004:	ee07 3a90 	vmov	s15, r3
 800f008:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800f00c:	edc7 7a02 	vstr	s15, [r7, #8]

    if (pllm != 0U)
 800f010:	693b      	ldr	r3, [r7, #16]
 800f012:	2b00      	cmp	r3, #0
 800f014:	f000 80b7 	beq.w	800f186 <HAL_RCC_GetSysClockFreq+0x21e>
    {
      switch (pllsource)
 800f018:	697b      	ldr	r3, [r7, #20]
 800f01a:	2b01      	cmp	r3, #1
 800f01c:	d003      	beq.n	800f026 <HAL_RCC_GetSysClockFreq+0xbe>
 800f01e:	697b      	ldr	r3, [r7, #20]
 800f020:	2b03      	cmp	r3, #3
 800f022:	d056      	beq.n	800f0d2 <HAL_RCC_GetSysClockFreq+0x16a>
 800f024:	e077      	b.n	800f116 <HAL_RCC_GetSysClockFreq+0x1ae>
      {
        case RCC_PLL1_SOURCE_HSI:  /* HSI used as PLL1 clock source */

          if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIVF) != 0U)
 800f026:	4b5e      	ldr	r3, [pc, #376]	@ (800f1a0 <HAL_RCC_GetSysClockFreq+0x238>)
 800f028:	681b      	ldr	r3, [r3, #0]
 800f02a:	f003 0320 	and.w	r3, r3, #32
 800f02e:	2b00      	cmp	r3, #0
 800f030:	d02d      	beq.n	800f08e <HAL_RCC_GetSysClockFreq+0x126>
          {
            hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 800f032:	4b5b      	ldr	r3, [pc, #364]	@ (800f1a0 <HAL_RCC_GetSysClockFreq+0x238>)
 800f034:	681b      	ldr	r3, [r3, #0]
 800f036:	08db      	lsrs	r3, r3, #3
 800f038:	f003 0303 	and.w	r3, r3, #3
 800f03c:	4a5a      	ldr	r2, [pc, #360]	@ (800f1a8 <HAL_RCC_GetSysClockFreq+0x240>)
 800f03e:	fa22 f303 	lsr.w	r3, r2, r3
 800f042:	607b      	str	r3, [r7, #4]
            pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800f044:	687b      	ldr	r3, [r7, #4]
 800f046:	ee07 3a90 	vmov	s15, r3
 800f04a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800f04e:	693b      	ldr	r3, [r7, #16]
 800f050:	ee07 3a90 	vmov	s15, r3
 800f054:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800f058:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800f05c:	4b50      	ldr	r3, [pc, #320]	@ (800f1a0 <HAL_RCC_GetSysClockFreq+0x238>)
 800f05e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800f060:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800f064:	ee07 3a90 	vmov	s15, r3
 800f068:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                            (fracn1 / (float_t)0x2000) + (float_t)1);
 800f06c:	ed97 6a02 	vldr	s12, [r7, #8]
 800f070:	eddf 5a4f 	vldr	s11, [pc, #316]	@ 800f1b0 <HAL_RCC_GetSysClockFreq+0x248>
 800f074:	eec6 7a25 	vdiv.f32	s15, s12, s11
            pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800f078:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                            (fracn1 / (float_t)0x2000) + (float_t)1);
 800f07c:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800f080:	ee77 7aa6 	vadd.f32	s15, s15, s13
            pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800f084:	ee67 7a27 	vmul.f32	s15, s14, s15
 800f088:	edc7 7a06 	vstr	s15, [r7, #24]
          {
            pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
                                                             (fracn1 / (float_t)0x2000) + (float_t)1);
          }

          break;
 800f08c:	e065      	b.n	800f15a <HAL_RCC_GetSysClockFreq+0x1f2>
            pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800f08e:	693b      	ldr	r3, [r7, #16]
 800f090:	ee07 3a90 	vmov	s15, r3
 800f094:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800f098:	eddf 6a46 	vldr	s13, [pc, #280]	@ 800f1b4 <HAL_RCC_GetSysClockFreq+0x24c>
 800f09c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800f0a0:	4b3f      	ldr	r3, [pc, #252]	@ (800f1a0 <HAL_RCC_GetSysClockFreq+0x238>)
 800f0a2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800f0a4:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800f0a8:	ee07 3a90 	vmov	s15, r3
 800f0ac:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                             (fracn1 / (float_t)0x2000) + (float_t)1);
 800f0b0:	ed97 6a02 	vldr	s12, [r7, #8]
 800f0b4:	eddf 5a3e 	vldr	s11, [pc, #248]	@ 800f1b0 <HAL_RCC_GetSysClockFreq+0x248>
 800f0b8:	eec6 7a25 	vdiv.f32	s15, s12, s11
            pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800f0bc:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                             (fracn1 / (float_t)0x2000) + (float_t)1);
 800f0c0:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800f0c4:	ee77 7aa6 	vadd.f32	s15, s15, s13
            pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800f0c8:	ee67 7a27 	vmul.f32	s15, s14, s15
 800f0cc:	edc7 7a06 	vstr	s15, [r7, #24]
          break;
 800f0d0:	e043      	b.n	800f15a <HAL_RCC_GetSysClockFreq+0x1f2>

        case RCC_PLL1_SOURCE_HSE:  /* HSE used as PLL1 clock source */
          pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800f0d2:	693b      	ldr	r3, [r7, #16]
 800f0d4:	ee07 3a90 	vmov	s15, r3
 800f0d8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800f0dc:	eddf 6a36 	vldr	s13, [pc, #216]	@ 800f1b8 <HAL_RCC_GetSysClockFreq+0x250>
 800f0e0:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800f0e4:	4b2e      	ldr	r3, [pc, #184]	@ (800f1a0 <HAL_RCC_GetSysClockFreq+0x238>)
 800f0e6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800f0e8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800f0ec:	ee07 3a90 	vmov	s15, r3
 800f0f0:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                           (fracn1 / (float_t)0x2000) + (float_t)1);
 800f0f4:	ed97 6a02 	vldr	s12, [r7, #8]
 800f0f8:	eddf 5a2d 	vldr	s11, [pc, #180]	@ 800f1b0 <HAL_RCC_GetSysClockFreq+0x248>
 800f0fc:	eec6 7a25 	vdiv.f32	s15, s12, s11
          pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800f100:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                           (fracn1 / (float_t)0x2000) + (float_t)1);
 800f104:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800f108:	ee77 7aa6 	vadd.f32	s15, s15, s13
          pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800f10c:	ee67 7a27 	vmul.f32	s15, s14, s15
 800f110:	edc7 7a06 	vstr	s15, [r7, #24]

          break;
 800f114:	e021      	b.n	800f15a <HAL_RCC_GetSysClockFreq+0x1f2>

        case RCC_PLL1_SOURCE_CSI:  /* CSI used as PLL1 clock source */
        default:
          pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800f116:	693b      	ldr	r3, [r7, #16]
 800f118:	ee07 3a90 	vmov	s15, r3
 800f11c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800f120:	eddf 6a26 	vldr	s13, [pc, #152]	@ 800f1bc <HAL_RCC_GetSysClockFreq+0x254>
 800f124:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800f128:	4b1d      	ldr	r3, [pc, #116]	@ (800f1a0 <HAL_RCC_GetSysClockFreq+0x238>)
 800f12a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800f12c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800f130:	ee07 3a90 	vmov	s15, r3
 800f134:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                           (fracn1 / (float_t)0x2000) + (float_t)1);
 800f138:	ed97 6a02 	vldr	s12, [r7, #8]
 800f13c:	eddf 5a1c 	vldr	s11, [pc, #112]	@ 800f1b0 <HAL_RCC_GetSysClockFreq+0x248>
 800f140:	eec6 7a25 	vdiv.f32	s15, s12, s11
          pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800f144:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                           (fracn1 / (float_t)0x2000) + (float_t)1);
 800f148:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800f14c:	ee77 7aa6 	vadd.f32	s15, s15, s13
          pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800f150:	ee67 7a27 	vmul.f32	s15, s14, s15
 800f154:	edc7 7a06 	vstr	s15, [r7, #24]
          break;
 800f158:	bf00      	nop
      }

      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1P) >> RCC_PLL1DIVR_PLL1P_Pos) + 1U) ;
 800f15a:	4b11      	ldr	r3, [pc, #68]	@ (800f1a0 <HAL_RCC_GetSysClockFreq+0x238>)
 800f15c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800f15e:	0a5b      	lsrs	r3, r3, #9
 800f160:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800f164:	3301      	adds	r3, #1
 800f166:	603b      	str	r3, [r7, #0]
      sysclockfreq = (uint32_t)(float_t)(pllvco / (float_t)pllp);
 800f168:	683b      	ldr	r3, [r7, #0]
 800f16a:	ee07 3a90 	vmov	s15, r3
 800f16e:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 800f172:	edd7 6a06 	vldr	s13, [r7, #24]
 800f176:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800f17a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800f17e:	ee17 3a90 	vmov	r3, s15
 800f182:	61fb      	str	r3, [r7, #28]
 800f184:	e004      	b.n	800f190 <HAL_RCC_GetSysClockFreq+0x228>
    }
    else
    {
      sysclockfreq = 0;
 800f186:	2300      	movs	r3, #0
 800f188:	61fb      	str	r3, [r7, #28]
 800f18a:	e001      	b.n	800f190 <HAL_RCC_GetSysClockFreq+0x228>
  }

  else
  {
    /* HSI is the default system clock source */
    sysclockfreq = (uint32_t) HSI_VALUE;
 800f18c:	4b06      	ldr	r3, [pc, #24]	@ (800f1a8 <HAL_RCC_GetSysClockFreq+0x240>)
 800f18e:	61fb      	str	r3, [r7, #28]
  }

  return sysclockfreq;
 800f190:	69fb      	ldr	r3, [r7, #28]
}
 800f192:	4618      	mov	r0, r3
 800f194:	3724      	adds	r7, #36	@ 0x24
 800f196:	46bd      	mov	sp, r7
 800f198:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f19c:	4770      	bx	lr
 800f19e:	bf00      	nop
 800f1a0:	44020c00 	.word	0x44020c00
 800f1a4:	003d0900 	.word	0x003d0900
 800f1a8:	03d09000 	.word	0x03d09000
 800f1ac:	017d7840 	.word	0x017d7840
 800f1b0:	46000000 	.word	0x46000000
 800f1b4:	4c742400 	.word	0x4c742400
 800f1b8:	4bbebc20 	.word	0x4bbebc20
 800f1bc:	4a742400 	.word	0x4a742400

0800f1c0 <HAL_RCC_GetHCLKFreq>:
  *
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800f1c0:	b580      	push	{r7, lr}
 800f1c2:	af00      	add	r7, sp, #0

  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) \
 800f1c4:	f7ff fed0 	bl	800ef68 <HAL_RCC_GetSysClockFreq>
 800f1c8:	4602      	mov	r2, r0
 800f1ca:	4b08      	ldr	r3, [pc, #32]	@ (800f1ec <HAL_RCC_GetHCLKFreq+0x2c>)
 800f1cc:	6a1b      	ldr	r3, [r3, #32]
                                                                >> RCC_CFGR2_HPRE_Pos] & 0x1FU);
 800f1ce:	f003 030f 	and.w	r3, r3, #15
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) \
 800f1d2:	4907      	ldr	r1, [pc, #28]	@ (800f1f0 <HAL_RCC_GetHCLKFreq+0x30>)
 800f1d4:	5ccb      	ldrb	r3, [r1, r3]
                                                                >> RCC_CFGR2_HPRE_Pos] & 0x1FU);
 800f1d6:	f003 031f 	and.w	r3, r3, #31
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) \
 800f1da:	fa22 f303 	lsr.w	r3, r2, r3
 800f1de:	4a05      	ldr	r2, [pc, #20]	@ (800f1f4 <HAL_RCC_GetHCLKFreq+0x34>)
 800f1e0:	6013      	str	r3, [r2, #0]

  return SystemCoreClock;
 800f1e2:	4b04      	ldr	r3, [pc, #16]	@ (800f1f4 <HAL_RCC_GetHCLKFreq+0x34>)
 800f1e4:	681b      	ldr	r3, [r3, #0]
}
 800f1e6:	4618      	mov	r0, r3
 800f1e8:	bd80      	pop	{r7, pc}
 800f1ea:	bf00      	nop
 800f1ec:	44020c00 	.word	0x44020c00
 800f1f0:	08016fd0 	.word	0x08016fd0
 800f1f4:	20000030 	.word	0x20000030

0800f1f8 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 800f1f8:	b580      	push	{r7, lr}
 800f1fa:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((APBPrescTable[(RCC->CFGR2 & RCC_CFGR2_PPRE1) >> RCC_CFGR2_PPRE1_Pos]) & 0x1FU));
 800f1fc:	f7ff ffe0 	bl	800f1c0 <HAL_RCC_GetHCLKFreq>
 800f200:	4602      	mov	r2, r0
 800f202:	4b06      	ldr	r3, [pc, #24]	@ (800f21c <HAL_RCC_GetPCLK1Freq+0x24>)
 800f204:	6a1b      	ldr	r3, [r3, #32]
 800f206:	091b      	lsrs	r3, r3, #4
 800f208:	f003 0307 	and.w	r3, r3, #7
 800f20c:	4904      	ldr	r1, [pc, #16]	@ (800f220 <HAL_RCC_GetPCLK1Freq+0x28>)
 800f20e:	5ccb      	ldrb	r3, [r1, r3]
 800f210:	f003 031f 	and.w	r3, r3, #31
 800f214:	fa22 f303 	lsr.w	r3, r2, r3
}
 800f218:	4618      	mov	r0, r3
 800f21a:	bd80      	pop	{r7, pc}
 800f21c:	44020c00 	.word	0x44020c00
 800f220:	08016fe0 	.word	0x08016fe0

0800f224 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800f224:	b580      	push	{r7, lr}
 800f226:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((APBPrescTable[(RCC->CFGR2 & RCC_CFGR2_PPRE2) >> RCC_CFGR2_PPRE2_Pos]) & 0x1FU));
 800f228:	f7ff ffca 	bl	800f1c0 <HAL_RCC_GetHCLKFreq>
 800f22c:	4602      	mov	r2, r0
 800f22e:	4b06      	ldr	r3, [pc, #24]	@ (800f248 <HAL_RCC_GetPCLK2Freq+0x24>)
 800f230:	6a1b      	ldr	r3, [r3, #32]
 800f232:	0a1b      	lsrs	r3, r3, #8
 800f234:	f003 0307 	and.w	r3, r3, #7
 800f238:	4904      	ldr	r1, [pc, #16]	@ (800f24c <HAL_RCC_GetPCLK2Freq+0x28>)
 800f23a:	5ccb      	ldrb	r3, [r1, r3]
 800f23c:	f003 031f 	and.w	r3, r3, #31
 800f240:	fa22 f303 	lsr.w	r3, r2, r3
}
 800f244:	4618      	mov	r0, r3
 800f246:	bd80      	pop	{r7, pc}
 800f248:	44020c00 	.word	0x44020c00
 800f24c:	08016fe0 	.word	0x08016fe0

0800f250 <HAL_RCC_GetPCLK3Freq>:
  * @note   Each time PCLK3 changes, this function must be called to update the
  *         right PCLK3 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK3 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK3Freq(void)
{
 800f250:	b580      	push	{r7, lr}
 800f252:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK3 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((APBPrescTable[(RCC->CFGR2 & RCC_CFGR2_PPRE3) >> RCC_CFGR2_PPRE3_Pos]) & 0x1FU));
 800f254:	f7ff ffb4 	bl	800f1c0 <HAL_RCC_GetHCLKFreq>
 800f258:	4602      	mov	r2, r0
 800f25a:	4b06      	ldr	r3, [pc, #24]	@ (800f274 <HAL_RCC_GetPCLK3Freq+0x24>)
 800f25c:	6a1b      	ldr	r3, [r3, #32]
 800f25e:	0b1b      	lsrs	r3, r3, #12
 800f260:	f003 0307 	and.w	r3, r3, #7
 800f264:	4904      	ldr	r1, [pc, #16]	@ (800f278 <HAL_RCC_GetPCLK3Freq+0x28>)
 800f266:	5ccb      	ldrb	r3, [r1, r3]
 800f268:	f003 031f 	and.w	r3, r3, #31
 800f26c:	fa22 f303 	lsr.w	r3, r2, r3
}
 800f270:	4618      	mov	r0, r3
 800f272:	bd80      	pop	{r7, pc}
 800f274:	44020c00 	.word	0x44020c00
 800f278:	08016fe0 	.word	0x08016fe0

0800f27c <HAL_RCCEx_PeriphCLKConfig>:
  *  (*)   : For stm32h56xxx and stm32h57xxx family lines only.
  *  (**)  : For stm32h563xx and stm32h57xxx family lines only.
  *  (***) : For stm32h503xx family line only.
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(const RCC_PeriphCLKInitTypeDef  *pPeriphClkInit)
{
 800f27c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800f280:	b0d8      	sub	sp, #352	@ 0x160
 800f282:	af00      	add	r7, sp, #0
 800f284:	f8c7 014c 	str.w	r0, [r7, #332]	@ 0x14c
  uint32_t tmpregister;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 800f288:	2300      	movs	r3, #0
 800f28a:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 800f28e:	2300      	movs	r3, #0
 800f290:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(pPeriphClkInit->PeriphClockSelection));

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
 800f294:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f298:	e9d3 2300 	ldrd	r2, r3, [r3]
 800f29c:	f002 7480 	and.w	r4, r2, #16777216	@ 0x1000000
 800f2a0:	2500      	movs	r5, #0
 800f2a2:	ea54 0305 	orrs.w	r3, r4, r5
 800f2a6:	d00b      	beq.n	800f2c0 <HAL_RCCEx_PeriphCLKConfig+0x44>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLKPSOURCE(pPeriphClkInit->CkperClockSelection));

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(pPeriphClkInit->CkperClockSelection);
 800f2a8:	4bcd      	ldr	r3, [pc, #820]	@ (800f5e0 <HAL_RCCEx_PeriphCLKConfig+0x364>)
 800f2aa:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 800f2ae:	f023 4140 	bic.w	r1, r3, #3221225472	@ 0xc0000000
 800f2b2:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f2b6:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800f2b8:	4ac9      	ldr	r2, [pc, #804]	@ (800f5e0 <HAL_RCCEx_PeriphCLKConfig+0x364>)
 800f2ba:	430b      	orrs	r3, r1
 800f2bc:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 800f2c0:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f2c4:	e9d3 2300 	ldrd	r2, r3, [r3]
 800f2c8:	f002 0801 	and.w	r8, r2, #1
 800f2cc:	f04f 0900 	mov.w	r9, #0
 800f2d0:	ea58 0309 	orrs.w	r3, r8, r9
 800f2d4:	d042      	beq.n	800f35c <HAL_RCCEx_PeriphCLKConfig+0xe0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(pPeriphClkInit->Usart1ClockSelection));

    switch (pPeriphClkInit->Usart1ClockSelection)
 800f2d6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f2da:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800f2dc:	2b05      	cmp	r3, #5
 800f2de:	d823      	bhi.n	800f328 <HAL_RCCEx_PeriphCLKConfig+0xac>
 800f2e0:	a201      	add	r2, pc, #4	@ (adr r2, 800f2e8 <HAL_RCCEx_PeriphCLKConfig+0x6c>)
 800f2e2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800f2e6:	bf00      	nop
 800f2e8:	0800f331 	.word	0x0800f331
 800f2ec:	0800f301 	.word	0x0800f301
 800f2f0:	0800f315 	.word	0x0800f315
 800f2f4:	0800f331 	.word	0x0800f331
 800f2f8:	0800f331 	.word	0x0800f331
 800f2fc:	0800f331 	.word	0x0800f331
        /* USART1 clock source config set later after clock selection check */
        break;

      case RCC_USART1CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for USART1*/
        /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 800f300:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f304:	3308      	adds	r3, #8
 800f306:	4618      	mov	r0, r3
 800f308:	f004 fee0 	bl	80140cc <RCCEx_PLL2_Config>
 800f30c:	4603      	mov	r3, r0
 800f30e:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* USART1 clock source config set later after clock selection check */
        break;
 800f312:	e00e      	b.n	800f332 <HAL_RCCEx_PeriphCLKConfig+0xb6>
#if defined(RCC_USART1CLKSOURCE_PLL3Q)
      case RCC_USART1CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for USART1*/
        /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 800f314:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f318:	3330      	adds	r3, #48	@ 0x30
 800f31a:	4618      	mov	r0, r3
 800f31c:	f004 ff6e 	bl	80141fc <RCCEx_PLL3_Config>
 800f320:	4603      	mov	r3, r0
 800f322:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* USART1 clock source config set later after clock selection check */
        break;
 800f326:	e004      	b.n	800f332 <HAL_RCCEx_PeriphCLKConfig+0xb6>
      case RCC_USART1CLKSOURCE_LSE:      /* LSE clock is used as source of USART1 clock*/
        /* USART1 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800f328:	2301      	movs	r3, #1
 800f32a:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 800f32e:	e000      	b.n	800f332 <HAL_RCCEx_PeriphCLKConfig+0xb6>
        break;
 800f330:	bf00      	nop
    }

    if (ret == HAL_OK)
 800f332:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800f336:	2b00      	cmp	r3, #0
 800f338:	d10c      	bne.n	800f354 <HAL_RCCEx_PeriphCLKConfig+0xd8>
    {
      /* Set the source of USART1 clock*/
      __HAL_RCC_USART1_CONFIG(pPeriphClkInit->Usart1ClockSelection);
 800f33a:	4ba9      	ldr	r3, [pc, #676]	@ (800f5e0 <HAL_RCCEx_PeriphCLKConfig+0x364>)
 800f33c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 800f340:	f023 0107 	bic.w	r1, r3, #7
 800f344:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f348:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800f34a:	4aa5      	ldr	r2, [pc, #660]	@ (800f5e0 <HAL_RCCEx_PeriphCLKConfig+0x364>)
 800f34c:	430b      	orrs	r3, r1
 800f34e:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
 800f352:	e003      	b.n	800f35c <HAL_RCCEx_PeriphCLKConfig+0xe0>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800f354:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800f358:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
    }
  }

  /*-------------------------- USART2 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 800f35c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f360:	e9d3 2300 	ldrd	r2, r3, [r3]
 800f364:	f002 0a02 	and.w	sl, r2, #2
 800f368:	f04f 0b00 	mov.w	fp, #0
 800f36c:	ea5a 030b 	orrs.w	r3, sl, fp
 800f370:	f000 8088 	beq.w	800f484 <HAL_RCCEx_PeriphCLKConfig+0x208>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(pPeriphClkInit->Usart2ClockSelection));

    switch (pPeriphClkInit->Usart2ClockSelection)
 800f374:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f378:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 800f37a:	2b28      	cmp	r3, #40	@ 0x28
 800f37c:	d868      	bhi.n	800f450 <HAL_RCCEx_PeriphCLKConfig+0x1d4>
 800f37e:	a201      	add	r2, pc, #4	@ (adr r2, 800f384 <HAL_RCCEx_PeriphCLKConfig+0x108>)
 800f380:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800f384:	0800f459 	.word	0x0800f459
 800f388:	0800f451 	.word	0x0800f451
 800f38c:	0800f451 	.word	0x0800f451
 800f390:	0800f451 	.word	0x0800f451
 800f394:	0800f451 	.word	0x0800f451
 800f398:	0800f451 	.word	0x0800f451
 800f39c:	0800f451 	.word	0x0800f451
 800f3a0:	0800f451 	.word	0x0800f451
 800f3a4:	0800f429 	.word	0x0800f429
 800f3a8:	0800f451 	.word	0x0800f451
 800f3ac:	0800f451 	.word	0x0800f451
 800f3b0:	0800f451 	.word	0x0800f451
 800f3b4:	0800f451 	.word	0x0800f451
 800f3b8:	0800f451 	.word	0x0800f451
 800f3bc:	0800f451 	.word	0x0800f451
 800f3c0:	0800f451 	.word	0x0800f451
 800f3c4:	0800f43d 	.word	0x0800f43d
 800f3c8:	0800f451 	.word	0x0800f451
 800f3cc:	0800f451 	.word	0x0800f451
 800f3d0:	0800f451 	.word	0x0800f451
 800f3d4:	0800f451 	.word	0x0800f451
 800f3d8:	0800f451 	.word	0x0800f451
 800f3dc:	0800f451 	.word	0x0800f451
 800f3e0:	0800f451 	.word	0x0800f451
 800f3e4:	0800f459 	.word	0x0800f459
 800f3e8:	0800f451 	.word	0x0800f451
 800f3ec:	0800f451 	.word	0x0800f451
 800f3f0:	0800f451 	.word	0x0800f451
 800f3f4:	0800f451 	.word	0x0800f451
 800f3f8:	0800f451 	.word	0x0800f451
 800f3fc:	0800f451 	.word	0x0800f451
 800f400:	0800f451 	.word	0x0800f451
 800f404:	0800f459 	.word	0x0800f459
 800f408:	0800f451 	.word	0x0800f451
 800f40c:	0800f451 	.word	0x0800f451
 800f410:	0800f451 	.word	0x0800f451
 800f414:	0800f451 	.word	0x0800f451
 800f418:	0800f451 	.word	0x0800f451
 800f41c:	0800f451 	.word	0x0800f451
 800f420:	0800f451 	.word	0x0800f451
 800f424:	0800f459 	.word	0x0800f459
        /* USART2 clock source config set later after clock selection check */
        break;

      case RCC_USART2CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for USART2*/
        /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 800f428:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f42c:	3308      	adds	r3, #8
 800f42e:	4618      	mov	r0, r3
 800f430:	f004 fe4c 	bl	80140cc <RCCEx_PLL2_Config>
 800f434:	4603      	mov	r3, r0
 800f436:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* USART2 clock source config set later after clock selection check */
        break;
 800f43a:	e00e      	b.n	800f45a <HAL_RCCEx_PeriphCLKConfig+0x1de>

#if defined(RCC_USART2CLKSOURCE_PLL3Q)
      case RCC_USART2CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for USART2*/
        /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 800f43c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f440:	3330      	adds	r3, #48	@ 0x30
 800f442:	4618      	mov	r0, r3
 800f444:	f004 feda 	bl	80141fc <RCCEx_PLL3_Config>
 800f448:	4603      	mov	r3, r0
 800f44a:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* USART2 clock source config set later after clock selection check */
        break;
 800f44e:	e004      	b.n	800f45a <HAL_RCCEx_PeriphCLKConfig+0x1de>
      case RCC_USART2CLKSOURCE_LSE:      /* LSE clock is used as source of USART2 clock*/
        /* USART2 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800f450:	2301      	movs	r3, #1
 800f452:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 800f456:	e000      	b.n	800f45a <HAL_RCCEx_PeriphCLKConfig+0x1de>
        break;
 800f458:	bf00      	nop
    }

    if (ret == HAL_OK)
 800f45a:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800f45e:	2b00      	cmp	r3, #0
 800f460:	d10c      	bne.n	800f47c <HAL_RCCEx_PeriphCLKConfig+0x200>
    {
      /* Set the source of USART2 clock*/
      __HAL_RCC_USART2_CONFIG(pPeriphClkInit->Usart2ClockSelection);
 800f462:	4b5f      	ldr	r3, [pc, #380]	@ (800f5e0 <HAL_RCCEx_PeriphCLKConfig+0x364>)
 800f464:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 800f468:	f023 0138 	bic.w	r1, r3, #56	@ 0x38
 800f46c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f470:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 800f472:	4a5b      	ldr	r2, [pc, #364]	@ (800f5e0 <HAL_RCCEx_PeriphCLKConfig+0x364>)
 800f474:	430b      	orrs	r3, r1
 800f476:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
 800f47a:	e003      	b.n	800f484 <HAL_RCCEx_PeriphCLKConfig+0x208>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800f47c:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800f480:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
    }
  }

  /*-------------------------- USART3 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 800f484:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f488:	e9d3 2300 	ldrd	r2, r3, [r3]
 800f48c:	f002 0304 	and.w	r3, r2, #4
 800f490:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 800f494:	2300      	movs	r3, #0
 800f496:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
 800f49a:	e9d7 1250 	ldrd	r1, r2, [r7, #320]	@ 0x140
 800f49e:	460b      	mov	r3, r1
 800f4a0:	4313      	orrs	r3, r2
 800f4a2:	d04e      	beq.n	800f542 <HAL_RCCEx_PeriphCLKConfig+0x2c6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(pPeriphClkInit->Usart3ClockSelection));

    switch (pPeriphClkInit->Usart3ClockSelection)
 800f4a4:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f4a8:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800f4aa:	f5b3 7fa0 	cmp.w	r3, #320	@ 0x140
 800f4ae:	d02c      	beq.n	800f50a <HAL_RCCEx_PeriphCLKConfig+0x28e>
 800f4b0:	f5b3 7fa0 	cmp.w	r3, #320	@ 0x140
 800f4b4:	d825      	bhi.n	800f502 <HAL_RCCEx_PeriphCLKConfig+0x286>
 800f4b6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800f4ba:	d028      	beq.n	800f50e <HAL_RCCEx_PeriphCLKConfig+0x292>
 800f4bc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800f4c0:	d81f      	bhi.n	800f502 <HAL_RCCEx_PeriphCLKConfig+0x286>
 800f4c2:	2bc0      	cmp	r3, #192	@ 0xc0
 800f4c4:	d025      	beq.n	800f512 <HAL_RCCEx_PeriphCLKConfig+0x296>
 800f4c6:	2bc0      	cmp	r3, #192	@ 0xc0
 800f4c8:	d81b      	bhi.n	800f502 <HAL_RCCEx_PeriphCLKConfig+0x286>
 800f4ca:	2b80      	cmp	r3, #128	@ 0x80
 800f4cc:	d00f      	beq.n	800f4ee <HAL_RCCEx_PeriphCLKConfig+0x272>
 800f4ce:	2b80      	cmp	r3, #128	@ 0x80
 800f4d0:	d817      	bhi.n	800f502 <HAL_RCCEx_PeriphCLKConfig+0x286>
 800f4d2:	2b00      	cmp	r3, #0
 800f4d4:	d01f      	beq.n	800f516 <HAL_RCCEx_PeriphCLKConfig+0x29a>
 800f4d6:	2b40      	cmp	r3, #64	@ 0x40
 800f4d8:	d113      	bne.n	800f502 <HAL_RCCEx_PeriphCLKConfig+0x286>
        /* USART3 clock source config set later after clock selection check */
        break;

      case RCC_USART3CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for USART3*/
        /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 800f4da:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f4de:	3308      	adds	r3, #8
 800f4e0:	4618      	mov	r0, r3
 800f4e2:	f004 fdf3 	bl	80140cc <RCCEx_PLL2_Config>
 800f4e6:	4603      	mov	r3, r0
 800f4e8:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* USART3 clock source config set later after clock selection check */
        break;
 800f4ec:	e014      	b.n	800f518 <HAL_RCCEx_PeriphCLKConfig+0x29c>

#if defined(RCC_USART3CLKSOURCE_PLL3Q)
      case RCC_USART3CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for USART3*/
        /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 800f4ee:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f4f2:	3330      	adds	r3, #48	@ 0x30
 800f4f4:	4618      	mov	r0, r3
 800f4f6:	f004 fe81 	bl	80141fc <RCCEx_PLL3_Config>
 800f4fa:	4603      	mov	r3, r0
 800f4fc:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* USART3 clock source config set later after clock selection check */
        break;
 800f500:	e00a      	b.n	800f518 <HAL_RCCEx_PeriphCLKConfig+0x29c>
      case RCC_USART3CLKSOURCE_LSE:      /* LSE clock is used as source of USART3 clock*/
        /* USART3 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800f502:	2301      	movs	r3, #1
 800f504:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 800f508:	e006      	b.n	800f518 <HAL_RCCEx_PeriphCLKConfig+0x29c>
        break;
 800f50a:	bf00      	nop
 800f50c:	e004      	b.n	800f518 <HAL_RCCEx_PeriphCLKConfig+0x29c>
        break;
 800f50e:	bf00      	nop
 800f510:	e002      	b.n	800f518 <HAL_RCCEx_PeriphCLKConfig+0x29c>
        break;
 800f512:	bf00      	nop
 800f514:	e000      	b.n	800f518 <HAL_RCCEx_PeriphCLKConfig+0x29c>
        break;
 800f516:	bf00      	nop
    }

    if (ret == HAL_OK)
 800f518:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800f51c:	2b00      	cmp	r3, #0
 800f51e:	d10c      	bne.n	800f53a <HAL_RCCEx_PeriphCLKConfig+0x2be>
    {
      /* Set the source of USART3 clock*/
      __HAL_RCC_USART3_CONFIG(pPeriphClkInit->Usart3ClockSelection);
 800f520:	4b2f      	ldr	r3, [pc, #188]	@ (800f5e0 <HAL_RCCEx_PeriphCLKConfig+0x364>)
 800f522:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 800f526:	f423 71e0 	bic.w	r1, r3, #448	@ 0x1c0
 800f52a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f52e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800f530:	4a2b      	ldr	r2, [pc, #172]	@ (800f5e0 <HAL_RCCEx_PeriphCLKConfig+0x364>)
 800f532:	430b      	orrs	r3, r1
 800f534:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
 800f538:	e003      	b.n	800f542 <HAL_RCCEx_PeriphCLKConfig+0x2c6>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800f53a:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800f53e:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
    }
  }

#if defined(UART4)
  /*-------------------------- UART4 clock source configuration --------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 800f542:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f546:	e9d3 2300 	ldrd	r2, r3, [r3]
 800f54a:	f002 0308 	and.w	r3, r2, #8
 800f54e:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
 800f552:	2300      	movs	r3, #0
 800f554:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
 800f558:	e9d7 124e 	ldrd	r1, r2, [r7, #312]	@ 0x138
 800f55c:	460b      	mov	r3, r1
 800f55e:	4313      	orrs	r3, r2
 800f560:	d056      	beq.n	800f610 <HAL_RCCEx_PeriphCLKConfig+0x394>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(pPeriphClkInit->Uart4ClockSelection));

    switch (pPeriphClkInit->Uart4ClockSelection)
 800f562:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f566:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800f568:	f5b3 6f20 	cmp.w	r3, #2560	@ 0xa00
 800f56c:	d031      	beq.n	800f5d2 <HAL_RCCEx_PeriphCLKConfig+0x356>
 800f56e:	f5b3 6f20 	cmp.w	r3, #2560	@ 0xa00
 800f572:	d82a      	bhi.n	800f5ca <HAL_RCCEx_PeriphCLKConfig+0x34e>
 800f574:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800f578:	d02d      	beq.n	800f5d6 <HAL_RCCEx_PeriphCLKConfig+0x35a>
 800f57a:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800f57e:	d824      	bhi.n	800f5ca <HAL_RCCEx_PeriphCLKConfig+0x34e>
 800f580:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
 800f584:	d029      	beq.n	800f5da <HAL_RCCEx_PeriphCLKConfig+0x35e>
 800f586:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
 800f58a:	d81e      	bhi.n	800f5ca <HAL_RCCEx_PeriphCLKConfig+0x34e>
 800f58c:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800f590:	d011      	beq.n	800f5b6 <HAL_RCCEx_PeriphCLKConfig+0x33a>
 800f592:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800f596:	d818      	bhi.n	800f5ca <HAL_RCCEx_PeriphCLKConfig+0x34e>
 800f598:	2b00      	cmp	r3, #0
 800f59a:	d023      	beq.n	800f5e4 <HAL_RCCEx_PeriphCLKConfig+0x368>
 800f59c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800f5a0:	d113      	bne.n	800f5ca <HAL_RCCEx_PeriphCLKConfig+0x34e>
        /* UART4 clock source config set later after clock selection check */
        break;

      case RCC_UART4CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for UART4*/
        /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 800f5a2:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f5a6:	3308      	adds	r3, #8
 800f5a8:	4618      	mov	r0, r3
 800f5aa:	f004 fd8f 	bl	80140cc <RCCEx_PLL2_Config>
 800f5ae:	4603      	mov	r3, r0
 800f5b0:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* UART4 clock source config set later after clock selection check */
        break;
 800f5b4:	e017      	b.n	800f5e6 <HAL_RCCEx_PeriphCLKConfig+0x36a>

      case RCC_UART4CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for UART4*/
        /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 800f5b6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f5ba:	3330      	adds	r3, #48	@ 0x30
 800f5bc:	4618      	mov	r0, r3
 800f5be:	f004 fe1d 	bl	80141fc <RCCEx_PLL3_Config>
 800f5c2:	4603      	mov	r3, r0
 800f5c4:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* UART4 clock source config set later after clock selection check */
        break;
 800f5c8:	e00d      	b.n	800f5e6 <HAL_RCCEx_PeriphCLKConfig+0x36a>
      case RCC_UART4CLKSOURCE_LSE:      /* LSE clock is used as source of UART4 clock*/
        /* UART4 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800f5ca:	2301      	movs	r3, #1
 800f5cc:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 800f5d0:	e009      	b.n	800f5e6 <HAL_RCCEx_PeriphCLKConfig+0x36a>
        break;
 800f5d2:	bf00      	nop
 800f5d4:	e007      	b.n	800f5e6 <HAL_RCCEx_PeriphCLKConfig+0x36a>
        break;
 800f5d6:	bf00      	nop
 800f5d8:	e005      	b.n	800f5e6 <HAL_RCCEx_PeriphCLKConfig+0x36a>
        break;
 800f5da:	bf00      	nop
 800f5dc:	e003      	b.n	800f5e6 <HAL_RCCEx_PeriphCLKConfig+0x36a>
 800f5de:	bf00      	nop
 800f5e0:	44020c00 	.word	0x44020c00
        break;
 800f5e4:	bf00      	nop
    }

    if (ret == HAL_OK)
 800f5e6:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800f5ea:	2b00      	cmp	r3, #0
 800f5ec:	d10c      	bne.n	800f608 <HAL_RCCEx_PeriphCLKConfig+0x38c>
    {
      /* Set the source of UART4 clock*/
      __HAL_RCC_UART4_CONFIG(pPeriphClkInit->Uart4ClockSelection);
 800f5ee:	4bbb      	ldr	r3, [pc, #748]	@ (800f8dc <HAL_RCCEx_PeriphCLKConfig+0x660>)
 800f5f0:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 800f5f4:	f423 6160 	bic.w	r1, r3, #3584	@ 0xe00
 800f5f8:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f5fc:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800f5fe:	4ab7      	ldr	r2, [pc, #732]	@ (800f8dc <HAL_RCCEx_PeriphCLKConfig+0x660>)
 800f600:	430b      	orrs	r3, r1
 800f602:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
 800f606:	e003      	b.n	800f610 <HAL_RCCEx_PeriphCLKConfig+0x394>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800f608:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800f60c:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
  }
#endif /* UART4 */

#if defined(UART5)
  /*-------------------------- UART5 clock source configuration --------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 800f610:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f614:	e9d3 2300 	ldrd	r2, r3, [r3]
 800f618:	f002 0310 	and.w	r3, r2, #16
 800f61c:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 800f620:	2300      	movs	r3, #0
 800f622:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
 800f626:	e9d7 124c 	ldrd	r1, r2, [r7, #304]	@ 0x130
 800f62a:	460b      	mov	r3, r1
 800f62c:	4313      	orrs	r3, r2
 800f62e:	d053      	beq.n	800f6d8 <HAL_RCCEx_PeriphCLKConfig+0x45c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(pPeriphClkInit->Uart5ClockSelection));

    switch (pPeriphClkInit->Uart5ClockSelection)
 800f630:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f634:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 800f636:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
 800f63a:	d031      	beq.n	800f6a0 <HAL_RCCEx_PeriphCLKConfig+0x424>
 800f63c:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
 800f640:	d82a      	bhi.n	800f698 <HAL_RCCEx_PeriphCLKConfig+0x41c>
 800f642:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 800f646:	d02d      	beq.n	800f6a4 <HAL_RCCEx_PeriphCLKConfig+0x428>
 800f648:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 800f64c:	d824      	bhi.n	800f698 <HAL_RCCEx_PeriphCLKConfig+0x41c>
 800f64e:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 800f652:	d029      	beq.n	800f6a8 <HAL_RCCEx_PeriphCLKConfig+0x42c>
 800f654:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 800f658:	d81e      	bhi.n	800f698 <HAL_RCCEx_PeriphCLKConfig+0x41c>
 800f65a:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 800f65e:	d011      	beq.n	800f684 <HAL_RCCEx_PeriphCLKConfig+0x408>
 800f660:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 800f664:	d818      	bhi.n	800f698 <HAL_RCCEx_PeriphCLKConfig+0x41c>
 800f666:	2b00      	cmp	r3, #0
 800f668:	d020      	beq.n	800f6ac <HAL_RCCEx_PeriphCLKConfig+0x430>
 800f66a:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 800f66e:	d113      	bne.n	800f698 <HAL_RCCEx_PeriphCLKConfig+0x41c>
        /* UART5 clock source config set later after clock selection check */
        break;

      case RCC_UART5CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for UART5*/
        /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 800f670:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f674:	3308      	adds	r3, #8
 800f676:	4618      	mov	r0, r3
 800f678:	f004 fd28 	bl	80140cc <RCCEx_PLL2_Config>
 800f67c:	4603      	mov	r3, r0
 800f67e:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* UART5 clock source config set later after clock selection check */
        break;
 800f682:	e014      	b.n	800f6ae <HAL_RCCEx_PeriphCLKConfig+0x432>

      case RCC_UART5CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for UART5*/
        /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 800f684:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f688:	3330      	adds	r3, #48	@ 0x30
 800f68a:	4618      	mov	r0, r3
 800f68c:	f004 fdb6 	bl	80141fc <RCCEx_PLL3_Config>
 800f690:	4603      	mov	r3, r0
 800f692:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* UART5 clock source config set later after clock selection check */
        break;
 800f696:	e00a      	b.n	800f6ae <HAL_RCCEx_PeriphCLKConfig+0x432>
      case RCC_UART5CLKSOURCE_LSE:      /* LSE clock is used as source of UART5 clock*/
        /* UART5 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800f698:	2301      	movs	r3, #1
 800f69a:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 800f69e:	e006      	b.n	800f6ae <HAL_RCCEx_PeriphCLKConfig+0x432>
        break;
 800f6a0:	bf00      	nop
 800f6a2:	e004      	b.n	800f6ae <HAL_RCCEx_PeriphCLKConfig+0x432>
        break;
 800f6a4:	bf00      	nop
 800f6a6:	e002      	b.n	800f6ae <HAL_RCCEx_PeriphCLKConfig+0x432>
        break;
 800f6a8:	bf00      	nop
 800f6aa:	e000      	b.n	800f6ae <HAL_RCCEx_PeriphCLKConfig+0x432>
        break;
 800f6ac:	bf00      	nop
    }

    if (ret == HAL_OK)
 800f6ae:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800f6b2:	2b00      	cmp	r3, #0
 800f6b4:	d10c      	bne.n	800f6d0 <HAL_RCCEx_PeriphCLKConfig+0x454>
    {
      /* Set the source of UART5 clock*/
      __HAL_RCC_UART5_CONFIG(pPeriphClkInit->Uart5ClockSelection);
 800f6b6:	4b89      	ldr	r3, [pc, #548]	@ (800f8dc <HAL_RCCEx_PeriphCLKConfig+0x660>)
 800f6b8:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 800f6bc:	f423 41e0 	bic.w	r1, r3, #28672	@ 0x7000
 800f6c0:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f6c4:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 800f6c6:	4a85      	ldr	r2, [pc, #532]	@ (800f8dc <HAL_RCCEx_PeriphCLKConfig+0x660>)
 800f6c8:	430b      	orrs	r3, r1
 800f6ca:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
 800f6ce:	e003      	b.n	800f6d8 <HAL_RCCEx_PeriphCLKConfig+0x45c>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800f6d0:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800f6d4:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
  }
#endif /* UART5 */

#if defined(USART6)
  /*-------------------------- USART6 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
 800f6d8:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f6dc:	e9d3 2300 	ldrd	r2, r3, [r3]
 800f6e0:	f002 0320 	and.w	r3, r2, #32
 800f6e4:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
 800f6e8:	2300      	movs	r3, #0
 800f6ea:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 800f6ee:	e9d7 124a 	ldrd	r1, r2, [r7, #296]	@ 0x128
 800f6f2:	460b      	mov	r3, r1
 800f6f4:	4313      	orrs	r3, r2
 800f6f6:	d053      	beq.n	800f7a0 <HAL_RCCEx_PeriphCLKConfig+0x524>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(pPeriphClkInit->Usart6ClockSelection));

    switch (pPeriphClkInit->Usart6ClockSelection)
 800f6f8:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f6fc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800f6fe:	f5b3 3f20 	cmp.w	r3, #163840	@ 0x28000
 800f702:	d031      	beq.n	800f768 <HAL_RCCEx_PeriphCLKConfig+0x4ec>
 800f704:	f5b3 3f20 	cmp.w	r3, #163840	@ 0x28000
 800f708:	d82a      	bhi.n	800f760 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
 800f70a:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800f70e:	d02d      	beq.n	800f76c <HAL_RCCEx_PeriphCLKConfig+0x4f0>
 800f710:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800f714:	d824      	bhi.n	800f760 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
 800f716:	f5b3 3fc0 	cmp.w	r3, #98304	@ 0x18000
 800f71a:	d029      	beq.n	800f770 <HAL_RCCEx_PeriphCLKConfig+0x4f4>
 800f71c:	f5b3 3fc0 	cmp.w	r3, #98304	@ 0x18000
 800f720:	d81e      	bhi.n	800f760 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
 800f722:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800f726:	d011      	beq.n	800f74c <HAL_RCCEx_PeriphCLKConfig+0x4d0>
 800f728:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800f72c:	d818      	bhi.n	800f760 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
 800f72e:	2b00      	cmp	r3, #0
 800f730:	d020      	beq.n	800f774 <HAL_RCCEx_PeriphCLKConfig+0x4f8>
 800f732:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800f736:	d113      	bne.n	800f760 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
        /* USART6 clock source config set later after clock selection check */
        break;

      case RCC_USART6CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for USART6*/
        /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 800f738:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f73c:	3308      	adds	r3, #8
 800f73e:	4618      	mov	r0, r3
 800f740:	f004 fcc4 	bl	80140cc <RCCEx_PLL2_Config>
 800f744:	4603      	mov	r3, r0
 800f746:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* USART6 clock source config set later after clock selection check */
        break;
 800f74a:	e014      	b.n	800f776 <HAL_RCCEx_PeriphCLKConfig+0x4fa>

      case RCC_USART6CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for USART6*/
        /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 800f74c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f750:	3330      	adds	r3, #48	@ 0x30
 800f752:	4618      	mov	r0, r3
 800f754:	f004 fd52 	bl	80141fc <RCCEx_PLL3_Config>
 800f758:	4603      	mov	r3, r0
 800f75a:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* USART6 clock source config set later after clock selection check */
        break;
 800f75e:	e00a      	b.n	800f776 <HAL_RCCEx_PeriphCLKConfig+0x4fa>
      case RCC_USART6CLKSOURCE_LSE:      /* LSE clock is used as source of USART6 clock*/
        /* USART6 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800f760:	2301      	movs	r3, #1
 800f762:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 800f766:	e006      	b.n	800f776 <HAL_RCCEx_PeriphCLKConfig+0x4fa>
        break;
 800f768:	bf00      	nop
 800f76a:	e004      	b.n	800f776 <HAL_RCCEx_PeriphCLKConfig+0x4fa>
        break;
 800f76c:	bf00      	nop
 800f76e:	e002      	b.n	800f776 <HAL_RCCEx_PeriphCLKConfig+0x4fa>
        break;
 800f770:	bf00      	nop
 800f772:	e000      	b.n	800f776 <HAL_RCCEx_PeriphCLKConfig+0x4fa>
        break;
 800f774:	bf00      	nop
    }

    if (ret == HAL_OK)
 800f776:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800f77a:	2b00      	cmp	r3, #0
 800f77c:	d10c      	bne.n	800f798 <HAL_RCCEx_PeriphCLKConfig+0x51c>
    {
      /* Set the source of USART6 clock*/
      __HAL_RCC_USART6_CONFIG(pPeriphClkInit->Usart6ClockSelection);
 800f77e:	4b57      	ldr	r3, [pc, #348]	@ (800f8dc <HAL_RCCEx_PeriphCLKConfig+0x660>)
 800f780:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 800f784:	f423 3160 	bic.w	r1, r3, #229376	@ 0x38000
 800f788:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f78c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800f78e:	4a53      	ldr	r2, [pc, #332]	@ (800f8dc <HAL_RCCEx_PeriphCLKConfig+0x660>)
 800f790:	430b      	orrs	r3, r1
 800f792:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
 800f796:	e003      	b.n	800f7a0 <HAL_RCCEx_PeriphCLKConfig+0x524>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800f798:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800f79c:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
  }
#endif /* USART6 */

#if defined(UART7)
  /*-------------------------- UART7 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
 800f7a0:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f7a4:	e9d3 2300 	ldrd	r2, r3, [r3]
 800f7a8:	f002 0340 	and.w	r3, r2, #64	@ 0x40
 800f7ac:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 800f7b0:	2300      	movs	r3, #0
 800f7b2:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
 800f7b6:	e9d7 1248 	ldrd	r1, r2, [r7, #288]	@ 0x120
 800f7ba:	460b      	mov	r3, r1
 800f7bc:	4313      	orrs	r3, r2
 800f7be:	d053      	beq.n	800f868 <HAL_RCCEx_PeriphCLKConfig+0x5ec>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(pPeriphClkInit->Uart7ClockSelection));

    switch (pPeriphClkInit->Uart7ClockSelection)
 800f7c0:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f7c4:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800f7c6:	f5b3 1fa0 	cmp.w	r3, #1310720	@ 0x140000
 800f7ca:	d031      	beq.n	800f830 <HAL_RCCEx_PeriphCLKConfig+0x5b4>
 800f7cc:	f5b3 1fa0 	cmp.w	r3, #1310720	@ 0x140000
 800f7d0:	d82a      	bhi.n	800f828 <HAL_RCCEx_PeriphCLKConfig+0x5ac>
 800f7d2:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 800f7d6:	d02d      	beq.n	800f834 <HAL_RCCEx_PeriphCLKConfig+0x5b8>
 800f7d8:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 800f7dc:	d824      	bhi.n	800f828 <HAL_RCCEx_PeriphCLKConfig+0x5ac>
 800f7de:	f5b3 2f40 	cmp.w	r3, #786432	@ 0xc0000
 800f7e2:	d029      	beq.n	800f838 <HAL_RCCEx_PeriphCLKConfig+0x5bc>
 800f7e4:	f5b3 2f40 	cmp.w	r3, #786432	@ 0xc0000
 800f7e8:	d81e      	bhi.n	800f828 <HAL_RCCEx_PeriphCLKConfig+0x5ac>
 800f7ea:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 800f7ee:	d011      	beq.n	800f814 <HAL_RCCEx_PeriphCLKConfig+0x598>
 800f7f0:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 800f7f4:	d818      	bhi.n	800f828 <HAL_RCCEx_PeriphCLKConfig+0x5ac>
 800f7f6:	2b00      	cmp	r3, #0
 800f7f8:	d020      	beq.n	800f83c <HAL_RCCEx_PeriphCLKConfig+0x5c0>
 800f7fa:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 800f7fe:	d113      	bne.n	800f828 <HAL_RCCEx_PeriphCLKConfig+0x5ac>
        /* UART7 clock source config set later after clock selection check */
        break;

      case RCC_UART7CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for UART7*/
        /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 800f800:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f804:	3308      	adds	r3, #8
 800f806:	4618      	mov	r0, r3
 800f808:	f004 fc60 	bl	80140cc <RCCEx_PLL2_Config>
 800f80c:	4603      	mov	r3, r0
 800f80e:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* UART7 clock source config set later after clock selection check */
        break;
 800f812:	e014      	b.n	800f83e <HAL_RCCEx_PeriphCLKConfig+0x5c2>

      case RCC_UART7CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for UART7*/
        /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 800f814:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f818:	3330      	adds	r3, #48	@ 0x30
 800f81a:	4618      	mov	r0, r3
 800f81c:	f004 fcee 	bl	80141fc <RCCEx_PLL3_Config>
 800f820:	4603      	mov	r3, r0
 800f822:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* UART7 clock source config set later after clock selection check */
        break;
 800f826:	e00a      	b.n	800f83e <HAL_RCCEx_PeriphCLKConfig+0x5c2>
      case RCC_UART7CLKSOURCE_LSE:      /* LSE clock is used as source of UART7 clock*/
        /* UART7 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800f828:	2301      	movs	r3, #1
 800f82a:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 800f82e:	e006      	b.n	800f83e <HAL_RCCEx_PeriphCLKConfig+0x5c2>
        break;
 800f830:	bf00      	nop
 800f832:	e004      	b.n	800f83e <HAL_RCCEx_PeriphCLKConfig+0x5c2>
        break;
 800f834:	bf00      	nop
 800f836:	e002      	b.n	800f83e <HAL_RCCEx_PeriphCLKConfig+0x5c2>
        break;
 800f838:	bf00      	nop
 800f83a:	e000      	b.n	800f83e <HAL_RCCEx_PeriphCLKConfig+0x5c2>
        break;
 800f83c:	bf00      	nop
    }

    if (ret == HAL_OK)
 800f83e:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800f842:	2b00      	cmp	r3, #0
 800f844:	d10c      	bne.n	800f860 <HAL_RCCEx_PeriphCLKConfig+0x5e4>
    {
      /* Set the source of UART7 clock*/
      __HAL_RCC_UART7_CONFIG(pPeriphClkInit->Uart7ClockSelection);
 800f846:	4b25      	ldr	r3, [pc, #148]	@ (800f8dc <HAL_RCCEx_PeriphCLKConfig+0x660>)
 800f848:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 800f84c:	f423 11e0 	bic.w	r1, r3, #1835008	@ 0x1c0000
 800f850:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f854:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800f856:	4a21      	ldr	r2, [pc, #132]	@ (800f8dc <HAL_RCCEx_PeriphCLKConfig+0x660>)
 800f858:	430b      	orrs	r3, r1
 800f85a:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
 800f85e:	e003      	b.n	800f868 <HAL_RCCEx_PeriphCLKConfig+0x5ec>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800f860:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800f864:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
  }
#endif /* UART7 */

#if defined(UART8)
  /*-------------------------- UART8 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
 800f868:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f86c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800f870:	f002 0380 	and.w	r3, r2, #128	@ 0x80
 800f874:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 800f878:	2300      	movs	r3, #0
 800f87a:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 800f87e:	e9d7 1246 	ldrd	r1, r2, [r7, #280]	@ 0x118
 800f882:	460b      	mov	r3, r1
 800f884:	4313      	orrs	r3, r2
 800f886:	d055      	beq.n	800f934 <HAL_RCCEx_PeriphCLKConfig+0x6b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(pPeriphClkInit->Uart8ClockSelection));

    switch (pPeriphClkInit->Uart8ClockSelection)
 800f888:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f88c:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 800f88e:	f5b3 0f20 	cmp.w	r3, #10485760	@ 0xa00000
 800f892:	d033      	beq.n	800f8fc <HAL_RCCEx_PeriphCLKConfig+0x680>
 800f894:	f5b3 0f20 	cmp.w	r3, #10485760	@ 0xa00000
 800f898:	d82c      	bhi.n	800f8f4 <HAL_RCCEx_PeriphCLKConfig+0x678>
 800f89a:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 800f89e:	d02f      	beq.n	800f900 <HAL_RCCEx_PeriphCLKConfig+0x684>
 800f8a0:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 800f8a4:	d826      	bhi.n	800f8f4 <HAL_RCCEx_PeriphCLKConfig+0x678>
 800f8a6:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
 800f8aa:	d02b      	beq.n	800f904 <HAL_RCCEx_PeriphCLKConfig+0x688>
 800f8ac:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
 800f8b0:	d820      	bhi.n	800f8f4 <HAL_RCCEx_PeriphCLKConfig+0x678>
 800f8b2:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 800f8b6:	d013      	beq.n	800f8e0 <HAL_RCCEx_PeriphCLKConfig+0x664>
 800f8b8:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 800f8bc:	d81a      	bhi.n	800f8f4 <HAL_RCCEx_PeriphCLKConfig+0x678>
 800f8be:	2b00      	cmp	r3, #0
 800f8c0:	d022      	beq.n	800f908 <HAL_RCCEx_PeriphCLKConfig+0x68c>
 800f8c2:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 800f8c6:	d115      	bne.n	800f8f4 <HAL_RCCEx_PeriphCLKConfig+0x678>
        /* UART8 clock source config set later after clock selection check */
        break;

      case RCC_UART8CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for UART8*/
        /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 800f8c8:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f8cc:	3308      	adds	r3, #8
 800f8ce:	4618      	mov	r0, r3
 800f8d0:	f004 fbfc 	bl	80140cc <RCCEx_PLL2_Config>
 800f8d4:	4603      	mov	r3, r0
 800f8d6:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* UART8 clock source config set later after clock selection check */
        break;
 800f8da:	e016      	b.n	800f90a <HAL_RCCEx_PeriphCLKConfig+0x68e>
 800f8dc:	44020c00 	.word	0x44020c00

      case RCC_UART8CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for UART8*/
        /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 800f8e0:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f8e4:	3330      	adds	r3, #48	@ 0x30
 800f8e6:	4618      	mov	r0, r3
 800f8e8:	f004 fc88 	bl	80141fc <RCCEx_PLL3_Config>
 800f8ec:	4603      	mov	r3, r0
 800f8ee:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* UART8 clock source config set later after clock selection check */
        break;
 800f8f2:	e00a      	b.n	800f90a <HAL_RCCEx_PeriphCLKConfig+0x68e>
      case RCC_UART8CLKSOURCE_LSE:      /* LSE clock is used as source of UART8 clock*/
        /* UART8 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800f8f4:	2301      	movs	r3, #1
 800f8f6:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 800f8fa:	e006      	b.n	800f90a <HAL_RCCEx_PeriphCLKConfig+0x68e>
        break;
 800f8fc:	bf00      	nop
 800f8fe:	e004      	b.n	800f90a <HAL_RCCEx_PeriphCLKConfig+0x68e>
        break;
 800f900:	bf00      	nop
 800f902:	e002      	b.n	800f90a <HAL_RCCEx_PeriphCLKConfig+0x68e>
        break;
 800f904:	bf00      	nop
 800f906:	e000      	b.n	800f90a <HAL_RCCEx_PeriphCLKConfig+0x68e>
        break;
 800f908:	bf00      	nop
    }

    if (ret == HAL_OK)
 800f90a:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800f90e:	2b00      	cmp	r3, #0
 800f910:	d10c      	bne.n	800f92c <HAL_RCCEx_PeriphCLKConfig+0x6b0>
    {
      /* Set the source of UART8 clock*/
      __HAL_RCC_UART8_CONFIG(pPeriphClkInit->Uart8ClockSelection);
 800f912:	4bbb      	ldr	r3, [pc, #748]	@ (800fc00 <HAL_RCCEx_PeriphCLKConfig+0x984>)
 800f914:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 800f918:	f423 0160 	bic.w	r1, r3, #14680064	@ 0xe00000
 800f91c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f920:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 800f922:	4ab7      	ldr	r2, [pc, #732]	@ (800fc00 <HAL_RCCEx_PeriphCLKConfig+0x984>)
 800f924:	430b      	orrs	r3, r1
 800f926:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
 800f92a:	e003      	b.n	800f934 <HAL_RCCEx_PeriphCLKConfig+0x6b8>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800f92c:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800f930:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
  }
#endif /* UART9 */

#if defined(UART9)
  /*-------------------------- UART9 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART9) == RCC_PERIPHCLK_UART9)
 800f934:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f938:	e9d3 2300 	ldrd	r2, r3, [r3]
 800f93c:	f402 7380 	and.w	r3, r2, #256	@ 0x100
 800f940:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
 800f944:	2300      	movs	r3, #0
 800f946:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
 800f94a:	e9d7 1244 	ldrd	r1, r2, [r7, #272]	@ 0x110
 800f94e:	460b      	mov	r3, r1
 800f950:	4313      	orrs	r3, r2
 800f952:	d053      	beq.n	800f9fc <HAL_RCCEx_PeriphCLKConfig+0x780>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART9CLKSOURCE(pPeriphClkInit->Uart9ClockSelection));

    switch (pPeriphClkInit->Uart9ClockSelection)
 800f954:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f958:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 800f95a:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
 800f95e:	d031      	beq.n	800f9c4 <HAL_RCCEx_PeriphCLKConfig+0x748>
 800f960:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
 800f964:	d82a      	bhi.n	800f9bc <HAL_RCCEx_PeriphCLKConfig+0x740>
 800f966:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 800f96a:	d02d      	beq.n	800f9c8 <HAL_RCCEx_PeriphCLKConfig+0x74c>
 800f96c:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 800f970:	d824      	bhi.n	800f9bc <HAL_RCCEx_PeriphCLKConfig+0x740>
 800f972:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 800f976:	d029      	beq.n	800f9cc <HAL_RCCEx_PeriphCLKConfig+0x750>
 800f978:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 800f97c:	d81e      	bhi.n	800f9bc <HAL_RCCEx_PeriphCLKConfig+0x740>
 800f97e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 800f982:	d011      	beq.n	800f9a8 <HAL_RCCEx_PeriphCLKConfig+0x72c>
 800f984:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 800f988:	d818      	bhi.n	800f9bc <HAL_RCCEx_PeriphCLKConfig+0x740>
 800f98a:	2b00      	cmp	r3, #0
 800f98c:	d020      	beq.n	800f9d0 <HAL_RCCEx_PeriphCLKConfig+0x754>
 800f98e:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 800f992:	d113      	bne.n	800f9bc <HAL_RCCEx_PeriphCLKConfig+0x740>
        /* UART9 clock source config set later after clock selection check */
        break;

      case RCC_UART9CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for UART9*/
        /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 800f994:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f998:	3308      	adds	r3, #8
 800f99a:	4618      	mov	r0, r3
 800f99c:	f004 fb96 	bl	80140cc <RCCEx_PLL2_Config>
 800f9a0:	4603      	mov	r3, r0
 800f9a2:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* UART9 clock source config set later after clock selection check */
        break;
 800f9a6:	e014      	b.n	800f9d2 <HAL_RCCEx_PeriphCLKConfig+0x756>

      case RCC_UART9CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for UART9*/
        /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 800f9a8:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f9ac:	3330      	adds	r3, #48	@ 0x30
 800f9ae:	4618      	mov	r0, r3
 800f9b0:	f004 fc24 	bl	80141fc <RCCEx_PLL3_Config>
 800f9b4:	4603      	mov	r3, r0
 800f9b6:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* UART9 clock source config set later after clock selection check */
        break;
 800f9ba:	e00a      	b.n	800f9d2 <HAL_RCCEx_PeriphCLKConfig+0x756>
      case RCC_UART9CLKSOURCE_LSE:      /* LSE clock is used as source of UART9 clock*/
        /* UART9 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800f9bc:	2301      	movs	r3, #1
 800f9be:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 800f9c2:	e006      	b.n	800f9d2 <HAL_RCCEx_PeriphCLKConfig+0x756>
        break;
 800f9c4:	bf00      	nop
 800f9c6:	e004      	b.n	800f9d2 <HAL_RCCEx_PeriphCLKConfig+0x756>
        break;
 800f9c8:	bf00      	nop
 800f9ca:	e002      	b.n	800f9d2 <HAL_RCCEx_PeriphCLKConfig+0x756>
        break;
 800f9cc:	bf00      	nop
 800f9ce:	e000      	b.n	800f9d2 <HAL_RCCEx_PeriphCLKConfig+0x756>
        break;
 800f9d0:	bf00      	nop
    }

    if (ret == HAL_OK)
 800f9d2:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800f9d6:	2b00      	cmp	r3, #0
 800f9d8:	d10c      	bne.n	800f9f4 <HAL_RCCEx_PeriphCLKConfig+0x778>
    {
      /* Set the source of UART9 clock*/
      __HAL_RCC_UART9_CONFIG(pPeriphClkInit->Uart9ClockSelection);
 800f9da:	4b89      	ldr	r3, [pc, #548]	@ (800fc00 <HAL_RCCEx_PeriphCLKConfig+0x984>)
 800f9dc:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 800f9e0:	f023 61e0 	bic.w	r1, r3, #117440512	@ 0x7000000
 800f9e4:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800f9e8:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 800f9ea:	4a85      	ldr	r2, [pc, #532]	@ (800fc00 <HAL_RCCEx_PeriphCLKConfig+0x984>)
 800f9ec:	430b      	orrs	r3, r1
 800f9ee:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
 800f9f2:	e003      	b.n	800f9fc <HAL_RCCEx_PeriphCLKConfig+0x780>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800f9f4:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800f9f8:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
  }
#endif /* UART9 */

#if defined(USART10)
  /*-------------------------- USART10 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART10) == RCC_PERIPHCLK_USART10)
 800f9fc:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fa00:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fa04:	f402 7300 	and.w	r3, r2, #512	@ 0x200
 800fa08:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 800fa0c:	2300      	movs	r3, #0
 800fa0e:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
 800fa12:	e9d7 1242 	ldrd	r1, r2, [r7, #264]	@ 0x108
 800fa16:	460b      	mov	r3, r1
 800fa18:	4313      	orrs	r3, r2
 800fa1a:	d055      	beq.n	800fac8 <HAL_RCCEx_PeriphCLKConfig+0x84c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART10CLKSOURCE(pPeriphClkInit->Usart10ClockSelection));

    switch (pPeriphClkInit->Usart10ClockSelection)
 800fa1c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fa20:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800fa24:	f1b3 5f20 	cmp.w	r3, #671088640	@ 0x28000000
 800fa28:	d031      	beq.n	800fa8e <HAL_RCCEx_PeriphCLKConfig+0x812>
 800fa2a:	f1b3 5f20 	cmp.w	r3, #671088640	@ 0x28000000
 800fa2e:	d82a      	bhi.n	800fa86 <HAL_RCCEx_PeriphCLKConfig+0x80a>
 800fa30:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800fa34:	d02d      	beq.n	800fa92 <HAL_RCCEx_PeriphCLKConfig+0x816>
 800fa36:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800fa3a:	d824      	bhi.n	800fa86 <HAL_RCCEx_PeriphCLKConfig+0x80a>
 800fa3c:	f1b3 5fc0 	cmp.w	r3, #402653184	@ 0x18000000
 800fa40:	d029      	beq.n	800fa96 <HAL_RCCEx_PeriphCLKConfig+0x81a>
 800fa42:	f1b3 5fc0 	cmp.w	r3, #402653184	@ 0x18000000
 800fa46:	d81e      	bhi.n	800fa86 <HAL_RCCEx_PeriphCLKConfig+0x80a>
 800fa48:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 800fa4c:	d011      	beq.n	800fa72 <HAL_RCCEx_PeriphCLKConfig+0x7f6>
 800fa4e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 800fa52:	d818      	bhi.n	800fa86 <HAL_RCCEx_PeriphCLKConfig+0x80a>
 800fa54:	2b00      	cmp	r3, #0
 800fa56:	d020      	beq.n	800fa9a <HAL_RCCEx_PeriphCLKConfig+0x81e>
 800fa58:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 800fa5c:	d113      	bne.n	800fa86 <HAL_RCCEx_PeriphCLKConfig+0x80a>
        /* USART10 clock source config set later after clock selection check */
        break;

      case RCC_USART10CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for USART10*/
        /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 800fa5e:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fa62:	3308      	adds	r3, #8
 800fa64:	4618      	mov	r0, r3
 800fa66:	f004 fb31 	bl	80140cc <RCCEx_PLL2_Config>
 800fa6a:	4603      	mov	r3, r0
 800fa6c:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* USART10 clock source config set later after clock selection check */
        break;
 800fa70:	e014      	b.n	800fa9c <HAL_RCCEx_PeriphCLKConfig+0x820>

      case RCC_USART10CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for USART10*/
        /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 800fa72:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fa76:	3330      	adds	r3, #48	@ 0x30
 800fa78:	4618      	mov	r0, r3
 800fa7a:	f004 fbbf 	bl	80141fc <RCCEx_PLL3_Config>
 800fa7e:	4603      	mov	r3, r0
 800fa80:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* USART10 clock source config set later after clock selection check */
        break;
 800fa84:	e00a      	b.n	800fa9c <HAL_RCCEx_PeriphCLKConfig+0x820>
      case RCC_USART10CLKSOURCE_LSE:      /* LSE clock is used as source of USART10 clock*/
        /* USART10 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800fa86:	2301      	movs	r3, #1
 800fa88:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 800fa8c:	e006      	b.n	800fa9c <HAL_RCCEx_PeriphCLKConfig+0x820>
        break;
 800fa8e:	bf00      	nop
 800fa90:	e004      	b.n	800fa9c <HAL_RCCEx_PeriphCLKConfig+0x820>
        break;
 800fa92:	bf00      	nop
 800fa94:	e002      	b.n	800fa9c <HAL_RCCEx_PeriphCLKConfig+0x820>
        break;
 800fa96:	bf00      	nop
 800fa98:	e000      	b.n	800fa9c <HAL_RCCEx_PeriphCLKConfig+0x820>
        break;
 800fa9a:	bf00      	nop
    }

    if (ret == HAL_OK)
 800fa9c:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800faa0:	2b00      	cmp	r3, #0
 800faa2:	d10d      	bne.n	800fac0 <HAL_RCCEx_PeriphCLKConfig+0x844>
    {
      /* Set the source of USART10 clock*/
      __HAL_RCC_USART10_CONFIG(pPeriphClkInit->Usart10ClockSelection);
 800faa4:	4b56      	ldr	r3, [pc, #344]	@ (800fc00 <HAL_RCCEx_PeriphCLKConfig+0x984>)
 800faa6:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 800faaa:	f023 5160 	bic.w	r1, r3, #939524096	@ 0x38000000
 800faae:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fab2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800fab6:	4a52      	ldr	r2, [pc, #328]	@ (800fc00 <HAL_RCCEx_PeriphCLKConfig+0x984>)
 800fab8:	430b      	orrs	r3, r1
 800faba:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
 800fabe:	e003      	b.n	800fac8 <HAL_RCCEx_PeriphCLKConfig+0x84c>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800fac0:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800fac4:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
  }
#endif /* USART10 */

#if defined(USART11)
  /*-------------------------- USART11 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART11) == RCC_PERIPHCLK_USART11)
 800fac8:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800facc:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fad0:	f402 6380 	and.w	r3, r2, #1024	@ 0x400
 800fad4:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
 800fad8:	2300      	movs	r3, #0
 800fada:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
 800fade:	e9d7 1240 	ldrd	r1, r2, [r7, #256]	@ 0x100
 800fae2:	460b      	mov	r3, r1
 800fae4:	4313      	orrs	r3, r2
 800fae6:	d044      	beq.n	800fb72 <HAL_RCCEx_PeriphCLKConfig+0x8f6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART11CLKSOURCE(pPeriphClkInit->Usart11ClockSelection));

    switch (pPeriphClkInit->Usart11ClockSelection)
 800fae8:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800faec:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800faf0:	2b05      	cmp	r3, #5
 800faf2:	d823      	bhi.n	800fb3c <HAL_RCCEx_PeriphCLKConfig+0x8c0>
 800faf4:	a201      	add	r2, pc, #4	@ (adr r2, 800fafc <HAL_RCCEx_PeriphCLKConfig+0x880>)
 800faf6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800fafa:	bf00      	nop
 800fafc:	0800fb45 	.word	0x0800fb45
 800fb00:	0800fb15 	.word	0x0800fb15
 800fb04:	0800fb29 	.word	0x0800fb29
 800fb08:	0800fb45 	.word	0x0800fb45
 800fb0c:	0800fb45 	.word	0x0800fb45
 800fb10:	0800fb45 	.word	0x0800fb45
        /* USART11 clock source config set later after clock selection check */
        break;

      case RCC_USART11CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for USART11*/
        /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 800fb14:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fb18:	3308      	adds	r3, #8
 800fb1a:	4618      	mov	r0, r3
 800fb1c:	f004 fad6 	bl	80140cc <RCCEx_PLL2_Config>
 800fb20:	4603      	mov	r3, r0
 800fb22:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* USART11 clock source config set later after clock selection check */
        break;
 800fb26:	e00e      	b.n	800fb46 <HAL_RCCEx_PeriphCLKConfig+0x8ca>

      case RCC_USART11CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for USART11*/
        /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 800fb28:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fb2c:	3330      	adds	r3, #48	@ 0x30
 800fb2e:	4618      	mov	r0, r3
 800fb30:	f004 fb64 	bl	80141fc <RCCEx_PLL3_Config>
 800fb34:	4603      	mov	r3, r0
 800fb36:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* USART11 clock source config set later after clock selection check */
        break;
 800fb3a:	e004      	b.n	800fb46 <HAL_RCCEx_PeriphCLKConfig+0x8ca>
      case RCC_USART11CLKSOURCE_LSE:      /* LSE clock is used as source of USART11 clock*/
        /* USART11 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800fb3c:	2301      	movs	r3, #1
 800fb3e:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 800fb42:	e000      	b.n	800fb46 <HAL_RCCEx_PeriphCLKConfig+0x8ca>
        break;
 800fb44:	bf00      	nop
    }

    if (ret == HAL_OK)
 800fb46:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800fb4a:	2b00      	cmp	r3, #0
 800fb4c:	d10d      	bne.n	800fb6a <HAL_RCCEx_PeriphCLKConfig+0x8ee>
    {
      /* Set the source of USART11 clock*/
      __HAL_RCC_USART11_CONFIG(pPeriphClkInit->Usart11ClockSelection);
 800fb4e:	4b2c      	ldr	r3, [pc, #176]	@ (800fc00 <HAL_RCCEx_PeriphCLKConfig+0x984>)
 800fb50:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 800fb54:	f023 0107 	bic.w	r1, r3, #7
 800fb58:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fb5c:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800fb60:	4a27      	ldr	r2, [pc, #156]	@ (800fc00 <HAL_RCCEx_PeriphCLKConfig+0x984>)
 800fb62:	430b      	orrs	r3, r1
 800fb64:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
 800fb68:	e003      	b.n	800fb72 <HAL_RCCEx_PeriphCLKConfig+0x8f6>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800fb6a:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800fb6e:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
  }
#endif /*USART11*/

#if defined(UART12)
  /*-------------------------- UART12 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART12) == RCC_PERIPHCLK_UART12)
 800fb72:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fb76:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fb7a:	f402 6300 	and.w	r3, r2, #2048	@ 0x800
 800fb7e:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 800fb82:	2300      	movs	r3, #0
 800fb84:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
 800fb88:	e9d7 123e 	ldrd	r1, r2, [r7, #248]	@ 0xf8
 800fb8c:	460b      	mov	r3, r1
 800fb8e:	4313      	orrs	r3, r2
 800fb90:	d04f      	beq.n	800fc32 <HAL_RCCEx_PeriphCLKConfig+0x9b6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART12CLKSOURCE(pPeriphClkInit->Uart12ClockSelection));

    switch (pPeriphClkInit->Uart12ClockSelection)
 800fb92:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fb96:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800fb9a:	2b50      	cmp	r3, #80	@ 0x50
 800fb9c:	d029      	beq.n	800fbf2 <HAL_RCCEx_PeriphCLKConfig+0x976>
 800fb9e:	2b50      	cmp	r3, #80	@ 0x50
 800fba0:	d823      	bhi.n	800fbea <HAL_RCCEx_PeriphCLKConfig+0x96e>
 800fba2:	2b40      	cmp	r3, #64	@ 0x40
 800fba4:	d027      	beq.n	800fbf6 <HAL_RCCEx_PeriphCLKConfig+0x97a>
 800fba6:	2b40      	cmp	r3, #64	@ 0x40
 800fba8:	d81f      	bhi.n	800fbea <HAL_RCCEx_PeriphCLKConfig+0x96e>
 800fbaa:	2b30      	cmp	r3, #48	@ 0x30
 800fbac:	d025      	beq.n	800fbfa <HAL_RCCEx_PeriphCLKConfig+0x97e>
 800fbae:	2b30      	cmp	r3, #48	@ 0x30
 800fbb0:	d81b      	bhi.n	800fbea <HAL_RCCEx_PeriphCLKConfig+0x96e>
 800fbb2:	2b20      	cmp	r3, #32
 800fbb4:	d00f      	beq.n	800fbd6 <HAL_RCCEx_PeriphCLKConfig+0x95a>
 800fbb6:	2b20      	cmp	r3, #32
 800fbb8:	d817      	bhi.n	800fbea <HAL_RCCEx_PeriphCLKConfig+0x96e>
 800fbba:	2b00      	cmp	r3, #0
 800fbbc:	d022      	beq.n	800fc04 <HAL_RCCEx_PeriphCLKConfig+0x988>
 800fbbe:	2b10      	cmp	r3, #16
 800fbc0:	d113      	bne.n	800fbea <HAL_RCCEx_PeriphCLKConfig+0x96e>
        /* UART12 clock source config set later after clock selection check */
        break;

      case RCC_UART12CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for UART12*/
        /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 800fbc2:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fbc6:	3308      	adds	r3, #8
 800fbc8:	4618      	mov	r0, r3
 800fbca:	f004 fa7f 	bl	80140cc <RCCEx_PLL2_Config>
 800fbce:	4603      	mov	r3, r0
 800fbd0:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* UART12 clock source config set later after clock selection check */
        break;
 800fbd4:	e017      	b.n	800fc06 <HAL_RCCEx_PeriphCLKConfig+0x98a>

      case RCC_UART12CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for UART12*/
        /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 800fbd6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fbda:	3330      	adds	r3, #48	@ 0x30
 800fbdc:	4618      	mov	r0, r3
 800fbde:	f004 fb0d 	bl	80141fc <RCCEx_PLL3_Config>
 800fbe2:	4603      	mov	r3, r0
 800fbe4:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* UART12 clock source config set later after clock selection check */
        break;
 800fbe8:	e00d      	b.n	800fc06 <HAL_RCCEx_PeriphCLKConfig+0x98a>
      case RCC_UART12CLKSOURCE_LSE:      /* LSE clock is used as source of UART12 clock*/
        /* UART12 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800fbea:	2301      	movs	r3, #1
 800fbec:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 800fbf0:	e009      	b.n	800fc06 <HAL_RCCEx_PeriphCLKConfig+0x98a>
        break;
 800fbf2:	bf00      	nop
 800fbf4:	e007      	b.n	800fc06 <HAL_RCCEx_PeriphCLKConfig+0x98a>
        break;
 800fbf6:	bf00      	nop
 800fbf8:	e005      	b.n	800fc06 <HAL_RCCEx_PeriphCLKConfig+0x98a>
        break;
 800fbfa:	bf00      	nop
 800fbfc:	e003      	b.n	800fc06 <HAL_RCCEx_PeriphCLKConfig+0x98a>
 800fbfe:	bf00      	nop
 800fc00:	44020c00 	.word	0x44020c00
        break;
 800fc04:	bf00      	nop
    }

    if (ret == HAL_OK)
 800fc06:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800fc0a:	2b00      	cmp	r3, #0
 800fc0c:	d10d      	bne.n	800fc2a <HAL_RCCEx_PeriphCLKConfig+0x9ae>
    {
      /* Set the source of UART12 clock*/
      __HAL_RCC_UART12_CONFIG(pPeriphClkInit->Uart12ClockSelection);
 800fc0e:	4baf      	ldr	r3, [pc, #700]	@ (800fecc <HAL_RCCEx_PeriphCLKConfig+0xc50>)
 800fc10:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 800fc14:	f023 0170 	bic.w	r1, r3, #112	@ 0x70
 800fc18:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fc1c:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800fc20:	4aaa      	ldr	r2, [pc, #680]	@ (800fecc <HAL_RCCEx_PeriphCLKConfig+0xc50>)
 800fc22:	430b      	orrs	r3, r1
 800fc24:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
 800fc28:	e003      	b.n	800fc32 <HAL_RCCEx_PeriphCLKConfig+0x9b6>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800fc2a:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800fc2e:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
    }
  }
#endif /* UART12 */

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 800fc32:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fc36:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fc3a:	f402 5380 	and.w	r3, r2, #4096	@ 0x1000
 800fc3e:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
 800fc42:	2300      	movs	r3, #0
 800fc44:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
 800fc48:	e9d7 123c 	ldrd	r1, r2, [r7, #240]	@ 0xf0
 800fc4c:	460b      	mov	r3, r1
 800fc4e:	4313      	orrs	r3, r2
 800fc50:	d055      	beq.n	800fcfe <HAL_RCCEx_PeriphCLKConfig+0xa82>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(pPeriphClkInit->Lpuart1ClockSelection));

    switch (pPeriphClkInit->Lpuart1ClockSelection)
 800fc52:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fc56:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800fc5a:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
 800fc5e:	d031      	beq.n	800fcc4 <HAL_RCCEx_PeriphCLKConfig+0xa48>
 800fc60:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
 800fc64:	d82a      	bhi.n	800fcbc <HAL_RCCEx_PeriphCLKConfig+0xa40>
 800fc66:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 800fc6a:	d02d      	beq.n	800fcc8 <HAL_RCCEx_PeriphCLKConfig+0xa4c>
 800fc6c:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 800fc70:	d824      	bhi.n	800fcbc <HAL_RCCEx_PeriphCLKConfig+0xa40>
 800fc72:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 800fc76:	d029      	beq.n	800fccc <HAL_RCCEx_PeriphCLKConfig+0xa50>
 800fc78:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 800fc7c:	d81e      	bhi.n	800fcbc <HAL_RCCEx_PeriphCLKConfig+0xa40>
 800fc7e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 800fc82:	d011      	beq.n	800fca8 <HAL_RCCEx_PeriphCLKConfig+0xa2c>
 800fc84:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 800fc88:	d818      	bhi.n	800fcbc <HAL_RCCEx_PeriphCLKConfig+0xa40>
 800fc8a:	2b00      	cmp	r3, #0
 800fc8c:	d020      	beq.n	800fcd0 <HAL_RCCEx_PeriphCLKConfig+0xa54>
 800fc8e:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 800fc92:	d113      	bne.n	800fcbc <HAL_RCCEx_PeriphCLKConfig+0xa40>
        /* LPUART1 clock source config set later after clock selection check */
        break;

      case RCC_LPUART1CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for LPUART1*/
        /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 800fc94:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fc98:	3308      	adds	r3, #8
 800fc9a:	4618      	mov	r0, r3
 800fc9c:	f004 fa16 	bl	80140cc <RCCEx_PLL2_Config>
 800fca0:	4603      	mov	r3, r0
 800fca2:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* LPUART1 clock source config set later after clock selection check */
        break;
 800fca6:	e014      	b.n	800fcd2 <HAL_RCCEx_PeriphCLKConfig+0xa56>

#if defined(RCC_LPUART1CLKSOURCE_PLL3Q)
      case RCC_LPUART1CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for LPUART1*/
        /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 800fca8:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fcac:	3330      	adds	r3, #48	@ 0x30
 800fcae:	4618      	mov	r0, r3
 800fcb0:	f004 faa4 	bl	80141fc <RCCEx_PLL3_Config>
 800fcb4:	4603      	mov	r3, r0
 800fcb6:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* LPUART1 clock source config set later after clock selection check */
        break;
 800fcba:	e00a      	b.n	800fcd2 <HAL_RCCEx_PeriphCLKConfig+0xa56>
      case RCC_LPUART1CLKSOURCE_LSE:      /* LSE clock is used as source of LPUART1 clock*/
        /* LPUART1 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800fcbc:	2301      	movs	r3, #1
 800fcbe:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 800fcc2:	e006      	b.n	800fcd2 <HAL_RCCEx_PeriphCLKConfig+0xa56>
        break;
 800fcc4:	bf00      	nop
 800fcc6:	e004      	b.n	800fcd2 <HAL_RCCEx_PeriphCLKConfig+0xa56>
        break;
 800fcc8:	bf00      	nop
 800fcca:	e002      	b.n	800fcd2 <HAL_RCCEx_PeriphCLKConfig+0xa56>
        break;
 800fccc:	bf00      	nop
 800fcce:	e000      	b.n	800fcd2 <HAL_RCCEx_PeriphCLKConfig+0xa56>
        break;
 800fcd0:	bf00      	nop
    }

    if (ret == HAL_OK)
 800fcd2:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800fcd6:	2b00      	cmp	r3, #0
 800fcd8:	d10d      	bne.n	800fcf6 <HAL_RCCEx_PeriphCLKConfig+0xa7a>
    {
      /* Set the source of LPUART1 clock*/
      __HAL_RCC_LPUART1_CONFIG(pPeriphClkInit->Lpuart1ClockSelection);
 800fcda:	4b7c      	ldr	r3, [pc, #496]	@ (800fecc <HAL_RCCEx_PeriphCLKConfig+0xc50>)
 800fcdc:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800fce0:	f023 61e0 	bic.w	r1, r3, #117440512	@ 0x7000000
 800fce4:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fce8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800fcec:	4a77      	ldr	r2, [pc, #476]	@ (800fecc <HAL_RCCEx_PeriphCLKConfig+0xc50>)
 800fcee:	430b      	orrs	r3, r1
 800fcf0:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 800fcf4:	e003      	b.n	800fcfe <HAL_RCCEx_PeriphCLKConfig+0xa82>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800fcf6:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800fcfa:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
    }
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800fcfe:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fd02:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fd06:	f402 5300 	and.w	r3, r2, #8192	@ 0x2000
 800fd0a:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
 800fd0e:	2300      	movs	r3, #0
 800fd10:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
 800fd14:	e9d7 123a 	ldrd	r1, r2, [r7, #232]	@ 0xe8
 800fd18:	460b      	mov	r3, r1
 800fd1a:	4313      	orrs	r3, r2
 800fd1c:	d03d      	beq.n	800fd9a <HAL_RCCEx_PeriphCLKConfig+0xb1e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(pPeriphClkInit->I2c1ClockSelection));

    switch (pPeriphClkInit->I2c1ClockSelection)
 800fd1e:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fd22:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800fd26:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 800fd2a:	d01b      	beq.n	800fd64 <HAL_RCCEx_PeriphCLKConfig+0xae8>
 800fd2c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 800fd30:	d814      	bhi.n	800fd5c <HAL_RCCEx_PeriphCLKConfig+0xae0>
 800fd32:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800fd36:	d017      	beq.n	800fd68 <HAL_RCCEx_PeriphCLKConfig+0xaec>
 800fd38:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800fd3c:	d80e      	bhi.n	800fd5c <HAL_RCCEx_PeriphCLKConfig+0xae0>
 800fd3e:	2b00      	cmp	r3, #0
 800fd40:	d014      	beq.n	800fd6c <HAL_RCCEx_PeriphCLKConfig+0xaf0>
 800fd42:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800fd46:	d109      	bne.n	800fd5c <HAL_RCCEx_PeriphCLKConfig+0xae0>
        break;

#if defined(RCC_I2C1CLKSOURCE_PLL3R)
      case RCC_I2C1CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for I2C1*/
        /* PLL3  input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 800fd48:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fd4c:	3330      	adds	r3, #48	@ 0x30
 800fd4e:	4618      	mov	r0, r3
 800fd50:	f004 fa54 	bl	80141fc <RCCEx_PLL3_Config>
 800fd54:	4603      	mov	r3, r0
 800fd56:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
      case RCC_I2C1CLKSOURCE_PLL2R:  /* PLL2 is used as clock source for I2C1*/
        /* PLL2  input clock, parameters M, N & R configuration clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
#endif /* RCC_I2C1CLKSOURCE_PLL3R */
        /* I2C1 clock source config set later after clock selection check */
        break;
 800fd5a:	e008      	b.n	800fd6e <HAL_RCCEx_PeriphCLKConfig+0xaf2>
      case RCC_I2C1CLKSOURCE_CSI:      /* CSI clock is used as source of I2C1 clock*/
        /* I2C1 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800fd5c:	2301      	movs	r3, #1
 800fd5e:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 800fd62:	e004      	b.n	800fd6e <HAL_RCCEx_PeriphCLKConfig+0xaf2>
        break;
 800fd64:	bf00      	nop
 800fd66:	e002      	b.n	800fd6e <HAL_RCCEx_PeriphCLKConfig+0xaf2>
        break;
 800fd68:	bf00      	nop
 800fd6a:	e000      	b.n	800fd6e <HAL_RCCEx_PeriphCLKConfig+0xaf2>
        break;
 800fd6c:	bf00      	nop
    }

    if (ret == HAL_OK)
 800fd6e:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800fd72:	2b00      	cmp	r3, #0
 800fd74:	d10d      	bne.n	800fd92 <HAL_RCCEx_PeriphCLKConfig+0xb16>
    {
      /* Set the source of I2C1 clock*/
      __HAL_RCC_I2C1_CONFIG(pPeriphClkInit->I2c1ClockSelection);
 800fd76:	4b55      	ldr	r3, [pc, #340]	@ (800fecc <HAL_RCCEx_PeriphCLKConfig+0xc50>)
 800fd78:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 800fd7c:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
 800fd80:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fd84:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800fd88:	4a50      	ldr	r2, [pc, #320]	@ (800fecc <HAL_RCCEx_PeriphCLKConfig+0xc50>)
 800fd8a:	430b      	orrs	r3, r1
 800fd8c:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
 800fd90:	e003      	b.n	800fd9a <HAL_RCCEx_PeriphCLKConfig+0xb1e>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800fd92:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800fd96:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
    }
  }

  /*-------------------------- I2C2 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 800fd9a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fd9e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fda2:	f402 4380 	and.w	r3, r2, #16384	@ 0x4000
 800fda6:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 800fdaa:	2300      	movs	r3, #0
 800fdac:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 800fdb0:	e9d7 1238 	ldrd	r1, r2, [r7, #224]	@ 0xe0
 800fdb4:	460b      	mov	r3, r1
 800fdb6:	4313      	orrs	r3, r2
 800fdb8:	d03d      	beq.n	800fe36 <HAL_RCCEx_PeriphCLKConfig+0xbba>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(pPeriphClkInit->I2c2ClockSelection));

    switch (pPeriphClkInit->I2c2ClockSelection)
 800fdba:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fdbe:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 800fdc2:	f5b3 2f40 	cmp.w	r3, #786432	@ 0xc0000
 800fdc6:	d01b      	beq.n	800fe00 <HAL_RCCEx_PeriphCLKConfig+0xb84>
 800fdc8:	f5b3 2f40 	cmp.w	r3, #786432	@ 0xc0000
 800fdcc:	d814      	bhi.n	800fdf8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>
 800fdce:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 800fdd2:	d017      	beq.n	800fe04 <HAL_RCCEx_PeriphCLKConfig+0xb88>
 800fdd4:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 800fdd8:	d80e      	bhi.n	800fdf8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>
 800fdda:	2b00      	cmp	r3, #0
 800fddc:	d014      	beq.n	800fe08 <HAL_RCCEx_PeriphCLKConfig+0xb8c>
 800fdde:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 800fde2:	d109      	bne.n	800fdf8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>
        break;

#if defined(RCC_I2C2CLKSOURCE_PLL3R)
      case RCC_I2C2CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for I2C2*/
        /* PLL3  input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 800fde4:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fde8:	3330      	adds	r3, #48	@ 0x30
 800fdea:	4618      	mov	r0, r3
 800fdec:	f004 fa06 	bl	80141fc <RCCEx_PLL3_Config>
 800fdf0:	4603      	mov	r3, r0
 800fdf2:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
      case RCC_I2C2CLKSOURCE_PLL2R:  /* PLL32 is used as clock source for I2C2*/
        /* PLL2  input clock, parameters M, N & R configuration clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
#endif /* RCC_I2C2CLKSOURCE_PLL3R */
        /* I2C2 clock source config set later after clock selection check */
        break;
 800fdf6:	e008      	b.n	800fe0a <HAL_RCCEx_PeriphCLKConfig+0xb8e>
      case RCC_I2C2CLKSOURCE_CSI:      /* CSI clock is used as source of I2C2 clock*/
        /* I2C2 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800fdf8:	2301      	movs	r3, #1
 800fdfa:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 800fdfe:	e004      	b.n	800fe0a <HAL_RCCEx_PeriphCLKConfig+0xb8e>
        break;
 800fe00:	bf00      	nop
 800fe02:	e002      	b.n	800fe0a <HAL_RCCEx_PeriphCLKConfig+0xb8e>
        break;
 800fe04:	bf00      	nop
 800fe06:	e000      	b.n	800fe0a <HAL_RCCEx_PeriphCLKConfig+0xb8e>
        break;
 800fe08:	bf00      	nop
    }

    if (ret == HAL_OK)
 800fe0a:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800fe0e:	2b00      	cmp	r3, #0
 800fe10:	d10d      	bne.n	800fe2e <HAL_RCCEx_PeriphCLKConfig+0xbb2>
    {
      /* Set the source of I2C2 clock*/
      __HAL_RCC_I2C2_CONFIG(pPeriphClkInit->I2c2ClockSelection);
 800fe12:	4b2e      	ldr	r3, [pc, #184]	@ (800fecc <HAL_RCCEx_PeriphCLKConfig+0xc50>)
 800fe14:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 800fe18:	f423 2140 	bic.w	r1, r3, #786432	@ 0xc0000
 800fe1c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fe20:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 800fe24:	4a29      	ldr	r2, [pc, #164]	@ (800fecc <HAL_RCCEx_PeriphCLKConfig+0xc50>)
 800fe26:	430b      	orrs	r3, r1
 800fe28:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
 800fe2c:	e003      	b.n	800fe36 <HAL_RCCEx_PeriphCLKConfig+0xbba>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800fe2e:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800fe32:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
    }
  }

#if defined(I2C3)
  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 800fe36:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fe3a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fe3e:	f402 4300 	and.w	r3, r2, #32768	@ 0x8000
 800fe42:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
 800fe46:	2300      	movs	r3, #0
 800fe48:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
 800fe4c:	e9d7 1236 	ldrd	r1, r2, [r7, #216]	@ 0xd8
 800fe50:	460b      	mov	r3, r1
 800fe52:	4313      	orrs	r3, r2
 800fe54:	d040      	beq.n	800fed8 <HAL_RCCEx_PeriphCLKConfig+0xc5c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(pPeriphClkInit->I2c3ClockSelection));

    switch (pPeriphClkInit->I2c3ClockSelection)
 800fe56:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fe5a:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 800fe5e:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 800fe62:	d01b      	beq.n	800fe9c <HAL_RCCEx_PeriphCLKConfig+0xc20>
 800fe64:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 800fe68:	d814      	bhi.n	800fe94 <HAL_RCCEx_PeriphCLKConfig+0xc18>
 800fe6a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 800fe6e:	d017      	beq.n	800fea0 <HAL_RCCEx_PeriphCLKConfig+0xc24>
 800fe70:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 800fe74:	d80e      	bhi.n	800fe94 <HAL_RCCEx_PeriphCLKConfig+0xc18>
 800fe76:	2b00      	cmp	r3, #0
 800fe78:	d014      	beq.n	800fea4 <HAL_RCCEx_PeriphCLKConfig+0xc28>
 800fe7a:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 800fe7e:	d109      	bne.n	800fe94 <HAL_RCCEx_PeriphCLKConfig+0xc18>
        /* I2C3 clock source config set later after clock selection check */
        break;

      case RCC_I2C3CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for I2C3*/
        /* PLL3  input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 800fe80:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fe84:	3330      	adds	r3, #48	@ 0x30
 800fe86:	4618      	mov	r0, r3
 800fe88:	f004 f9b8 	bl	80141fc <RCCEx_PLL3_Config>
 800fe8c:	4603      	mov	r3, r0
 800fe8e:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* I2C3 clock source config set later after clock selection check */
        break;
 800fe92:	e008      	b.n	800fea6 <HAL_RCCEx_PeriphCLKConfig+0xc2a>
      case RCC_I2C3CLKSOURCE_CSI:      /* CSI clock is used as source of I2C3 clock*/
        /* I2C3 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800fe94:	2301      	movs	r3, #1
 800fe96:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 800fe9a:	e004      	b.n	800fea6 <HAL_RCCEx_PeriphCLKConfig+0xc2a>
        break;
 800fe9c:	bf00      	nop
 800fe9e:	e002      	b.n	800fea6 <HAL_RCCEx_PeriphCLKConfig+0xc2a>
        break;
 800fea0:	bf00      	nop
 800fea2:	e000      	b.n	800fea6 <HAL_RCCEx_PeriphCLKConfig+0xc2a>
        break;
 800fea4:	bf00      	nop
    }

    if (ret == HAL_OK)
 800fea6:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800feaa:	2b00      	cmp	r3, #0
 800feac:	d110      	bne.n	800fed0 <HAL_RCCEx_PeriphCLKConfig+0xc54>
    {
      /* Set the source of I2C3 clock*/
      __HAL_RCC_I2C3_CONFIG(pPeriphClkInit->I2c3ClockSelection);
 800feae:	4b07      	ldr	r3, [pc, #28]	@ (800fecc <HAL_RCCEx_PeriphCLKConfig+0xc50>)
 800feb0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 800feb4:	f423 1140 	bic.w	r1, r3, #3145728	@ 0x300000
 800feb8:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800febc:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 800fec0:	4a02      	ldr	r2, [pc, #8]	@ (800fecc <HAL_RCCEx_PeriphCLKConfig+0xc50>)
 800fec2:	430b      	orrs	r3, r1
 800fec4:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
 800fec8:	e006      	b.n	800fed8 <HAL_RCCEx_PeriphCLKConfig+0xc5c>
 800feca:	bf00      	nop
 800fecc:	44020c00 	.word	0x44020c00
    }
    else
    {
      /* set overall return value */
      status = ret;
 800fed0:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800fed4:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
  }
#endif /* I2C3 */

#if defined(I2C4)
  /*-------------------------- I2C4 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 800fed8:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fedc:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fee0:	2100      	movs	r1, #0
 800fee2:	f8c7 10d0 	str.w	r1, [r7, #208]	@ 0xd0
 800fee6:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800feea:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 800feee:	e9d7 1234 	ldrd	r1, r2, [r7, #208]	@ 0xd0
 800fef2:	460b      	mov	r3, r1
 800fef4:	4313      	orrs	r3, r2
 800fef6:	d03d      	beq.n	800ff74 <HAL_RCCEx_PeriphCLKConfig+0xcf8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(pPeriphClkInit->I2c4ClockSelection));

    switch (pPeriphClkInit->I2c4ClockSelection)
 800fef8:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800fefc:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 800ff00:	f5b3 0f40 	cmp.w	r3, #12582912	@ 0xc00000
 800ff04:	d01b      	beq.n	800ff3e <HAL_RCCEx_PeriphCLKConfig+0xcc2>
 800ff06:	f5b3 0f40 	cmp.w	r3, #12582912	@ 0xc00000
 800ff0a:	d814      	bhi.n	800ff36 <HAL_RCCEx_PeriphCLKConfig+0xcba>
 800ff0c:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 800ff10:	d017      	beq.n	800ff42 <HAL_RCCEx_PeriphCLKConfig+0xcc6>
 800ff12:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 800ff16:	d80e      	bhi.n	800ff36 <HAL_RCCEx_PeriphCLKConfig+0xcba>
 800ff18:	2b00      	cmp	r3, #0
 800ff1a:	d014      	beq.n	800ff46 <HAL_RCCEx_PeriphCLKConfig+0xcca>
 800ff1c:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 800ff20:	d109      	bne.n	800ff36 <HAL_RCCEx_PeriphCLKConfig+0xcba>
        /* I2C4 clock source config set later after clock selection check */
        break;

      case RCC_I2C4CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for I2C4*/
        /* PLL3  input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 800ff22:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800ff26:	3330      	adds	r3, #48	@ 0x30
 800ff28:	4618      	mov	r0, r3
 800ff2a:	f004 f967 	bl	80141fc <RCCEx_PLL3_Config>
 800ff2e:	4603      	mov	r3, r0
 800ff30:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* I2C4 clock source config set later after clock selection check */
        break;
 800ff34:	e008      	b.n	800ff48 <HAL_RCCEx_PeriphCLKConfig+0xccc>
      case RCC_I2C4CLKSOURCE_CSI:      /* CSI clock is used as source of I2C4 clock*/
        /* I2C4 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800ff36:	2301      	movs	r3, #1
 800ff38:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 800ff3c:	e004      	b.n	800ff48 <HAL_RCCEx_PeriphCLKConfig+0xccc>
        break;
 800ff3e:	bf00      	nop
 800ff40:	e002      	b.n	800ff48 <HAL_RCCEx_PeriphCLKConfig+0xccc>
        break;
 800ff42:	bf00      	nop
 800ff44:	e000      	b.n	800ff48 <HAL_RCCEx_PeriphCLKConfig+0xccc>
        break;
 800ff46:	bf00      	nop
    }

    if (ret == HAL_OK)
 800ff48:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800ff4c:	2b00      	cmp	r3, #0
 800ff4e:	d10d      	bne.n	800ff6c <HAL_RCCEx_PeriphCLKConfig+0xcf0>
    {
      /* Set the source of I2C4 clock*/
      __HAL_RCC_I2C4_CONFIG(pPeriphClkInit->I2c4ClockSelection);
 800ff50:	4bbe      	ldr	r3, [pc, #760]	@ (801024c <HAL_RCCEx_PeriphCLKConfig+0xfd0>)
 800ff52:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 800ff56:	f423 0140 	bic.w	r1, r3, #12582912	@ 0xc00000
 800ff5a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800ff5e:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 800ff62:	4aba      	ldr	r2, [pc, #744]	@ (801024c <HAL_RCCEx_PeriphCLKConfig+0xfd0>)
 800ff64:	430b      	orrs	r3, r1
 800ff66:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
 800ff6a:	e003      	b.n	800ff74 <HAL_RCCEx_PeriphCLKConfig+0xcf8>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800ff6c:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800ff70:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
    }
  }
#endif /* I2C4 */

  /*-------------------------- I3C1 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I3C1) == RCC_PERIPHCLK_I3C1)
 800ff74:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800ff78:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ff7c:	f402 3380 	and.w	r3, r2, #65536	@ 0x10000
 800ff80:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 800ff84:	2300      	movs	r3, #0
 800ff86:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 800ff8a:	e9d7 1232 	ldrd	r1, r2, [r7, #200]	@ 0xc8
 800ff8e:	460b      	mov	r3, r1
 800ff90:	4313      	orrs	r3, r2
 800ff92:	d035      	beq.n	8010000 <HAL_RCCEx_PeriphCLKConfig+0xd84>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C1CLKSOURCE(pPeriphClkInit->I3c1ClockSelection));

    switch (pPeriphClkInit->I3c1ClockSelection)
 800ff94:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800ff98:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 800ff9c:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 800ffa0:	d015      	beq.n	800ffce <HAL_RCCEx_PeriphCLKConfig+0xd52>
 800ffa2:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 800ffa6:	d80e      	bhi.n	800ffc6 <HAL_RCCEx_PeriphCLKConfig+0xd4a>
 800ffa8:	2b00      	cmp	r3, #0
 800ffaa:	d012      	beq.n	800ffd2 <HAL_RCCEx_PeriphCLKConfig+0xd56>
 800ffac:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 800ffb0:	d109      	bne.n	800ffc6 <HAL_RCCEx_PeriphCLKConfig+0xd4a>
        break;

#if defined(RCC_I3C1CLKSOURCE_PLL3R)
      case RCC_I3C1CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for I3C1*/
        /* PLL3  input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 800ffb2:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800ffb6:	3330      	adds	r3, #48	@ 0x30
 800ffb8:	4618      	mov	r0, r3
 800ffba:	f004 f91f 	bl	80141fc <RCCEx_PLL3_Config>
 800ffbe:	4603      	mov	r3, r0
 800ffc0:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
      case RCC_I3C1CLKSOURCE_PLL2R:  /* PLL2 is used as clock source for I3C1*/
        /* PLL2  input clock, parameters M, N & R configuration clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
#endif /* RCC_I3C1CLKSOURCE_PLL3R */
        /* I3C1 clock source config set later after clock selection check */
        break;
 800ffc4:	e006      	b.n	800ffd4 <HAL_RCCEx_PeriphCLKConfig+0xd58>
      case RCC_I3C1CLKSOURCE_HSI:      /* HSI clock is used as source of I3C1 clock*/
        /* I3C1 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800ffc6:	2301      	movs	r3, #1
 800ffc8:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 800ffcc:	e002      	b.n	800ffd4 <HAL_RCCEx_PeriphCLKConfig+0xd58>
        break;
 800ffce:	bf00      	nop
 800ffd0:	e000      	b.n	800ffd4 <HAL_RCCEx_PeriphCLKConfig+0xd58>
        break;
 800ffd2:	bf00      	nop
    }

    if (ret == HAL_OK)
 800ffd4:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800ffd8:	2b00      	cmp	r3, #0
 800ffda:	d10d      	bne.n	800fff8 <HAL_RCCEx_PeriphCLKConfig+0xd7c>
    {
      /* Set the source of I3C1 clock*/
      __HAL_RCC_I3C1_CONFIG(pPeriphClkInit->I3c1ClockSelection);
 800ffdc:	4b9b      	ldr	r3, [pc, #620]	@ (801024c <HAL_RCCEx_PeriphCLKConfig+0xfd0>)
 800ffde:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 800ffe2:	f023 7140 	bic.w	r1, r3, #50331648	@ 0x3000000
 800ffe6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800ffea:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 800ffee:	4a97      	ldr	r2, [pc, #604]	@ (801024c <HAL_RCCEx_PeriphCLKConfig+0xfd0>)
 800fff0:	430b      	orrs	r3, r1
 800fff2:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
 800fff6:	e003      	b.n	8010000 <HAL_RCCEx_PeriphCLKConfig+0xd84>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800fff8:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 800fffc:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
    }
  }
#endif /* I3C2 */

  /*------------------------------------ TIM configuration --------------------------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
 8010000:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010004:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010008:	2100      	movs	r1, #0
 801000a:	f8c7 10c0 	str.w	r1, [r7, #192]	@ 0xc0
 801000e:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8010012:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 8010016:	e9d7 1230 	ldrd	r1, r2, [r7, #192]	@ 0xc0
 801001a:	460b      	mov	r3, r1
 801001c:	4313      	orrs	r3, r2
 801001e:	d00e      	beq.n	801003e <HAL_RCCEx_PeriphCLKConfig+0xdc2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(pPeriphClkInit->TimPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(pPeriphClkInit->TimPresSelection);
 8010020:	4b8a      	ldr	r3, [pc, #552]	@ (801024c <HAL_RCCEx_PeriphCLKConfig+0xfd0>)
 8010022:	69db      	ldr	r3, [r3, #28]
 8010024:	4a89      	ldr	r2, [pc, #548]	@ (801024c <HAL_RCCEx_PeriphCLKConfig+0xfd0>)
 8010026:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 801002a:	61d3      	str	r3, [r2, #28]
 801002c:	4b87      	ldr	r3, [pc, #540]	@ (801024c <HAL_RCCEx_PeriphCLKConfig+0xfd0>)
 801002e:	69d9      	ldr	r1, [r3, #28]
 8010030:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010034:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8010038:	4a84      	ldr	r2, [pc, #528]	@ (801024c <HAL_RCCEx_PeriphCLKConfig+0xfd0>)
 801003a:	430b      	orrs	r3, r1
 801003c:	61d3      	str	r3, [r2, #28]
  }

  /*-------------------------- LPTIM1 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 801003e:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010042:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010046:	f402 3300 	and.w	r3, r2, #131072	@ 0x20000
 801004a:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
 801004e:	2300      	movs	r3, #0
 8010050:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
 8010054:	e9d7 122e 	ldrd	r1, r2, [r7, #184]	@ 0xb8
 8010058:	460b      	mov	r3, r1
 801005a:	4313      	orrs	r3, r2
 801005c:	d055      	beq.n	801010a <HAL_RCCEx_PeriphCLKConfig+0xe8e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(pPeriphClkInit->Lptim1ClockSelection));

    switch (pPeriphClkInit->Lptim1ClockSelection)
 801005e:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010062:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8010066:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
 801006a:	d031      	beq.n	80100d0 <HAL_RCCEx_PeriphCLKConfig+0xe54>
 801006c:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
 8010070:	d82a      	bhi.n	80100c8 <HAL_RCCEx_PeriphCLKConfig+0xe4c>
 8010072:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8010076:	d02d      	beq.n	80100d4 <HAL_RCCEx_PeriphCLKConfig+0xe58>
 8010078:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 801007c:	d824      	bhi.n	80100c8 <HAL_RCCEx_PeriphCLKConfig+0xe4c>
 801007e:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8010082:	d029      	beq.n	80100d8 <HAL_RCCEx_PeriphCLKConfig+0xe5c>
 8010084:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8010088:	d81e      	bhi.n	80100c8 <HAL_RCCEx_PeriphCLKConfig+0xe4c>
 801008a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 801008e:	d011      	beq.n	80100b4 <HAL_RCCEx_PeriphCLKConfig+0xe38>
 8010090:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8010094:	d818      	bhi.n	80100c8 <HAL_RCCEx_PeriphCLKConfig+0xe4c>
 8010096:	2b00      	cmp	r3, #0
 8010098:	d020      	beq.n	80100dc <HAL_RCCEx_PeriphCLKConfig+0xe60>
 801009a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 801009e:	d113      	bne.n	80100c8 <HAL_RCCEx_PeriphCLKConfig+0xe4c>
        /* LPTIM1 clock source config set later after clock selection check */
        break;

      case RCC_LPTIM1CLKSOURCE_PLL2P:  /* PLL2 is used as clock source for LPTIM1*/
        /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 80100a0:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80100a4:	3308      	adds	r3, #8
 80100a6:	4618      	mov	r0, r3
 80100a8:	f004 f810 	bl	80140cc <RCCEx_PLL2_Config>
 80100ac:	4603      	mov	r3, r0
 80100ae:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* LPTIM1 clock source config set later after clock selection check */
        break;
 80100b2:	e014      	b.n	80100de <HAL_RCCEx_PeriphCLKConfig+0xe62>

#if defined(RCC_LPTIM1CLKSOURCE_PLL3R)
      case RCC_LPTIM1CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for LPTIM1*/
        /* PLL3 R input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 80100b4:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80100b8:	3330      	adds	r3, #48	@ 0x30
 80100ba:	4618      	mov	r0, r3
 80100bc:	f004 f89e 	bl	80141fc <RCCEx_PLL3_Config>
 80100c0:	4603      	mov	r3, r0
 80100c2:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* LPTIM1 clock source config set later after clock selection check */
        break;
 80100c6:	e00a      	b.n	80100de <HAL_RCCEx_PeriphCLKConfig+0xe62>
      case RCC_LPTIM1CLKSOURCE_CLKP:      /* CLKP is used as source of LPTIM1 clock*/
        /* LPTIM1 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 80100c8:	2301      	movs	r3, #1
 80100ca:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 80100ce:	e006      	b.n	80100de <HAL_RCCEx_PeriphCLKConfig+0xe62>
        break;
 80100d0:	bf00      	nop
 80100d2:	e004      	b.n	80100de <HAL_RCCEx_PeriphCLKConfig+0xe62>
        break;
 80100d4:	bf00      	nop
 80100d6:	e002      	b.n	80100de <HAL_RCCEx_PeriphCLKConfig+0xe62>
        break;
 80100d8:	bf00      	nop
 80100da:	e000      	b.n	80100de <HAL_RCCEx_PeriphCLKConfig+0xe62>
        break;
 80100dc:	bf00      	nop
    }

    if (ret == HAL_OK)
 80100de:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 80100e2:	2b00      	cmp	r3, #0
 80100e4:	d10d      	bne.n	8010102 <HAL_RCCEx_PeriphCLKConfig+0xe86>
    {
      /* Set the source of LPTIM1 clock*/
      __HAL_RCC_LPTIM1_CONFIG(pPeriphClkInit->Lptim1ClockSelection);
 80100e6:	4b59      	ldr	r3, [pc, #356]	@ (801024c <HAL_RCCEx_PeriphCLKConfig+0xfd0>)
 80100e8:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 80100ec:	f423 61e0 	bic.w	r1, r3, #1792	@ 0x700
 80100f0:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80100f4:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 80100f8:	4a54      	ldr	r2, [pc, #336]	@ (801024c <HAL_RCCEx_PeriphCLKConfig+0xfd0>)
 80100fa:	430b      	orrs	r3, r1
 80100fc:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
 8010100:	e003      	b.n	801010a <HAL_RCCEx_PeriphCLKConfig+0xe8e>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8010102:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010106:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
    }
  }

  /*-------------------------- LPTIM2 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
 801010a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801010e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010112:	f402 2380 	and.w	r3, r2, #262144	@ 0x40000
 8010116:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
 801011a:	2300      	movs	r3, #0
 801011c:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
 8010120:	e9d7 122c 	ldrd	r1, r2, [r7, #176]	@ 0xb0
 8010124:	460b      	mov	r3, r1
 8010126:	4313      	orrs	r3, r2
 8010128:	d055      	beq.n	80101d6 <HAL_RCCEx_PeriphCLKConfig+0xf5a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLK(pPeriphClkInit->Lptim2ClockSelection));

    switch (pPeriphClkInit->Lptim2ClockSelection)
 801012a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801012e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8010132:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
 8010136:	d031      	beq.n	801019c <HAL_RCCEx_PeriphCLKConfig+0xf20>
 8010138:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
 801013c:	d82a      	bhi.n	8010194 <HAL_RCCEx_PeriphCLKConfig+0xf18>
 801013e:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8010142:	d02d      	beq.n	80101a0 <HAL_RCCEx_PeriphCLKConfig+0xf24>
 8010144:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8010148:	d824      	bhi.n	8010194 <HAL_RCCEx_PeriphCLKConfig+0xf18>
 801014a:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 801014e:	d029      	beq.n	80101a4 <HAL_RCCEx_PeriphCLKConfig+0xf28>
 8010150:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8010154:	d81e      	bhi.n	8010194 <HAL_RCCEx_PeriphCLKConfig+0xf18>
 8010156:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 801015a:	d011      	beq.n	8010180 <HAL_RCCEx_PeriphCLKConfig+0xf04>
 801015c:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8010160:	d818      	bhi.n	8010194 <HAL_RCCEx_PeriphCLKConfig+0xf18>
 8010162:	2b00      	cmp	r3, #0
 8010164:	d020      	beq.n	80101a8 <HAL_RCCEx_PeriphCLKConfig+0xf2c>
 8010166:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 801016a:	d113      	bne.n	8010194 <HAL_RCCEx_PeriphCLKConfig+0xf18>
        /* LPTIM2 clock source config set later after clock selection check */
        break;

      case RCC_LPTIM2CLKSOURCE_PLL2P:  /* PLL2 is used as clock source for LPTIM2*/
        /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 801016c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010170:	3308      	adds	r3, #8
 8010172:	4618      	mov	r0, r3
 8010174:	f003 ffaa 	bl	80140cc <RCCEx_PLL2_Config>
 8010178:	4603      	mov	r3, r0
 801017a:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* LPTIM2 clock source config set later after clock selection check */
        break;
 801017e:	e014      	b.n	80101aa <HAL_RCCEx_PeriphCLKConfig+0xf2e>

#if defined(RCC_LPTIM2CLKSOURCE_PLL3R)
      case RCC_LPTIM2CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for LPTIM2*/
        /* PLL3 R input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 8010180:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010184:	3330      	adds	r3, #48	@ 0x30
 8010186:	4618      	mov	r0, r3
 8010188:	f004 f838 	bl	80141fc <RCCEx_PLL3_Config>
 801018c:	4603      	mov	r3, r0
 801018e:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* LPTIM2 clock source config set later after clock selection check */
        break;
 8010192:	e00a      	b.n	80101aa <HAL_RCCEx_PeriphCLKConfig+0xf2e>
      case RCC_LPTIM2CLKSOURCE_CLKP:      /* CLKP is used as source of LPTIM2 clock*/
        /* LPTIM2 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8010194:	2301      	movs	r3, #1
 8010196:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 801019a:	e006      	b.n	80101aa <HAL_RCCEx_PeriphCLKConfig+0xf2e>
        break;
 801019c:	bf00      	nop
 801019e:	e004      	b.n	80101aa <HAL_RCCEx_PeriphCLKConfig+0xf2e>
        break;
 80101a0:	bf00      	nop
 80101a2:	e002      	b.n	80101aa <HAL_RCCEx_PeriphCLKConfig+0xf2e>
        break;
 80101a4:	bf00      	nop
 80101a6:	e000      	b.n	80101aa <HAL_RCCEx_PeriphCLKConfig+0xf2e>
        break;
 80101a8:	bf00      	nop
    }

    if (ret == HAL_OK)
 80101aa:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 80101ae:	2b00      	cmp	r3, #0
 80101b0:	d10d      	bne.n	80101ce <HAL_RCCEx_PeriphCLKConfig+0xf52>
    {
      /* Set the source of LPTIM2 clock*/
      __HAL_RCC_LPTIM2_CONFIG(pPeriphClkInit->Lptim2ClockSelection);
 80101b2:	4b26      	ldr	r3, [pc, #152]	@ (801024c <HAL_RCCEx_PeriphCLKConfig+0xfd0>)
 80101b4:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 80101b8:	f423 41e0 	bic.w	r1, r3, #28672	@ 0x7000
 80101bc:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80101c0:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 80101c4:	4a21      	ldr	r2, [pc, #132]	@ (801024c <HAL_RCCEx_PeriphCLKConfig+0xfd0>)
 80101c6:	430b      	orrs	r3, r1
 80101c8:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
 80101cc:	e003      	b.n	80101d6 <HAL_RCCEx_PeriphCLKConfig+0xf5a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80101ce:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 80101d2:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
    }
  }

#if defined(LPTIM3)
  /*-------------------------- LPTIM3 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM3) == RCC_PERIPHCLK_LPTIM3)
 80101d6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80101da:	e9d3 2300 	ldrd	r2, r3, [r3]
 80101de:	2100      	movs	r1, #0
 80101e0:	f8c7 10a8 	str.w	r1, [r7, #168]	@ 0xa8
 80101e4:	f003 0320 	and.w	r3, r3, #32
 80101e8:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
 80101ec:	e9d7 122a 	ldrd	r1, r2, [r7, #168]	@ 0xa8
 80101f0:	460b      	mov	r3, r1
 80101f2:	4313      	orrs	r3, r2
 80101f4:	d057      	beq.n	80102a6 <HAL_RCCEx_PeriphCLKConfig+0x102a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLK(pPeriphClkInit->Lptim3ClockSelection));

    switch (pPeriphClkInit->Lptim3ClockSelection)
 80101f6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80101fa:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 80101fe:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8010202:	d033      	beq.n	801026c <HAL_RCCEx_PeriphCLKConfig+0xff0>
 8010204:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8010208:	d82c      	bhi.n	8010264 <HAL_RCCEx_PeriphCLKConfig+0xfe8>
 801020a:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 801020e:	d02f      	beq.n	8010270 <HAL_RCCEx_PeriphCLKConfig+0xff4>
 8010210:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8010214:	d826      	bhi.n	8010264 <HAL_RCCEx_PeriphCLKConfig+0xfe8>
 8010216:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 801021a:	d02b      	beq.n	8010274 <HAL_RCCEx_PeriphCLKConfig+0xff8>
 801021c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8010220:	d820      	bhi.n	8010264 <HAL_RCCEx_PeriphCLKConfig+0xfe8>
 8010222:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8010226:	d013      	beq.n	8010250 <HAL_RCCEx_PeriphCLKConfig+0xfd4>
 8010228:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 801022c:	d81a      	bhi.n	8010264 <HAL_RCCEx_PeriphCLKConfig+0xfe8>
 801022e:	2b00      	cmp	r3, #0
 8010230:	d022      	beq.n	8010278 <HAL_RCCEx_PeriphCLKConfig+0xffc>
 8010232:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8010236:	d115      	bne.n	8010264 <HAL_RCCEx_PeriphCLKConfig+0xfe8>
        /* LPTIM3 clock source config set later after clock selection check */
        break;

      case RCC_LPTIM3CLKSOURCE_PLL2P:  /* PLL2 is used as clock source for LPTIM3*/
        /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8010238:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801023c:	3308      	adds	r3, #8
 801023e:	4618      	mov	r0, r3
 8010240:	f003 ff44 	bl	80140cc <RCCEx_PLL2_Config>
 8010244:	4603      	mov	r3, r0
 8010246:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* LPTIM3 clock source config set later after clock selection check */
        break;
 801024a:	e016      	b.n	801027a <HAL_RCCEx_PeriphCLKConfig+0xffe>
 801024c:	44020c00 	.word	0x44020c00

      case RCC_LPTIM3CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for LPTIM3*/
        /* PLL3 R input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 8010250:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010254:	3330      	adds	r3, #48	@ 0x30
 8010256:	4618      	mov	r0, r3
 8010258:	f003 ffd0 	bl	80141fc <RCCEx_PLL3_Config>
 801025c:	4603      	mov	r3, r0
 801025e:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* LPTIM3 clock source config set later after clock selection check */
        break;
 8010262:	e00a      	b.n	801027a <HAL_RCCEx_PeriphCLKConfig+0xffe>
      case RCC_LPTIM3CLKSOURCE_CLKP:      /* CLKP is used as source of LPTIM3 clock*/
        /* LPTIM3 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8010264:	2301      	movs	r3, #1
 8010266:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 801026a:	e006      	b.n	801027a <HAL_RCCEx_PeriphCLKConfig+0xffe>
        break;
 801026c:	bf00      	nop
 801026e:	e004      	b.n	801027a <HAL_RCCEx_PeriphCLKConfig+0xffe>
        break;
 8010270:	bf00      	nop
 8010272:	e002      	b.n	801027a <HAL_RCCEx_PeriphCLKConfig+0xffe>
        break;
 8010274:	bf00      	nop
 8010276:	e000      	b.n	801027a <HAL_RCCEx_PeriphCLKConfig+0xffe>
        break;
 8010278:	bf00      	nop
    }

    if (ret == HAL_OK)
 801027a:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 801027e:	2b00      	cmp	r3, #0
 8010280:	d10d      	bne.n	801029e <HAL_RCCEx_PeriphCLKConfig+0x1022>
    {
      /* Set the source of LPTIM3 clock*/
      __HAL_RCC_LPTIM3_CONFIG(pPeriphClkInit->Lptim3ClockSelection);
 8010282:	4bbb      	ldr	r3, [pc, #748]	@ (8010570 <HAL_RCCEx_PeriphCLKConfig+0x12f4>)
 8010284:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 8010288:	f423 21e0 	bic.w	r1, r3, #458752	@ 0x70000
 801028c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010290:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 8010294:	4ab6      	ldr	r2, [pc, #728]	@ (8010570 <HAL_RCCEx_PeriphCLKConfig+0x12f4>)
 8010296:	430b      	orrs	r3, r1
 8010298:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
 801029c:	e003      	b.n	80102a6 <HAL_RCCEx_PeriphCLKConfig+0x102a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 801029e:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 80102a2:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
  }
#endif /* LPTIM3 */

#if defined(LPTIM4)
  /*-------------------------- LPTIM4 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM4) == RCC_PERIPHCLK_LPTIM4)
 80102a6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80102aa:	e9d3 2300 	ldrd	r2, r3, [r3]
 80102ae:	2100      	movs	r1, #0
 80102b0:	f8c7 10a0 	str.w	r1, [r7, #160]	@ 0xa0
 80102b4:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80102b8:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
 80102bc:	e9d7 1228 	ldrd	r1, r2, [r7, #160]	@ 0xa0
 80102c0:	460b      	mov	r3, r1
 80102c2:	4313      	orrs	r3, r2
 80102c4:	d055      	beq.n	8010372 <HAL_RCCEx_PeriphCLKConfig+0x10f6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM4CLK(pPeriphClkInit->Lptim4ClockSelection));

    switch (pPeriphClkInit->Lptim4ClockSelection)
 80102c6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80102ca:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 80102ce:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
 80102d2:	d031      	beq.n	8010338 <HAL_RCCEx_PeriphCLKConfig+0x10bc>
 80102d4:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
 80102d8:	d82a      	bhi.n	8010330 <HAL_RCCEx_PeriphCLKConfig+0x10b4>
 80102da:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 80102de:	d02d      	beq.n	801033c <HAL_RCCEx_PeriphCLKConfig+0x10c0>
 80102e0:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 80102e4:	d824      	bhi.n	8010330 <HAL_RCCEx_PeriphCLKConfig+0x10b4>
 80102e6:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 80102ea:	d029      	beq.n	8010340 <HAL_RCCEx_PeriphCLKConfig+0x10c4>
 80102ec:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 80102f0:	d81e      	bhi.n	8010330 <HAL_RCCEx_PeriphCLKConfig+0x10b4>
 80102f2:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 80102f6:	d011      	beq.n	801031c <HAL_RCCEx_PeriphCLKConfig+0x10a0>
 80102f8:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 80102fc:	d818      	bhi.n	8010330 <HAL_RCCEx_PeriphCLKConfig+0x10b4>
 80102fe:	2b00      	cmp	r3, #0
 8010300:	d020      	beq.n	8010344 <HAL_RCCEx_PeriphCLKConfig+0x10c8>
 8010302:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8010306:	d113      	bne.n	8010330 <HAL_RCCEx_PeriphCLKConfig+0x10b4>
        /* LPTIM4 clock source config set later after clock selection check */
        break;

      case RCC_LPTIM4CLKSOURCE_PLL2P:  /* PLL2 is used as clock source for LPTIM4*/
        /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8010308:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801030c:	3308      	adds	r3, #8
 801030e:	4618      	mov	r0, r3
 8010310:	f003 fedc 	bl	80140cc <RCCEx_PLL2_Config>
 8010314:	4603      	mov	r3, r0
 8010316:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* LPTIM4 clock source config set later after clock selection check */
        break;
 801031a:	e014      	b.n	8010346 <HAL_RCCEx_PeriphCLKConfig+0x10ca>

      case RCC_LPTIM4CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for LPTIM4*/
        /* PLL3 R input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 801031c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010320:	3330      	adds	r3, #48	@ 0x30
 8010322:	4618      	mov	r0, r3
 8010324:	f003 ff6a 	bl	80141fc <RCCEx_PLL3_Config>
 8010328:	4603      	mov	r3, r0
 801032a:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* LPTIM4 clock source config set later after clock selection check */
        break;
 801032e:	e00a      	b.n	8010346 <HAL_RCCEx_PeriphCLKConfig+0x10ca>
      case RCC_LPTIM4CLKSOURCE_CLKP:      /* CLKP is used as source of LPTIM4 clock*/
        /* LPTIM4 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8010330:	2301      	movs	r3, #1
 8010332:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 8010336:	e006      	b.n	8010346 <HAL_RCCEx_PeriphCLKConfig+0x10ca>
        break;
 8010338:	bf00      	nop
 801033a:	e004      	b.n	8010346 <HAL_RCCEx_PeriphCLKConfig+0x10ca>
        break;
 801033c:	bf00      	nop
 801033e:	e002      	b.n	8010346 <HAL_RCCEx_PeriphCLKConfig+0x10ca>
        break;
 8010340:	bf00      	nop
 8010342:	e000      	b.n	8010346 <HAL_RCCEx_PeriphCLKConfig+0x10ca>
        break;
 8010344:	bf00      	nop
    }

    if (ret == HAL_OK)
 8010346:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 801034a:	2b00      	cmp	r3, #0
 801034c:	d10d      	bne.n	801036a <HAL_RCCEx_PeriphCLKConfig+0x10ee>
    {
      /* Set the source of LPTIM4 clock*/
      __HAL_RCC_LPTIM4_CONFIG(pPeriphClkInit->Lptim4ClockSelection);
 801034e:	4b88      	ldr	r3, [pc, #544]	@ (8010570 <HAL_RCCEx_PeriphCLKConfig+0x12f4>)
 8010350:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 8010354:	f423 01e0 	bic.w	r1, r3, #7340032	@ 0x700000
 8010358:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801035c:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 8010360:	4a83      	ldr	r2, [pc, #524]	@ (8010570 <HAL_RCCEx_PeriphCLKConfig+0x12f4>)
 8010362:	430b      	orrs	r3, r1
 8010364:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
 8010368:	e003      	b.n	8010372 <HAL_RCCEx_PeriphCLKConfig+0x10f6>
    }
    else
    {
      /* set overall return value */
      status = ret;
 801036a:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 801036e:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
  }
#endif /* LPTIM4 */

#if defined(LPTIM5)
  /*-------------------------- LPTIM5 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM5) == RCC_PERIPHCLK_LPTIM5)
 8010372:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010376:	e9d3 2300 	ldrd	r2, r3, [r3]
 801037a:	2100      	movs	r1, #0
 801037c:	f8c7 1098 	str.w	r1, [r7, #152]	@ 0x98
 8010380:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8010384:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
 8010388:	e9d7 1226 	ldrd	r1, r2, [r7, #152]	@ 0x98
 801038c:	460b      	mov	r3, r1
 801038e:	4313      	orrs	r3, r2
 8010390:	d055      	beq.n	801043e <HAL_RCCEx_PeriphCLKConfig+0x11c2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM5CLK(pPeriphClkInit->Lptim5ClockSelection));

    switch (pPeriphClkInit->Lptim5ClockSelection)
 8010392:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010396:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 801039a:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
 801039e:	d031      	beq.n	8010404 <HAL_RCCEx_PeriphCLKConfig+0x1188>
 80103a0:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
 80103a4:	d82a      	bhi.n	80103fc <HAL_RCCEx_PeriphCLKConfig+0x1180>
 80103a6:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 80103aa:	d02d      	beq.n	8010408 <HAL_RCCEx_PeriphCLKConfig+0x118c>
 80103ac:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 80103b0:	d824      	bhi.n	80103fc <HAL_RCCEx_PeriphCLKConfig+0x1180>
 80103b2:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 80103b6:	d029      	beq.n	801040c <HAL_RCCEx_PeriphCLKConfig+0x1190>
 80103b8:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 80103bc:	d81e      	bhi.n	80103fc <HAL_RCCEx_PeriphCLKConfig+0x1180>
 80103be:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 80103c2:	d011      	beq.n	80103e8 <HAL_RCCEx_PeriphCLKConfig+0x116c>
 80103c4:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 80103c8:	d818      	bhi.n	80103fc <HAL_RCCEx_PeriphCLKConfig+0x1180>
 80103ca:	2b00      	cmp	r3, #0
 80103cc:	d020      	beq.n	8010410 <HAL_RCCEx_PeriphCLKConfig+0x1194>
 80103ce:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 80103d2:	d113      	bne.n	80103fc <HAL_RCCEx_PeriphCLKConfig+0x1180>
        /* LPTIM5 clock source config set later after clock selection check */
        break;

      case RCC_LPTIM5CLKSOURCE_PLL2P:  /* PLL2 is used as clock source for LPTIM5*/
        /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 80103d4:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80103d8:	3308      	adds	r3, #8
 80103da:	4618      	mov	r0, r3
 80103dc:	f003 fe76 	bl	80140cc <RCCEx_PLL2_Config>
 80103e0:	4603      	mov	r3, r0
 80103e2:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* LPTIM5 clock source config set later after clock selection check */
        break;
 80103e6:	e014      	b.n	8010412 <HAL_RCCEx_PeriphCLKConfig+0x1196>

      case RCC_LPTIM5CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for LPTIM5*/
        /* PLL3 R input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 80103e8:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80103ec:	3330      	adds	r3, #48	@ 0x30
 80103ee:	4618      	mov	r0, r3
 80103f0:	f003 ff04 	bl	80141fc <RCCEx_PLL3_Config>
 80103f4:	4603      	mov	r3, r0
 80103f6:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* LPTIM5 clock source config set later after clock selection check */
        break;
 80103fa:	e00a      	b.n	8010412 <HAL_RCCEx_PeriphCLKConfig+0x1196>
      case RCC_LPTIM5CLKSOURCE_CLKP:      /* CLKP is used as source of LPTIM5 clock*/
        /* LPTIM5 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 80103fc:	2301      	movs	r3, #1
 80103fe:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 8010402:	e006      	b.n	8010412 <HAL_RCCEx_PeriphCLKConfig+0x1196>
        break;
 8010404:	bf00      	nop
 8010406:	e004      	b.n	8010412 <HAL_RCCEx_PeriphCLKConfig+0x1196>
        break;
 8010408:	bf00      	nop
 801040a:	e002      	b.n	8010412 <HAL_RCCEx_PeriphCLKConfig+0x1196>
        break;
 801040c:	bf00      	nop
 801040e:	e000      	b.n	8010412 <HAL_RCCEx_PeriphCLKConfig+0x1196>
        break;
 8010410:	bf00      	nop
    }

    if (ret == HAL_OK)
 8010412:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010416:	2b00      	cmp	r3, #0
 8010418:	d10d      	bne.n	8010436 <HAL_RCCEx_PeriphCLKConfig+0x11ba>
    {
      /* Set the source of LPTIM5 clock*/
      __HAL_RCC_LPTIM5_CONFIG(pPeriphClkInit->Lptim5ClockSelection);
 801041a:	4b55      	ldr	r3, [pc, #340]	@ (8010570 <HAL_RCCEx_PeriphCLKConfig+0x12f4>)
 801041c:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 8010420:	f023 61e0 	bic.w	r1, r3, #117440512	@ 0x7000000
 8010424:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010428:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 801042c:	4a50      	ldr	r2, [pc, #320]	@ (8010570 <HAL_RCCEx_PeriphCLKConfig+0x12f4>)
 801042e:	430b      	orrs	r3, r1
 8010430:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
 8010434:	e003      	b.n	801043e <HAL_RCCEx_PeriphCLKConfig+0x11c2>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8010436:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 801043a:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
  }
#endif /* LPTIM5 */

#if defined(LPTIM6)
  /*-------------------------- LPTIM6 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM6) == RCC_PERIPHCLK_LPTIM6)
 801043e:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010442:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010446:	2100      	movs	r1, #0
 8010448:	f8c7 1090 	str.w	r1, [r7, #144]	@ 0x90
 801044c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8010450:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
 8010454:	e9d7 1224 	ldrd	r1, r2, [r7, #144]	@ 0x90
 8010458:	460b      	mov	r3, r1
 801045a:	4313      	orrs	r3, r2
 801045c:	d055      	beq.n	801050a <HAL_RCCEx_PeriphCLKConfig+0x128e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM6CLK(pPeriphClkInit->Lptim6ClockSelection));

    switch (pPeriphClkInit->Lptim6ClockSelection)
 801045e:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010462:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
 8010466:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 801046a:	d031      	beq.n	80104d0 <HAL_RCCEx_PeriphCLKConfig+0x1254>
 801046c:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8010470:	d82a      	bhi.n	80104c8 <HAL_RCCEx_PeriphCLKConfig+0x124c>
 8010472:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8010476:	d02d      	beq.n	80104d4 <HAL_RCCEx_PeriphCLKConfig+0x1258>
 8010478:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 801047c:	d824      	bhi.n	80104c8 <HAL_RCCEx_PeriphCLKConfig+0x124c>
 801047e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 8010482:	d029      	beq.n	80104d8 <HAL_RCCEx_PeriphCLKConfig+0x125c>
 8010484:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 8010488:	d81e      	bhi.n	80104c8 <HAL_RCCEx_PeriphCLKConfig+0x124c>
 801048a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 801048e:	d011      	beq.n	80104b4 <HAL_RCCEx_PeriphCLKConfig+0x1238>
 8010490:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8010494:	d818      	bhi.n	80104c8 <HAL_RCCEx_PeriphCLKConfig+0x124c>
 8010496:	2b00      	cmp	r3, #0
 8010498:	d020      	beq.n	80104dc <HAL_RCCEx_PeriphCLKConfig+0x1260>
 801049a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 801049e:	d113      	bne.n	80104c8 <HAL_RCCEx_PeriphCLKConfig+0x124c>
        /* LPTIM6 clock source config set later after clock selection check */
        break;

      case RCC_LPTIM6CLKSOURCE_PLL2P:  /* PLL2 is used as clock source for LPTIM6*/
        /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 80104a0:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80104a4:	3308      	adds	r3, #8
 80104a6:	4618      	mov	r0, r3
 80104a8:	f003 fe10 	bl	80140cc <RCCEx_PLL2_Config>
 80104ac:	4603      	mov	r3, r0
 80104ae:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* LPTIM6 clock source config set later after clock selection check */
        break;
 80104b2:	e014      	b.n	80104de <HAL_RCCEx_PeriphCLKConfig+0x1262>

      case RCC_LPTIM6CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for LPTIM6*/
        /* PLL3 R input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 80104b4:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80104b8:	3330      	adds	r3, #48	@ 0x30
 80104ba:	4618      	mov	r0, r3
 80104bc:	f003 fe9e 	bl	80141fc <RCCEx_PLL3_Config>
 80104c0:	4603      	mov	r3, r0
 80104c2:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* LPTIM6 clock source config set later after clock selection check */
        break;
 80104c6:	e00a      	b.n	80104de <HAL_RCCEx_PeriphCLKConfig+0x1262>
      case RCC_LPTIM6CLKSOURCE_CLKP:      /* CLKP is used as source of LPTIM6 clock*/
        /* LPTIM6 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 80104c8:	2301      	movs	r3, #1
 80104ca:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 80104ce:	e006      	b.n	80104de <HAL_RCCEx_PeriphCLKConfig+0x1262>
        break;
 80104d0:	bf00      	nop
 80104d2:	e004      	b.n	80104de <HAL_RCCEx_PeriphCLKConfig+0x1262>
        break;
 80104d4:	bf00      	nop
 80104d6:	e002      	b.n	80104de <HAL_RCCEx_PeriphCLKConfig+0x1262>
        break;
 80104d8:	bf00      	nop
 80104da:	e000      	b.n	80104de <HAL_RCCEx_PeriphCLKConfig+0x1262>
        break;
 80104dc:	bf00      	nop
    }

    if (ret == HAL_OK)
 80104de:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 80104e2:	2b00      	cmp	r3, #0
 80104e4:	d10d      	bne.n	8010502 <HAL_RCCEx_PeriphCLKConfig+0x1286>
    {
      /* Set the source of LPTIM6 clock*/
      __HAL_RCC_LPTIM6_CONFIG(pPeriphClkInit->Lptim6ClockSelection);
 80104e6:	4b22      	ldr	r3, [pc, #136]	@ (8010570 <HAL_RCCEx_PeriphCLKConfig+0x12f4>)
 80104e8:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 80104ec:	f023 41e0 	bic.w	r1, r3, #1879048192	@ 0x70000000
 80104f0:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80104f4:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
 80104f8:	4a1d      	ldr	r2, [pc, #116]	@ (8010570 <HAL_RCCEx_PeriphCLKConfig+0x12f4>)
 80104fa:	430b      	orrs	r3, r1
 80104fc:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
 8010500:	e003      	b.n	801050a <HAL_RCCEx_PeriphCLKConfig+0x128e>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8010502:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010506:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
  }
#endif /* LPTIM6 */

#if defined(SAI1)
  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 801050a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801050e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010512:	f402 2300 	and.w	r3, r2, #524288	@ 0x80000
 8010516:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 801051a:	2300      	movs	r3, #0
 801051c:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 8010520:	e9d7 1222 	ldrd	r1, r2, [r7, #136]	@ 0x88
 8010524:	460b      	mov	r3, r1
 8010526:	4313      	orrs	r3, r2
 8010528:	d055      	beq.n	80105d6 <HAL_RCCEx_PeriphCLKConfig+0x135a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(pPeriphClkInit->Sai1ClockSelection));

    switch (pPeriphClkInit->Sai1ClockSelection)
 801052a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801052e:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
 8010532:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8010536:	d035      	beq.n	80105a4 <HAL_RCCEx_PeriphCLKConfig+0x1328>
 8010538:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 801053c:	d82e      	bhi.n	801059c <HAL_RCCEx_PeriphCLKConfig+0x1320>
 801053e:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8010542:	d031      	beq.n	80105a8 <HAL_RCCEx_PeriphCLKConfig+0x132c>
 8010544:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8010548:	d828      	bhi.n	801059c <HAL_RCCEx_PeriphCLKConfig+0x1320>
 801054a:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 801054e:	d01b      	beq.n	8010588 <HAL_RCCEx_PeriphCLKConfig+0x130c>
 8010550:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8010554:	d822      	bhi.n	801059c <HAL_RCCEx_PeriphCLKConfig+0x1320>
 8010556:	2b00      	cmp	r3, #0
 8010558:	d003      	beq.n	8010562 <HAL_RCCEx_PeriphCLKConfig+0x12e6>
 801055a:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 801055e:	d009      	beq.n	8010574 <HAL_RCCEx_PeriphCLKConfig+0x12f8>
 8010560:	e01c      	b.n	801059c <HAL_RCCEx_PeriphCLKConfig+0x1320>
    {
      case RCC_SAI1CLKSOURCE_PLL1Q:      /* PLL is used as clock source for SAI1*/
        /* Enable SAI Clock output generated from System PLL . */
        __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8010562:	4b03      	ldr	r3, [pc, #12]	@ (8010570 <HAL_RCCEx_PeriphCLKConfig+0x12f4>)
 8010564:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8010566:	4a02      	ldr	r2, [pc, #8]	@ (8010570 <HAL_RCCEx_PeriphCLKConfig+0x12f4>)
 8010568:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 801056c:	6293      	str	r3, [r2, #40]	@ 0x28
        /* SAI1 clock source config set later after clock selection check */
        break;
 801056e:	e01c      	b.n	80105aa <HAL_RCCEx_PeriphCLKConfig+0x132e>
 8010570:	44020c00 	.word	0x44020c00

      case RCC_SAI1CLKSOURCE_PLL2P:  /* PLL2 is used as clock source for SAI1*/
        /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8010574:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010578:	3308      	adds	r3, #8
 801057a:	4618      	mov	r0, r3
 801057c:	f003 fda6 	bl	80140cc <RCCEx_PLL2_Config>
 8010580:	4603      	mov	r3, r0
 8010582:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* SAI1 clock source config set later after clock selection check */
        break;
 8010586:	e010      	b.n	80105aa <HAL_RCCEx_PeriphCLKConfig+0x132e>

      case RCC_SAI1CLKSOURCE_PLL3P:  /* PLL3 is used as clock source for SAI1*/
        /* PLL3 P input clock, parameters M, N & P configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 8010588:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801058c:	3330      	adds	r3, #48	@ 0x30
 801058e:	4618      	mov	r0, r3
 8010590:	f003 fe34 	bl	80141fc <RCCEx_PLL3_Config>
 8010594:	4603      	mov	r3, r0
 8010596:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* SAI1 clock source config set later after clock selection check */
        break;
 801059a:	e006      	b.n	80105aa <HAL_RCCEx_PeriphCLKConfig+0x132e>
      case RCC_SAI1CLKSOURCE_CLKP:      /* CLKP is used as source of SAI1 clock*/
        /* SAI1 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 801059c:	2301      	movs	r3, #1
 801059e:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 80105a2:	e002      	b.n	80105aa <HAL_RCCEx_PeriphCLKConfig+0x132e>
        break;
 80105a4:	bf00      	nop
 80105a6:	e000      	b.n	80105aa <HAL_RCCEx_PeriphCLKConfig+0x132e>
        break;
 80105a8:	bf00      	nop
    }

    if (ret == HAL_OK)
 80105aa:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 80105ae:	2b00      	cmp	r3, #0
 80105b0:	d10d      	bne.n	80105ce <HAL_RCCEx_PeriphCLKConfig+0x1352>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(pPeriphClkInit->Sai1ClockSelection);
 80105b2:	4bc3      	ldr	r3, [pc, #780]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 80105b4:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 80105b8:	f423 21e0 	bic.w	r1, r3, #458752	@ 0x70000
 80105bc:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80105c0:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
 80105c4:	4abe      	ldr	r2, [pc, #760]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 80105c6:	430b      	orrs	r3, r1
 80105c8:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
 80105cc:	e003      	b.n	80105d6 <HAL_RCCEx_PeriphCLKConfig+0x135a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80105ce:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 80105d2:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
  }
#endif /* SAI1*/

#if defined(SAI2)
  /*-------------------------- SAI2 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2)
 80105d6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80105da:	e9d3 2300 	ldrd	r2, r3, [r3]
 80105de:	f402 1380 	and.w	r3, r2, #1048576	@ 0x100000
 80105e2:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 80105e6:	2300      	movs	r3, #0
 80105e8:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 80105ec:	e9d7 1220 	ldrd	r1, r2, [r7, #128]	@ 0x80
 80105f0:	460b      	mov	r3, r1
 80105f2:	4313      	orrs	r3, r2
 80105f4:	d051      	beq.n	801069a <HAL_RCCEx_PeriphCLKConfig+0x141e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLK(pPeriphClkInit->Sai2ClockSelection));

    switch (pPeriphClkInit->Sai2ClockSelection)
 80105f6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80105fa:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
 80105fe:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8010602:	d033      	beq.n	801066c <HAL_RCCEx_PeriphCLKConfig+0x13f0>
 8010604:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8010608:	d82c      	bhi.n	8010664 <HAL_RCCEx_PeriphCLKConfig+0x13e8>
 801060a:	f5b3 1fc0 	cmp.w	r3, #1572864	@ 0x180000
 801060e:	d02d      	beq.n	801066c <HAL_RCCEx_PeriphCLKConfig+0x13f0>
 8010610:	f5b3 1fc0 	cmp.w	r3, #1572864	@ 0x180000
 8010614:	d826      	bhi.n	8010664 <HAL_RCCEx_PeriphCLKConfig+0x13e8>
 8010616:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 801061a:	d019      	beq.n	8010650 <HAL_RCCEx_PeriphCLKConfig+0x13d4>
 801061c:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8010620:	d820      	bhi.n	8010664 <HAL_RCCEx_PeriphCLKConfig+0x13e8>
 8010622:	2b00      	cmp	r3, #0
 8010624:	d003      	beq.n	801062e <HAL_RCCEx_PeriphCLKConfig+0x13b2>
 8010626:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 801062a:	d007      	beq.n	801063c <HAL_RCCEx_PeriphCLKConfig+0x13c0>
 801062c:	e01a      	b.n	8010664 <HAL_RCCEx_PeriphCLKConfig+0x13e8>
    {
      case RCC_SAI2CLKSOURCE_PLL1Q:      /* PLL is used as clock source for SAI2*/
        /* Enable SAI Clock output generated from System PLL . */
        __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
 801062e:	4ba4      	ldr	r3, [pc, #656]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 8010630:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8010632:	4aa3      	ldr	r2, [pc, #652]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 8010634:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8010638:	6293      	str	r3, [r2, #40]	@ 0x28
        /* SAI2 clock source config set later after clock selection check */
        break;
 801063a:	e018      	b.n	801066e <HAL_RCCEx_PeriphCLKConfig+0x13f2>

      case RCC_SAI2CLKSOURCE_PLL2P: /* PLL2 is used as clock source for SAI2*/
        /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 801063c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010640:	3308      	adds	r3, #8
 8010642:	4618      	mov	r0, r3
 8010644:	f003 fd42 	bl	80140cc <RCCEx_PLL2_Config>
 8010648:	4603      	mov	r3, r0
 801064a:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* SAI2 clock source config set later after clock selection check */
        break;
 801064e:	e00e      	b.n	801066e <HAL_RCCEx_PeriphCLKConfig+0x13f2>

      case RCC_SAI2CLKSOURCE_PLL3P:  /* PLL3 is used as clock source for SAI2*/
        /* PLL3 P input clock, parameters M, N & P configuration and clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 8010650:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010654:	3330      	adds	r3, #48	@ 0x30
 8010656:	4618      	mov	r0, r3
 8010658:	f003 fdd0 	bl	80141fc <RCCEx_PLL3_Config>
 801065c:	4603      	mov	r3, r0
 801065e:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* SAI2 clock source config set later after clock selection check */
        break;
 8010662:	e004      	b.n	801066e <HAL_RCCEx_PeriphCLKConfig+0x13f2>
      case RCC_SAI2CLKSOURCE_CLKP:      /* CLKP is used as source of SAI2 clock*/
        /* SAI2 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8010664:	2301      	movs	r3, #1
 8010666:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 801066a:	e000      	b.n	801066e <HAL_RCCEx_PeriphCLKConfig+0x13f2>
        break;
 801066c:	bf00      	nop
    }

    if (ret == HAL_OK)
 801066e:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010672:	2b00      	cmp	r3, #0
 8010674:	d10d      	bne.n	8010692 <HAL_RCCEx_PeriphCLKConfig+0x1416>
    {
      /* Set the source of SAI2 clock*/
      __HAL_RCC_SAI2_CONFIG(pPeriphClkInit->Sai2ClockSelection);
 8010676:	4b92      	ldr	r3, [pc, #584]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 8010678:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 801067c:	f423 1160 	bic.w	r1, r3, #3670016	@ 0x380000
 8010680:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010684:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
 8010688:	4a8d      	ldr	r2, [pc, #564]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 801068a:	430b      	orrs	r3, r1
 801068c:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
 8010690:	e003      	b.n	801069a <HAL_RCCEx_PeriphCLKConfig+0x141e>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8010692:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010696:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
    }
  }
#endif /* SAI2*/

  /*-------------------------- ADCDAC clock source configuration ----------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADCDAC) == RCC_PERIPHCLK_ADCDAC)
 801069a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801069e:	e9d3 2300 	ldrd	r2, r3, [r3]
 80106a2:	f402 1300 	and.w	r3, r2, #2097152	@ 0x200000
 80106a6:	67bb      	str	r3, [r7, #120]	@ 0x78
 80106a8:	2300      	movs	r3, #0
 80106aa:	67fb      	str	r3, [r7, #124]	@ 0x7c
 80106ac:	e9d7 121e 	ldrd	r1, r2, [r7, #120]	@ 0x78
 80106b0:	460b      	mov	r3, r1
 80106b2:	4313      	orrs	r3, r2
 80106b4:	d032      	beq.n	801071c <HAL_RCCEx_PeriphCLKConfig+0x14a0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCDACCLKSOURCE(pPeriphClkInit->AdcDacClockSelection));

    switch (pPeriphClkInit->AdcDacClockSelection)
 80106b6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80106ba:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
 80106be:	2b05      	cmp	r3, #5
 80106c0:	d80f      	bhi.n	80106e2 <HAL_RCCEx_PeriphCLKConfig+0x1466>
 80106c2:	2b03      	cmp	r3, #3
 80106c4:	d211      	bcs.n	80106ea <HAL_RCCEx_PeriphCLKConfig+0x146e>
 80106c6:	2b01      	cmp	r3, #1
 80106c8:	d911      	bls.n	80106ee <HAL_RCCEx_PeriphCLKConfig+0x1472>
 80106ca:	2b02      	cmp	r3, #2
 80106cc:	d109      	bne.n	80106e2 <HAL_RCCEx_PeriphCLKConfig+0x1466>
        /* ADCDAC clock source config set later after clock selection check */
        break;

      case RCC_ADCDACCLKSOURCE_PLL2R:
        /* PLL2 input clock, parameters M, N & R configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 80106ce:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80106d2:	3308      	adds	r3, #8
 80106d4:	4618      	mov	r0, r3
 80106d6:	f003 fcf9 	bl	80140cc <RCCEx_PLL2_Config>
 80106da:	4603      	mov	r3, r0
 80106dc:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 80106e0:	e006      	b.n	80106f0 <HAL_RCCEx_PeriphCLKConfig+0x1474>
        /* ADCDAC clock source configuration done later after clock selection check */
        break;


      default:
        ret = HAL_ERROR;
 80106e2:	2301      	movs	r3, #1
 80106e4:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 80106e8:	e002      	b.n	80106f0 <HAL_RCCEx_PeriphCLKConfig+0x1474>
        break;
 80106ea:	bf00      	nop
 80106ec:	e000      	b.n	80106f0 <HAL_RCCEx_PeriphCLKConfig+0x1474>
        break;
 80106ee:	bf00      	nop
    }

    if (ret == HAL_OK)
 80106f0:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 80106f4:	2b00      	cmp	r3, #0
 80106f6:	d10d      	bne.n	8010714 <HAL_RCCEx_PeriphCLKConfig+0x1498>
    {
      /* Configure the ADCDAC interface clock source */
      __HAL_RCC_ADCDAC_CONFIG(pPeriphClkInit->AdcDacClockSelection);
 80106f8:	4b71      	ldr	r3, [pc, #452]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 80106fa:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 80106fe:	f023 0107 	bic.w	r1, r3, #7
 8010702:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010706:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
 801070a:	4a6d      	ldr	r2, [pc, #436]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 801070c:	430b      	orrs	r3, r1
 801070e:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
 8010712:	e003      	b.n	801071c <HAL_RCCEx_PeriphCLKConfig+0x14a0>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8010714:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010718:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
    }

  }

  /*-------------------------- DAC low-power clock source configuration ----------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DAC_LP) == RCC_PERIPHCLK_DAC_LP)
 801071c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010720:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010724:	2100      	movs	r1, #0
 8010726:	6739      	str	r1, [r7, #112]	@ 0x70
 8010728:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 801072c:	677b      	str	r3, [r7, #116]	@ 0x74
 801072e:	e9d7 121c 	ldrd	r1, r2, [r7, #112]	@ 0x70
 8010732:	460b      	mov	r3, r1
 8010734:	4313      	orrs	r3, r2
 8010736:	d024      	beq.n	8010782 <HAL_RCCEx_PeriphCLKConfig+0x1506>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DACLPCLKSOURCE(pPeriphClkInit->DacLowPowerClockSelection));

    switch (pPeriphClkInit->DacLowPowerClockSelection)
 8010738:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801073c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8010740:	2b00      	cmp	r3, #0
 8010742:	d005      	beq.n	8010750 <HAL_RCCEx_PeriphCLKConfig+0x14d4>
 8010744:	2b08      	cmp	r3, #8
 8010746:	d005      	beq.n	8010754 <HAL_RCCEx_PeriphCLKConfig+0x14d8>
        /* LSI is used as clock source for DAC low-power clock */
        /* DAC clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8010748:	2301      	movs	r3, #1
 801074a:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 801074e:	e002      	b.n	8010756 <HAL_RCCEx_PeriphCLKConfig+0x14da>
        break;
 8010750:	bf00      	nop
 8010752:	e000      	b.n	8010756 <HAL_RCCEx_PeriphCLKConfig+0x14da>
        break;
 8010754:	bf00      	nop
    }

    if (ret == HAL_OK)
 8010756:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 801075a:	2b00      	cmp	r3, #0
 801075c:	d10d      	bne.n	801077a <HAL_RCCEx_PeriphCLKConfig+0x14fe>
    {
      /* Configure the DAC low-power interface clock source */
      __HAL_RCC_DAC_LP_CONFIG(pPeriphClkInit->DacLowPowerClockSelection);
 801075e:	4b58      	ldr	r3, [pc, #352]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 8010760:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8010764:	f023 0108 	bic.w	r1, r3, #8
 8010768:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801076c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8010770:	4a53      	ldr	r2, [pc, #332]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 8010772:	430b      	orrs	r3, r1
 8010774:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
 8010778:	e003      	b.n	8010782 <HAL_RCCEx_PeriphCLKConfig+0x1506>
    }
    else
    {
      /* set overall return value */
      status = ret;
 801077a:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 801077e:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
    }

  }

  /*-------------------------- RTC clock source configuration ----------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8010782:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010786:	e9d3 2300 	ldrd	r2, r3, [r3]
 801078a:	f002 7300 	and.w	r3, r2, #33554432	@ 0x2000000
 801078e:	66bb      	str	r3, [r7, #104]	@ 0x68
 8010790:	2300      	movs	r3, #0
 8010792:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8010794:	e9d7 121a 	ldrd	r1, r2, [r7, #104]	@ 0x68
 8010798:	460b      	mov	r3, r1
 801079a:	4313      	orrs	r3, r2
 801079c:	f000 80b9 	beq.w	8010912 <HAL_RCCEx_PeriphCLKConfig+0x1696>

    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(pPeriphClkInit->RTCClockSelection));

    /* Enable write access to Backup domain */
    SET_BIT(PWR->DBPCR, PWR_DBPCR_DBP);
 80107a0:	4b48      	ldr	r3, [pc, #288]	@ (80108c4 <HAL_RCCEx_PeriphCLKConfig+0x1648>)
 80107a2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80107a4:	4a47      	ldr	r2, [pc, #284]	@ (80108c4 <HAL_RCCEx_PeriphCLKConfig+0x1648>)
 80107a6:	f043 0301 	orr.w	r3, r3, #1
 80107aa:	6253      	str	r3, [r2, #36]	@ 0x24

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 80107ac:	f7fd fb0e 	bl	800ddcc <HAL_GetTick>
 80107b0:	f8c7 0154 	str.w	r0, [r7, #340]	@ 0x154

    while (HAL_IS_BIT_CLR(PWR->DBPCR, PWR_DBPCR_DBP))
 80107b4:	e00b      	b.n	80107ce <HAL_RCCEx_PeriphCLKConfig+0x1552>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80107b6:	f7fd fb09 	bl	800ddcc <HAL_GetTick>
 80107ba:	4602      	mov	r2, r0
 80107bc:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 80107c0:	1ad3      	subs	r3, r2, r3
 80107c2:	2b02      	cmp	r3, #2
 80107c4:	d903      	bls.n	80107ce <HAL_RCCEx_PeriphCLKConfig+0x1552>
      {
        ret = HAL_TIMEOUT;
 80107c6:	2303      	movs	r3, #3
 80107c8:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 80107cc:	e005      	b.n	80107da <HAL_RCCEx_PeriphCLKConfig+0x155e>
    while (HAL_IS_BIT_CLR(PWR->DBPCR, PWR_DBPCR_DBP))
 80107ce:	4b3d      	ldr	r3, [pc, #244]	@ (80108c4 <HAL_RCCEx_PeriphCLKConfig+0x1648>)
 80107d0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80107d2:	f003 0301 	and.w	r3, r3, #1
 80107d6:	2b00      	cmp	r3, #0
 80107d8:	d0ed      	beq.n	80107b6 <HAL_RCCEx_PeriphCLKConfig+0x153a>
      }
    }

    if (ret == HAL_OK)
 80107da:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 80107de:	2b00      	cmp	r3, #0
 80107e0:	f040 8093 	bne.w	801090a <HAL_RCCEx_PeriphCLKConfig+0x168e>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 80107e4:	4b36      	ldr	r3, [pc, #216]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 80107e6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80107ea:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 80107ee:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c

      if ((tmpregister != RCC_RTCCLKSOURCE_NO_CLK) && (tmpregister != pPeriphClkInit->RTCClockSelection))
 80107f2:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 80107f6:	2b00      	cmp	r3, #0
 80107f8:	d023      	beq.n	8010842 <HAL_RCCEx_PeriphCLKConfig+0x15c6>
 80107fa:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80107fe:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
 8010802:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8010806:	4293      	cmp	r3, r2
 8010808:	d01b      	beq.n	8010842 <HAL_RCCEx_PeriphCLKConfig+0x15c6>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 801080a:	4b2d      	ldr	r3, [pc, #180]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 801080c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8010810:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8010814:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 8010818:	4b29      	ldr	r3, [pc, #164]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 801081a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 801081e:	4a28      	ldr	r2, [pc, #160]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 8010820:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8010824:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
        __HAL_RCC_BACKUPRESET_RELEASE();
 8010828:	4b25      	ldr	r3, [pc, #148]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 801082a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 801082e:	4a24      	ldr	r2, [pc, #144]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 8010830:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8010834:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
 8010838:	4a21      	ldr	r2, [pc, #132]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 801083a:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801083e:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8010842:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8010846:	f003 0301 	and.w	r3, r3, #1
 801084a:	2b00      	cmp	r3, #0
 801084c:	d019      	beq.n	8010882 <HAL_RCCEx_PeriphCLKConfig+0x1606>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 801084e:	f7fd fabd 	bl	800ddcc <HAL_GetTick>
 8010852:	f8c7 0154 	str.w	r0, [r7, #340]	@ 0x154

        /* Wait till LSE is ready */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8010856:	e00d      	b.n	8010874 <HAL_RCCEx_PeriphCLKConfig+0x15f8>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8010858:	f7fd fab8 	bl	800ddcc <HAL_GetTick>
 801085c:	4602      	mov	r2, r0
 801085e:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 8010862:	1ad2      	subs	r2, r2, r3
 8010864:	f241 3388 	movw	r3, #5000	@ 0x1388
 8010868:	429a      	cmp	r2, r3
 801086a:	d903      	bls.n	8010874 <HAL_RCCEx_PeriphCLKConfig+0x15f8>
          {
            ret = HAL_TIMEOUT;
 801086c:	2303      	movs	r3, #3
 801086e:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
            break;
 8010872:	e006      	b.n	8010882 <HAL_RCCEx_PeriphCLKConfig+0x1606>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8010874:	4b12      	ldr	r3, [pc, #72]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 8010876:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 801087a:	f003 0302 	and.w	r3, r3, #2
 801087e:	2b00      	cmp	r3, #0
 8010880:	d0ea      	beq.n	8010858 <HAL_RCCEx_PeriphCLKConfig+0x15dc>
          }
        }
      }

      if (ret == HAL_OK)
 8010882:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010886:	2b00      	cmp	r3, #0
 8010888:	d13a      	bne.n	8010900 <HAL_RCCEx_PeriphCLKConfig+0x1684>
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(pPeriphClkInit->RTCClockSelection);
 801088a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801088e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
 8010892:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8010896:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 801089a:	d115      	bne.n	80108c8 <HAL_RCCEx_PeriphCLKConfig+0x164c>
 801089c:	4b08      	ldr	r3, [pc, #32]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 801089e:	69db      	ldr	r3, [r3, #28]
 80108a0:	f423 517c 	bic.w	r1, r3, #16128	@ 0x3f00
 80108a4:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80108a8:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
 80108ac:	091b      	lsrs	r3, r3, #4
 80108ae:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
 80108b2:	f023 0330 	bic.w	r3, r3, #48	@ 0x30
 80108b6:	4a02      	ldr	r2, [pc, #8]	@ (80108c0 <HAL_RCCEx_PeriphCLKConfig+0x1644>)
 80108b8:	430b      	orrs	r3, r1
 80108ba:	61d3      	str	r3, [r2, #28]
 80108bc:	e00a      	b.n	80108d4 <HAL_RCCEx_PeriphCLKConfig+0x1658>
 80108be:	bf00      	nop
 80108c0:	44020c00 	.word	0x44020c00
 80108c4:	44020800 	.word	0x44020800
 80108c8:	4b9f      	ldr	r3, [pc, #636]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 80108ca:	69db      	ldr	r3, [r3, #28]
 80108cc:	4a9e      	ldr	r2, [pc, #632]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 80108ce:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
 80108d2:	61d3      	str	r3, [r2, #28]
 80108d4:	4b9c      	ldr	r3, [pc, #624]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 80108d6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80108da:	4a9b      	ldr	r2, [pc, #620]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 80108dc:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 80108e0:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 80108e4:	4b98      	ldr	r3, [pc, #608]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 80108e6:	f8d3 10f0 	ldr.w	r1, [r3, #240]	@ 0xf0
 80108ea:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80108ee:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
 80108f2:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80108f6:	4a94      	ldr	r2, [pc, #592]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 80108f8:	430b      	orrs	r3, r1
 80108fa:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 80108fe:	e008      	b.n	8010912 <HAL_RCCEx_PeriphCLKConfig+0x1696>
      }
      else
      {
        /* set overall return value */
        status = ret;
 8010900:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010904:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
 8010908:	e003      	b.n	8010912 <HAL_RCCEx_PeriphCLKConfig+0x1696>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
 801090a:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 801090e:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
    }

  }

  /*------------------------------ RNG Configuration -------------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
 8010912:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010916:	e9d3 2300 	ldrd	r2, r3, [r3]
 801091a:	f002 6380 	and.w	r3, r2, #67108864	@ 0x4000000
 801091e:	663b      	str	r3, [r7, #96]	@ 0x60
 8010920:	2300      	movs	r3, #0
 8010922:	667b      	str	r3, [r7, #100]	@ 0x64
 8010924:	e9d7 1218 	ldrd	r1, r2, [r7, #96]	@ 0x60
 8010928:	460b      	mov	r3, r1
 801092a:	4313      	orrs	r3, r2
 801092c:	d035      	beq.n	801099a <HAL_RCCEx_PeriphCLKConfig+0x171e>
  {

    /* Check the parameters */
    assert_param(IS_RCC_RNGCLKSOURCE(pPeriphClkInit->RngClockSelection));

    switch (pPeriphClkInit->RngClockSelection)
 801092e:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010932:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
 8010936:	2b30      	cmp	r3, #48	@ 0x30
 8010938:	d014      	beq.n	8010964 <HAL_RCCEx_PeriphCLKConfig+0x16e8>
 801093a:	2b30      	cmp	r3, #48	@ 0x30
 801093c:	d80e      	bhi.n	801095c <HAL_RCCEx_PeriphCLKConfig+0x16e0>
 801093e:	2b20      	cmp	r3, #32
 8010940:	d012      	beq.n	8010968 <HAL_RCCEx_PeriphCLKConfig+0x16ec>
 8010942:	2b20      	cmp	r3, #32
 8010944:	d80a      	bhi.n	801095c <HAL_RCCEx_PeriphCLKConfig+0x16e0>
 8010946:	2b00      	cmp	r3, #0
 8010948:	d010      	beq.n	801096c <HAL_RCCEx_PeriphCLKConfig+0x16f0>
 801094a:	2b10      	cmp	r3, #16
 801094c:	d106      	bne.n	801095c <HAL_RCCEx_PeriphCLKConfig+0x16e0>
        /* RNG clock source configuration done later after clock selection check */
        break;

      case RCC_RNGCLKSOURCE_PLL1Q: /* PLL1 is used as clock source for RNG*/
        /* Enable PLL1Q Clock output generated from System PLL . */
        __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
 801094e:	4b7e      	ldr	r3, [pc, #504]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 8010950:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8010952:	4a7d      	ldr	r2, [pc, #500]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 8010954:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8010958:	6293      	str	r3, [r2, #40]	@ 0x28
        /* RNG clock source configuration done later after clock selection check */
        break;
 801095a:	e008      	b.n	801096e <HAL_RCCEx_PeriphCLKConfig+0x16f2>

        /* RNG clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 801095c:	2301      	movs	r3, #1
 801095e:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 8010962:	e004      	b.n	801096e <HAL_RCCEx_PeriphCLKConfig+0x16f2>
        break;
 8010964:	bf00      	nop
 8010966:	e002      	b.n	801096e <HAL_RCCEx_PeriphCLKConfig+0x16f2>
        break;
 8010968:	bf00      	nop
 801096a:	e000      	b.n	801096e <HAL_RCCEx_PeriphCLKConfig+0x16f2>
        break;
 801096c:	bf00      	nop
    }

    if (ret == HAL_OK)
 801096e:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010972:	2b00      	cmp	r3, #0
 8010974:	d10d      	bne.n	8010992 <HAL_RCCEx_PeriphCLKConfig+0x1716>
    {
      /* Set the source of RNG clock*/
      __HAL_RCC_RNG_CONFIG(pPeriphClkInit->RngClockSelection);
 8010976:	4b74      	ldr	r3, [pc, #464]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 8010978:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 801097c:	f023 0130 	bic.w	r1, r3, #48	@ 0x30
 8010980:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010984:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
 8010988:	4a6f      	ldr	r2, [pc, #444]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 801098a:	430b      	orrs	r3, r1
 801098c:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
 8010990:	e003      	b.n	801099a <HAL_RCCEx_PeriphCLKConfig+0x171e>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8010992:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010996:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a

  }

#if defined(SDMMC1)
  /*-------------------------- SDMMC1 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
 801099a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801099e:	e9d3 2300 	ldrd	r2, r3, [r3]
 80109a2:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
 80109a6:	65bb      	str	r3, [r7, #88]	@ 0x58
 80109a8:	2300      	movs	r3, #0
 80109aa:	65fb      	str	r3, [r7, #92]	@ 0x5c
 80109ac:	e9d7 1216 	ldrd	r1, r2, [r7, #88]	@ 0x58
 80109b0:	460b      	mov	r3, r1
 80109b2:	4313      	orrs	r3, r2
 80109b4:	d033      	beq.n	8010a1e <HAL_RCCEx_PeriphCLKConfig+0x17a2>
  {

    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(pPeriphClkInit->Sdmmc1ClockSelection));

    switch (pPeriphClkInit->Sdmmc1ClockSelection)
 80109b6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80109ba:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
 80109be:	2b00      	cmp	r3, #0
 80109c0:	d002      	beq.n	80109c8 <HAL_RCCEx_PeriphCLKConfig+0x174c>
 80109c2:	2b40      	cmp	r3, #64	@ 0x40
 80109c4:	d007      	beq.n	80109d6 <HAL_RCCEx_PeriphCLKConfig+0x175a>
 80109c6:	e010      	b.n	80109ea <HAL_RCCEx_PeriphCLKConfig+0x176e>
    {
      case RCC_SDMMC1CLKSOURCE_PLL1Q:      /* PLL1 is used as clock source for SDMMC1 kernel clock*/
        /* Enable PLL1Q Clock output generated from System PLL . */
        __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80109c8:	4b5f      	ldr	r3, [pc, #380]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 80109ca:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80109cc:	4a5e      	ldr	r2, [pc, #376]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 80109ce:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 80109d2:	6293      	str	r3, [r2, #40]	@ 0x28
        /* SDMMC1 kernel clock source config set later after clock selection check */
        break;
 80109d4:	e00d      	b.n	80109f2 <HAL_RCCEx_PeriphCLKConfig+0x1776>

      case RCC_SDMMC1CLKSOURCE_PLL2R:  /* PLL2 is used as clock source for SDMMC1 kernel clock*/
        /* PLL2R input clock, parameters M, N & R configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 80109d6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80109da:	3308      	adds	r3, #8
 80109dc:	4618      	mov	r0, r3
 80109de:	f003 fb75 	bl	80140cc <RCCEx_PLL2_Config>
 80109e2:	4603      	mov	r3, r0
 80109e4:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* SDMMC1 kernel clock source config set later after clock selection check */
        break;
 80109e8:	e003      	b.n	80109f2 <HAL_RCCEx_PeriphCLKConfig+0x1776>

      default:
        ret = HAL_ERROR;
 80109ea:	2301      	movs	r3, #1
 80109ec:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 80109f0:	bf00      	nop
    }

    if (ret == HAL_OK)
 80109f2:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 80109f6:	2b00      	cmp	r3, #0
 80109f8:	d10d      	bne.n	8010a16 <HAL_RCCEx_PeriphCLKConfig+0x179a>
    {
      /* Configure the SDMMC1 clock source */
      __HAL_RCC_SDMMC1_CONFIG(pPeriphClkInit->Sdmmc1ClockSelection);
 80109fa:	4b53      	ldr	r3, [pc, #332]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 80109fc:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8010a00:	f023 0140 	bic.w	r1, r3, #64	@ 0x40
 8010a04:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010a08:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
 8010a0c:	4a4e      	ldr	r2, [pc, #312]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 8010a0e:	430b      	orrs	r3, r1
 8010a10:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
 8010a14:	e003      	b.n	8010a1e <HAL_RCCEx_PeriphCLKConfig+0x17a2>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8010a16:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010a1a:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
  }
#endif /* SDMMC1 */

#if defined(SDMMC2)
  /*-------------------------- SDMMC2 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
 8010a1e:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010a22:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010a26:	f402 0300 	and.w	r3, r2, #8388608	@ 0x800000
 8010a2a:	653b      	str	r3, [r7, #80]	@ 0x50
 8010a2c:	2300      	movs	r3, #0
 8010a2e:	657b      	str	r3, [r7, #84]	@ 0x54
 8010a30:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	@ 0x50
 8010a34:	460b      	mov	r3, r1
 8010a36:	4313      	orrs	r3, r2
 8010a38:	d033      	beq.n	8010aa2 <HAL_RCCEx_PeriphCLKConfig+0x1826>
  {

    /* Check the parameters */
    assert_param(IS_RCC_SDMMC2CLKSOURCE(pPeriphClkInit->Sdmmc2ClockSelection));

    switch (pPeriphClkInit->Sdmmc2ClockSelection)
 8010a3a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010a3e:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
 8010a42:	2b00      	cmp	r3, #0
 8010a44:	d002      	beq.n	8010a4c <HAL_RCCEx_PeriphCLKConfig+0x17d0>
 8010a46:	2b80      	cmp	r3, #128	@ 0x80
 8010a48:	d007      	beq.n	8010a5a <HAL_RCCEx_PeriphCLKConfig+0x17de>
 8010a4a:	e010      	b.n	8010a6e <HAL_RCCEx_PeriphCLKConfig+0x17f2>
    {
      case RCC_SDMMC2CLKSOURCE_PLL1Q:      /* PLL1 is used as clock source for SDMMC2 kernel clock*/
        /* Enable PLL1Q Clock output generated from System PLL . */
        __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8010a4c:	4b3e      	ldr	r3, [pc, #248]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 8010a4e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8010a50:	4a3d      	ldr	r2, [pc, #244]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 8010a52:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8010a56:	6293      	str	r3, [r2, #40]	@ 0x28
        /* SDMMC2 kernel clock source config set later after clock selection check */
        break;
 8010a58:	e00d      	b.n	8010a76 <HAL_RCCEx_PeriphCLKConfig+0x17fa>

      case RCC_SDMMC2CLKSOURCE_PLL2R:  /* PLL2 is used as clock source for SDMMC2 kernel clock*/
        /* PLL2R input clock, parameters M, N & R configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8010a5a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010a5e:	3308      	adds	r3, #8
 8010a60:	4618      	mov	r0, r3
 8010a62:	f003 fb33 	bl	80140cc <RCCEx_PLL2_Config>
 8010a66:	4603      	mov	r3, r0
 8010a68:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* SDMMC2 kernel clock source config set later after clock selection check */
        break;
 8010a6c:	e003      	b.n	8010a76 <HAL_RCCEx_PeriphCLKConfig+0x17fa>

      default:
        ret = HAL_ERROR;
 8010a6e:	2301      	movs	r3, #1
 8010a70:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 8010a74:	bf00      	nop
    }

    if (ret == HAL_OK)
 8010a76:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010a7a:	2b00      	cmp	r3, #0
 8010a7c:	d10d      	bne.n	8010a9a <HAL_RCCEx_PeriphCLKConfig+0x181e>
    {
      /* Configure the SDMMC2 clock source */
      __HAL_RCC_SDMMC2_CONFIG(pPeriphClkInit->Sdmmc2ClockSelection);
 8010a7e:	4b32      	ldr	r3, [pc, #200]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 8010a80:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8010a84:	f023 0180 	bic.w	r1, r3, #128	@ 0x80
 8010a88:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010a8c:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
 8010a90:	4a2d      	ldr	r2, [pc, #180]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 8010a92:	430b      	orrs	r3, r1
 8010a94:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
 8010a98:	e003      	b.n	8010aa2 <HAL_RCCEx_PeriphCLKConfig+0x1826>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8010a9a:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010a9e:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a

  }
#endif /* SDMMC2 */

  /*-------------------------- SPI1 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
 8010aa2:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010aa6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010aaa:	f002 6300 	and.w	r3, r2, #134217728	@ 0x8000000
 8010aae:	64bb      	str	r3, [r7, #72]	@ 0x48
 8010ab0:	2300      	movs	r3, #0
 8010ab2:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8010ab4:	e9d7 1212 	ldrd	r1, r2, [r7, #72]	@ 0x48
 8010ab8:	460b      	mov	r3, r1
 8010aba:	4313      	orrs	r3, r2
 8010abc:	d04a      	beq.n	8010b54 <HAL_RCCEx_PeriphCLKConfig+0x18d8>
  {

    /* Check the parameters */
    assert_param(IS_RCC_SPI1CLKSOURCE(pPeriphClkInit->Spi1ClockSelection));

    switch (pPeriphClkInit->Spi1ClockSelection)
 8010abe:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010ac2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8010ac6:	2b04      	cmp	r3, #4
 8010ac8:	d827      	bhi.n	8010b1a <HAL_RCCEx_PeriphCLKConfig+0x189e>
 8010aca:	a201      	add	r2, pc, #4	@ (adr r2, 8010ad0 <HAL_RCCEx_PeriphCLKConfig+0x1854>)
 8010acc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8010ad0:	08010ae5 	.word	0x08010ae5
 8010ad4:	08010af3 	.word	0x08010af3
 8010ad8:	08010b07 	.word	0x08010b07
 8010adc:	08010b23 	.word	0x08010b23
 8010ae0:	08010b23 	.word	0x08010b23
    {
      case RCC_SPI1CLKSOURCE_PLL1Q:      /* PLL1 is used as clock source for SPI1 */
        /* Enable SPI Clock output generated from System PLL . */
        __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8010ae4:	4b18      	ldr	r3, [pc, #96]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 8010ae6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8010ae8:	4a17      	ldr	r2, [pc, #92]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 8010aea:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8010aee:	6293      	str	r3, [r2, #40]	@ 0x28

        /* SPI1 clock source configuration done later after clock selection check */
        break;
 8010af0:	e018      	b.n	8010b24 <HAL_RCCEx_PeriphCLKConfig+0x18a8>

      case RCC_SPI1CLKSOURCE_PLL2P: /* PLL2 is used as clock source for SPI1*/
        /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8010af2:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010af6:	3308      	adds	r3, #8
 8010af8:	4618      	mov	r0, r3
 8010afa:	f003 fae7 	bl	80140cc <RCCEx_PLL2_Config>
 8010afe:	4603      	mov	r3, r0
 8010b00:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b

        /* SPI1 clock source configuration done later after clock selection check */
        break;
 8010b04:	e00e      	b.n	8010b24 <HAL_RCCEx_PeriphCLKConfig+0x18a8>

#if defined(RCC_SPI1CLKSOURCE_PLL3P)
      case RCC_SPI1CLKSOURCE_PLL3P:  /* PLL3 is used as clock source for SPI1 */
        /* PLL3 P input clock, parameters M, N & P configuration and clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 8010b06:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010b0a:	3330      	adds	r3, #48	@ 0x30
 8010b0c:	4618      	mov	r0, r3
 8010b0e:	f003 fb75 	bl	80141fc <RCCEx_PLL3_Config>
 8010b12:	4603      	mov	r3, r0
 8010b14:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b

        /* SPI1 clock source configuration done later after clock selection check */
        break;
 8010b18:	e004      	b.n	8010b24 <HAL_RCCEx_PeriphCLKConfig+0x18a8>
        /* HSI, HSE, or CSI oscillator is used as source of SPI1 clock */
        /* SPI1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8010b1a:	2301      	movs	r3, #1
 8010b1c:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 8010b20:	e000      	b.n	8010b24 <HAL_RCCEx_PeriphCLKConfig+0x18a8>
        break;
 8010b22:	bf00      	nop
    }

    if (ret == HAL_OK)
 8010b24:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010b28:	2b00      	cmp	r3, #0
 8010b2a:	d10f      	bne.n	8010b4c <HAL_RCCEx_PeriphCLKConfig+0x18d0>
    {
      /* Configure the SPI1 clock source */
      __HAL_RCC_SPI1_CONFIG(pPeriphClkInit->Spi1ClockSelection);
 8010b2c:	4b06      	ldr	r3, [pc, #24]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 8010b2e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8010b32:	f023 0107 	bic.w	r1, r3, #7
 8010b36:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010b3a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8010b3e:	4a02      	ldr	r2, [pc, #8]	@ (8010b48 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
 8010b40:	430b      	orrs	r3, r1
 8010b42:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8010b46:	e005      	b.n	8010b54 <HAL_RCCEx_PeriphCLKConfig+0x18d8>
 8010b48:	44020c00 	.word	0x44020c00
    }
    else
    {
      /* set overall return value */
      status = ret;
 8010b4c:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010b50:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
    }

  }

  /*-------------------------- SPI2 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
 8010b54:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010b58:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010b5c:	f002 5380 	and.w	r3, r2, #268435456	@ 0x10000000
 8010b60:	643b      	str	r3, [r7, #64]	@ 0x40
 8010b62:	2300      	movs	r3, #0
 8010b64:	647b      	str	r3, [r7, #68]	@ 0x44
 8010b66:	e9d7 1210 	ldrd	r1, r2, [r7, #64]	@ 0x40
 8010b6a:	460b      	mov	r3, r1
 8010b6c:	4313      	orrs	r3, r2
 8010b6e:	f000 8081 	beq.w	8010c74 <HAL_RCCEx_PeriphCLKConfig+0x19f8>
  {

    /* Check the parameters */
    assert_param(IS_RCC_SPI2CLKSOURCE(pPeriphClkInit->Spi2ClockSelection));

    switch (pPeriphClkInit->Spi2ClockSelection)
 8010b72:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010b76:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8010b7a:	2b20      	cmp	r3, #32
 8010b7c:	d85f      	bhi.n	8010c3e <HAL_RCCEx_PeriphCLKConfig+0x19c2>
 8010b7e:	a201      	add	r2, pc, #4	@ (adr r2, 8010b84 <HAL_RCCEx_PeriphCLKConfig+0x1908>)
 8010b80:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8010b84:	08010c09 	.word	0x08010c09
 8010b88:	08010c3f 	.word	0x08010c3f
 8010b8c:	08010c3f 	.word	0x08010c3f
 8010b90:	08010c3f 	.word	0x08010c3f
 8010b94:	08010c3f 	.word	0x08010c3f
 8010b98:	08010c3f 	.word	0x08010c3f
 8010b9c:	08010c3f 	.word	0x08010c3f
 8010ba0:	08010c3f 	.word	0x08010c3f
 8010ba4:	08010c17 	.word	0x08010c17
 8010ba8:	08010c3f 	.word	0x08010c3f
 8010bac:	08010c3f 	.word	0x08010c3f
 8010bb0:	08010c3f 	.word	0x08010c3f
 8010bb4:	08010c3f 	.word	0x08010c3f
 8010bb8:	08010c3f 	.word	0x08010c3f
 8010bbc:	08010c3f 	.word	0x08010c3f
 8010bc0:	08010c3f 	.word	0x08010c3f
 8010bc4:	08010c2b 	.word	0x08010c2b
 8010bc8:	08010c3f 	.word	0x08010c3f
 8010bcc:	08010c3f 	.word	0x08010c3f
 8010bd0:	08010c3f 	.word	0x08010c3f
 8010bd4:	08010c3f 	.word	0x08010c3f
 8010bd8:	08010c3f 	.word	0x08010c3f
 8010bdc:	08010c3f 	.word	0x08010c3f
 8010be0:	08010c3f 	.word	0x08010c3f
 8010be4:	08010c47 	.word	0x08010c47
 8010be8:	08010c3f 	.word	0x08010c3f
 8010bec:	08010c3f 	.word	0x08010c3f
 8010bf0:	08010c3f 	.word	0x08010c3f
 8010bf4:	08010c3f 	.word	0x08010c3f
 8010bf8:	08010c3f 	.word	0x08010c3f
 8010bfc:	08010c3f 	.word	0x08010c3f
 8010c00:	08010c3f 	.word	0x08010c3f
 8010c04:	08010c47 	.word	0x08010c47
    {
      case RCC_SPI2CLKSOURCE_PLL1Q:      /* PLL1 is used as clock source for SPI2 */
        /* Enable SPI Clock output generated from System PLL . */
        __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8010c08:	4bab      	ldr	r3, [pc, #684]	@ (8010eb8 <HAL_RCCEx_PeriphCLKConfig+0x1c3c>)
 8010c0a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8010c0c:	4aaa      	ldr	r2, [pc, #680]	@ (8010eb8 <HAL_RCCEx_PeriphCLKConfig+0x1c3c>)
 8010c0e:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8010c12:	6293      	str	r3, [r2, #40]	@ 0x28

        /* SPI2 clock source configuration done later after clock selection check */
        break;
 8010c14:	e018      	b.n	8010c48 <HAL_RCCEx_PeriphCLKConfig+0x19cc>

      case RCC_SPI2CLKSOURCE_PLL2P: /* PLL2 is used as clock source for SPI2*/
        /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8010c16:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010c1a:	3308      	adds	r3, #8
 8010c1c:	4618      	mov	r0, r3
 8010c1e:	f003 fa55 	bl	80140cc <RCCEx_PLL2_Config>
 8010c22:	4603      	mov	r3, r0
 8010c24:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b

        /* SPI2 clock source configuration done later after clock selection check */
        break;
 8010c28:	e00e      	b.n	8010c48 <HAL_RCCEx_PeriphCLKConfig+0x19cc>

#if defined(RCC_SPI2CLKSOURCE_PLL3P)
      case RCC_SPI2CLKSOURCE_PLL3P:  /* PLL3 is used as clock source for SPI2 */
        /* PLL3 P input clock, parameters M, N & P configuration and clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 8010c2a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010c2e:	3330      	adds	r3, #48	@ 0x30
 8010c30:	4618      	mov	r0, r3
 8010c32:	f003 fae3 	bl	80141fc <RCCEx_PLL3_Config>
 8010c36:	4603      	mov	r3, r0
 8010c38:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b

        /* SPI2 clock source configuration done later after clock selection check */
        break;
 8010c3c:	e004      	b.n	8010c48 <HAL_RCCEx_PeriphCLKConfig+0x19cc>
        /* HSI, HSE, or CSI oscillator is used as source of SPI2 clock */
        /* SPI2 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8010c3e:	2301      	movs	r3, #1
 8010c40:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 8010c44:	e000      	b.n	8010c48 <HAL_RCCEx_PeriphCLKConfig+0x19cc>
        break;
 8010c46:	bf00      	nop
    }

    if (ret == HAL_OK)
 8010c48:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010c4c:	2b00      	cmp	r3, #0
 8010c4e:	d10d      	bne.n	8010c6c <HAL_RCCEx_PeriphCLKConfig+0x19f0>
    {
      /* Configure the SPI2 clock source */
      __HAL_RCC_SPI2_CONFIG(pPeriphClkInit->Spi2ClockSelection);
 8010c50:	4b99      	ldr	r3, [pc, #612]	@ (8010eb8 <HAL_RCCEx_PeriphCLKConfig+0x1c3c>)
 8010c52:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8010c56:	f023 0138 	bic.w	r1, r3, #56	@ 0x38
 8010c5a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010c5e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8010c62:	4a95      	ldr	r2, [pc, #596]	@ (8010eb8 <HAL_RCCEx_PeriphCLKConfig+0x1c3c>)
 8010c64:	430b      	orrs	r3, r1
 8010c66:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8010c6a:	e003      	b.n	8010c74 <HAL_RCCEx_PeriphCLKConfig+0x19f8>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8010c6c:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010c70:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
    }

  }

  /*-------------------------- SPI3 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
 8010c74:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010c78:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010c7c:	f002 5300 	and.w	r3, r2, #536870912	@ 0x20000000
 8010c80:	63bb      	str	r3, [r7, #56]	@ 0x38
 8010c82:	2300      	movs	r3, #0
 8010c84:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8010c86:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	@ 0x38
 8010c8a:	460b      	mov	r3, r1
 8010c8c:	4313      	orrs	r3, r2
 8010c8e:	d04e      	beq.n	8010d2e <HAL_RCCEx_PeriphCLKConfig+0x1ab2>
  {

    /* Check the parameters */
    assert_param(IS_RCC_SPI3CLKSOURCE(pPeriphClkInit->Spi3ClockSelection));

    switch (pPeriphClkInit->Spi3ClockSelection)
 8010c90:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010c94:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8010c98:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8010c9c:	d02e      	beq.n	8010cfc <HAL_RCCEx_PeriphCLKConfig+0x1a80>
 8010c9e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8010ca2:	d827      	bhi.n	8010cf4 <HAL_RCCEx_PeriphCLKConfig+0x1a78>
 8010ca4:	2bc0      	cmp	r3, #192	@ 0xc0
 8010ca6:	d02b      	beq.n	8010d00 <HAL_RCCEx_PeriphCLKConfig+0x1a84>
 8010ca8:	2bc0      	cmp	r3, #192	@ 0xc0
 8010caa:	d823      	bhi.n	8010cf4 <HAL_RCCEx_PeriphCLKConfig+0x1a78>
 8010cac:	2b80      	cmp	r3, #128	@ 0x80
 8010cae:	d017      	beq.n	8010ce0 <HAL_RCCEx_PeriphCLKConfig+0x1a64>
 8010cb0:	2b80      	cmp	r3, #128	@ 0x80
 8010cb2:	d81f      	bhi.n	8010cf4 <HAL_RCCEx_PeriphCLKConfig+0x1a78>
 8010cb4:	2b00      	cmp	r3, #0
 8010cb6:	d002      	beq.n	8010cbe <HAL_RCCEx_PeriphCLKConfig+0x1a42>
 8010cb8:	2b40      	cmp	r3, #64	@ 0x40
 8010cba:	d007      	beq.n	8010ccc <HAL_RCCEx_PeriphCLKConfig+0x1a50>
 8010cbc:	e01a      	b.n	8010cf4 <HAL_RCCEx_PeriphCLKConfig+0x1a78>
    {
      case RCC_SPI3CLKSOURCE_PLL1Q:      /* PLL1 is used as clock source for SPI3 */
        /* Enable SPI Clock output generated from System PLL . */
        __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8010cbe:	4b7e      	ldr	r3, [pc, #504]	@ (8010eb8 <HAL_RCCEx_PeriphCLKConfig+0x1c3c>)
 8010cc0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8010cc2:	4a7d      	ldr	r2, [pc, #500]	@ (8010eb8 <HAL_RCCEx_PeriphCLKConfig+0x1c3c>)
 8010cc4:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8010cc8:	6293      	str	r3, [r2, #40]	@ 0x28

        /* SPI3 clock source configuration done later after clock selection check */
        break;
 8010cca:	e01a      	b.n	8010d02 <HAL_RCCEx_PeriphCLKConfig+0x1a86>

      case RCC_SPI3CLKSOURCE_PLL2P: /* PLL2 is used as clock source for SPI3*/
        /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8010ccc:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010cd0:	3308      	adds	r3, #8
 8010cd2:	4618      	mov	r0, r3
 8010cd4:	f003 f9fa 	bl	80140cc <RCCEx_PLL2_Config>
 8010cd8:	4603      	mov	r3, r0
 8010cda:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b

        /* SPI3 clock source configuration done later after clock selection check */
        break;
 8010cde:	e010      	b.n	8010d02 <HAL_RCCEx_PeriphCLKConfig+0x1a86>

#if defined(RCC_SPI3CLKSOURCE_PLL3P)
      case RCC_SPI3CLKSOURCE_PLL3P:  /* PLL3 is used as clock source for SPI3 */
        /* PLL3 P input clock, parameters M, N & P configuration and clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 8010ce0:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010ce4:	3330      	adds	r3, #48	@ 0x30
 8010ce6:	4618      	mov	r0, r3
 8010ce8:	f003 fa88 	bl	80141fc <RCCEx_PLL3_Config>
 8010cec:	4603      	mov	r3, r0
 8010cee:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b

        /* SPI3 clock source configuration done later after clock selection check */
        break;
 8010cf2:	e006      	b.n	8010d02 <HAL_RCCEx_PeriphCLKConfig+0x1a86>
        /* HSI, HSE, or CSI oscillator is used as source of SPI3 clock */
        /* SPI3 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8010cf4:	2301      	movs	r3, #1
 8010cf6:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 8010cfa:	e002      	b.n	8010d02 <HAL_RCCEx_PeriphCLKConfig+0x1a86>
        break;
 8010cfc:	bf00      	nop
 8010cfe:	e000      	b.n	8010d02 <HAL_RCCEx_PeriphCLKConfig+0x1a86>
        break;
 8010d00:	bf00      	nop
    }

    if (ret == HAL_OK)
 8010d02:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010d06:	2b00      	cmp	r3, #0
 8010d08:	d10d      	bne.n	8010d26 <HAL_RCCEx_PeriphCLKConfig+0x1aaa>
    {
      /* Configure the SPI3 clock source */
      __HAL_RCC_SPI3_CONFIG(pPeriphClkInit->Spi3ClockSelection);
 8010d0a:	4b6b      	ldr	r3, [pc, #428]	@ (8010eb8 <HAL_RCCEx_PeriphCLKConfig+0x1c3c>)
 8010d0c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8010d10:	f423 71e0 	bic.w	r1, r3, #448	@ 0x1c0
 8010d14:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010d18:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8010d1c:	4a66      	ldr	r2, [pc, #408]	@ (8010eb8 <HAL_RCCEx_PeriphCLKConfig+0x1c3c>)
 8010d1e:	430b      	orrs	r3, r1
 8010d20:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8010d24:	e003      	b.n	8010d2e <HAL_RCCEx_PeriphCLKConfig+0x1ab2>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8010d26:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010d2a:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a

  }

#if defined(SPI4)
  /*-------------------------- SPI4 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI4) == RCC_PERIPHCLK_SPI4)
 8010d2e:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010d32:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010d36:	f002 4380 	and.w	r3, r2, #1073741824	@ 0x40000000
 8010d3a:	633b      	str	r3, [r7, #48]	@ 0x30
 8010d3c:	2300      	movs	r3, #0
 8010d3e:	637b      	str	r3, [r7, #52]	@ 0x34
 8010d40:	e9d7 120c 	ldrd	r1, r2, [r7, #48]	@ 0x30
 8010d44:	460b      	mov	r3, r1
 8010d46:	4313      	orrs	r3, r2
 8010d48:	d055      	beq.n	8010df6 <HAL_RCCEx_PeriphCLKConfig+0x1b7a>
  {

    /* Check the parameters */
    assert_param(IS_RCC_SPI4CLKSOURCE(pPeriphClkInit->Spi4ClockSelection));

    switch (pPeriphClkInit->Spi4ClockSelection)
 8010d4a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010d4e:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
 8010d52:	f5b3 6f20 	cmp.w	r3, #2560	@ 0xa00
 8010d56:	d031      	beq.n	8010dbc <HAL_RCCEx_PeriphCLKConfig+0x1b40>
 8010d58:	f5b3 6f20 	cmp.w	r3, #2560	@ 0xa00
 8010d5c:	d82a      	bhi.n	8010db4 <HAL_RCCEx_PeriphCLKConfig+0x1b38>
 8010d5e:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8010d62:	d02d      	beq.n	8010dc0 <HAL_RCCEx_PeriphCLKConfig+0x1b44>
 8010d64:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8010d68:	d824      	bhi.n	8010db4 <HAL_RCCEx_PeriphCLKConfig+0x1b38>
 8010d6a:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
 8010d6e:	d029      	beq.n	8010dc4 <HAL_RCCEx_PeriphCLKConfig+0x1b48>
 8010d70:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
 8010d74:	d81e      	bhi.n	8010db4 <HAL_RCCEx_PeriphCLKConfig+0x1b38>
 8010d76:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8010d7a:	d011      	beq.n	8010da0 <HAL_RCCEx_PeriphCLKConfig+0x1b24>
 8010d7c:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8010d80:	d818      	bhi.n	8010db4 <HAL_RCCEx_PeriphCLKConfig+0x1b38>
 8010d82:	2b00      	cmp	r3, #0
 8010d84:	d020      	beq.n	8010dc8 <HAL_RCCEx_PeriphCLKConfig+0x1b4c>
 8010d86:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8010d8a:	d113      	bne.n	8010db4 <HAL_RCCEx_PeriphCLKConfig+0x1b38>
        /* SPI4 clock source configuration done later after clock selection check */
        break;

      case RCC_SPI4CLKSOURCE_PLL2Q: /* PLL2 is used as clock source for SPI4*/
        /* PLL2 Q input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8010d8c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010d90:	3308      	adds	r3, #8
 8010d92:	4618      	mov	r0, r3
 8010d94:	f003 f99a 	bl	80140cc <RCCEx_PLL2_Config>
 8010d98:	4603      	mov	r3, r0
 8010d9a:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b

        /* SPI4 clock source configuration done later after clock selection check */
        break;
 8010d9e:	e014      	b.n	8010dca <HAL_RCCEx_PeriphCLKConfig+0x1b4e>

      case RCC_SPI4CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for SPI4 */
        /* PLL3 Q input clock, parameters M, N & P configuration and clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 8010da0:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010da4:	3330      	adds	r3, #48	@ 0x30
 8010da6:	4618      	mov	r0, r3
 8010da8:	f003 fa28 	bl	80141fc <RCCEx_PLL3_Config>
 8010dac:	4603      	mov	r3, r0
 8010dae:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b

        /* SPI4 clock source configuration done later after clock selection check */
        break;
 8010db2:	e00a      	b.n	8010dca <HAL_RCCEx_PeriphCLKConfig+0x1b4e>
        /*  HSE oscillator is used as source of SPI4 clock */
        /* SPI4 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8010db4:	2301      	movs	r3, #1
 8010db6:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 8010dba:	e006      	b.n	8010dca <HAL_RCCEx_PeriphCLKConfig+0x1b4e>
        break;
 8010dbc:	bf00      	nop
 8010dbe:	e004      	b.n	8010dca <HAL_RCCEx_PeriphCLKConfig+0x1b4e>
        break;
 8010dc0:	bf00      	nop
 8010dc2:	e002      	b.n	8010dca <HAL_RCCEx_PeriphCLKConfig+0x1b4e>
        break;
 8010dc4:	bf00      	nop
 8010dc6:	e000      	b.n	8010dca <HAL_RCCEx_PeriphCLKConfig+0x1b4e>
        break;
 8010dc8:	bf00      	nop
    }

    if (ret == HAL_OK)
 8010dca:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010dce:	2b00      	cmp	r3, #0
 8010dd0:	d10d      	bne.n	8010dee <HAL_RCCEx_PeriphCLKConfig+0x1b72>
    {
      /* Configure the SPI4 clock source */
      __HAL_RCC_SPI4_CONFIG(pPeriphClkInit->Spi4ClockSelection);
 8010dd2:	4b39      	ldr	r3, [pc, #228]	@ (8010eb8 <HAL_RCCEx_PeriphCLKConfig+0x1c3c>)
 8010dd4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8010dd8:	f423 6160 	bic.w	r1, r3, #3584	@ 0xe00
 8010ddc:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010de0:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
 8010de4:	4a34      	ldr	r2, [pc, #208]	@ (8010eb8 <HAL_RCCEx_PeriphCLKConfig+0x1c3c>)
 8010de6:	430b      	orrs	r3, r1
 8010de8:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8010dec:	e003      	b.n	8010df6 <HAL_RCCEx_PeriphCLKConfig+0x1b7a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8010dee:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010df2:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
  }
#endif /* SPI4 */

#if defined(SPI5)
  /*-------------------------- SPI5 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI5) == RCC_PERIPHCLK_SPI5)
 8010df6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010dfa:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010dfe:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
 8010e02:	62bb      	str	r3, [r7, #40]	@ 0x28
 8010e04:	2300      	movs	r3, #0
 8010e06:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010e08:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	@ 0x28
 8010e0c:	460b      	mov	r3, r1
 8010e0e:	4313      	orrs	r3, r2
 8010e10:	d058      	beq.n	8010ec4 <HAL_RCCEx_PeriphCLKConfig+0x1c48>
  {

    /* Check the parameters */
    assert_param(IS_RCC_SPI5CLKSOURCE(pPeriphClkInit->Spi5ClockSelection));

    switch (pPeriphClkInit->Spi5ClockSelection)
 8010e12:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010e16:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8010e1a:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
 8010e1e:	d031      	beq.n	8010e84 <HAL_RCCEx_PeriphCLKConfig+0x1c08>
 8010e20:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
 8010e24:	d82a      	bhi.n	8010e7c <HAL_RCCEx_PeriphCLKConfig+0x1c00>
 8010e26:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8010e2a:	d02d      	beq.n	8010e88 <HAL_RCCEx_PeriphCLKConfig+0x1c0c>
 8010e2c:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8010e30:	d824      	bhi.n	8010e7c <HAL_RCCEx_PeriphCLKConfig+0x1c00>
 8010e32:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8010e36:	d029      	beq.n	8010e8c <HAL_RCCEx_PeriphCLKConfig+0x1c10>
 8010e38:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8010e3c:	d81e      	bhi.n	8010e7c <HAL_RCCEx_PeriphCLKConfig+0x1c00>
 8010e3e:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8010e42:	d011      	beq.n	8010e68 <HAL_RCCEx_PeriphCLKConfig+0x1bec>
 8010e44:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8010e48:	d818      	bhi.n	8010e7c <HAL_RCCEx_PeriphCLKConfig+0x1c00>
 8010e4a:	2b00      	cmp	r3, #0
 8010e4c:	d020      	beq.n	8010e90 <HAL_RCCEx_PeriphCLKConfig+0x1c14>
 8010e4e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8010e52:	d113      	bne.n	8010e7c <HAL_RCCEx_PeriphCLKConfig+0x1c00>
        /* SPI5 clock source configuration done later after clock selection check */
        break;

      case RCC_SPI5CLKSOURCE_PLL2Q: /* PLL2 is used as clock source for SPI5*/
        /* PLL2 Q input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8010e54:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010e58:	3308      	adds	r3, #8
 8010e5a:	4618      	mov	r0, r3
 8010e5c:	f003 f936 	bl	80140cc <RCCEx_PLL2_Config>
 8010e60:	4603      	mov	r3, r0
 8010e62:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b

        /* SPI5 clock source configuration done later after clock selection check */
        break;
 8010e66:	e014      	b.n	8010e92 <HAL_RCCEx_PeriphCLKConfig+0x1c16>

      case RCC_SPI5CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for SPI5 */
        /* PLL3 Q input clock, parameters M, N & P configuration and clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 8010e68:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010e6c:	3330      	adds	r3, #48	@ 0x30
 8010e6e:	4618      	mov	r0, r3
 8010e70:	f003 f9c4 	bl	80141fc <RCCEx_PLL3_Config>
 8010e74:	4603      	mov	r3, r0
 8010e76:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b

        /* SPI5 clock source configuration done later after clock selection check */
        break;
 8010e7a:	e00a      	b.n	8010e92 <HAL_RCCEx_PeriphCLKConfig+0x1c16>
        /*  HSE oscillator is used as source of SPI5 clock */
        /* SPI5 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8010e7c:	2301      	movs	r3, #1
 8010e7e:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 8010e82:	e006      	b.n	8010e92 <HAL_RCCEx_PeriphCLKConfig+0x1c16>
        break;
 8010e84:	bf00      	nop
 8010e86:	e004      	b.n	8010e92 <HAL_RCCEx_PeriphCLKConfig+0x1c16>
        break;
 8010e88:	bf00      	nop
 8010e8a:	e002      	b.n	8010e92 <HAL_RCCEx_PeriphCLKConfig+0x1c16>
        break;
 8010e8c:	bf00      	nop
 8010e8e:	e000      	b.n	8010e92 <HAL_RCCEx_PeriphCLKConfig+0x1c16>
        break;
 8010e90:	bf00      	nop
    }

    if (ret == HAL_OK)
 8010e92:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010e96:	2b00      	cmp	r3, #0
 8010e98:	d110      	bne.n	8010ebc <HAL_RCCEx_PeriphCLKConfig+0x1c40>
    {
      /* Configure the SPI5 clock source */
      __HAL_RCC_SPI5_CONFIG(pPeriphClkInit->Spi5ClockSelection);
 8010e9a:	4b07      	ldr	r3, [pc, #28]	@ (8010eb8 <HAL_RCCEx_PeriphCLKConfig+0x1c3c>)
 8010e9c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8010ea0:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
 8010ea4:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010ea8:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8010eac:	4902      	ldr	r1, [pc, #8]	@ (8010eb8 <HAL_RCCEx_PeriphCLKConfig+0x1c3c>)
 8010eae:	4313      	orrs	r3, r2
 8010eb0:	f8c1 30e0 	str.w	r3, [r1, #224]	@ 0xe0
 8010eb4:	e006      	b.n	8010ec4 <HAL_RCCEx_PeriphCLKConfig+0x1c48>
 8010eb6:	bf00      	nop
 8010eb8:	44020c00 	.word	0x44020c00
    }
    else
    {
      /* set overall return value */
      status = ret;
 8010ebc:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010ec0:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
  }
#endif /* SPI5 */

#if defined(SPI6)
  /*-------------------------- SPI6 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
 8010ec4:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010ec8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010ecc:	2100      	movs	r1, #0
 8010ece:	6239      	str	r1, [r7, #32]
 8010ed0:	f003 0301 	and.w	r3, r3, #1
 8010ed4:	627b      	str	r3, [r7, #36]	@ 0x24
 8010ed6:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
 8010eda:	460b      	mov	r3, r1
 8010edc:	4313      	orrs	r3, r2
 8010ede:	d055      	beq.n	8010f8c <HAL_RCCEx_PeriphCLKConfig+0x1d10>
  {

    /* Check the parameters */
    assert_param(IS_RCC_SPI6CLKSOURCE(pPeriphClkInit->Spi6ClockSelection));

    switch (pPeriphClkInit->Spi6ClockSelection)
 8010ee0:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010ee4:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8010ee8:	f5b3 3f20 	cmp.w	r3, #163840	@ 0x28000
 8010eec:	d031      	beq.n	8010f52 <HAL_RCCEx_PeriphCLKConfig+0x1cd6>
 8010eee:	f5b3 3f20 	cmp.w	r3, #163840	@ 0x28000
 8010ef2:	d82a      	bhi.n	8010f4a <HAL_RCCEx_PeriphCLKConfig+0x1cce>
 8010ef4:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8010ef8:	d02d      	beq.n	8010f56 <HAL_RCCEx_PeriphCLKConfig+0x1cda>
 8010efa:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8010efe:	d824      	bhi.n	8010f4a <HAL_RCCEx_PeriphCLKConfig+0x1cce>
 8010f00:	f5b3 3fc0 	cmp.w	r3, #98304	@ 0x18000
 8010f04:	d029      	beq.n	8010f5a <HAL_RCCEx_PeriphCLKConfig+0x1cde>
 8010f06:	f5b3 3fc0 	cmp.w	r3, #98304	@ 0x18000
 8010f0a:	d81e      	bhi.n	8010f4a <HAL_RCCEx_PeriphCLKConfig+0x1cce>
 8010f0c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8010f10:	d011      	beq.n	8010f36 <HAL_RCCEx_PeriphCLKConfig+0x1cba>
 8010f12:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8010f16:	d818      	bhi.n	8010f4a <HAL_RCCEx_PeriphCLKConfig+0x1cce>
 8010f18:	2b00      	cmp	r3, #0
 8010f1a:	d020      	beq.n	8010f5e <HAL_RCCEx_PeriphCLKConfig+0x1ce2>
 8010f1c:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8010f20:	d113      	bne.n	8010f4a <HAL_RCCEx_PeriphCLKConfig+0x1cce>
        /* SPI6 clock source configuration done later after clock selection check */
        break;

      case RCC_SPI6CLKSOURCE_PLL2Q: /* PLL2 is used as clock source for SPI6*/
        /* PLL2 Q input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8010f22:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010f26:	3308      	adds	r3, #8
 8010f28:	4618      	mov	r0, r3
 8010f2a:	f003 f8cf 	bl	80140cc <RCCEx_PLL2_Config>
 8010f2e:	4603      	mov	r3, r0
 8010f30:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b

        /* SPI6 clock source configuration done later after clock selection check */
        break;
 8010f34:	e014      	b.n	8010f60 <HAL_RCCEx_PeriphCLKConfig+0x1ce4>

      case RCC_SPI6CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for SPI6 */
        /* PLL3 Q input clock, parameters M, N & P configuration and clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 8010f36:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010f3a:	3330      	adds	r3, #48	@ 0x30
 8010f3c:	4618      	mov	r0, r3
 8010f3e:	f003 f95d 	bl	80141fc <RCCEx_PLL3_Config>
 8010f42:	4603      	mov	r3, r0
 8010f44:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b

        /* SPI6 clock source configuration done later after clock selection check */
        break;
 8010f48:	e00a      	b.n	8010f60 <HAL_RCCEx_PeriphCLKConfig+0x1ce4>
        /*  HSE oscillator is used as source of SPI6 clock */
        /* SPI6 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8010f4a:	2301      	movs	r3, #1
 8010f4c:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 8010f50:	e006      	b.n	8010f60 <HAL_RCCEx_PeriphCLKConfig+0x1ce4>
        break;
 8010f52:	bf00      	nop
 8010f54:	e004      	b.n	8010f60 <HAL_RCCEx_PeriphCLKConfig+0x1ce4>
        break;
 8010f56:	bf00      	nop
 8010f58:	e002      	b.n	8010f60 <HAL_RCCEx_PeriphCLKConfig+0x1ce4>
        break;
 8010f5a:	bf00      	nop
 8010f5c:	e000      	b.n	8010f60 <HAL_RCCEx_PeriphCLKConfig+0x1ce4>
        break;
 8010f5e:	bf00      	nop
    }

    if (ret == HAL_OK)
 8010f60:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010f64:	2b00      	cmp	r3, #0
 8010f66:	d10d      	bne.n	8010f84 <HAL_RCCEx_PeriphCLKConfig+0x1d08>
    {
      /* Configure the SPI6 clock source */
      __HAL_RCC_SPI6_CONFIG(pPeriphClkInit->Spi6ClockSelection);
 8010f68:	4b88      	ldr	r3, [pc, #544]	@ (801118c <HAL_RCCEx_PeriphCLKConfig+0x1f10>)
 8010f6a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8010f6e:	f423 3260 	bic.w	r2, r3, #229376	@ 0x38000
 8010f72:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010f76:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8010f7a:	4984      	ldr	r1, [pc, #528]	@ (801118c <HAL_RCCEx_PeriphCLKConfig+0x1f10>)
 8010f7c:	4313      	orrs	r3, r2
 8010f7e:	f8c1 30e0 	str.w	r3, [r1, #224]	@ 0xe0
 8010f82:	e003      	b.n	8010f8c <HAL_RCCEx_PeriphCLKConfig+0x1d10>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8010f84:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010f88:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
  }
#endif /* SPI6 */

#if defined(OCTOSPI1)
  /*-------------------------- OctoSPIx clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)
 8010f8c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010f90:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010f94:	2100      	movs	r1, #0
 8010f96:	61b9      	str	r1, [r7, #24]
 8010f98:	f003 0302 	and.w	r3, r3, #2
 8010f9c:	61fb      	str	r3, [r7, #28]
 8010f9e:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
 8010fa2:	460b      	mov	r3, r1
 8010fa4:	4313      	orrs	r3, r2
 8010fa6:	d03d      	beq.n	8011024 <HAL_RCCEx_PeriphCLKConfig+0x1da8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_OSPICLKSOURCE(pPeriphClkInit->OspiClockSelection));

    switch (pPeriphClkInit->OspiClockSelection)
 8010fa8:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010fac:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 8010fb0:	2b03      	cmp	r3, #3
 8010fb2:	d81c      	bhi.n	8010fee <HAL_RCCEx_PeriphCLKConfig+0x1d72>
 8010fb4:	a201      	add	r2, pc, #4	@ (adr r2, 8010fbc <HAL_RCCEx_PeriphCLKConfig+0x1d40>)
 8010fb6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8010fba:	bf00      	nop
 8010fbc:	08010ff7 	.word	0x08010ff7
 8010fc0:	08010fcd 	.word	0x08010fcd
 8010fc4:	08010fdb 	.word	0x08010fdb
 8010fc8:	08010ff7 	.word	0x08010ff7
        break;

      case RCC_OSPICLKSOURCE_PLL1Q:  /* PLL1 Q is used as clock source for OCTOSPI*/

        /* Enable PLL1 Q CLK output */
        __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8010fcc:	4b6f      	ldr	r3, [pc, #444]	@ (801118c <HAL_RCCEx_PeriphCLKConfig+0x1f10>)
 8010fce:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8010fd0:	4a6e      	ldr	r2, [pc, #440]	@ (801118c <HAL_RCCEx_PeriphCLKConfig+0x1f10>)
 8010fd2:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8010fd6:	6293      	str	r3, [r2, #40]	@ 0x28
        break;
 8010fd8:	e00e      	b.n	8010ff8 <HAL_RCCEx_PeriphCLKConfig+0x1d7c>

      case RCC_OSPICLKSOURCE_PLL2R:  /* PLL2 is used as clock source for OCTOSPI*/
        /* PLL2 R input clock, parameters M, N & R configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8010fda:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8010fde:	3308      	adds	r3, #8
 8010fe0:	4618      	mov	r0, r3
 8010fe2:	f003 f873 	bl	80140cc <RCCEx_PLL2_Config>
 8010fe6:	4603      	mov	r3, r0
 8010fe8:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* OCTOSPI clock source config set later after clock selection check */
        break;
 8010fec:	e004      	b.n	8010ff8 <HAL_RCCEx_PeriphCLKConfig+0x1d7c>
      case RCC_OSPICLKSOURCE_CLKP:  /* CLKP is used as source of OCTOSPI clock*/
        /* OCTOSPI clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8010fee:	2301      	movs	r3, #1
 8010ff0:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 8010ff4:	e000      	b.n	8010ff8 <HAL_RCCEx_PeriphCLKConfig+0x1d7c>
        break;
 8010ff6:	bf00      	nop
    }

    if (ret == HAL_OK)
 8010ff8:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8010ffc:	2b00      	cmp	r3, #0
 8010ffe:	d10d      	bne.n	801101c <HAL_RCCEx_PeriphCLKConfig+0x1da0>
    {
      /* Configure the OctoSPI clock source */
      __HAL_RCC_OSPI_CONFIG(pPeriphClkInit->OspiClockSelection);
 8011000:	4b62      	ldr	r3, [pc, #392]	@ (801118c <HAL_RCCEx_PeriphCLKConfig+0x1f10>)
 8011002:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8011006:	f023 0203 	bic.w	r2, r3, #3
 801100a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801100e:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 8011012:	495e      	ldr	r1, [pc, #376]	@ (801118c <HAL_RCCEx_PeriphCLKConfig+0x1f10>)
 8011014:	4313      	orrs	r3, r2
 8011016:	f8c1 30e4 	str.w	r3, [r1, #228]	@ 0xe4
 801101a:	e003      	b.n	8011024 <HAL_RCCEx_PeriphCLKConfig+0x1da8>
    }
    else
    {
      /* set overall return value */
      status = ret;
 801101c:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8011020:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
    }
  }
#endif /* OCTOSPI1*/

  /*-------------------------- FDCAN kernel clock source configuration -------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 8011024:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8011028:	e9d3 2300 	ldrd	r2, r3, [r3]
 801102c:	2100      	movs	r1, #0
 801102e:	6139      	str	r1, [r7, #16]
 8011030:	f003 0304 	and.w	r3, r3, #4
 8011034:	617b      	str	r3, [r7, #20]
 8011036:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 801103a:	460b      	mov	r3, r1
 801103c:	4313      	orrs	r3, r2
 801103e:	d03a      	beq.n	80110b6 <HAL_RCCEx_PeriphCLKConfig+0x1e3a>
  {
    assert_param(IS_RCC_FDCANCLK(pPeriphClkInit->FdcanClockSelection));

    switch (pPeriphClkInit->FdcanClockSelection)
 8011040:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8011044:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 8011048:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 801104c:	d00e      	beq.n	801106c <HAL_RCCEx_PeriphCLKConfig+0x1df0>
 801104e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8011052:	d815      	bhi.n	8011080 <HAL_RCCEx_PeriphCLKConfig+0x1e04>
 8011054:	2b00      	cmp	r3, #0
 8011056:	d017      	beq.n	8011088 <HAL_RCCEx_PeriphCLKConfig+0x1e0c>
 8011058:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 801105c:	d110      	bne.n	8011080 <HAL_RCCEx_PeriphCLKConfig+0x1e04>
        /* FDCAN kernel clock source config set later after clock selection check */
        break;

      case RCC_FDCANCLKSOURCE_PLL1Q:      /* PLL1 is used as clock source for FDCAN kernel clock*/
        /* Enable PLL1Q Clock output generated from System PLL . */
        __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
 801105e:	4b4b      	ldr	r3, [pc, #300]	@ (801118c <HAL_RCCEx_PeriphCLKConfig+0x1f10>)
 8011060:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8011062:	4a4a      	ldr	r2, [pc, #296]	@ (801118c <HAL_RCCEx_PeriphCLKConfig+0x1f10>)
 8011064:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8011068:	6293      	str	r3, [r2, #40]	@ 0x28
        /* FDCAN kernel clock source config set later after clock selection check */
        break;
 801106a:	e00e      	b.n	801108a <HAL_RCCEx_PeriphCLKConfig+0x1e0e>

      case RCC_FDCANCLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for FDCAN kernel clock*/
        /* PLL2Q input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 801106c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8011070:	3308      	adds	r3, #8
 8011072:	4618      	mov	r0, r3
 8011074:	f003 f82a 	bl	80140cc <RCCEx_PLL2_Config>
 8011078:	4603      	mov	r3, r0
 801107a:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        /* FDCAN kernel clock source config set later after clock selection check */
        break;
 801107e:	e004      	b.n	801108a <HAL_RCCEx_PeriphCLKConfig+0x1e0e>

      default:
        ret = HAL_ERROR;
 8011080:	2301      	movs	r3, #1
 8011082:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 8011086:	e000      	b.n	801108a <HAL_RCCEx_PeriphCLKConfig+0x1e0e>
        break;
 8011088:	bf00      	nop
    }

    if (ret == HAL_OK)
 801108a:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 801108e:	2b00      	cmp	r3, #0
 8011090:	d10d      	bne.n	80110ae <HAL_RCCEx_PeriphCLKConfig+0x1e32>
    {
      /* Set the source of FDCAN kernel clock*/
      __HAL_RCC_FDCAN_CONFIG(pPeriphClkInit->FdcanClockSelection);
 8011092:	4b3e      	ldr	r3, [pc, #248]	@ (801118c <HAL_RCCEx_PeriphCLKConfig+0x1f10>)
 8011094:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8011098:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
 801109c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80110a0:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 80110a4:	4939      	ldr	r1, [pc, #228]	@ (801118c <HAL_RCCEx_PeriphCLKConfig+0x1f10>)
 80110a6:	4313      	orrs	r3, r2
 80110a8:	f8c1 30e8 	str.w	r3, [r1, #232]	@ 0xe8
 80110ac:	e003      	b.n	80110b6 <HAL_RCCEx_PeriphCLKConfig+0x1e3a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80110ae:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 80110b2:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
    }
  }

#if defined(USB_DRD_FS)
  /*------------------------------ USB Configuration -------------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 80110b6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80110ba:	e9d3 2300 	ldrd	r2, r3, [r3]
 80110be:	2100      	movs	r1, #0
 80110c0:	60b9      	str	r1, [r7, #8]
 80110c2:	f003 0310 	and.w	r3, r3, #16
 80110c6:	60fb      	str	r3, [r7, #12]
 80110c8:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 80110cc:	460b      	mov	r3, r1
 80110ce:	4313      	orrs	r3, r2
 80110d0:	d038      	beq.n	8011144 <HAL_RCCEx_PeriphCLKConfig+0x1ec8>
  {

    /* Check the parameters */
    assert_param(IS_RCC_USBCLKSOURCE(pPeriphClkInit->UsbClockSelection));

    switch (pPeriphClkInit->UsbClockSelection)
 80110d2:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80110d6:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
 80110da:	2b30      	cmp	r3, #48	@ 0x30
 80110dc:	d01b      	beq.n	8011116 <HAL_RCCEx_PeriphCLKConfig+0x1e9a>
 80110de:	2b30      	cmp	r3, #48	@ 0x30
 80110e0:	d815      	bhi.n	801110e <HAL_RCCEx_PeriphCLKConfig+0x1e92>
 80110e2:	2b10      	cmp	r3, #16
 80110e4:	d002      	beq.n	80110ec <HAL_RCCEx_PeriphCLKConfig+0x1e70>
 80110e6:	2b20      	cmp	r3, #32
 80110e8:	d007      	beq.n	80110fa <HAL_RCCEx_PeriphCLKConfig+0x1e7e>
 80110ea:	e010      	b.n	801110e <HAL_RCCEx_PeriphCLKConfig+0x1e92>
    {
      case RCC_USBCLKSOURCE_PLL1Q:      /* PLL is used as clock source for USB*/
        /* Enable USB Clock output generated form System USB . */
        __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80110ec:	4b27      	ldr	r3, [pc, #156]	@ (801118c <HAL_RCCEx_PeriphCLKConfig+0x1f10>)
 80110ee:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80110f0:	4a26      	ldr	r2, [pc, #152]	@ (801118c <HAL_RCCEx_PeriphCLKConfig+0x1f10>)
 80110f2:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 80110f6:	6293      	str	r3, [r2, #40]	@ 0x28

        /* USB clock source configuration done later after clock selection check */
        break;
 80110f8:	e00e      	b.n	8011118 <HAL_RCCEx_PeriphCLKConfig+0x1e9c>

#if defined(RCC_USBCLKSOURCE_PLL3Q)
      case RCC_USBCLKSOURCE_PLL3Q: /* PLL3 is used as clock source for USB*/
        /* PLL3Q input clock, parameters M, N & Q configuration and clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 80110fa:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80110fe:	3330      	adds	r3, #48	@ 0x30
 8011100:	4618      	mov	r0, r3
 8011102:	f003 f87b 	bl	80141fc <RCCEx_PLL3_Config>
 8011106:	4603      	mov	r3, r0
 8011108:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
      case RCC_USBCLKSOURCE_PLL2Q: /* PLL2 is used as clock source for USB*/
        /* PLL2Q input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
#endif /* RCC_USBCLKSOURCE_PLL3Q */
        /* USB clock source configuration done later after clock selection check */
        break;
 801110c:	e004      	b.n	8011118 <HAL_RCCEx_PeriphCLKConfig+0x1e9c>
        /* HSI48 oscillator is used as source of USB clock */
        /* USB clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 801110e:	2301      	movs	r3, #1
 8011110:	f887 315b 	strb.w	r3, [r7, #347]	@ 0x15b
        break;
 8011114:	e000      	b.n	8011118 <HAL_RCCEx_PeriphCLKConfig+0x1e9c>
        break;
 8011116:	bf00      	nop
    }

    if (ret == HAL_OK)
 8011118:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 801111c:	2b00      	cmp	r3, #0
 801111e:	d10d      	bne.n	801113c <HAL_RCCEx_PeriphCLKConfig+0x1ec0>
    {
      /* Set the source of USB clock*/
      __HAL_RCC_USB_CONFIG(pPeriphClkInit->UsbClockSelection);
 8011120:	4b1a      	ldr	r3, [pc, #104]	@ (801118c <HAL_RCCEx_PeriphCLKConfig+0x1f10>)
 8011122:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8011126:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
 801112a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801112e:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
 8011132:	4916      	ldr	r1, [pc, #88]	@ (801118c <HAL_RCCEx_PeriphCLKConfig+0x1f10>)
 8011134:	4313      	orrs	r3, r2
 8011136:	f8c1 30e4 	str.w	r3, [r1, #228]	@ 0xe4
 801113a:	e003      	b.n	8011144 <HAL_RCCEx_PeriphCLKConfig+0x1ec8>
    }
    else
    {
      /* set overall return value */
      status = ret;
 801113c:	f897 315b 	ldrb.w	r3, [r7, #347]	@ 0x15b
 8011140:	f887 315a 	strb.w	r3, [r7, #346]	@ 0x15a
  }
#endif /* USB_DRD_FS */

#if defined(CEC)
  /*-------------------------- CEC clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8011144:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8011148:	e9d3 2300 	ldrd	r2, r3, [r3]
 801114c:	2100      	movs	r1, #0
 801114e:	6039      	str	r1, [r7, #0]
 8011150:	f003 0308 	and.w	r3, r3, #8
 8011154:	607b      	str	r3, [r7, #4]
 8011156:	e9d7 1200 	ldrd	r1, r2, [r7]
 801115a:	460b      	mov	r3, r1
 801115c:	4313      	orrs	r3, r2
 801115e:	d00c      	beq.n	801117a <HAL_RCCEx_PeriphCLKConfig+0x1efe>

    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(pPeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(pPeriphClkInit->CecClockSelection);
 8011160:	4b0a      	ldr	r3, [pc, #40]	@ (801118c <HAL_RCCEx_PeriphCLKConfig+0x1f10>)
 8011162:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8011166:	f023 02c0 	bic.w	r2, r3, #192	@ 0xc0
 801116a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801116e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
 8011172:	4906      	ldr	r1, [pc, #24]	@ (801118c <HAL_RCCEx_PeriphCLKConfig+0x1f10>)
 8011174:	4313      	orrs	r3, r2
 8011176:	f8c1 30e8 	str.w	r3, [r1, #232]	@ 0xe8

  }
#endif /* CEC */

  return status;
 801117a:	f897 315a 	ldrb.w	r3, [r7, #346]	@ 0x15a
}
 801117e:	4618      	mov	r0, r3
 8011180:	f507 77b0 	add.w	r7, r7, #352	@ 0x160
 8011184:	46bd      	mov	sp, r7
 8011186:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 801118a:	bf00      	nop
 801118c:	44020c00 	.word	0x44020c00

08011190 <HAL_RCCEx_GetPLL1ClockFreq>:
  *         right PLL1CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  pPLL1_Clocks pointer to PLL1_ClocksTypeDef structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL1ClockFreq(PLL1_ClocksTypeDef *pPLL1_Clocks)
{
 8011190:	b480      	push	{r7}
 8011192:	b08b      	sub	sp, #44	@ 0x2c
 8011194:	af00      	add	r7, sp, #0
 8011196:	6078      	str	r0, [r7, #4]

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL1M) * PLL1N
  PLL1xCLK = PLL1_VCO / PLL1x
  */

  pll1n = (RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N);
 8011198:	4bae      	ldr	r3, [pc, #696]	@ (8011454 <HAL_RCCEx_GetPLL1ClockFreq+0x2c4>)
 801119a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801119c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80111a0:	623b      	str	r3, [r7, #32]
  pll1source = (RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1SRC);
 80111a2:	4bac      	ldr	r3, [pc, #688]	@ (8011454 <HAL_RCCEx_GetPLL1ClockFreq+0x2c4>)
 80111a4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80111a6:	f003 0303 	and.w	r3, r3, #3
 80111aa:	61fb      	str	r3, [r7, #28]
  pll1m = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos);
 80111ac:	4ba9      	ldr	r3, [pc, #676]	@ (8011454 <HAL_RCCEx_GetPLL1ClockFreq+0x2c4>)
 80111ae:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80111b0:	0a1b      	lsrs	r3, r3, #8
 80111b2:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 80111b6:	61bb      	str	r3, [r7, #24]
  pll1fracen = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1FRACEN) >> RCC_PLL1CFGR_PLL1FRACEN_Pos);
 80111b8:	4ba6      	ldr	r3, [pc, #664]	@ (8011454 <HAL_RCCEx_GetPLL1ClockFreq+0x2c4>)
 80111ba:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80111bc:	091b      	lsrs	r3, r3, #4
 80111be:	f003 0301 	and.w	r3, r3, #1
 80111c2:	617b      	str	r3, [r7, #20]
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 80111c4:	4ba3      	ldr	r3, [pc, #652]	@ (8011454 <HAL_RCCEx_GetPLL1ClockFreq+0x2c4>)
 80111c6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80111c8:	08db      	lsrs	r3, r3, #3
 80111ca:	f3c3 030c 	ubfx	r3, r3, #0, #13
 80111ce:	697a      	ldr	r2, [r7, #20]
 80111d0:	fb02 f303 	mul.w	r3, r2, r3
 80111d4:	ee07 3a90 	vmov	s15, r3
 80111d8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80111dc:	edc7 7a04 	vstr	s15, [r7, #16]
                                             RCC_PLL1FRACR_PLL1FRACN_Pos));

  if (pll1m != 0U)
 80111e0:	69bb      	ldr	r3, [r7, #24]
 80111e2:	2b00      	cmp	r3, #0
 80111e4:	f000 8126 	beq.w	8011434 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>
  {
    switch (pll1source)
 80111e8:	69fb      	ldr	r3, [r7, #28]
 80111ea:	2b03      	cmp	r3, #3
 80111ec:	d053      	beq.n	8011296 <HAL_RCCEx_GetPLL1ClockFreq+0x106>
 80111ee:	69fb      	ldr	r3, [r7, #28]
 80111f0:	2b03      	cmp	r3, #3
 80111f2:	d86f      	bhi.n	80112d4 <HAL_RCCEx_GetPLL1ClockFreq+0x144>
 80111f4:	69fb      	ldr	r3, [r7, #28]
 80111f6:	2b01      	cmp	r3, #1
 80111f8:	d003      	beq.n	8011202 <HAL_RCCEx_GetPLL1ClockFreq+0x72>
 80111fa:	69fb      	ldr	r3, [r7, #28]
 80111fc:	2b02      	cmp	r3, #2
 80111fe:	d02b      	beq.n	8011258 <HAL_RCCEx_GetPLL1ClockFreq+0xc8>
 8011200:	e068      	b.n	80112d4 <HAL_RCCEx_GetPLL1ClockFreq+0x144>
    {

      case RCC_PLL1_SOURCE_HSI:  /* HSI used as PLL1 clock source */
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8011202:	4b94      	ldr	r3, [pc, #592]	@ (8011454 <HAL_RCCEx_GetPLL1ClockFreq+0x2c4>)
 8011204:	681b      	ldr	r3, [r3, #0]
 8011206:	08db      	lsrs	r3, r3, #3
 8011208:	f003 0303 	and.w	r3, r3, #3
 801120c:	4a92      	ldr	r2, [pc, #584]	@ (8011458 <HAL_RCCEx_GetPLL1ClockFreq+0x2c8>)
 801120e:	fa22 f303 	lsr.w	r3, r2, r3
 8011212:	60fb      	str	r3, [r7, #12]
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)pll1n + (fracn1 / (float_t)0x2000) + \
 8011214:	68fb      	ldr	r3, [r7, #12]
 8011216:	ee07 3a90 	vmov	s15, r3
 801121a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 801121e:	69bb      	ldr	r3, [r7, #24]
 8011220:	ee07 3a90 	vmov	s15, r3
 8011224:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8011228:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 801122c:	6a3b      	ldr	r3, [r7, #32]
 801122e:	ee07 3a90 	vmov	s15, r3
 8011232:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8011236:	ed97 6a04 	vldr	s12, [r7, #16]
 801123a:	eddf 5a88 	vldr	s11, [pc, #544]	@ 801145c <HAL_RCCEx_GetPLL1ClockFreq+0x2cc>
 801123e:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8011242:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8011246:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 801124a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 801124e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8011252:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
                                                          (float_t)1);
        break;
 8011256:	e068      	b.n	801132a <HAL_RCCEx_GetPLL1ClockFreq+0x19a>

      case RCC_PLL1_SOURCE_CSI:  /* CSI used as PLL1 clock source */
        pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)pll1n + (fracn1 / (float_t)0x2000) + \
 8011258:	69bb      	ldr	r3, [r7, #24]
 801125a:	ee07 3a90 	vmov	s15, r3
 801125e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8011262:	eddf 6a7f 	vldr	s13, [pc, #508]	@ 8011460 <HAL_RCCEx_GetPLL1ClockFreq+0x2d0>
 8011266:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 801126a:	6a3b      	ldr	r3, [r7, #32]
 801126c:	ee07 3a90 	vmov	s15, r3
 8011270:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8011274:	ed97 6a04 	vldr	s12, [r7, #16]
 8011278:	eddf 5a78 	vldr	s11, [pc, #480]	@ 801145c <HAL_RCCEx_GetPLL1ClockFreq+0x2cc>
 801127c:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8011280:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8011284:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8011288:	ee77 7aa6 	vadd.f32	s15, s15, s13
 801128c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8011290:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
                                                           (float_t)1);
        break;
 8011294:	e049      	b.n	801132a <HAL_RCCEx_GetPLL1ClockFreq+0x19a>

      case RCC_PLL1_SOURCE_HSE:  /* HSE used as PLL1 clock source */
        pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)pll1n + (fracn1 / (float_t)0x2000) + \
 8011296:	69bb      	ldr	r3, [r7, #24]
 8011298:	ee07 3a90 	vmov	s15, r3
 801129c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80112a0:	eddf 6a70 	vldr	s13, [pc, #448]	@ 8011464 <HAL_RCCEx_GetPLL1ClockFreq+0x2d4>
 80112a4:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 80112a8:	6a3b      	ldr	r3, [r7, #32]
 80112aa:	ee07 3a90 	vmov	s15, r3
 80112ae:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80112b2:	ed97 6a04 	vldr	s12, [r7, #16]
 80112b6:	eddf 5a69 	vldr	s11, [pc, #420]	@ 801145c <HAL_RCCEx_GetPLL1ClockFreq+0x2cc>
 80112ba:	eec6 7a25 	vdiv.f32	s15, s12, s11
 80112be:	ee76 7aa7 	vadd.f32	s15, s13, s15
 80112c2:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 80112c6:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80112ca:	ee67 7a27 	vmul.f32	s15, s14, s15
 80112ce:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
                                                           (float_t)1);
        break;
 80112d2:	e02a      	b.n	801132a <HAL_RCCEx_GetPLL1ClockFreq+0x19a>

      default:
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 80112d4:	4b5f      	ldr	r3, [pc, #380]	@ (8011454 <HAL_RCCEx_GetPLL1ClockFreq+0x2c4>)
 80112d6:	681b      	ldr	r3, [r3, #0]
 80112d8:	08db      	lsrs	r3, r3, #3
 80112da:	f003 0303 	and.w	r3, r3, #3
 80112de:	4a5e      	ldr	r2, [pc, #376]	@ (8011458 <HAL_RCCEx_GetPLL1ClockFreq+0x2c8>)
 80112e0:	fa22 f303 	lsr.w	r3, r2, r3
 80112e4:	60fb      	str	r3, [r7, #12]
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)pll1n + (fracn1 / (float_t)0x2000) + \
 80112e6:	68fb      	ldr	r3, [r7, #12]
 80112e8:	ee07 3a90 	vmov	s15, r3
 80112ec:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80112f0:	69bb      	ldr	r3, [r7, #24]
 80112f2:	ee07 3a90 	vmov	s15, r3
 80112f6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80112fa:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 80112fe:	6a3b      	ldr	r3, [r7, #32]
 8011300:	ee07 3a90 	vmov	s15, r3
 8011304:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8011308:	ed97 6a04 	vldr	s12, [r7, #16]
 801130c:	eddf 5a53 	vldr	s11, [pc, #332]	@ 801145c <HAL_RCCEx_GetPLL1ClockFreq+0x2cc>
 8011310:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8011314:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8011318:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 801131c:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8011320:	ee67 7a27 	vmul.f32	s15, s14, s15
 8011324:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
                                                          (float_t)1);
        break;
 8011328:	bf00      	nop
    }

    if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 801132a:	4b4a      	ldr	r3, [pc, #296]	@ (8011454 <HAL_RCCEx_GetPLL1ClockFreq+0x2c4>)
 801132c:	681b      	ldr	r3, [r3, #0]
 801132e:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8011332:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8011336:	d121      	bne.n	801137c <HAL_RCCEx_GetPLL1ClockFreq+0x1ec>
    {
      if (__HAL_RCC_GET_PLL1_CLKOUT_CONFIG(RCC_PLL1_DIVP) != 0U)
 8011338:	4b46      	ldr	r3, [pc, #280]	@ (8011454 <HAL_RCCEx_GetPLL1ClockFreq+0x2c4>)
 801133a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801133c:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8011340:	2b00      	cmp	r3, #0
 8011342:	d017      	beq.n	8011374 <HAL_RCCEx_GetPLL1ClockFreq+0x1e4>
      {
        pPLL1_Clocks->PLL1_P_Frequency = \
                                         (uint32_t)(float_t)(pll1vco / \
                                                             ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 8011344:	4b43      	ldr	r3, [pc, #268]	@ (8011454 <HAL_RCCEx_GetPLL1ClockFreq+0x2c4>)
 8011346:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8011348:	0a5b      	lsrs	r3, r3, #9
 801134a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 801134e:	ee07 3a90 	vmov	s15, r3
 8011352:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                                   RCC_PLL1DIVR_PLL1P) >> \
                                                                                  RCC_PLL1DIVR_PLL1P_Pos) + \
 8011356:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 801135a:	ee37 7a87 	vadd.f32	s14, s15, s14
                                         (uint32_t)(float_t)(pll1vco / \
 801135e:	edd7 6a09 	vldr	s13, [r7, #36]	@ 0x24
 8011362:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8011366:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801136a:	ee17 2a90 	vmov	r2, s15
        pPLL1_Clocks->PLL1_P_Frequency = \
 801136e:	687b      	ldr	r3, [r7, #4]
 8011370:	601a      	str	r2, [r3, #0]
 8011372:	e006      	b.n	8011382 <HAL_RCCEx_GetPLL1ClockFreq+0x1f2>
                                                              (float_t)1));
      }
      else
      {
        pPLL1_Clocks->PLL1_P_Frequency = 0U;
 8011374:	687b      	ldr	r3, [r7, #4]
 8011376:	2200      	movs	r2, #0
 8011378:	601a      	str	r2, [r3, #0]
 801137a:	e002      	b.n	8011382 <HAL_RCCEx_GetPLL1ClockFreq+0x1f2>
      }
    }
    else
    {
      pPLL1_Clocks->PLL1_P_Frequency = 0U;
 801137c:	687b      	ldr	r3, [r7, #4]
 801137e:	2200      	movs	r2, #0
 8011380:	601a      	str	r2, [r3, #0]
    }

    if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 8011382:	4b34      	ldr	r3, [pc, #208]	@ (8011454 <HAL_RCCEx_GetPLL1ClockFreq+0x2c4>)
 8011384:	681b      	ldr	r3, [r3, #0]
 8011386:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 801138a:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 801138e:	d121      	bne.n	80113d4 <HAL_RCCEx_GetPLL1ClockFreq+0x244>
    {
      if (__HAL_RCC_GET_PLL1_CLKOUT_CONFIG(RCC_PLL1_DIVQ) != 0U)
 8011390:	4b30      	ldr	r3, [pc, #192]	@ (8011454 <HAL_RCCEx_GetPLL1ClockFreq+0x2c4>)
 8011392:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8011394:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8011398:	2b00      	cmp	r3, #0
 801139a:	d017      	beq.n	80113cc <HAL_RCCEx_GetPLL1ClockFreq+0x23c>
      {
        pPLL1_Clocks->PLL1_Q_Frequency = \
                                         (uint32_t)(float_t)(pll1vco / \
                                                             ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 801139c:	4b2d      	ldr	r3, [pc, #180]	@ (8011454 <HAL_RCCEx_GetPLL1ClockFreq+0x2c4>)
 801139e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80113a0:	0c1b      	lsrs	r3, r3, #16
 80113a2:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 80113a6:	ee07 3a90 	vmov	s15, r3
 80113aa:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                                   RCC_PLL1DIVR_PLL1Q) >> \
                                                                                  RCC_PLL1DIVR_PLL1Q_Pos) + \
 80113ae:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 80113b2:	ee37 7a87 	vadd.f32	s14, s15, s14
                                         (uint32_t)(float_t)(pll1vco / \
 80113b6:	edd7 6a09 	vldr	s13, [r7, #36]	@ 0x24
 80113ba:	eec6 7a87 	vdiv.f32	s15, s13, s14
 80113be:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80113c2:	ee17 2a90 	vmov	r2, s15
        pPLL1_Clocks->PLL1_Q_Frequency = \
 80113c6:	687b      	ldr	r3, [r7, #4]
 80113c8:	605a      	str	r2, [r3, #4]
 80113ca:	e006      	b.n	80113da <HAL_RCCEx_GetPLL1ClockFreq+0x24a>
                                                              (float_t)1));
      }
      else
      {
        pPLL1_Clocks->PLL1_Q_Frequency = 0U;
 80113cc:	687b      	ldr	r3, [r7, #4]
 80113ce:	2200      	movs	r2, #0
 80113d0:	605a      	str	r2, [r3, #4]
 80113d2:	e002      	b.n	80113da <HAL_RCCEx_GetPLL1ClockFreq+0x24a>
      }
    }
    else
    {
      pPLL1_Clocks->PLL1_Q_Frequency = 0U;
 80113d4:	687b      	ldr	r3, [r7, #4]
 80113d6:	2200      	movs	r2, #0
 80113d8:	605a      	str	r2, [r3, #4]
    }

    if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 80113da:	4b1e      	ldr	r3, [pc, #120]	@ (8011454 <HAL_RCCEx_GetPLL1ClockFreq+0x2c4>)
 80113dc:	681b      	ldr	r3, [r3, #0]
 80113de:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 80113e2:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 80113e6:	d121      	bne.n	801142c <HAL_RCCEx_GetPLL1ClockFreq+0x29c>
    {
      if (__HAL_RCC_GET_PLL1_CLKOUT_CONFIG(RCC_PLL1_DIVR) != 0U)
 80113e8:	4b1a      	ldr	r3, [pc, #104]	@ (8011454 <HAL_RCCEx_GetPLL1ClockFreq+0x2c4>)
 80113ea:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80113ec:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 80113f0:	2b00      	cmp	r3, #0
 80113f2:	d017      	beq.n	8011424 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
      {
        pPLL1_Clocks->PLL1_R_Frequency = \
                                         (uint32_t)(float_t)(pll1vco / \
                                                             ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 80113f4:	4b17      	ldr	r3, [pc, #92]	@ (8011454 <HAL_RCCEx_GetPLL1ClockFreq+0x2c4>)
 80113f6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80113f8:	0e1b      	lsrs	r3, r3, #24
 80113fa:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 80113fe:	ee07 3a90 	vmov	s15, r3
 8011402:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                                   RCC_PLL1DIVR_PLL1R) >> \
                                                                                  RCC_PLL1DIVR_PLL1R_Pos) + \
 8011406:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 801140a:	ee37 7a87 	vadd.f32	s14, s15, s14
                                         (uint32_t)(float_t)(pll1vco / \
 801140e:	edd7 6a09 	vldr	s13, [r7, #36]	@ 0x24
 8011412:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8011416:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801141a:	ee17 2a90 	vmov	r2, s15
        pPLL1_Clocks->PLL1_R_Frequency = \
 801141e:	687b      	ldr	r3, [r7, #4]
 8011420:	609a      	str	r2, [r3, #8]
    pPLL1_Clocks->PLL1_P_Frequency = 0U;
    pPLL1_Clocks->PLL1_Q_Frequency = 0U;
    pPLL1_Clocks->PLL1_R_Frequency = 0U;
  }

}
 8011422:	e010      	b.n	8011446 <HAL_RCCEx_GetPLL1ClockFreq+0x2b6>
        pPLL1_Clocks->PLL1_R_Frequency = 0U;
 8011424:	687b      	ldr	r3, [r7, #4]
 8011426:	2200      	movs	r2, #0
 8011428:	609a      	str	r2, [r3, #8]
}
 801142a:	e00c      	b.n	8011446 <HAL_RCCEx_GetPLL1ClockFreq+0x2b6>
      pPLL1_Clocks->PLL1_R_Frequency = 0U;
 801142c:	687b      	ldr	r3, [r7, #4]
 801142e:	2200      	movs	r2, #0
 8011430:	609a      	str	r2, [r3, #8]
}
 8011432:	e008      	b.n	8011446 <HAL_RCCEx_GetPLL1ClockFreq+0x2b6>
    pPLL1_Clocks->PLL1_P_Frequency = 0U;
 8011434:	687b      	ldr	r3, [r7, #4]
 8011436:	2200      	movs	r2, #0
 8011438:	601a      	str	r2, [r3, #0]
    pPLL1_Clocks->PLL1_Q_Frequency = 0U;
 801143a:	687b      	ldr	r3, [r7, #4]
 801143c:	2200      	movs	r2, #0
 801143e:	605a      	str	r2, [r3, #4]
    pPLL1_Clocks->PLL1_R_Frequency = 0U;
 8011440:	687b      	ldr	r3, [r7, #4]
 8011442:	2200      	movs	r2, #0
 8011444:	609a      	str	r2, [r3, #8]
}
 8011446:	bf00      	nop
 8011448:	372c      	adds	r7, #44	@ 0x2c
 801144a:	46bd      	mov	sp, r7
 801144c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011450:	4770      	bx	lr
 8011452:	bf00      	nop
 8011454:	44020c00 	.word	0x44020c00
 8011458:	03d09000 	.word	0x03d09000
 801145c:	46000000 	.word	0x46000000
 8011460:	4a742400 	.word	0x4a742400
 8011464:	4bbebc20 	.word	0x4bbebc20

08011468 <HAL_RCCEx_GetPLL2ClockFreq>:
  *         right PLL2CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  pPLL2_Clocks pointer to PLL2_ClocksTypeDef structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL2ClockFreq(PLL2_ClocksTypeDef *pPLL2_Clocks)
{
 8011468:	b480      	push	{r7}
 801146a:	b08b      	sub	sp, #44	@ 0x2c
 801146c:	af00      	add	r7, sp, #0
 801146e:	6078      	str	r0, [r7, #4]
  float_t pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
  PLL2xCLK = PLL2_VCO / PLL2x
  */
  pll2n = (RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N);
 8011470:	4bae      	ldr	r3, [pc, #696]	@ (801172c <HAL_RCCEx_GetPLL2ClockFreq+0x2c4>)
 8011472:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8011474:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8011478:	623b      	str	r3, [r7, #32]
  pll2source = (RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2SRC);
 801147a:	4bac      	ldr	r3, [pc, #688]	@ (801172c <HAL_RCCEx_GetPLL2ClockFreq+0x2c4>)
 801147c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801147e:	f003 0303 	and.w	r3, r3, #3
 8011482:	61fb      	str	r3, [r7, #28]
  pll2m = ((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2M) >> RCC_PLL2CFGR_PLL2M_Pos);
 8011484:	4ba9      	ldr	r3, [pc, #676]	@ (801172c <HAL_RCCEx_GetPLL2ClockFreq+0x2c4>)
 8011486:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8011488:	0a1b      	lsrs	r3, r3, #8
 801148a:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801148e:	61bb      	str	r3, [r7, #24]
  pll2fracen = ((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2FRACEN) >> RCC_PLL2CFGR_PLL2FRACEN_Pos);
 8011490:	4ba6      	ldr	r3, [pc, #664]	@ (801172c <HAL_RCCEx_GetPLL2ClockFreq+0x2c4>)
 8011492:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8011494:	091b      	lsrs	r3, r3, #4
 8011496:	f003 0301 	and.w	r3, r3, #1
 801149a:	617b      	str	r3, [r7, #20]
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_PLL2FRACN) >> \
 801149c:	4ba3      	ldr	r3, [pc, #652]	@ (801172c <HAL_RCCEx_GetPLL2ClockFreq+0x2c4>)
 801149e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80114a0:	08db      	lsrs	r3, r3, #3
 80114a2:	f3c3 030c 	ubfx	r3, r3, #0, #13
 80114a6:	697a      	ldr	r2, [r7, #20]
 80114a8:	fb02 f303 	mul.w	r3, r2, r3
 80114ac:	ee07 3a90 	vmov	s15, r3
 80114b0:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80114b4:	edc7 7a04 	vstr	s15, [r7, #16]
                                             RCC_PLL2FRACR_PLL2FRACN_Pos));

  if (pll2m != 0U)
 80114b8:	69bb      	ldr	r3, [r7, #24]
 80114ba:	2b00      	cmp	r3, #0
 80114bc:	f000 8126 	beq.w	801170c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>
  {
    switch (pll2source)
 80114c0:	69fb      	ldr	r3, [r7, #28]
 80114c2:	2b03      	cmp	r3, #3
 80114c4:	d053      	beq.n	801156e <HAL_RCCEx_GetPLL2ClockFreq+0x106>
 80114c6:	69fb      	ldr	r3, [r7, #28]
 80114c8:	2b03      	cmp	r3, #3
 80114ca:	d86f      	bhi.n	80115ac <HAL_RCCEx_GetPLL2ClockFreq+0x144>
 80114cc:	69fb      	ldr	r3, [r7, #28]
 80114ce:	2b01      	cmp	r3, #1
 80114d0:	d003      	beq.n	80114da <HAL_RCCEx_GetPLL2ClockFreq+0x72>
 80114d2:	69fb      	ldr	r3, [r7, #28]
 80114d4:	2b02      	cmp	r3, #2
 80114d6:	d02b      	beq.n	8011530 <HAL_RCCEx_GetPLL2ClockFreq+0xc8>
 80114d8:	e068      	b.n	80115ac <HAL_RCCEx_GetPLL2ClockFreq+0x144>
    {
      case RCC_PLL2_SOURCE_HSI:  /* HSI used as PLL clock source */
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 80114da:	4b94      	ldr	r3, [pc, #592]	@ (801172c <HAL_RCCEx_GetPLL2ClockFreq+0x2c4>)
 80114dc:	681b      	ldr	r3, [r3, #0]
 80114de:	08db      	lsrs	r3, r3, #3
 80114e0:	f003 0303 	and.w	r3, r3, #3
 80114e4:	4a92      	ldr	r2, [pc, #584]	@ (8011730 <HAL_RCCEx_GetPLL2ClockFreq+0x2c8>)
 80114e6:	fa22 f303 	lsr.w	r3, r2, r3
 80114ea:	60fb      	str	r3, [r7, #12]
        pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)pll2n + (fracn2 / (float_t)0x2000) + \
 80114ec:	68fb      	ldr	r3, [r7, #12]
 80114ee:	ee07 3a90 	vmov	s15, r3
 80114f2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80114f6:	69bb      	ldr	r3, [r7, #24]
 80114f8:	ee07 3a90 	vmov	s15, r3
 80114fc:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8011500:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8011504:	6a3b      	ldr	r3, [r7, #32]
 8011506:	ee07 3a90 	vmov	s15, r3
 801150a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 801150e:	ed97 6a04 	vldr	s12, [r7, #16]
 8011512:	eddf 5a88 	vldr	s11, [pc, #544]	@ 8011734 <HAL_RCCEx_GetPLL2ClockFreq+0x2cc>
 8011516:	eec6 7a25 	vdiv.f32	s15, s12, s11
 801151a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801151e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8011522:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8011526:	ee67 7a27 	vmul.f32	s15, s14, s15
 801152a:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
                                                          (float_t)1);
        break;
 801152e:	e068      	b.n	8011602 <HAL_RCCEx_GetPLL2ClockFreq+0x19a>

      case RCC_PLL2_SOURCE_CSI:  /* CSI used as PLL clock source */
        pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)pll2n + (fracn2 / (float_t)0x2000) + \
 8011530:	69bb      	ldr	r3, [r7, #24]
 8011532:	ee07 3a90 	vmov	s15, r3
 8011536:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801153a:	eddf 6a7f 	vldr	s13, [pc, #508]	@ 8011738 <HAL_RCCEx_GetPLL2ClockFreq+0x2d0>
 801153e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8011542:	6a3b      	ldr	r3, [r7, #32]
 8011544:	ee07 3a90 	vmov	s15, r3
 8011548:	eef8 6a67 	vcvt.f32.u32	s13, s15
 801154c:	ed97 6a04 	vldr	s12, [r7, #16]
 8011550:	eddf 5a78 	vldr	s11, [pc, #480]	@ 8011734 <HAL_RCCEx_GetPLL2ClockFreq+0x2cc>
 8011554:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8011558:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801155c:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8011560:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8011564:	ee67 7a27 	vmul.f32	s15, s14, s15
 8011568:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
                                                           (float_t)1);
        break;
 801156c:	e049      	b.n	8011602 <HAL_RCCEx_GetPLL2ClockFreq+0x19a>

      case RCC_PLL2_SOURCE_HSE:  /* HSE used as PLL clock source */
        pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)pll2n + (fracn2 / (float_t)0x2000) + \
 801156e:	69bb      	ldr	r3, [r7, #24]
 8011570:	ee07 3a90 	vmov	s15, r3
 8011574:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8011578:	eddf 6a70 	vldr	s13, [pc, #448]	@ 801173c <HAL_RCCEx_GetPLL2ClockFreq+0x2d4>
 801157c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8011580:	6a3b      	ldr	r3, [r7, #32]
 8011582:	ee07 3a90 	vmov	s15, r3
 8011586:	eef8 6a67 	vcvt.f32.u32	s13, s15
 801158a:	ed97 6a04 	vldr	s12, [r7, #16]
 801158e:	eddf 5a69 	vldr	s11, [pc, #420]	@ 8011734 <HAL_RCCEx_GetPLL2ClockFreq+0x2cc>
 8011592:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8011596:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801159a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 801159e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80115a2:	ee67 7a27 	vmul.f32	s15, s14, s15
 80115a6:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
                                                           (float_t)1);
        break;
 80115aa:	e02a      	b.n	8011602 <HAL_RCCEx_GetPLL2ClockFreq+0x19a>

      default:
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 80115ac:	4b5f      	ldr	r3, [pc, #380]	@ (801172c <HAL_RCCEx_GetPLL2ClockFreq+0x2c4>)
 80115ae:	681b      	ldr	r3, [r3, #0]
 80115b0:	08db      	lsrs	r3, r3, #3
 80115b2:	f003 0303 	and.w	r3, r3, #3
 80115b6:	4a5e      	ldr	r2, [pc, #376]	@ (8011730 <HAL_RCCEx_GetPLL2ClockFreq+0x2c8>)
 80115b8:	fa22 f303 	lsr.w	r3, r2, r3
 80115bc:	60fb      	str	r3, [r7, #12]
        pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)pll2n + (fracn2 / (float_t)0x2000) + \
 80115be:	68fb      	ldr	r3, [r7, #12]
 80115c0:	ee07 3a90 	vmov	s15, r3
 80115c4:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80115c8:	69bb      	ldr	r3, [r7, #24]
 80115ca:	ee07 3a90 	vmov	s15, r3
 80115ce:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80115d2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 80115d6:	6a3b      	ldr	r3, [r7, #32]
 80115d8:	ee07 3a90 	vmov	s15, r3
 80115dc:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80115e0:	ed97 6a04 	vldr	s12, [r7, #16]
 80115e4:	eddf 5a53 	vldr	s11, [pc, #332]	@ 8011734 <HAL_RCCEx_GetPLL2ClockFreq+0x2cc>
 80115e8:	eec6 7a25 	vdiv.f32	s15, s12, s11
 80115ec:	ee76 7aa7 	vadd.f32	s15, s13, s15
 80115f0:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 80115f4:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80115f8:	ee67 7a27 	vmul.f32	s15, s14, s15
 80115fc:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
                                                          (float_t)1);
        break;
 8011600:	bf00      	nop
    }

    if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 8011602:	4b4a      	ldr	r3, [pc, #296]	@ (801172c <HAL_RCCEx_GetPLL2ClockFreq+0x2c4>)
 8011604:	681b      	ldr	r3, [r3, #0]
 8011606:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 801160a:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 801160e:	d121      	bne.n	8011654 <HAL_RCCEx_GetPLL2ClockFreq+0x1ec>
    {
      if (__HAL_RCC_GET_PLL2_CLKOUT_CONFIG(RCC_PLL2_DIVP) != 0U)
 8011610:	4b46      	ldr	r3, [pc, #280]	@ (801172c <HAL_RCCEx_GetPLL2ClockFreq+0x2c4>)
 8011612:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8011614:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8011618:	2b00      	cmp	r3, #0
 801161a:	d017      	beq.n	801164c <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>
      {
        pPLL2_Clocks->PLL2_P_Frequency = \
                                         (uint32_t)(float_t)(pll2vco / \
                                                             ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 801161c:	4b43      	ldr	r3, [pc, #268]	@ (801172c <HAL_RCCEx_GetPLL2ClockFreq+0x2c4>)
 801161e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8011620:	0a5b      	lsrs	r3, r3, #9
 8011622:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8011626:	ee07 3a90 	vmov	s15, r3
 801162a:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                                   RCC_PLL2DIVR_PLL2P) >> \
                                                                                  RCC_PLL2DIVR_PLL2P_Pos) + \
 801162e:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8011632:	ee37 7a87 	vadd.f32	s14, s15, s14
                                         (uint32_t)(float_t)(pll2vco / \
 8011636:	edd7 6a09 	vldr	s13, [r7, #36]	@ 0x24
 801163a:	eec6 7a87 	vdiv.f32	s15, s13, s14
 801163e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8011642:	ee17 2a90 	vmov	r2, s15
        pPLL2_Clocks->PLL2_P_Frequency = \
 8011646:	687b      	ldr	r3, [r7, #4]
 8011648:	601a      	str	r2, [r3, #0]
 801164a:	e006      	b.n	801165a <HAL_RCCEx_GetPLL2ClockFreq+0x1f2>
                                                              (float_t)1));
      }
      else
      {
        pPLL2_Clocks->PLL2_P_Frequency = 0U;
 801164c:	687b      	ldr	r3, [r7, #4]
 801164e:	2200      	movs	r2, #0
 8011650:	601a      	str	r2, [r3, #0]
 8011652:	e002      	b.n	801165a <HAL_RCCEx_GetPLL2ClockFreq+0x1f2>
      }
    }
    else
    {
      pPLL2_Clocks->PLL2_P_Frequency = 0U;
 8011654:	687b      	ldr	r3, [r7, #4]
 8011656:	2200      	movs	r2, #0
 8011658:	601a      	str	r2, [r3, #0]
    }

    if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 801165a:	4b34      	ldr	r3, [pc, #208]	@ (801172c <HAL_RCCEx_GetPLL2ClockFreq+0x2c4>)
 801165c:	681b      	ldr	r3, [r3, #0]
 801165e:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8011662:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8011666:	d121      	bne.n	80116ac <HAL_RCCEx_GetPLL2ClockFreq+0x244>
    {
      if (__HAL_RCC_GET_PLL2_CLKOUT_CONFIG(RCC_PLL2_DIVQ) != 0U)
 8011668:	4b30      	ldr	r3, [pc, #192]	@ (801172c <HAL_RCCEx_GetPLL2ClockFreq+0x2c4>)
 801166a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801166c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8011670:	2b00      	cmp	r3, #0
 8011672:	d017      	beq.n	80116a4 <HAL_RCCEx_GetPLL2ClockFreq+0x23c>
      {
        pPLL2_Clocks->PLL2_Q_Frequency = \
                                         (uint32_t)(float_t)(pll2vco / \
                                                             ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 8011674:	4b2d      	ldr	r3, [pc, #180]	@ (801172c <HAL_RCCEx_GetPLL2ClockFreq+0x2c4>)
 8011676:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8011678:	0c1b      	lsrs	r3, r3, #16
 801167a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 801167e:	ee07 3a90 	vmov	s15, r3
 8011682:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                                   RCC_PLL2DIVR_PLL2Q) >> \
                                                                                  RCC_PLL2DIVR_PLL2Q_Pos) + \
 8011686:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 801168a:	ee37 7a87 	vadd.f32	s14, s15, s14
                                         (uint32_t)(float_t)(pll2vco / \
 801168e:	edd7 6a09 	vldr	s13, [r7, #36]	@ 0x24
 8011692:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8011696:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801169a:	ee17 2a90 	vmov	r2, s15
        pPLL2_Clocks->PLL2_Q_Frequency = \
 801169e:	687b      	ldr	r3, [r7, #4]
 80116a0:	605a      	str	r2, [r3, #4]
 80116a2:	e006      	b.n	80116b2 <HAL_RCCEx_GetPLL2ClockFreq+0x24a>
                                                              (float_t)1));
      }
      else
      {
        pPLL2_Clocks->PLL2_Q_Frequency = 0U;
 80116a4:	687b      	ldr	r3, [r7, #4]
 80116a6:	2200      	movs	r2, #0
 80116a8:	605a      	str	r2, [r3, #4]
 80116aa:	e002      	b.n	80116b2 <HAL_RCCEx_GetPLL2ClockFreq+0x24a>
      }
    }
    else
    {
      pPLL2_Clocks->PLL2_Q_Frequency = 0U;
 80116ac:	687b      	ldr	r3, [r7, #4]
 80116ae:	2200      	movs	r2, #0
 80116b0:	605a      	str	r2, [r3, #4]
    }

    if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 80116b2:	4b1e      	ldr	r3, [pc, #120]	@ (801172c <HAL_RCCEx_GetPLL2ClockFreq+0x2c4>)
 80116b4:	681b      	ldr	r3, [r3, #0]
 80116b6:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 80116ba:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 80116be:	d121      	bne.n	8011704 <HAL_RCCEx_GetPLL2ClockFreq+0x29c>
    {
      if (__HAL_RCC_GET_PLL2_CLKOUT_CONFIG(RCC_PLL2_DIVR) != 0U)
 80116c0:	4b1a      	ldr	r3, [pc, #104]	@ (801172c <HAL_RCCEx_GetPLL2ClockFreq+0x2c4>)
 80116c2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80116c4:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 80116c8:	2b00      	cmp	r3, #0
 80116ca:	d017      	beq.n	80116fc <HAL_RCCEx_GetPLL2ClockFreq+0x294>
      {
        pPLL2_Clocks->PLL2_R_Frequency = \
                                         (uint32_t)(float_t)(pll2vco / \
                                                             ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 80116cc:	4b17      	ldr	r3, [pc, #92]	@ (801172c <HAL_RCCEx_GetPLL2ClockFreq+0x2c4>)
 80116ce:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80116d0:	0e1b      	lsrs	r3, r3, #24
 80116d2:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 80116d6:	ee07 3a90 	vmov	s15, r3
 80116da:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                                   RCC_PLL2DIVR_PLL2R) >> \
                                                                                  RCC_PLL2DIVR_PLL2R_Pos) + \
 80116de:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 80116e2:	ee37 7a87 	vadd.f32	s14, s15, s14
                                         (uint32_t)(float_t)(pll2vco / \
 80116e6:	edd7 6a09 	vldr	s13, [r7, #36]	@ 0x24
 80116ea:	eec6 7a87 	vdiv.f32	s15, s13, s14
 80116ee:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80116f2:	ee17 2a90 	vmov	r2, s15
        pPLL2_Clocks->PLL2_R_Frequency = \
 80116f6:	687b      	ldr	r3, [r7, #4]
 80116f8:	609a      	str	r2, [r3, #8]
  {
    pPLL2_Clocks->PLL2_P_Frequency = 0U;
    pPLL2_Clocks->PLL2_Q_Frequency = 0U;
    pPLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
 80116fa:	e010      	b.n	801171e <HAL_RCCEx_GetPLL2ClockFreq+0x2b6>
        pPLL2_Clocks->PLL2_R_Frequency = 0U;
 80116fc:	687b      	ldr	r3, [r7, #4]
 80116fe:	2200      	movs	r2, #0
 8011700:	609a      	str	r2, [r3, #8]
}
 8011702:	e00c      	b.n	801171e <HAL_RCCEx_GetPLL2ClockFreq+0x2b6>
      pPLL2_Clocks->PLL2_R_Frequency = 0U;
 8011704:	687b      	ldr	r3, [r7, #4]
 8011706:	2200      	movs	r2, #0
 8011708:	609a      	str	r2, [r3, #8]
}
 801170a:	e008      	b.n	801171e <HAL_RCCEx_GetPLL2ClockFreq+0x2b6>
    pPLL2_Clocks->PLL2_P_Frequency = 0U;
 801170c:	687b      	ldr	r3, [r7, #4]
 801170e:	2200      	movs	r2, #0
 8011710:	601a      	str	r2, [r3, #0]
    pPLL2_Clocks->PLL2_Q_Frequency = 0U;
 8011712:	687b      	ldr	r3, [r7, #4]
 8011714:	2200      	movs	r2, #0
 8011716:	605a      	str	r2, [r3, #4]
    pPLL2_Clocks->PLL2_R_Frequency = 0U;
 8011718:	687b      	ldr	r3, [r7, #4]
 801171a:	2200      	movs	r2, #0
 801171c:	609a      	str	r2, [r3, #8]
}
 801171e:	bf00      	nop
 8011720:	372c      	adds	r7, #44	@ 0x2c
 8011722:	46bd      	mov	sp, r7
 8011724:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011728:	4770      	bx	lr
 801172a:	bf00      	nop
 801172c:	44020c00 	.word	0x44020c00
 8011730:	03d09000 	.word	0x03d09000
 8011734:	46000000 	.word	0x46000000
 8011738:	4a742400 	.word	0x4a742400
 801173c:	4bbebc20 	.word	0x4bbebc20

08011740 <HAL_RCCEx_GetPLL3ClockFreq>:
  *         right PLL3CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  pPLL3_Clocks pointer to PLL3_ClocksTypeDef structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL3ClockFreq(PLL3_ClocksTypeDef *pPLL3_Clocks)
{
 8011740:	b480      	push	{r7}
 8011742:	b08b      	sub	sp, #44	@ 0x2c
 8011744:	af00      	add	r7, sp, #0
 8011746:	6078      	str	r0, [r7, #4]
  float_t pll3vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
  PLL3xCLK = PLL3_VCO / PLL3x
  */
  pll3n = (RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N);
 8011748:	4bae      	ldr	r3, [pc, #696]	@ (8011a04 <HAL_RCCEx_GetPLL3ClockFreq+0x2c4>)
 801174a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801174c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8011750:	623b      	str	r3, [r7, #32]
  pll3source = (RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3SRC);
 8011752:	4bac      	ldr	r3, [pc, #688]	@ (8011a04 <HAL_RCCEx_GetPLL3ClockFreq+0x2c4>)
 8011754:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8011756:	f003 0303 	and.w	r3, r3, #3
 801175a:	61fb      	str	r3, [r7, #28]
  pll3m = ((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3M) >> RCC_PLL3CFGR_PLL3M_Pos);
 801175c:	4ba9      	ldr	r3, [pc, #676]	@ (8011a04 <HAL_RCCEx_GetPLL3ClockFreq+0x2c4>)
 801175e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8011760:	0a1b      	lsrs	r3, r3, #8
 8011762:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8011766:	61bb      	str	r3, [r7, #24]
  pll3fracen = ((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3FRACEN) >> RCC_PLL3CFGR_PLL3FRACEN_Pos);
 8011768:	4ba6      	ldr	r3, [pc, #664]	@ (8011a04 <HAL_RCCEx_GetPLL3ClockFreq+0x2c4>)
 801176a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801176c:	091b      	lsrs	r3, r3, #4
 801176e:	f003 0301 	and.w	r3, r3, #1
 8011772:	617b      	str	r3, [r7, #20]
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_PLL3FRACN) >> \
 8011774:	4ba3      	ldr	r3, [pc, #652]	@ (8011a04 <HAL_RCCEx_GetPLL3ClockFreq+0x2c4>)
 8011776:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8011778:	08db      	lsrs	r3, r3, #3
 801177a:	f3c3 030c 	ubfx	r3, r3, #0, #13
 801177e:	697a      	ldr	r2, [r7, #20]
 8011780:	fb02 f303 	mul.w	r3, r2, r3
 8011784:	ee07 3a90 	vmov	s15, r3
 8011788:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801178c:	edc7 7a04 	vstr	s15, [r7, #16]
                                             RCC_PLL3FRACR_PLL3FRACN_Pos));

  if (pll3m != 0U)
 8011790:	69bb      	ldr	r3, [r7, #24]
 8011792:	2b00      	cmp	r3, #0
 8011794:	f000 8126 	beq.w	80119e4 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>
  {
    switch (pll3source)
 8011798:	69fb      	ldr	r3, [r7, #28]
 801179a:	2b03      	cmp	r3, #3
 801179c:	d053      	beq.n	8011846 <HAL_RCCEx_GetPLL3ClockFreq+0x106>
 801179e:	69fb      	ldr	r3, [r7, #28]
 80117a0:	2b03      	cmp	r3, #3
 80117a2:	d86f      	bhi.n	8011884 <HAL_RCCEx_GetPLL3ClockFreq+0x144>
 80117a4:	69fb      	ldr	r3, [r7, #28]
 80117a6:	2b01      	cmp	r3, #1
 80117a8:	d003      	beq.n	80117b2 <HAL_RCCEx_GetPLL3ClockFreq+0x72>
 80117aa:	69fb      	ldr	r3, [r7, #28]
 80117ac:	2b02      	cmp	r3, #2
 80117ae:	d02b      	beq.n	8011808 <HAL_RCCEx_GetPLL3ClockFreq+0xc8>
 80117b0:	e068      	b.n	8011884 <HAL_RCCEx_GetPLL3ClockFreq+0x144>
    {
      case RCC_PLL3_SOURCE_HSI:  /* HSI used as PLL clock source */
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 80117b2:	4b94      	ldr	r3, [pc, #592]	@ (8011a04 <HAL_RCCEx_GetPLL3ClockFreq+0x2c4>)
 80117b4:	681b      	ldr	r3, [r3, #0]
 80117b6:	08db      	lsrs	r3, r3, #3
 80117b8:	f003 0303 	and.w	r3, r3, #3
 80117bc:	4a92      	ldr	r2, [pc, #584]	@ (8011a08 <HAL_RCCEx_GetPLL3ClockFreq+0x2c8>)
 80117be:	fa22 f303 	lsr.w	r3, r2, r3
 80117c2:	60fb      	str	r3, [r7, #12]
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)pll3n + (fracn3 / (float_t)0x2000) + \
 80117c4:	68fb      	ldr	r3, [r7, #12]
 80117c6:	ee07 3a90 	vmov	s15, r3
 80117ca:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80117ce:	69bb      	ldr	r3, [r7, #24]
 80117d0:	ee07 3a90 	vmov	s15, r3
 80117d4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80117d8:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 80117dc:	6a3b      	ldr	r3, [r7, #32]
 80117de:	ee07 3a90 	vmov	s15, r3
 80117e2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80117e6:	ed97 6a04 	vldr	s12, [r7, #16]
 80117ea:	eddf 5a88 	vldr	s11, [pc, #544]	@ 8011a0c <HAL_RCCEx_GetPLL3ClockFreq+0x2cc>
 80117ee:	eec6 7a25 	vdiv.f32	s15, s12, s11
 80117f2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 80117f6:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 80117fa:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80117fe:	ee67 7a27 	vmul.f32	s15, s14, s15
 8011802:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
                                                          (float_t)1);
        break;
 8011806:	e068      	b.n	80118da <HAL_RCCEx_GetPLL3ClockFreq+0x19a>

      case RCC_PLL3_SOURCE_CSI:  /* CSI used as PLL clock source */
        pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)pll3n + (fracn3 / (float_t)0x2000) + \
 8011808:	69bb      	ldr	r3, [r7, #24]
 801180a:	ee07 3a90 	vmov	s15, r3
 801180e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8011812:	eddf 6a7f 	vldr	s13, [pc, #508]	@ 8011a10 <HAL_RCCEx_GetPLL3ClockFreq+0x2d0>
 8011816:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 801181a:	6a3b      	ldr	r3, [r7, #32]
 801181c:	ee07 3a90 	vmov	s15, r3
 8011820:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8011824:	ed97 6a04 	vldr	s12, [r7, #16]
 8011828:	eddf 5a78 	vldr	s11, [pc, #480]	@ 8011a0c <HAL_RCCEx_GetPLL3ClockFreq+0x2cc>
 801182c:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8011830:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8011834:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8011838:	ee77 7aa6 	vadd.f32	s15, s15, s13
 801183c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8011840:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
                                                           (float_t)1);
        break;
 8011844:	e049      	b.n	80118da <HAL_RCCEx_GetPLL3ClockFreq+0x19a>

      case RCC_PLL3_SOURCE_HSE:  /* HSE used as PLL clock source */
        pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)pll3n + (fracn3 / (float_t)0x2000) + \
 8011846:	69bb      	ldr	r3, [r7, #24]
 8011848:	ee07 3a90 	vmov	s15, r3
 801184c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8011850:	eddf 6a70 	vldr	s13, [pc, #448]	@ 8011a14 <HAL_RCCEx_GetPLL3ClockFreq+0x2d4>
 8011854:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8011858:	6a3b      	ldr	r3, [r7, #32]
 801185a:	ee07 3a90 	vmov	s15, r3
 801185e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8011862:	ed97 6a04 	vldr	s12, [r7, #16]
 8011866:	eddf 5a69 	vldr	s11, [pc, #420]	@ 8011a0c <HAL_RCCEx_GetPLL3ClockFreq+0x2cc>
 801186a:	eec6 7a25 	vdiv.f32	s15, s12, s11
 801186e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8011872:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8011876:	ee77 7aa6 	vadd.f32	s15, s15, s13
 801187a:	ee67 7a27 	vmul.f32	s15, s14, s15
 801187e:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
                                                           (float_t)1);
        break;
 8011882:	e02a      	b.n	80118da <HAL_RCCEx_GetPLL3ClockFreq+0x19a>

      default:
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8011884:	4b5f      	ldr	r3, [pc, #380]	@ (8011a04 <HAL_RCCEx_GetPLL3ClockFreq+0x2c4>)
 8011886:	681b      	ldr	r3, [r3, #0]
 8011888:	08db      	lsrs	r3, r3, #3
 801188a:	f003 0303 	and.w	r3, r3, #3
 801188e:	4a5e      	ldr	r2, [pc, #376]	@ (8011a08 <HAL_RCCEx_GetPLL3ClockFreq+0x2c8>)
 8011890:	fa22 f303 	lsr.w	r3, r2, r3
 8011894:	60fb      	str	r3, [r7, #12]
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)pll3n + (fracn3 / (float_t)0x2000) + \
 8011896:	68fb      	ldr	r3, [r7, #12]
 8011898:	ee07 3a90 	vmov	s15, r3
 801189c:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80118a0:	69bb      	ldr	r3, [r7, #24]
 80118a2:	ee07 3a90 	vmov	s15, r3
 80118a6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80118aa:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 80118ae:	6a3b      	ldr	r3, [r7, #32]
 80118b0:	ee07 3a90 	vmov	s15, r3
 80118b4:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80118b8:	ed97 6a04 	vldr	s12, [r7, #16]
 80118bc:	eddf 5a53 	vldr	s11, [pc, #332]	@ 8011a0c <HAL_RCCEx_GetPLL3ClockFreq+0x2cc>
 80118c0:	eec6 7a25 	vdiv.f32	s15, s12, s11
 80118c4:	ee76 7aa7 	vadd.f32	s15, s13, s15
 80118c8:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 80118cc:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80118d0:	ee67 7a27 	vmul.f32	s15, s14, s15
 80118d4:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
                                                          (float_t)1);
        break;
 80118d8:	bf00      	nop
    }

    if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 80118da:	4b4a      	ldr	r3, [pc, #296]	@ (8011a04 <HAL_RCCEx_GetPLL3ClockFreq+0x2c4>)
 80118dc:	681b      	ldr	r3, [r3, #0]
 80118de:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 80118e2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 80118e6:	d121      	bne.n	801192c <HAL_RCCEx_GetPLL3ClockFreq+0x1ec>
    {
      if (__HAL_RCC_GET_PLL3_CLKOUT_CONFIG(RCC_PLL3_DIVP) != 0U)
 80118e8:	4b46      	ldr	r3, [pc, #280]	@ (8011a04 <HAL_RCCEx_GetPLL3ClockFreq+0x2c4>)
 80118ea:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80118ec:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 80118f0:	2b00      	cmp	r3, #0
 80118f2:	d017      	beq.n	8011924 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>
      {
        pPLL3_Clocks->PLL3_P_Frequency = \
                                         (uint32_t)(float_t)(pll3vco / \
                                                             ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 80118f4:	4b43      	ldr	r3, [pc, #268]	@ (8011a04 <HAL_RCCEx_GetPLL3ClockFreq+0x2c4>)
 80118f6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80118f8:	0a5b      	lsrs	r3, r3, #9
 80118fa:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 80118fe:	ee07 3a90 	vmov	s15, r3
 8011902:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                                   RCC_PLL3DIVR_PLL3P) >> \
                                                                                  RCC_PLL3DIVR_PLL3P_Pos) + \
 8011906:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 801190a:	ee37 7a87 	vadd.f32	s14, s15, s14
                                         (uint32_t)(float_t)(pll3vco / \
 801190e:	edd7 6a09 	vldr	s13, [r7, #36]	@ 0x24
 8011912:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8011916:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801191a:	ee17 2a90 	vmov	r2, s15
        pPLL3_Clocks->PLL3_P_Frequency = \
 801191e:	687b      	ldr	r3, [r7, #4]
 8011920:	601a      	str	r2, [r3, #0]
 8011922:	e006      	b.n	8011932 <HAL_RCCEx_GetPLL3ClockFreq+0x1f2>
                                                              (float_t)1));
      }
      else
      {
        pPLL3_Clocks->PLL3_P_Frequency = 0U;
 8011924:	687b      	ldr	r3, [r7, #4]
 8011926:	2200      	movs	r2, #0
 8011928:	601a      	str	r2, [r3, #0]
 801192a:	e002      	b.n	8011932 <HAL_RCCEx_GetPLL3ClockFreq+0x1f2>
      }
    }
    else
    {
      pPLL3_Clocks->PLL3_P_Frequency = 0U;
 801192c:	687b      	ldr	r3, [r7, #4]
 801192e:	2200      	movs	r2, #0
 8011930:	601a      	str	r2, [r3, #0]
    }

    if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 8011932:	4b34      	ldr	r3, [pc, #208]	@ (8011a04 <HAL_RCCEx_GetPLL3ClockFreq+0x2c4>)
 8011934:	681b      	ldr	r3, [r3, #0]
 8011936:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 801193a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 801193e:	d121      	bne.n	8011984 <HAL_RCCEx_GetPLL3ClockFreq+0x244>
    {
      if (__HAL_RCC_GET_PLL3_CLKOUT_CONFIG(RCC_PLL3_DIVQ) != 0U)
 8011940:	4b30      	ldr	r3, [pc, #192]	@ (8011a04 <HAL_RCCEx_GetPLL3ClockFreq+0x2c4>)
 8011942:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8011944:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8011948:	2b00      	cmp	r3, #0
 801194a:	d017      	beq.n	801197c <HAL_RCCEx_GetPLL3ClockFreq+0x23c>
      {
        pPLL3_Clocks->PLL3_Q_Frequency = \
                                         (uint32_t)(float_t)(pll3vco / \
                                                             ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 801194c:	4b2d      	ldr	r3, [pc, #180]	@ (8011a04 <HAL_RCCEx_GetPLL3ClockFreq+0x2c4>)
 801194e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8011950:	0c1b      	lsrs	r3, r3, #16
 8011952:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8011956:	ee07 3a90 	vmov	s15, r3
 801195a:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                                   RCC_PLL3DIVR_PLL3Q) >> \
                                                                                  RCC_PLL3DIVR_PLL3Q_Pos) + \
 801195e:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8011962:	ee37 7a87 	vadd.f32	s14, s15, s14
                                         (uint32_t)(float_t)(pll3vco / \
 8011966:	edd7 6a09 	vldr	s13, [r7, #36]	@ 0x24
 801196a:	eec6 7a87 	vdiv.f32	s15, s13, s14
 801196e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8011972:	ee17 2a90 	vmov	r2, s15
        pPLL3_Clocks->PLL3_Q_Frequency = \
 8011976:	687b      	ldr	r3, [r7, #4]
 8011978:	605a      	str	r2, [r3, #4]
 801197a:	e006      	b.n	801198a <HAL_RCCEx_GetPLL3ClockFreq+0x24a>
                                                              (float_t)1));
      }
      else
      {
        pPLL3_Clocks->PLL3_Q_Frequency = 0U;
 801197c:	687b      	ldr	r3, [r7, #4]
 801197e:	2200      	movs	r2, #0
 8011980:	605a      	str	r2, [r3, #4]
 8011982:	e002      	b.n	801198a <HAL_RCCEx_GetPLL3ClockFreq+0x24a>
      }
    }
    else
    {
      pPLL3_Clocks->PLL3_Q_Frequency = 0U;
 8011984:	687b      	ldr	r3, [r7, #4]
 8011986:	2200      	movs	r2, #0
 8011988:	605a      	str	r2, [r3, #4]
    }

    if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 801198a:	4b1e      	ldr	r3, [pc, #120]	@ (8011a04 <HAL_RCCEx_GetPLL3ClockFreq+0x2c4>)
 801198c:	681b      	ldr	r3, [r3, #0]
 801198e:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8011992:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8011996:	d121      	bne.n	80119dc <HAL_RCCEx_GetPLL3ClockFreq+0x29c>
    {
      if (__HAL_RCC_GET_PLL3_CLKOUT_CONFIG(RCC_PLL3_DIVR) != 0U)
 8011998:	4b1a      	ldr	r3, [pc, #104]	@ (8011a04 <HAL_RCCEx_GetPLL3ClockFreq+0x2c4>)
 801199a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801199c:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 80119a0:	2b00      	cmp	r3, #0
 80119a2:	d017      	beq.n	80119d4 <HAL_RCCEx_GetPLL3ClockFreq+0x294>
      {
        pPLL3_Clocks->PLL3_R_Frequency = \
                                         (uint32_t)(float_t)(pll3vco / \
                                                             ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 80119a4:	4b17      	ldr	r3, [pc, #92]	@ (8011a04 <HAL_RCCEx_GetPLL3ClockFreq+0x2c4>)
 80119a6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80119a8:	0e1b      	lsrs	r3, r3, #24
 80119aa:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 80119ae:	ee07 3a90 	vmov	s15, r3
 80119b2:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                                   RCC_PLL3DIVR_PLL3R) >> \
                                                                                  RCC_PLL3DIVR_PLL3R_Pos) + \
 80119b6:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 80119ba:	ee37 7a87 	vadd.f32	s14, s15, s14
                                         (uint32_t)(float_t)(pll3vco / \
 80119be:	edd7 6a09 	vldr	s13, [r7, #36]	@ 0x24
 80119c2:	eec6 7a87 	vdiv.f32	s15, s13, s14
 80119c6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80119ca:	ee17 2a90 	vmov	r2, s15
        pPLL3_Clocks->PLL3_R_Frequency = \
 80119ce:	687b      	ldr	r3, [r7, #4]
 80119d0:	609a      	str	r2, [r3, #8]
  {
    pPLL3_Clocks->PLL3_P_Frequency = 0U;
    pPLL3_Clocks->PLL3_Q_Frequency = 0U;
    pPLL3_Clocks->PLL3_R_Frequency = 0U;
  }
}
 80119d2:	e010      	b.n	80119f6 <HAL_RCCEx_GetPLL3ClockFreq+0x2b6>
        pPLL3_Clocks->PLL3_R_Frequency = 0U;
 80119d4:	687b      	ldr	r3, [r7, #4]
 80119d6:	2200      	movs	r2, #0
 80119d8:	609a      	str	r2, [r3, #8]
}
 80119da:	e00c      	b.n	80119f6 <HAL_RCCEx_GetPLL3ClockFreq+0x2b6>
      pPLL3_Clocks->PLL3_R_Frequency = 0U;
 80119dc:	687b      	ldr	r3, [r7, #4]
 80119de:	2200      	movs	r2, #0
 80119e0:	609a      	str	r2, [r3, #8]
}
 80119e2:	e008      	b.n	80119f6 <HAL_RCCEx_GetPLL3ClockFreq+0x2b6>
    pPLL3_Clocks->PLL3_P_Frequency = 0U;
 80119e4:	687b      	ldr	r3, [r7, #4]
 80119e6:	2200      	movs	r2, #0
 80119e8:	601a      	str	r2, [r3, #0]
    pPLL3_Clocks->PLL3_Q_Frequency = 0U;
 80119ea:	687b      	ldr	r3, [r7, #4]
 80119ec:	2200      	movs	r2, #0
 80119ee:	605a      	str	r2, [r3, #4]
    pPLL3_Clocks->PLL3_R_Frequency = 0U;
 80119f0:	687b      	ldr	r3, [r7, #4]
 80119f2:	2200      	movs	r2, #0
 80119f4:	609a      	str	r2, [r3, #8]
}
 80119f6:	bf00      	nop
 80119f8:	372c      	adds	r7, #44	@ 0x2c
 80119fa:	46bd      	mov	sp, r7
 80119fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011a00:	4770      	bx	lr
 8011a02:	bf00      	nop
 8011a04:	44020c00 	.word	0x44020c00
 8011a08:	03d09000 	.word	0x03d09000
 8011a0c:	46000000 	.word	0x46000000
 8011a10:	4a742400 	.word	0x4a742400
 8011a14:	4bbebc20 	.word	0x4bbebc20

08011a18 <HAL_RCCEx_GetPeriphCLKFreq>:
  *  (*)   : For stm32h56xxx and stm32h57xxx family lines only.
  *  (**)  : For stm32h563xx and stm32h57xxx family lines only.
  *  (***) : For stm32h503xx family line only.
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint64_t PeriphClk)
{
 8011a18:	b590      	push	{r4, r7, lr}
 8011a1a:	b08f      	sub	sp, #60	@ 0x3c
 8011a1c:	af00      	add	r7, sp, #0
 8011a1e:	e9c7 0100 	strd	r0, r1, [r7]
  uint32_t srcclk;

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));

  if (PeriphClk == RCC_PERIPHCLK_RTC)
 8011a22:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011a26:	f100 447e 	add.w	r4, r0, #4261412864	@ 0xfe000000
 8011a2a:	4321      	orrs	r1, r4
 8011a2c:	d150      	bne.n	8011ad0 <HAL_RCCEx_GetPeriphCLKFreq+0xb8>
  {
    /* Get the current RTC source */
    srcclk = __HAL_RCC_GET_RTC_SOURCE();
 8011a2e:	4b26      	ldr	r3, [pc, #152]	@ (8011ac8 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8011a30:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8011a34:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8011a38:	633b      	str	r3, [r7, #48]	@ 0x30

    /* Check if LSE is ready and if RTC clock selection is LSE */
    if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_RTCCLKSOURCE_LSE))
 8011a3a:	4b23      	ldr	r3, [pc, #140]	@ (8011ac8 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8011a3c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8011a40:	f003 0302 	and.w	r3, r3, #2
 8011a44:	2b02      	cmp	r3, #2
 8011a46:	d108      	bne.n	8011a5a <HAL_RCCEx_GetPeriphCLKFreq+0x42>
 8011a48:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011a4a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8011a4e:	d104      	bne.n	8011a5a <HAL_RCCEx_GetPeriphCLKFreq+0x42>
    {
      frequency = LSE_VALUE;
 8011a50:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8011a54:	637b      	str	r3, [r7, #52]	@ 0x34
 8011a56:	f002 bb2a 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
    }
    /* Check if LSI is ready and if RTC clock selection is LSI */
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_RTCCLKSOURCE_LSI))
 8011a5a:	4b1b      	ldr	r3, [pc, #108]	@ (8011ac8 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8011a5c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8011a60:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8011a64:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8011a68:	d108      	bne.n	8011a7c <HAL_RCCEx_GetPeriphCLKFreq+0x64>
 8011a6a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011a6c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8011a70:	d104      	bne.n	8011a7c <HAL_RCCEx_GetPeriphCLKFreq+0x64>
    {
      frequency = LSI_VALUE;
 8011a72:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 8011a76:	637b      	str	r3, [r7, #52]	@ 0x34
 8011a78:	f002 bb19 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
    }
    /* Check if HSE is ready and if RTC clock selection is HSE_DIVx*/
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_RTCCLKSOURCE_HSE_DIVx))
 8011a7c:	4b12      	ldr	r3, [pc, #72]	@ (8011ac8 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8011a7e:	681b      	ldr	r3, [r3, #0]
 8011a80:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8011a84:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8011a88:	d119      	bne.n	8011abe <HAL_RCCEx_GetPeriphCLKFreq+0xa6>
 8011a8a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011a8c:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8011a90:	d115      	bne.n	8011abe <HAL_RCCEx_GetPeriphCLKFreq+0xa6>
    {
      if (__HAL_RCC_GET_RTC_HSE_PRESCALER() >= RCC_RTC_HSE_DIV2)
 8011a92:	4b0d      	ldr	r3, [pc, #52]	@ (8011ac8 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8011a94:	69db      	ldr	r3, [r3, #28]
 8011a96:	f403 537c 	and.w	r3, r3, #16128	@ 0x3f00
 8011a9a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8011a9e:	d30a      	bcc.n	8011ab6 <HAL_RCCEx_GetPeriphCLKFreq+0x9e>
      {
        frequency = (HSE_VALUE / ((uint32_t)(__HAL_RCC_GET_RTC_HSE_PRESCALER() >> RCC_CFGR1_RTCPRE_Pos)));
 8011aa0:	4b09      	ldr	r3, [pc, #36]	@ (8011ac8 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8011aa2:	69db      	ldr	r3, [r3, #28]
 8011aa4:	0a1b      	lsrs	r3, r3, #8
 8011aa6:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8011aaa:	4a08      	ldr	r2, [pc, #32]	@ (8011acc <HAL_RCCEx_GetPeriphCLKFreq+0xb4>)
 8011aac:	fbb2 f3f3 	udiv	r3, r2, r3
 8011ab0:	637b      	str	r3, [r7, #52]	@ 0x34
      if (__HAL_RCC_GET_RTC_HSE_PRESCALER() >= RCC_RTC_HSE_DIV2)
 8011ab2:	f002 bafc 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
      }
      else
      {
        frequency = 0U;
 8011ab6:	2300      	movs	r3, #0
 8011ab8:	637b      	str	r3, [r7, #52]	@ 0x34
      if (__HAL_RCC_GET_RTC_HSE_PRESCALER() >= RCC_RTC_HSE_DIV2)
 8011aba:	f002 baf8 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>

    }
    /* Clock not enabled for RTC*/
    else
    {
      frequency = 0U;
 8011abe:	2300      	movs	r3, #0
 8011ac0:	637b      	str	r3, [r7, #52]	@ 0x34
 8011ac2:	f002 baf4 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8011ac6:	bf00      	nop
 8011ac8:	44020c00 	.word	0x44020c00
 8011acc:	017d7840 	.word	0x017d7840
    }
  }
  else
  {
    /* Other external peripheral clock source than RTC */
    switch (PeriphClk)
 8011ad0:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011ad4:	f5a1 6480 	sub.w	r4, r1, #1024	@ 0x400
 8011ad8:	ea50 0104 	orrs.w	r1, r0, r4
 8011adc:	f001 8275 	beq.w	8012fca <HAL_RCCEx_GetPeriphCLKFreq+0x15b2>
 8011ae0:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011ae4:	2801      	cmp	r0, #1
 8011ae6:	f571 6180 	sbcs.w	r1, r1, #1024	@ 0x400
 8011aea:	f082 82dd 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011aee:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011af2:	f5a1 7400 	sub.w	r4, r1, #512	@ 0x200
 8011af6:	ea50 0104 	orrs.w	r1, r0, r4
 8011afa:	f001 816c 	beq.w	8012dd6 <HAL_RCCEx_GetPeriphCLKFreq+0x13be>
 8011afe:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011b02:	2801      	cmp	r0, #1
 8011b04:	f571 7100 	sbcs.w	r1, r1, #512	@ 0x200
 8011b08:	f082 82ce 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011b0c:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011b10:	f5a1 7480 	sub.w	r4, r1, #256	@ 0x100
 8011b14:	ea50 0104 	orrs.w	r1, r0, r4
 8011b18:	f001 8602 	beq.w	8013720 <HAL_RCCEx_GetPeriphCLKFreq+0x1d08>
 8011b1c:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011b20:	2801      	cmp	r0, #1
 8011b22:	f571 7180 	sbcs.w	r1, r1, #256	@ 0x100
 8011b26:	f082 82bf 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011b2a:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011b2e:	f1a1 0480 	sub.w	r4, r1, #128	@ 0x80
 8011b32:	ea50 0104 	orrs.w	r1, r0, r4
 8011b36:	f001 854c 	beq.w	80135d2 <HAL_RCCEx_GetPeriphCLKFreq+0x1bba>
 8011b3a:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011b3e:	2801      	cmp	r0, #1
 8011b40:	f171 0180 	sbcs.w	r1, r1, #128	@ 0x80
 8011b44:	f082 82b0 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011b48:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011b4c:	f1a1 0440 	sub.w	r4, r1, #64	@ 0x40
 8011b50:	ea50 0104 	orrs.w	r1, r0, r4
 8011b54:	f001 849e 	beq.w	8013494 <HAL_RCCEx_GetPeriphCLKFreq+0x1a7c>
 8011b58:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011b5c:	2801      	cmp	r0, #1
 8011b5e:	f171 0140 	sbcs.w	r1, r1, #64	@ 0x40
 8011b62:	f082 82a1 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011b66:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011b6a:	f1a1 0420 	sub.w	r4, r1, #32
 8011b6e:	ea50 0104 	orrs.w	r1, r0, r4
 8011b72:	f001 83e8 	beq.w	8013346 <HAL_RCCEx_GetPeriphCLKFreq+0x192e>
 8011b76:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011b7a:	2801      	cmp	r0, #1
 8011b7c:	f171 0120 	sbcs.w	r1, r1, #32
 8011b80:	f082 8292 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011b84:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011b88:	f1a1 0410 	sub.w	r4, r1, #16
 8011b8c:	ea50 0104 	orrs.w	r1, r0, r4
 8011b90:	f002 8256 	beq.w	8014040 <HAL_RCCEx_GetPeriphCLKFreq+0x2628>
 8011b94:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011b98:	2801      	cmp	r0, #1
 8011b9a:	f171 0110 	sbcs.w	r1, r1, #16
 8011b9e:	f082 8283 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011ba2:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011ba6:	f1a1 0408 	sub.w	r4, r1, #8
 8011baa:	ea50 0104 	orrs.w	r1, r0, r4
 8011bae:	f002 81cc 	beq.w	8013f4a <HAL_RCCEx_GetPeriphCLKFreq+0x2532>
 8011bb2:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011bb6:	2801      	cmp	r0, #1
 8011bb8:	f171 0108 	sbcs.w	r1, r1, #8
 8011bbc:	f082 8274 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011bc0:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011bc4:	1f0c      	subs	r4, r1, #4
 8011bc6:	ea50 0104 	orrs.w	r1, r0, r4
 8011bca:	f001 8648 	beq.w	801385e <HAL_RCCEx_GetPeriphCLKFreq+0x1e46>
 8011bce:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011bd2:	2801      	cmp	r0, #1
 8011bd4:	f171 0104 	sbcs.w	r1, r1, #4
 8011bd8:	f082 8266 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011bdc:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011be0:	1e8c      	subs	r4, r1, #2
 8011be2:	ea50 0104 	orrs.w	r1, r0, r4
 8011be6:	f002 8143 	beq.w	8013e70 <HAL_RCCEx_GetPeriphCLKFreq+0x2458>
 8011bea:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011bee:	2801      	cmp	r0, #1
 8011bf0:	f171 0102 	sbcs.w	r1, r1, #2
 8011bf4:	f082 8258 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011bf8:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011bfc:	1e4c      	subs	r4, r1, #1
 8011bfe:	ea50 0104 	orrs.w	r1, r0, r4
 8011c02:	f002 80ce 	beq.w	8013da2 <HAL_RCCEx_GetPeriphCLKFreq+0x238a>
 8011c06:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011c0a:	2801      	cmp	r0, #1
 8011c0c:	f171 0101 	sbcs.w	r1, r1, #1
 8011c10:	f082 824a 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011c14:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011c18:	f100 4400 	add.w	r4, r0, #2147483648	@ 0x80000000
 8011c1c:	4321      	orrs	r1, r4
 8011c1e:	f002 8059 	beq.w	8013cd4 <HAL_RCCEx_GetPeriphCLKFreq+0x22bc>
 8011c22:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011c26:	4cd9      	ldr	r4, [pc, #868]	@ (8011f8c <HAL_RCCEx_GetPeriphCLKFreq+0x574>)
 8011c28:	42a0      	cmp	r0, r4
 8011c2a:	f171 0100 	sbcs.w	r1, r1, #0
 8011c2e:	f082 823b 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011c32:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011c36:	f100 4440 	add.w	r4, r0, #3221225472	@ 0xc0000000
 8011c3a:	4321      	orrs	r1, r4
 8011c3c:	f001 87d9 	beq.w	8013bf2 <HAL_RCCEx_GetPeriphCLKFreq+0x21da>
 8011c40:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011c44:	4cd2      	ldr	r4, [pc, #840]	@ (8011f90 <HAL_RCCEx_GetPeriphCLKFreq+0x578>)
 8011c46:	42a0      	cmp	r0, r4
 8011c48:	f171 0100 	sbcs.w	r1, r1, #0
 8011c4c:	f082 822c 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011c50:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011c54:	f100 4460 	add.w	r4, r0, #3758096384	@ 0xe0000000
 8011c58:	4321      	orrs	r1, r4
 8011c5a:	f001 8751 	beq.w	8013b00 <HAL_RCCEx_GetPeriphCLKFreq+0x20e8>
 8011c5e:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011c62:	4ccc      	ldr	r4, [pc, #816]	@ (8011f94 <HAL_RCCEx_GetPeriphCLKFreq+0x57c>)
 8011c64:	42a0      	cmp	r0, r4
 8011c66:	f171 0100 	sbcs.w	r1, r1, #0
 8011c6a:	f082 821d 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011c6e:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011c72:	f100 4470 	add.w	r4, r0, #4026531840	@ 0xf0000000
 8011c76:	4321      	orrs	r1, r4
 8011c78:	f001 869a 	beq.w	80139b0 <HAL_RCCEx_GetPeriphCLKFreq+0x1f98>
 8011c7c:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011c80:	4cc5      	ldr	r4, [pc, #788]	@ (8011f98 <HAL_RCCEx_GetPeriphCLKFreq+0x580>)
 8011c82:	42a0      	cmp	r0, r4
 8011c84:	f171 0100 	sbcs.w	r1, r1, #0
 8011c88:	f082 820e 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011c8c:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011c90:	f100 4478 	add.w	r4, r0, #4160749568	@ 0xf8000000
 8011c94:	4321      	orrs	r1, r4
 8011c96:	f001 8612 	beq.w	80138be <HAL_RCCEx_GetPeriphCLKFreq+0x1ea6>
 8011c9a:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011c9e:	4cbf      	ldr	r4, [pc, #764]	@ (8011f9c <HAL_RCCEx_GetPeriphCLKFreq+0x584>)
 8011ca0:	42a0      	cmp	r0, r4
 8011ca2:	f171 0100 	sbcs.w	r1, r1, #0
 8011ca6:	f082 81ff 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011caa:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011cae:	f100 447c 	add.w	r4, r0, #4227858432	@ 0xfc000000
 8011cb2:	4321      	orrs	r1, r4
 8011cb4:	f002 817e 	beq.w	8013fb4 <HAL_RCCEx_GetPeriphCLKFreq+0x259c>
 8011cb8:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011cbc:	4cb8      	ldr	r4, [pc, #736]	@ (8011fa0 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 8011cbe:	42a0      	cmp	r0, r4
 8011cc0:	f171 0100 	sbcs.w	r1, r1, #0
 8011cc4:	f082 81f0 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011cc8:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011ccc:	f5a0 0400 	sub.w	r4, r0, #8388608	@ 0x800000
 8011cd0:	4321      	orrs	r1, r4
 8011cd2:	f000 829e 	beq.w	8012212 <HAL_RCCEx_GetPeriphCLKFreq+0x7fa>
 8011cd6:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011cda:	4cb2      	ldr	r4, [pc, #712]	@ (8011fa4 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
 8011cdc:	42a0      	cmp	r0, r4
 8011cde:	f171 0100 	sbcs.w	r1, r1, #0
 8011ce2:	f082 81e1 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011ce6:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011cea:	f5a0 0480 	sub.w	r4, r0, #4194304	@ 0x400000
 8011cee:	4321      	orrs	r1, r4
 8011cf0:	f000 826d 	beq.w	80121ce <HAL_RCCEx_GetPeriphCLKFreq+0x7b6>
 8011cf4:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011cf8:	4cab      	ldr	r4, [pc, #684]	@ (8011fa8 <HAL_RCCEx_GetPeriphCLKFreq+0x590>)
 8011cfa:	42a0      	cmp	r0, r4
 8011cfc:	f171 0100 	sbcs.w	r1, r1, #0
 8011d00:	f082 81d2 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011d04:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011d08:	f5a0 1400 	sub.w	r4, r0, #2097152	@ 0x200000
 8011d0c:	4321      	orrs	r1, r4
 8011d0e:	f001 800d 	beq.w	8012d2c <HAL_RCCEx_GetPeriphCLKFreq+0x1314>
 8011d12:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011d16:	4ca5      	ldr	r4, [pc, #660]	@ (8011fac <HAL_RCCEx_GetPeriphCLKFreq+0x594>)
 8011d18:	42a0      	cmp	r0, r4
 8011d1a:	f171 0100 	sbcs.w	r1, r1, #0
 8011d1e:	f082 81c3 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011d22:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011d26:	f5a0 1480 	sub.w	r4, r0, #1048576	@ 0x100000
 8011d2a:	4321      	orrs	r1, r4
 8011d2c:	f000 81d0 	beq.w	80120d0 <HAL_RCCEx_GetPeriphCLKFreq+0x6b8>
 8011d30:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011d34:	4c9e      	ldr	r4, [pc, #632]	@ (8011fb0 <HAL_RCCEx_GetPeriphCLKFreq+0x598>)
 8011d36:	42a0      	cmp	r0, r4
 8011d38:	f171 0100 	sbcs.w	r1, r1, #0
 8011d3c:	f082 81b4 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011d40:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011d44:	f5a0 2400 	sub.w	r4, r0, #524288	@ 0x80000
 8011d48:	4321      	orrs	r1, r4
 8011d4a:	f000 8142 	beq.w	8011fd2 <HAL_RCCEx_GetPeriphCLKFreq+0x5ba>
 8011d4e:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011d52:	4c98      	ldr	r4, [pc, #608]	@ (8011fb4 <HAL_RCCEx_GetPeriphCLKFreq+0x59c>)
 8011d54:	42a0      	cmp	r0, r4
 8011d56:	f171 0100 	sbcs.w	r1, r1, #0
 8011d5a:	f082 81a5 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011d5e:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011d62:	f5a0 2480 	sub.w	r4, r0, #262144	@ 0x40000
 8011d66:	4321      	orrs	r1, r4
 8011d68:	f001 824e 	beq.w	8013208 <HAL_RCCEx_GetPeriphCLKFreq+0x17f0>
 8011d6c:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011d70:	4c91      	ldr	r4, [pc, #580]	@ (8011fb8 <HAL_RCCEx_GetPeriphCLKFreq+0x5a0>)
 8011d72:	42a0      	cmp	r0, r4
 8011d74:	f171 0100 	sbcs.w	r1, r1, #0
 8011d78:	f082 8196 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011d7c:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011d80:	f5a0 3400 	sub.w	r4, r0, #131072	@ 0x20000
 8011d84:	4321      	orrs	r1, r4
 8011d86:	f001 8197 	beq.w	80130b8 <HAL_RCCEx_GetPeriphCLKFreq+0x16a0>
 8011d8a:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011d8e:	4c8b      	ldr	r4, [pc, #556]	@ (8011fbc <HAL_RCCEx_GetPeriphCLKFreq+0x5a4>)
 8011d90:	42a0      	cmp	r0, r4
 8011d92:	f171 0100 	sbcs.w	r1, r1, #0
 8011d96:	f082 8187 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011d9a:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011d9e:	f5a0 3480 	sub.w	r4, r0, #65536	@ 0x10000
 8011da2:	4321      	orrs	r1, r4
 8011da4:	f001 8154 	beq.w	8013050 <HAL_RCCEx_GetPeriphCLKFreq+0x1638>
 8011da8:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011dac:	f1b0 1f01 	cmp.w	r0, #65537	@ 0x10001
 8011db0:	f171 0100 	sbcs.w	r1, r1, #0
 8011db4:	f082 8178 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011db8:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011dbc:	f5a0 4400 	sub.w	r4, r0, #32768	@ 0x8000
 8011dc0:	4321      	orrs	r1, r4
 8011dc2:	f001 80b7 	beq.w	8012f34 <HAL_RCCEx_GetPeriphCLKFreq+0x151c>
 8011dc6:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011dca:	f248 0401 	movw	r4, #32769	@ 0x8001
 8011dce:	42a0      	cmp	r0, r4
 8011dd0:	f171 0100 	sbcs.w	r1, r1, #0
 8011dd4:	f082 8168 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011dd8:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011ddc:	f5a0 4480 	sub.w	r4, r0, #16384	@ 0x4000
 8011de0:	4321      	orrs	r1, r4
 8011de2:	f001 8064 	beq.w	8012eae <HAL_RCCEx_GetPeriphCLKFreq+0x1496>
 8011de6:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011dea:	f244 0401 	movw	r4, #16385	@ 0x4001
 8011dee:	42a0      	cmp	r0, r4
 8011df0:	f171 0100 	sbcs.w	r1, r1, #0
 8011df4:	f082 8158 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011df8:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011dfc:	f5a0 5400 	sub.w	r4, r0, #8192	@ 0x2000
 8011e00:	4321      	orrs	r1, r4
 8011e02:	f001 8011 	beq.w	8012e28 <HAL_RCCEx_GetPeriphCLKFreq+0x1410>
 8011e06:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011e0a:	f242 0401 	movw	r4, #8193	@ 0x2001
 8011e0e:	42a0      	cmp	r0, r4
 8011e10:	f171 0100 	sbcs.w	r1, r1, #0
 8011e14:	f082 8148 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011e18:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011e1c:	f5a0 5480 	sub.w	r4, r0, #4096	@ 0x1000
 8011e20:	4321      	orrs	r1, r4
 8011e22:	f000 871e 	beq.w	8012c62 <HAL_RCCEx_GetPeriphCLKFreq+0x124a>
 8011e26:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011e2a:	f241 0401 	movw	r4, #4097	@ 0x1001
 8011e2e:	42a0      	cmp	r0, r4
 8011e30:	f171 0100 	sbcs.w	r1, r1, #0
 8011e34:	f082 8138 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011e38:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011e3c:	f5a0 6400 	sub.w	r4, r0, #2048	@ 0x800
 8011e40:	4321      	orrs	r1, r4
 8011e42:	f000 86a8 	beq.w	8012b96 <HAL_RCCEx_GetPeriphCLKFreq+0x117e>
 8011e46:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011e4a:	f640 0401 	movw	r4, #2049	@ 0x801
 8011e4e:	42a0      	cmp	r0, r4
 8011e50:	f171 0100 	sbcs.w	r1, r1, #0
 8011e54:	f082 8128 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011e58:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011e5c:	f5a0 6480 	sub.w	r4, r0, #1024	@ 0x400
 8011e60:	4321      	orrs	r1, r4
 8011e62:	f000 8632 	beq.w	8012aca <HAL_RCCEx_GetPeriphCLKFreq+0x10b2>
 8011e66:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011e6a:	f240 4401 	movw	r4, #1025	@ 0x401
 8011e6e:	42a0      	cmp	r0, r4
 8011e70:	f171 0100 	sbcs.w	r1, r1, #0
 8011e74:	f082 8118 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011e78:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011e7c:	f5a0 7400 	sub.w	r4, r0, #512	@ 0x200
 8011e80:	4321      	orrs	r1, r4
 8011e82:	f000 85b0 	beq.w	80129e6 <HAL_RCCEx_GetPeriphCLKFreq+0xfce>
 8011e86:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011e8a:	f240 2401 	movw	r4, #513	@ 0x201
 8011e8e:	42a0      	cmp	r0, r4
 8011e90:	f171 0100 	sbcs.w	r1, r1, #0
 8011e94:	f082 8108 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011e98:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011e9c:	f5a0 7480 	sub.w	r4, r0, #256	@ 0x100
 8011ea0:	4321      	orrs	r1, r4
 8011ea2:	f000 8535 	beq.w	8012910 <HAL_RCCEx_GetPeriphCLKFreq+0xef8>
 8011ea6:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011eaa:	f240 1401 	movw	r4, #257	@ 0x101
 8011eae:	42a0      	cmp	r0, r4
 8011eb0:	f171 0100 	sbcs.w	r1, r1, #0
 8011eb4:	f082 80f8 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011eb8:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011ebc:	f1a0 0480 	sub.w	r4, r0, #128	@ 0x80
 8011ec0:	4321      	orrs	r1, r4
 8011ec2:	f000 84ba 	beq.w	801283a <HAL_RCCEx_GetPeriphCLKFreq+0xe22>
 8011ec6:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011eca:	2881      	cmp	r0, #129	@ 0x81
 8011ecc:	f171 0100 	sbcs.w	r1, r1, #0
 8011ed0:	f082 80ea 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011ed4:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011ed8:	2821      	cmp	r0, #33	@ 0x21
 8011eda:	f171 0100 	sbcs.w	r1, r1, #0
 8011ede:	d26f      	bcs.n	8011fc0 <HAL_RCCEx_GetPeriphCLKFreq+0x5a8>
 8011ee0:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011ee4:	4301      	orrs	r1, r0
 8011ee6:	f002 80df 	beq.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011eea:	e9d7 0100 	ldrd	r0, r1, [r7]
 8011eee:	1e42      	subs	r2, r0, #1
 8011ef0:	f141 33ff 	adc.w	r3, r1, #4294967295
 8011ef4:	2a20      	cmp	r2, #32
 8011ef6:	f173 0100 	sbcs.w	r1, r3, #0
 8011efa:	f082 80d5 	bcs.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011efe:	2a1f      	cmp	r2, #31
 8011f00:	f202 80d2 	bhi.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
 8011f04:	a101      	add	r1, pc, #4	@ (adr r1, 8011f0c <HAL_RCCEx_GetPeriphCLKFreq+0x4f4>)
 8011f06:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
 8011f0a:	bf00      	nop
 8011f0c:	0801226d 	.word	0x0801226d
 8011f10:	08012339 	.word	0x08012339
 8011f14:	080140a9 	.word	0x080140a9
 8011f18:	080123f9 	.word	0x080123f9
 8011f1c:	080140a9 	.word	0x080140a9
 8011f20:	080140a9 	.word	0x080140a9
 8011f24:	080140a9 	.word	0x080140a9
 8011f28:	080124c9 	.word	0x080124c9
 8011f2c:	080140a9 	.word	0x080140a9
 8011f30:	080140a9 	.word	0x080140a9
 8011f34:	080140a9 	.word	0x080140a9
 8011f38:	080140a9 	.word	0x080140a9
 8011f3c:	080140a9 	.word	0x080140a9
 8011f40:	080140a9 	.word	0x080140a9
 8011f44:	080140a9 	.word	0x080140a9
 8011f48:	080125ab 	.word	0x080125ab
 8011f4c:	080140a9 	.word	0x080140a9
 8011f50:	080140a9 	.word	0x080140a9
 8011f54:	080140a9 	.word	0x080140a9
 8011f58:	080140a9 	.word	0x080140a9
 8011f5c:	080140a9 	.word	0x080140a9
 8011f60:	080140a9 	.word	0x080140a9
 8011f64:	080140a9 	.word	0x080140a9
 8011f68:	080140a9 	.word	0x080140a9
 8011f6c:	080140a9 	.word	0x080140a9
 8011f70:	080140a9 	.word	0x080140a9
 8011f74:	080140a9 	.word	0x080140a9
 8011f78:	080140a9 	.word	0x080140a9
 8011f7c:	080140a9 	.word	0x080140a9
 8011f80:	080140a9 	.word	0x080140a9
 8011f84:	080140a9 	.word	0x080140a9
 8011f88:	08012681 	.word	0x08012681
 8011f8c:	80000001 	.word	0x80000001
 8011f90:	40000001 	.word	0x40000001
 8011f94:	20000001 	.word	0x20000001
 8011f98:	10000001 	.word	0x10000001
 8011f9c:	08000001 	.word	0x08000001
 8011fa0:	04000001 	.word	0x04000001
 8011fa4:	00800001 	.word	0x00800001
 8011fa8:	00400001 	.word	0x00400001
 8011fac:	00200001 	.word	0x00200001
 8011fb0:	00100001 	.word	0x00100001
 8011fb4:	00080001 	.word	0x00080001
 8011fb8:	00040001 	.word	0x00040001
 8011fbc:	00020001 	.word	0x00020001
 8011fc0:	e9d7 2300 	ldrd	r2, r3, [r7]
 8011fc4:	f1a2 0140 	sub.w	r1, r2, #64	@ 0x40
 8011fc8:	430b      	orrs	r3, r1
 8011fca:	f000 83c4 	beq.w	8012756 <HAL_RCCEx_GetPeriphCLKFreq+0xd3e>
 8011fce:	f002 b86b 	b.w	80140a8 <HAL_RCCEx_GetPeriphCLKFreq+0x2690>
    {
#if defined (SAI1)
      case RCC_PERIPHCLK_SAI1:

        srcclk = __HAL_RCC_GET_SAI1_SOURCE();
 8011fd2:	4ba1      	ldr	r3, [pc, #644]	@ (8012258 <HAL_RCCEx_GetPeriphCLKFreq+0x840>)
 8011fd4:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8011fd8:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
 8011fdc:	633b      	str	r3, [r7, #48]	@ 0x30

        switch (srcclk)
 8011fde:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011fe0:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8011fe4:	d036      	beq.n	8012054 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>
 8011fe6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011fe8:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8011fec:	d86b      	bhi.n	80120c6 <HAL_RCCEx_GetPeriphCLKFreq+0x6ae>
 8011fee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011ff0:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8011ff4:	d02b      	beq.n	801204e <HAL_RCCEx_GetPeriphCLKFreq+0x636>
 8011ff6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011ff8:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8011ffc:	d863      	bhi.n	80120c6 <HAL_RCCEx_GetPeriphCLKFreq+0x6ae>
 8011ffe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012000:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8012004:	d01b      	beq.n	801203e <HAL_RCCEx_GetPeriphCLKFreq+0x626>
 8012006:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012008:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 801200c:	d85b      	bhi.n	80120c6 <HAL_RCCEx_GetPeriphCLKFreq+0x6ae>
 801200e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012010:	2b00      	cmp	r3, #0
 8012012:	d004      	beq.n	801201e <HAL_RCCEx_GetPeriphCLKFreq+0x606>
 8012014:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012016:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 801201a:	d008      	beq.n	801202e <HAL_RCCEx_GetPeriphCLKFreq+0x616>
 801201c:	e053      	b.n	80120c6 <HAL_RCCEx_GetPeriphCLKFreq+0x6ae>
        {
          case RCC_SAI1CLKSOURCE_PLL1Q: /* PLL1Q is the clock source for SAI1 */
          {
            HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 801201e:	f107 0320 	add.w	r3, r7, #32
 8012022:	4618      	mov	r0, r3
 8012024:	f7ff f8b4 	bl	8011190 <HAL_RCCEx_GetPLL1ClockFreq>
            frequency = pll1_clocks.PLL1_Q_Frequency;
 8012028:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801202a:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 801202c:	e04e      	b.n	80120cc <HAL_RCCEx_GetPeriphCLKFreq+0x6b4>
          }
          case RCC_SAI1CLKSOURCE_PLL2P: /* PLL2P is the clock source for SAI1 */
          {
            HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 801202e:	f107 0314 	add.w	r3, r7, #20
 8012032:	4618      	mov	r0, r3
 8012034:	f7ff fa18 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
            frequency = pll2_clocks.PLL2_P_Frequency;
 8012038:	697b      	ldr	r3, [r7, #20]
 801203a:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 801203c:	e046      	b.n	80120cc <HAL_RCCEx_GetPeriphCLKFreq+0x6b4>
          }
          case RCC_SAI1CLKSOURCE_PLL3P: /* PLLI3P is the clock source for SAI1 */
          {
            HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 801203e:	f107 0308 	add.w	r3, r7, #8
 8012042:	4618      	mov	r0, r3
 8012044:	f7ff fb7c 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
            frequency = pll3_clocks.PLL3_P_Frequency;
 8012048:	68bb      	ldr	r3, [r7, #8]
 801204a:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 801204c:	e03e      	b.n	80120cc <HAL_RCCEx_GetPeriphCLKFreq+0x6b4>
          }
          case RCC_SAI1CLKSOURCE_PIN:
          {
            frequency = EXTERNAL_CLOCK_VALUE;
 801204e:	4b83      	ldr	r3, [pc, #524]	@ (801225c <HAL_RCCEx_GetPeriphCLKFreq+0x844>)
 8012050:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8012052:	e03b      	b.n	80120cc <HAL_RCCEx_GetPeriphCLKFreq+0x6b4>
          }
          case RCC_SAI1CLKSOURCE_CLKP: /* CLKP is the clock source for SAI1 */
          {

            ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 8012054:	4b80      	ldr	r3, [pc, #512]	@ (8012258 <HAL_RCCEx_GetPeriphCLKFreq+0x840>)
 8012056:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 801205a:	f003 4340 	and.w	r3, r3, #3221225472	@ 0xc0000000
 801205e:	62fb      	str	r3, [r7, #44]	@ 0x2c

            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 8012060:	4b7d      	ldr	r3, [pc, #500]	@ (8012258 <HAL_RCCEx_GetPeriphCLKFreq+0x840>)
 8012062:	681b      	ldr	r3, [r3, #0]
 8012064:	f003 0302 	and.w	r3, r3, #2
 8012068:	2b02      	cmp	r3, #2
 801206a:	d10c      	bne.n	8012086 <HAL_RCCEx_GetPeriphCLKFreq+0x66e>
 801206c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801206e:	2b00      	cmp	r3, #0
 8012070:	d109      	bne.n	8012086 <HAL_RCCEx_GetPeriphCLKFreq+0x66e>
            {
              /* In Case the CKPER Source is HSI */
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8012072:	4b79      	ldr	r3, [pc, #484]	@ (8012258 <HAL_RCCEx_GetPeriphCLKFreq+0x840>)
 8012074:	681b      	ldr	r3, [r3, #0]
 8012076:	08db      	lsrs	r3, r3, #3
 8012078:	f003 0303 	and.w	r3, r3, #3
 801207c:	4a78      	ldr	r2, [pc, #480]	@ (8012260 <HAL_RCCEx_GetPeriphCLKFreq+0x848>)
 801207e:	fa22 f303 	lsr.w	r3, r2, r3
 8012082:	637b      	str	r3, [r7, #52]	@ 0x34
 8012084:	e01e      	b.n	80120c4 <HAL_RCCEx_GetPeriphCLKFreq+0x6ac>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 8012086:	4b74      	ldr	r3, [pc, #464]	@ (8012258 <HAL_RCCEx_GetPeriphCLKFreq+0x840>)
 8012088:	681b      	ldr	r3, [r3, #0]
 801208a:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 801208e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8012092:	d106      	bne.n	80120a2 <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
 8012094:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012096:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 801209a:	d102      	bne.n	80120a2 <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
            {
              /* In Case the CKPER Source is CSI */
              frequency = CSI_VALUE;
 801209c:	4b71      	ldr	r3, [pc, #452]	@ (8012264 <HAL_RCCEx_GetPeriphCLKFreq+0x84c>)
 801209e:	637b      	str	r3, [r7, #52]	@ 0x34
 80120a0:	e010      	b.n	80120c4 <HAL_RCCEx_GetPeriphCLKFreq+0x6ac>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 80120a2:	4b6d      	ldr	r3, [pc, #436]	@ (8012258 <HAL_RCCEx_GetPeriphCLKFreq+0x840>)
 80120a4:	681b      	ldr	r3, [r3, #0]
 80120a6:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80120aa:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 80120ae:	d106      	bne.n	80120be <HAL_RCCEx_GetPeriphCLKFreq+0x6a6>
 80120b0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80120b2:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 80120b6:	d102      	bne.n	80120be <HAL_RCCEx_GetPeriphCLKFreq+0x6a6>
            {
              /* In Case the CKPER Source is HSE */
              frequency = HSE_VALUE;
 80120b8:	4b6b      	ldr	r3, [pc, #428]	@ (8012268 <HAL_RCCEx_GetPeriphCLKFreq+0x850>)
 80120ba:	637b      	str	r3, [r7, #52]	@ 0x34
 80120bc:	e002      	b.n	80120c4 <HAL_RCCEx_GetPeriphCLKFreq+0x6ac>
            }

            else
            {
              /* In Case the CKPER is disabled*/
              frequency = 0U;
 80120be:	2300      	movs	r3, #0
 80120c0:	637b      	str	r3, [r7, #52]	@ 0x34
            }

            break;
 80120c2:	e003      	b.n	80120cc <HAL_RCCEx_GetPeriphCLKFreq+0x6b4>
 80120c4:	e002      	b.n	80120cc <HAL_RCCEx_GetPeriphCLKFreq+0x6b4>
          }
          default :
          {
            frequency = 0U;
 80120c6:	2300      	movs	r3, #0
 80120c8:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 80120ca:	bf00      	nop
          }
        }
        break;
 80120cc:	f001 bfef 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /*SAI1*/

#if defined(SAI2)
      case RCC_PERIPHCLK_SAI2:

        srcclk = __HAL_RCC_GET_SAI2_SOURCE();
 80120d0:	4b61      	ldr	r3, [pc, #388]	@ (8012258 <HAL_RCCEx_GetPeriphCLKFreq+0x840>)
 80120d2:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 80120d6:	f403 1360 	and.w	r3, r3, #3670016	@ 0x380000
 80120da:	633b      	str	r3, [r7, #48]	@ 0x30

        switch (srcclk)
 80120dc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80120de:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 80120e2:	d036      	beq.n	8012152 <HAL_RCCEx_GetPeriphCLKFreq+0x73a>
 80120e4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80120e6:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 80120ea:	d86b      	bhi.n	80121c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>
 80120ec:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80120ee:	f5b3 1fc0 	cmp.w	r3, #1572864	@ 0x180000
 80120f2:	d02b      	beq.n	801214c <HAL_RCCEx_GetPeriphCLKFreq+0x734>
 80120f4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80120f6:	f5b3 1fc0 	cmp.w	r3, #1572864	@ 0x180000
 80120fa:	d863      	bhi.n	80121c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>
 80120fc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80120fe:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8012102:	d01b      	beq.n	801213c <HAL_RCCEx_GetPeriphCLKFreq+0x724>
 8012104:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012106:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 801210a:	d85b      	bhi.n	80121c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>
 801210c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801210e:	2b00      	cmp	r3, #0
 8012110:	d004      	beq.n	801211c <HAL_RCCEx_GetPeriphCLKFreq+0x704>
 8012112:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012114:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 8012118:	d008      	beq.n	801212c <HAL_RCCEx_GetPeriphCLKFreq+0x714>
 801211a:	e053      	b.n	80121c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>
        {
          case RCC_SAI2CLKSOURCE_PLL1Q: /* PLL1Q is the clock source for SAI2 */
          {
            HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 801211c:	f107 0320 	add.w	r3, r7, #32
 8012120:	4618      	mov	r0, r3
 8012122:	f7ff f835 	bl	8011190 <HAL_RCCEx_GetPLL1ClockFreq>
            frequency = pll1_clocks.PLL1_Q_Frequency;
 8012126:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012128:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 801212a:	e04e      	b.n	80121ca <HAL_RCCEx_GetPeriphCLKFreq+0x7b2>
          }
          case RCC_SAI2CLKSOURCE_PLL2P: /* PLL2P is the clock source for SAI2 */
          {
            HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 801212c:	f107 0314 	add.w	r3, r7, #20
 8012130:	4618      	mov	r0, r3
 8012132:	f7ff f999 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
            frequency = pll2_clocks.PLL2_P_Frequency;
 8012136:	697b      	ldr	r3, [r7, #20]
 8012138:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 801213a:	e046      	b.n	80121ca <HAL_RCCEx_GetPeriphCLKFreq+0x7b2>
          }
          case RCC_SAI2CLKSOURCE_PLL3P: /* PLLI3P is the clock source for SAI2 */
          {
            HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 801213c:	f107 0308 	add.w	r3, r7, #8
 8012140:	4618      	mov	r0, r3
 8012142:	f7ff fafd 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
            frequency = pll3_clocks.PLL3_P_Frequency;
 8012146:	68bb      	ldr	r3, [r7, #8]
 8012148:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 801214a:	e03e      	b.n	80121ca <HAL_RCCEx_GetPeriphCLKFreq+0x7b2>
          }
          case RCC_SAI2CLKSOURCE_PIN:
          {
            frequency = EXTERNAL_CLOCK_VALUE;
 801214c:	4b43      	ldr	r3, [pc, #268]	@ (801225c <HAL_RCCEx_GetPeriphCLKFreq+0x844>)
 801214e:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8012150:	e03b      	b.n	80121ca <HAL_RCCEx_GetPeriphCLKFreq+0x7b2>
          }
          case RCC_SAI2CLKSOURCE_CLKP: /* CLKP is the clock source for SAI2 */
          {

            ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 8012152:	4b41      	ldr	r3, [pc, #260]	@ (8012258 <HAL_RCCEx_GetPeriphCLKFreq+0x840>)
 8012154:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8012158:	f003 4340 	and.w	r3, r3, #3221225472	@ 0xc0000000
 801215c:	62fb      	str	r3, [r7, #44]	@ 0x2c

            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 801215e:	4b3e      	ldr	r3, [pc, #248]	@ (8012258 <HAL_RCCEx_GetPeriphCLKFreq+0x840>)
 8012160:	681b      	ldr	r3, [r3, #0]
 8012162:	f003 0302 	and.w	r3, r3, #2
 8012166:	2b02      	cmp	r3, #2
 8012168:	d10c      	bne.n	8012184 <HAL_RCCEx_GetPeriphCLKFreq+0x76c>
 801216a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801216c:	2b00      	cmp	r3, #0
 801216e:	d109      	bne.n	8012184 <HAL_RCCEx_GetPeriphCLKFreq+0x76c>
            {
              /* In Case the CKPER Source is HSI */
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8012170:	4b39      	ldr	r3, [pc, #228]	@ (8012258 <HAL_RCCEx_GetPeriphCLKFreq+0x840>)
 8012172:	681b      	ldr	r3, [r3, #0]
 8012174:	08db      	lsrs	r3, r3, #3
 8012176:	f003 0303 	and.w	r3, r3, #3
 801217a:	4a39      	ldr	r2, [pc, #228]	@ (8012260 <HAL_RCCEx_GetPeriphCLKFreq+0x848>)
 801217c:	fa22 f303 	lsr.w	r3, r2, r3
 8012180:	637b      	str	r3, [r7, #52]	@ 0x34
 8012182:	e01e      	b.n	80121c2 <HAL_RCCEx_GetPeriphCLKFreq+0x7aa>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 8012184:	4b34      	ldr	r3, [pc, #208]	@ (8012258 <HAL_RCCEx_GetPeriphCLKFreq+0x840>)
 8012186:	681b      	ldr	r3, [r3, #0]
 8012188:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 801218c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8012190:	d106      	bne.n	80121a0 <HAL_RCCEx_GetPeriphCLKFreq+0x788>
 8012192:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012194:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8012198:	d102      	bne.n	80121a0 <HAL_RCCEx_GetPeriphCLKFreq+0x788>
            {
              /* In Case the CKPER Source is CSI */
              frequency = CSI_VALUE;
 801219a:	4b32      	ldr	r3, [pc, #200]	@ (8012264 <HAL_RCCEx_GetPeriphCLKFreq+0x84c>)
 801219c:	637b      	str	r3, [r7, #52]	@ 0x34
 801219e:	e010      	b.n	80121c2 <HAL_RCCEx_GetPeriphCLKFreq+0x7aa>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 80121a0:	4b2d      	ldr	r3, [pc, #180]	@ (8012258 <HAL_RCCEx_GetPeriphCLKFreq+0x840>)
 80121a2:	681b      	ldr	r3, [r3, #0]
 80121a4:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80121a8:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 80121ac:	d106      	bne.n	80121bc <HAL_RCCEx_GetPeriphCLKFreq+0x7a4>
 80121ae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80121b0:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 80121b4:	d102      	bne.n	80121bc <HAL_RCCEx_GetPeriphCLKFreq+0x7a4>
            {
              /* In Case the CKPER Source is HSE */
              frequency = HSE_VALUE;
 80121b6:	4b2c      	ldr	r3, [pc, #176]	@ (8012268 <HAL_RCCEx_GetPeriphCLKFreq+0x850>)
 80121b8:	637b      	str	r3, [r7, #52]	@ 0x34
 80121ba:	e002      	b.n	80121c2 <HAL_RCCEx_GetPeriphCLKFreq+0x7aa>
            }

            else
            {
              /* In Case the CKPER is disabled*/
              frequency = 0U;
 80121bc:	2300      	movs	r3, #0
 80121be:	637b      	str	r3, [r7, #52]	@ 0x34
            }

            break;
 80121c0:	e003      	b.n	80121ca <HAL_RCCEx_GetPeriphCLKFreq+0x7b2>
 80121c2:	e002      	b.n	80121ca <HAL_RCCEx_GetPeriphCLKFreq+0x7b2>
          }
          default :
          {
            frequency = 0U;
 80121c4:	2300      	movs	r3, #0
 80121c6:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 80121c8:	bf00      	nop
          }
        }
        break;
 80121ca:	f001 bf70 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* SAI2 */

#if defined(SDMMC1)
      case RCC_PERIPHCLK_SDMMC1:
        srcclk = __HAL_RCC_GET_SDMMC1_SOURCE();
 80121ce:	4b22      	ldr	r3, [pc, #136]	@ (8012258 <HAL_RCCEx_GetPeriphCLKFreq+0x840>)
 80121d0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 80121d4:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80121d8:	633b      	str	r3, [r7, #48]	@ 0x30
        if (srcclk == RCC_SDMMC1CLKSOURCE_PLL1Q)
 80121da:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80121dc:	2b00      	cmp	r3, #0
 80121de:	d108      	bne.n	80121f2 <HAL_RCCEx_GetPeriphCLKFreq+0x7da>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 80121e0:	f107 0320 	add.w	r3, r7, #32
 80121e4:	4618      	mov	r0, r3
 80121e6:	f7fe ffd3 	bl	8011190 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 80121ea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80121ec:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 80121ee:	f001 bf5e 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if (srcclk == RCC_SDMMC1CLKSOURCE_PLL2R)
 80121f2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80121f4:	2b40      	cmp	r3, #64	@ 0x40
 80121f6:	d108      	bne.n	801220a <HAL_RCCEx_GetPeriphCLKFreq+0x7f2>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 80121f8:	f107 0314 	add.w	r3, r7, #20
 80121fc:	4618      	mov	r0, r3
 80121fe:	f7ff f933 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
 8012202:	69fb      	ldr	r3, [r7, #28]
 8012204:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012206:	f001 bf52 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
          frequency = 0U;
 801220a:	2300      	movs	r3, #0
 801220c:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 801220e:	f001 bf4e 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* SDMMC1 */

#if defined(SDMMC2)
      case RCC_PERIPHCLK_SDMMC2:
        srcclk = __HAL_RCC_GET_SDMMC2_SOURCE();
 8012212:	4b11      	ldr	r3, [pc, #68]	@ (8012258 <HAL_RCCEx_GetPeriphCLKFreq+0x840>)
 8012214:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8012218:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 801221c:	633b      	str	r3, [r7, #48]	@ 0x30
        if (srcclk == RCC_SDMMC2CLKSOURCE_PLL1Q)
 801221e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012220:	2b00      	cmp	r3, #0
 8012222:	d108      	bne.n	8012236 <HAL_RCCEx_GetPeriphCLKFreq+0x81e>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8012224:	f107 0320 	add.w	r3, r7, #32
 8012228:	4618      	mov	r0, r3
 801222a:	f7fe ffb1 	bl	8011190 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 801222e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012230:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8012232:	f001 bf3c 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if (srcclk == RCC_SDMMC2CLKSOURCE_PLL2R)
 8012236:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012238:	2b80      	cmp	r3, #128	@ 0x80
 801223a:	d108      	bne.n	801224e <HAL_RCCEx_GetPeriphCLKFreq+0x836>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 801223c:	f107 0314 	add.w	r3, r7, #20
 8012240:	4618      	mov	r0, r3
 8012242:	f7ff f911 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
 8012246:	69fb      	ldr	r3, [r7, #28]
 8012248:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 801224a:	f001 bf30 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
          frequency = 0U;
 801224e:	2300      	movs	r3, #0
 8012250:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012252:	f001 bf2c 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8012256:	bf00      	nop
 8012258:	44020c00 	.word	0x44020c00
 801225c:	00bb8000 	.word	0x00bb8000
 8012260:	03d09000 	.word	0x03d09000
 8012264:	003d0900 	.word	0x003d0900
 8012268:	017d7840 	.word	0x017d7840
#endif /* SDMMC2 */

      case RCC_PERIPHCLK_USART1:
        /* Get the current USART1 source */
        srcclk = __HAL_RCC_GET_USART1_SOURCE();
 801226c:	4b9d      	ldr	r3, [pc, #628]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 801226e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8012272:	f003 0307 	and.w	r3, r3, #7
 8012276:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_USART1CLKSOURCE_PCLK2)
 8012278:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801227a:	2b00      	cmp	r3, #0
 801227c:	d104      	bne.n	8012288 <HAL_RCCEx_GetPeriphCLKFreq+0x870>
        {
          frequency = HAL_RCC_GetPCLK2Freq();
 801227e:	f7fc ffd1 	bl	800f224 <HAL_RCC_GetPCLK2Freq>
 8012282:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Clock not enabled for USART1 */
        else
        {
          frequency = 0U;
        }
        break;
 8012284:	f001 bf13 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_USART1CLKSOURCE_PLL2Q))
 8012288:	4b96      	ldr	r3, [pc, #600]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 801228a:	681b      	ldr	r3, [r3, #0]
 801228c:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8012290:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8012294:	d10a      	bne.n	80122ac <HAL_RCCEx_GetPeriphCLKFreq+0x894>
 8012296:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012298:	2b01      	cmp	r3, #1
 801229a:	d107      	bne.n	80122ac <HAL_RCCEx_GetPeriphCLKFreq+0x894>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 801229c:	f107 0314 	add.w	r3, r7, #20
 80122a0:	4618      	mov	r0, r3
 80122a2:	f7ff f8e1 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 80122a6:	69bb      	ldr	r3, [r7, #24]
 80122a8:	637b      	str	r3, [r7, #52]	@ 0x34
 80122aa:	e043      	b.n	8012334 <HAL_RCCEx_GetPeriphCLKFreq+0x91c>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_USART1CLKSOURCE_PLL3Q))
 80122ac:	4b8d      	ldr	r3, [pc, #564]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 80122ae:	681b      	ldr	r3, [r3, #0]
 80122b0:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 80122b4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 80122b8:	d10a      	bne.n	80122d0 <HAL_RCCEx_GetPeriphCLKFreq+0x8b8>
 80122ba:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80122bc:	2b02      	cmp	r3, #2
 80122be:	d107      	bne.n	80122d0 <HAL_RCCEx_GetPeriphCLKFreq+0x8b8>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 80122c0:	f107 0308 	add.w	r3, r7, #8
 80122c4:	4618      	mov	r0, r3
 80122c6:	f7ff fa3b 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 80122ca:	68fb      	ldr	r3, [r7, #12]
 80122cc:	637b      	str	r3, [r7, #52]	@ 0x34
 80122ce:	e031      	b.n	8012334 <HAL_RCCEx_GetPeriphCLKFreq+0x91c>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART1CLKSOURCE_HSI))
 80122d0:	4b84      	ldr	r3, [pc, #528]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 80122d2:	681b      	ldr	r3, [r3, #0]
 80122d4:	f003 0302 	and.w	r3, r3, #2
 80122d8:	2b02      	cmp	r3, #2
 80122da:	d10c      	bne.n	80122f6 <HAL_RCCEx_GetPeriphCLKFreq+0x8de>
 80122dc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80122de:	2b03      	cmp	r3, #3
 80122e0:	d109      	bne.n	80122f6 <HAL_RCCEx_GetPeriphCLKFreq+0x8de>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 80122e2:	4b80      	ldr	r3, [pc, #512]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 80122e4:	681b      	ldr	r3, [r3, #0]
 80122e6:	08db      	lsrs	r3, r3, #3
 80122e8:	f003 0303 	and.w	r3, r3, #3
 80122ec:	4a7e      	ldr	r2, [pc, #504]	@ (80124e8 <HAL_RCCEx_GetPeriphCLKFreq+0xad0>)
 80122ee:	fa22 f303 	lsr.w	r3, r2, r3
 80122f2:	637b      	str	r3, [r7, #52]	@ 0x34
 80122f4:	e01e      	b.n	8012334 <HAL_RCCEx_GetPeriphCLKFreq+0x91c>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_USART1CLKSOURCE_CSI))
 80122f6:	4b7b      	ldr	r3, [pc, #492]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 80122f8:	681b      	ldr	r3, [r3, #0]
 80122fa:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 80122fe:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8012302:	d105      	bne.n	8012310 <HAL_RCCEx_GetPeriphCLKFreq+0x8f8>
 8012304:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012306:	2b04      	cmp	r3, #4
 8012308:	d102      	bne.n	8012310 <HAL_RCCEx_GetPeriphCLKFreq+0x8f8>
          frequency = CSI_VALUE;
 801230a:	4b78      	ldr	r3, [pc, #480]	@ (80124ec <HAL_RCCEx_GetPeriphCLKFreq+0xad4>)
 801230c:	637b      	str	r3, [r7, #52]	@ 0x34
 801230e:	e011      	b.n	8012334 <HAL_RCCEx_GetPeriphCLKFreq+0x91c>
        else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART1CLKSOURCE_LSE))
 8012310:	4b74      	ldr	r3, [pc, #464]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 8012312:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8012316:	f003 0302 	and.w	r3, r3, #2
 801231a:	2b02      	cmp	r3, #2
 801231c:	d106      	bne.n	801232c <HAL_RCCEx_GetPeriphCLKFreq+0x914>
 801231e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012320:	2b05      	cmp	r3, #5
 8012322:	d103      	bne.n	801232c <HAL_RCCEx_GetPeriphCLKFreq+0x914>
          frequency = LSE_VALUE;
 8012324:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8012328:	637b      	str	r3, [r7, #52]	@ 0x34
 801232a:	e003      	b.n	8012334 <HAL_RCCEx_GetPeriphCLKFreq+0x91c>
          frequency = 0U;
 801232c:	2300      	movs	r3, #0
 801232e:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012330:	f001 bebd 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8012334:	f001 bebb 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>

      case RCC_PERIPHCLK_USART2:
        /* Get the current USART2 source */
        srcclk = __HAL_RCC_GET_USART2_SOURCE();
 8012338:	4b6a      	ldr	r3, [pc, #424]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 801233a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801233e:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 8012342:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_USART2CLKSOURCE_PCLK1)
 8012344:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012346:	2b00      	cmp	r3, #0
 8012348:	d104      	bne.n	8012354 <HAL_RCCEx_GetPeriphCLKFreq+0x93c>
        {
          frequency = HAL_RCC_GetPCLK1Freq();
 801234a:	f7fc ff55 	bl	800f1f8 <HAL_RCC_GetPCLK1Freq>
 801234e:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Clock not enabled for USART2 */
        else
        {
          frequency = 0U;
        }
        break;
 8012350:	f001 bead 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_USART2CLKSOURCE_PLL2Q))
 8012354:	4b63      	ldr	r3, [pc, #396]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 8012356:	681b      	ldr	r3, [r3, #0]
 8012358:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 801235c:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8012360:	d10a      	bne.n	8012378 <HAL_RCCEx_GetPeriphCLKFreq+0x960>
 8012362:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012364:	2b08      	cmp	r3, #8
 8012366:	d107      	bne.n	8012378 <HAL_RCCEx_GetPeriphCLKFreq+0x960>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8012368:	f107 0314 	add.w	r3, r7, #20
 801236c:	4618      	mov	r0, r3
 801236e:	f7ff f87b 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8012372:	69bb      	ldr	r3, [r7, #24]
 8012374:	637b      	str	r3, [r7, #52]	@ 0x34
 8012376:	e03d      	b.n	80123f4 <HAL_RCCEx_GetPeriphCLKFreq+0x9dc>
        else if ((srcclk == RCC_USART2CLKSOURCE_PLL3Q))
 8012378:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801237a:	2b10      	cmp	r3, #16
 801237c:	d108      	bne.n	8012390 <HAL_RCCEx_GetPeriphCLKFreq+0x978>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 801237e:	f107 0308 	add.w	r3, r7, #8
 8012382:	4618      	mov	r0, r3
 8012384:	f7ff f9dc 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 8012388:	68fb      	ldr	r3, [r7, #12]
 801238a:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 801238c:	f001 be8f 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART2CLKSOURCE_HSI))
 8012390:	4b54      	ldr	r3, [pc, #336]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 8012392:	681b      	ldr	r3, [r3, #0]
 8012394:	f003 0302 	and.w	r3, r3, #2
 8012398:	2b02      	cmp	r3, #2
 801239a:	d10c      	bne.n	80123b6 <HAL_RCCEx_GetPeriphCLKFreq+0x99e>
 801239c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801239e:	2b18      	cmp	r3, #24
 80123a0:	d109      	bne.n	80123b6 <HAL_RCCEx_GetPeriphCLKFreq+0x99e>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 80123a2:	4b50      	ldr	r3, [pc, #320]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 80123a4:	681b      	ldr	r3, [r3, #0]
 80123a6:	08db      	lsrs	r3, r3, #3
 80123a8:	f003 0303 	and.w	r3, r3, #3
 80123ac:	4a4e      	ldr	r2, [pc, #312]	@ (80124e8 <HAL_RCCEx_GetPeriphCLKFreq+0xad0>)
 80123ae:	fa22 f303 	lsr.w	r3, r2, r3
 80123b2:	637b      	str	r3, [r7, #52]	@ 0x34
 80123b4:	e01e      	b.n	80123f4 <HAL_RCCEx_GetPeriphCLKFreq+0x9dc>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_USART2CLKSOURCE_CSI))
 80123b6:	4b4b      	ldr	r3, [pc, #300]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 80123b8:	681b      	ldr	r3, [r3, #0]
 80123ba:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 80123be:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80123c2:	d105      	bne.n	80123d0 <HAL_RCCEx_GetPeriphCLKFreq+0x9b8>
 80123c4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80123c6:	2b20      	cmp	r3, #32
 80123c8:	d102      	bne.n	80123d0 <HAL_RCCEx_GetPeriphCLKFreq+0x9b8>
          frequency = CSI_VALUE;
 80123ca:	4b48      	ldr	r3, [pc, #288]	@ (80124ec <HAL_RCCEx_GetPeriphCLKFreq+0xad4>)
 80123cc:	637b      	str	r3, [r7, #52]	@ 0x34
 80123ce:	e011      	b.n	80123f4 <HAL_RCCEx_GetPeriphCLKFreq+0x9dc>
        else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART2CLKSOURCE_LSE))
 80123d0:	4b44      	ldr	r3, [pc, #272]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 80123d2:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80123d6:	f003 0302 	and.w	r3, r3, #2
 80123da:	2b02      	cmp	r3, #2
 80123dc:	d106      	bne.n	80123ec <HAL_RCCEx_GetPeriphCLKFreq+0x9d4>
 80123de:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80123e0:	2b28      	cmp	r3, #40	@ 0x28
 80123e2:	d103      	bne.n	80123ec <HAL_RCCEx_GetPeriphCLKFreq+0x9d4>
          frequency = LSE_VALUE;
 80123e4:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80123e8:	637b      	str	r3, [r7, #52]	@ 0x34
 80123ea:	e003      	b.n	80123f4 <HAL_RCCEx_GetPeriphCLKFreq+0x9dc>
          frequency = 0U;
 80123ec:	2300      	movs	r3, #0
 80123ee:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80123f0:	f001 be5d 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 80123f4:	f001 be5b 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>

      case RCC_PERIPHCLK_USART3:
        /* Get the current USART3 source */
        srcclk = __HAL_RCC_GET_USART3_SOURCE();
 80123f8:	4b3a      	ldr	r3, [pc, #232]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 80123fa:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 80123fe:	f403 73e0 	and.w	r3, r3, #448	@ 0x1c0
 8012402:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_USART3CLKSOURCE_PCLK1)
 8012404:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012406:	2b00      	cmp	r3, #0
 8012408:	d104      	bne.n	8012414 <HAL_RCCEx_GetPeriphCLKFreq+0x9fc>
        {
          frequency = HAL_RCC_GetPCLK1Freq();
 801240a:	f7fc fef5 	bl	800f1f8 <HAL_RCC_GetPCLK1Freq>
 801240e:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Clock not enabled for USART3 */
        else
        {
          frequency = 0U;
        }
        break;
 8012410:	f001 be4d 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_USART3CLKSOURCE_PLL2Q))
 8012414:	4b33      	ldr	r3, [pc, #204]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 8012416:	681b      	ldr	r3, [r3, #0]
 8012418:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 801241c:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8012420:	d10a      	bne.n	8012438 <HAL_RCCEx_GetPeriphCLKFreq+0xa20>
 8012422:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012424:	2b40      	cmp	r3, #64	@ 0x40
 8012426:	d107      	bne.n	8012438 <HAL_RCCEx_GetPeriphCLKFreq+0xa20>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8012428:	f107 0314 	add.w	r3, r7, #20
 801242c:	4618      	mov	r0, r3
 801242e:	f7ff f81b 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8012432:	69bb      	ldr	r3, [r7, #24]
 8012434:	637b      	str	r3, [r7, #52]	@ 0x34
 8012436:	e045      	b.n	80124c4 <HAL_RCCEx_GetPeriphCLKFreq+0xaac>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_USART3CLKSOURCE_PLL3Q))
 8012438:	4b2a      	ldr	r3, [pc, #168]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 801243a:	681b      	ldr	r3, [r3, #0]
 801243c:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8012440:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8012444:	d10a      	bne.n	801245c <HAL_RCCEx_GetPeriphCLKFreq+0xa44>
 8012446:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012448:	2b80      	cmp	r3, #128	@ 0x80
 801244a:	d107      	bne.n	801245c <HAL_RCCEx_GetPeriphCLKFreq+0xa44>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 801244c:	f107 0308 	add.w	r3, r7, #8
 8012450:	4618      	mov	r0, r3
 8012452:	f7ff f975 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 8012456:	68fb      	ldr	r3, [r7, #12]
 8012458:	637b      	str	r3, [r7, #52]	@ 0x34
 801245a:	e033      	b.n	80124c4 <HAL_RCCEx_GetPeriphCLKFreq+0xaac>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART3CLKSOURCE_HSI))
 801245c:	4b21      	ldr	r3, [pc, #132]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 801245e:	681b      	ldr	r3, [r3, #0]
 8012460:	f003 0302 	and.w	r3, r3, #2
 8012464:	2b02      	cmp	r3, #2
 8012466:	d10c      	bne.n	8012482 <HAL_RCCEx_GetPeriphCLKFreq+0xa6a>
 8012468:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801246a:	2bc0      	cmp	r3, #192	@ 0xc0
 801246c:	d109      	bne.n	8012482 <HAL_RCCEx_GetPeriphCLKFreq+0xa6a>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 801246e:	4b1d      	ldr	r3, [pc, #116]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 8012470:	681b      	ldr	r3, [r3, #0]
 8012472:	08db      	lsrs	r3, r3, #3
 8012474:	f003 0303 	and.w	r3, r3, #3
 8012478:	4a1b      	ldr	r2, [pc, #108]	@ (80124e8 <HAL_RCCEx_GetPeriphCLKFreq+0xad0>)
 801247a:	fa22 f303 	lsr.w	r3, r2, r3
 801247e:	637b      	str	r3, [r7, #52]	@ 0x34
 8012480:	e020      	b.n	80124c4 <HAL_RCCEx_GetPeriphCLKFreq+0xaac>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_USART3CLKSOURCE_CSI))
 8012482:	4b18      	ldr	r3, [pc, #96]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 8012484:	681b      	ldr	r3, [r3, #0]
 8012486:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 801248a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 801248e:	d106      	bne.n	801249e <HAL_RCCEx_GetPeriphCLKFreq+0xa86>
 8012490:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012492:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8012496:	d102      	bne.n	801249e <HAL_RCCEx_GetPeriphCLKFreq+0xa86>
          frequency = CSI_VALUE;
 8012498:	4b14      	ldr	r3, [pc, #80]	@ (80124ec <HAL_RCCEx_GetPeriphCLKFreq+0xad4>)
 801249a:	637b      	str	r3, [r7, #52]	@ 0x34
 801249c:	e012      	b.n	80124c4 <HAL_RCCEx_GetPeriphCLKFreq+0xaac>
        else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART3CLKSOURCE_LSE))
 801249e:	4b11      	ldr	r3, [pc, #68]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 80124a0:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80124a4:	f003 0302 	and.w	r3, r3, #2
 80124a8:	2b02      	cmp	r3, #2
 80124aa:	d107      	bne.n	80124bc <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>
 80124ac:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80124ae:	f5b3 7fa0 	cmp.w	r3, #320	@ 0x140
 80124b2:	d103      	bne.n	80124bc <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>
          frequency = LSE_VALUE;
 80124b4:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80124b8:	637b      	str	r3, [r7, #52]	@ 0x34
 80124ba:	e003      	b.n	80124c4 <HAL_RCCEx_GetPeriphCLKFreq+0xaac>
          frequency = 0U;
 80124bc:	2300      	movs	r3, #0
 80124be:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80124c0:	f001 bdf5 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 80124c4:	f001 bdf3 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>

#if defined(UART4)
      case RCC_PERIPHCLK_UART4:
        /* Get the current UART4 source */
        srcclk = __HAL_RCC_GET_UART4_SOURCE();
 80124c8:	4b06      	ldr	r3, [pc, #24]	@ (80124e4 <HAL_RCCEx_GetPeriphCLKFreq+0xacc>)
 80124ca:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 80124ce:	f403 6360 	and.w	r3, r3, #3584	@ 0xe00
 80124d2:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_UART4CLKSOURCE_PCLK1)
 80124d4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80124d6:	2b00      	cmp	r3, #0
 80124d8:	d10a      	bne.n	80124f0 <HAL_RCCEx_GetPeriphCLKFreq+0xad8>
        {
          frequency = HAL_RCC_GetPCLK1Freq();
 80124da:	f7fc fe8d 	bl	800f1f8 <HAL_RCC_GetPCLK1Freq>
 80124de:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Clock not enabled for UART4 */
        else
        {
          frequency = 0U;
        }
        break;
 80124e0:	f001 bde5 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 80124e4:	44020c00 	.word	0x44020c00
 80124e8:	03d09000 	.word	0x03d09000
 80124ec:	003d0900 	.word	0x003d0900
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_UART4CLKSOURCE_PLL2Q))
 80124f0:	4ba0      	ldr	r3, [pc, #640]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 80124f2:	681b      	ldr	r3, [r3, #0]
 80124f4:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 80124f8:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 80124fc:	d10b      	bne.n	8012516 <HAL_RCCEx_GetPeriphCLKFreq+0xafe>
 80124fe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012500:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8012504:	d107      	bne.n	8012516 <HAL_RCCEx_GetPeriphCLKFreq+0xafe>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8012506:	f107 0314 	add.w	r3, r7, #20
 801250a:	4618      	mov	r0, r3
 801250c:	f7fe ffac 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8012510:	69bb      	ldr	r3, [r7, #24]
 8012512:	637b      	str	r3, [r7, #52]	@ 0x34
 8012514:	e047      	b.n	80125a6 <HAL_RCCEx_GetPeriphCLKFreq+0xb8e>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_UART4CLKSOURCE_PLL3Q))
 8012516:	4b97      	ldr	r3, [pc, #604]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 8012518:	681b      	ldr	r3, [r3, #0]
 801251a:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 801251e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8012522:	d10b      	bne.n	801253c <HAL_RCCEx_GetPeriphCLKFreq+0xb24>
 8012524:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012526:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 801252a:	d107      	bne.n	801253c <HAL_RCCEx_GetPeriphCLKFreq+0xb24>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 801252c:	f107 0308 	add.w	r3, r7, #8
 8012530:	4618      	mov	r0, r3
 8012532:	f7ff f905 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 8012536:	68fb      	ldr	r3, [r7, #12]
 8012538:	637b      	str	r3, [r7, #52]	@ 0x34
 801253a:	e034      	b.n	80125a6 <HAL_RCCEx_GetPeriphCLKFreq+0xb8e>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART4CLKSOURCE_HSI))
 801253c:	4b8d      	ldr	r3, [pc, #564]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 801253e:	681b      	ldr	r3, [r3, #0]
 8012540:	f003 0302 	and.w	r3, r3, #2
 8012544:	2b02      	cmp	r3, #2
 8012546:	d10d      	bne.n	8012564 <HAL_RCCEx_GetPeriphCLKFreq+0xb4c>
 8012548:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801254a:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
 801254e:	d109      	bne.n	8012564 <HAL_RCCEx_GetPeriphCLKFreq+0xb4c>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8012550:	4b88      	ldr	r3, [pc, #544]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 8012552:	681b      	ldr	r3, [r3, #0]
 8012554:	08db      	lsrs	r3, r3, #3
 8012556:	f003 0303 	and.w	r3, r3, #3
 801255a:	4a87      	ldr	r2, [pc, #540]	@ (8012778 <HAL_RCCEx_GetPeriphCLKFreq+0xd60>)
 801255c:	fa22 f303 	lsr.w	r3, r2, r3
 8012560:	637b      	str	r3, [r7, #52]	@ 0x34
 8012562:	e020      	b.n	80125a6 <HAL_RCCEx_GetPeriphCLKFreq+0xb8e>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_UART4CLKSOURCE_CSI))
 8012564:	4b83      	ldr	r3, [pc, #524]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 8012566:	681b      	ldr	r3, [r3, #0]
 8012568:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 801256c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8012570:	d106      	bne.n	8012580 <HAL_RCCEx_GetPeriphCLKFreq+0xb68>
 8012572:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012574:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8012578:	d102      	bne.n	8012580 <HAL_RCCEx_GetPeriphCLKFreq+0xb68>
          frequency = CSI_VALUE;
 801257a:	4b80      	ldr	r3, [pc, #512]	@ (801277c <HAL_RCCEx_GetPeriphCLKFreq+0xd64>)
 801257c:	637b      	str	r3, [r7, #52]	@ 0x34
 801257e:	e012      	b.n	80125a6 <HAL_RCCEx_GetPeriphCLKFreq+0xb8e>
        else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART4CLKSOURCE_LSE))
 8012580:	4b7c      	ldr	r3, [pc, #496]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 8012582:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8012586:	f003 0302 	and.w	r3, r3, #2
 801258a:	2b02      	cmp	r3, #2
 801258c:	d107      	bne.n	801259e <HAL_RCCEx_GetPeriphCLKFreq+0xb86>
 801258e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012590:	f5b3 6f20 	cmp.w	r3, #2560	@ 0xa00
 8012594:	d103      	bne.n	801259e <HAL_RCCEx_GetPeriphCLKFreq+0xb86>
          frequency = LSE_VALUE;
 8012596:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 801259a:	637b      	str	r3, [r7, #52]	@ 0x34
 801259c:	e003      	b.n	80125a6 <HAL_RCCEx_GetPeriphCLKFreq+0xb8e>
          frequency = 0U;
 801259e:	2300      	movs	r3, #0
 80125a0:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80125a2:	f001 bd84 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 80125a6:	f001 bd82 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* UART4 */

#if defined(UART5)
      case RCC_PERIPHCLK_UART5:
        /* Get the current UART5 source */
        srcclk = __HAL_RCC_GET_UART5_SOURCE();
 80125aa:	4b72      	ldr	r3, [pc, #456]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 80125ac:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 80125b0:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
 80125b4:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_UART5CLKSOURCE_PCLK1)
 80125b6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80125b8:	2b00      	cmp	r3, #0
 80125ba:	d104      	bne.n	80125c6 <HAL_RCCEx_GetPeriphCLKFreq+0xbae>
        {
          frequency = HAL_RCC_GetPCLK1Freq();
 80125bc:	f7fc fe1c 	bl	800f1f8 <HAL_RCC_GetPCLK1Freq>
 80125c0:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Clock not enabled for UART5 */
        else
        {
          frequency = 0U;
        }
        break;
 80125c2:	f001 bd74 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_UART5CLKSOURCE_PLL2Q))
 80125c6:	4b6b      	ldr	r3, [pc, #428]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 80125c8:	681b      	ldr	r3, [r3, #0]
 80125ca:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 80125ce:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 80125d2:	d10b      	bne.n	80125ec <HAL_RCCEx_GetPeriphCLKFreq+0xbd4>
 80125d4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80125d6:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 80125da:	d107      	bne.n	80125ec <HAL_RCCEx_GetPeriphCLKFreq+0xbd4>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 80125dc:	f107 0314 	add.w	r3, r7, #20
 80125e0:	4618      	mov	r0, r3
 80125e2:	f7fe ff41 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 80125e6:	69bb      	ldr	r3, [r7, #24]
 80125e8:	637b      	str	r3, [r7, #52]	@ 0x34
 80125ea:	e047      	b.n	801267c <HAL_RCCEx_GetPeriphCLKFreq+0xc64>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_UART5CLKSOURCE_PLL3Q))
 80125ec:	4b61      	ldr	r3, [pc, #388]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 80125ee:	681b      	ldr	r3, [r3, #0]
 80125f0:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 80125f4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 80125f8:	d10b      	bne.n	8012612 <HAL_RCCEx_GetPeriphCLKFreq+0xbfa>
 80125fa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80125fc:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8012600:	d107      	bne.n	8012612 <HAL_RCCEx_GetPeriphCLKFreq+0xbfa>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8012602:	f107 0308 	add.w	r3, r7, #8
 8012606:	4618      	mov	r0, r3
 8012608:	f7ff f89a 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 801260c:	68fb      	ldr	r3, [r7, #12]
 801260e:	637b      	str	r3, [r7, #52]	@ 0x34
 8012610:	e034      	b.n	801267c <HAL_RCCEx_GetPeriphCLKFreq+0xc64>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART5CLKSOURCE_HSI))
 8012612:	4b58      	ldr	r3, [pc, #352]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 8012614:	681b      	ldr	r3, [r3, #0]
 8012616:	f003 0302 	and.w	r3, r3, #2
 801261a:	2b02      	cmp	r3, #2
 801261c:	d10d      	bne.n	801263a <HAL_RCCEx_GetPeriphCLKFreq+0xc22>
 801261e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012620:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8012624:	d109      	bne.n	801263a <HAL_RCCEx_GetPeriphCLKFreq+0xc22>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8012626:	4b53      	ldr	r3, [pc, #332]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 8012628:	681b      	ldr	r3, [r3, #0]
 801262a:	08db      	lsrs	r3, r3, #3
 801262c:	f003 0303 	and.w	r3, r3, #3
 8012630:	4a51      	ldr	r2, [pc, #324]	@ (8012778 <HAL_RCCEx_GetPeriphCLKFreq+0xd60>)
 8012632:	fa22 f303 	lsr.w	r3, r2, r3
 8012636:	637b      	str	r3, [r7, #52]	@ 0x34
 8012638:	e020      	b.n	801267c <HAL_RCCEx_GetPeriphCLKFreq+0xc64>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_UART5CLKSOURCE_CSI))
 801263a:	4b4e      	ldr	r3, [pc, #312]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 801263c:	681b      	ldr	r3, [r3, #0]
 801263e:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8012642:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8012646:	d106      	bne.n	8012656 <HAL_RCCEx_GetPeriphCLKFreq+0xc3e>
 8012648:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801264a:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 801264e:	d102      	bne.n	8012656 <HAL_RCCEx_GetPeriphCLKFreq+0xc3e>
          frequency = CSI_VALUE;
 8012650:	4b4a      	ldr	r3, [pc, #296]	@ (801277c <HAL_RCCEx_GetPeriphCLKFreq+0xd64>)
 8012652:	637b      	str	r3, [r7, #52]	@ 0x34
 8012654:	e012      	b.n	801267c <HAL_RCCEx_GetPeriphCLKFreq+0xc64>
        else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART5CLKSOURCE_LSE))
 8012656:	4b47      	ldr	r3, [pc, #284]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 8012658:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 801265c:	f003 0302 	and.w	r3, r3, #2
 8012660:	2b02      	cmp	r3, #2
 8012662:	d107      	bne.n	8012674 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>
 8012664:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012666:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
 801266a:	d103      	bne.n	8012674 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>
          frequency = LSE_VALUE;
 801266c:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8012670:	637b      	str	r3, [r7, #52]	@ 0x34
 8012672:	e003      	b.n	801267c <HAL_RCCEx_GetPeriphCLKFreq+0xc64>
          frequency = 0U;
 8012674:	2300      	movs	r3, #0
 8012676:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012678:	f001 bd19 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 801267c:	f001 bd17 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* UART5 */

#if defined(USART6)
      case RCC_PERIPHCLK_USART6:
        /* Get the current USART6 source */
        srcclk = __HAL_RCC_GET_USART6_SOURCE();
 8012680:	4b3c      	ldr	r3, [pc, #240]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 8012682:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8012686:	f403 3360 	and.w	r3, r3, #229376	@ 0x38000
 801268a:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_USART6CLKSOURCE_PCLK1)
 801268c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801268e:	2b00      	cmp	r3, #0
 8012690:	d104      	bne.n	801269c <HAL_RCCEx_GetPeriphCLKFreq+0xc84>
        {
          frequency = HAL_RCC_GetPCLK1Freq();
 8012692:	f7fc fdb1 	bl	800f1f8 <HAL_RCC_GetPCLK1Freq>
 8012696:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Clock not enabled for USART6 */
        else
        {
          frequency = 0U;
        }
        break;
 8012698:	f001 bd09 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_USART6CLKSOURCE_PLL2Q))
 801269c:	4b35      	ldr	r3, [pc, #212]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 801269e:	681b      	ldr	r3, [r3, #0]
 80126a0:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 80126a4:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 80126a8:	d10b      	bne.n	80126c2 <HAL_RCCEx_GetPeriphCLKFreq+0xcaa>
 80126aa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80126ac:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 80126b0:	d107      	bne.n	80126c2 <HAL_RCCEx_GetPeriphCLKFreq+0xcaa>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 80126b2:	f107 0314 	add.w	r3, r7, #20
 80126b6:	4618      	mov	r0, r3
 80126b8:	f7fe fed6 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 80126bc:	69bb      	ldr	r3, [r7, #24]
 80126be:	637b      	str	r3, [r7, #52]	@ 0x34
 80126c0:	e047      	b.n	8012752 <HAL_RCCEx_GetPeriphCLKFreq+0xd3a>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_USART6CLKSOURCE_PLL3Q))
 80126c2:	4b2c      	ldr	r3, [pc, #176]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 80126c4:	681b      	ldr	r3, [r3, #0]
 80126c6:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 80126ca:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 80126ce:	d10b      	bne.n	80126e8 <HAL_RCCEx_GetPeriphCLKFreq+0xcd0>
 80126d0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80126d2:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 80126d6:	d107      	bne.n	80126e8 <HAL_RCCEx_GetPeriphCLKFreq+0xcd0>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 80126d8:	f107 0308 	add.w	r3, r7, #8
 80126dc:	4618      	mov	r0, r3
 80126de:	f7ff f82f 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 80126e2:	68fb      	ldr	r3, [r7, #12]
 80126e4:	637b      	str	r3, [r7, #52]	@ 0x34
 80126e6:	e034      	b.n	8012752 <HAL_RCCEx_GetPeriphCLKFreq+0xd3a>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART6CLKSOURCE_HSI))
 80126e8:	4b22      	ldr	r3, [pc, #136]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 80126ea:	681b      	ldr	r3, [r3, #0]
 80126ec:	f003 0302 	and.w	r3, r3, #2
 80126f0:	2b02      	cmp	r3, #2
 80126f2:	d10d      	bne.n	8012710 <HAL_RCCEx_GetPeriphCLKFreq+0xcf8>
 80126f4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80126f6:	f5b3 3fc0 	cmp.w	r3, #98304	@ 0x18000
 80126fa:	d109      	bne.n	8012710 <HAL_RCCEx_GetPeriphCLKFreq+0xcf8>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 80126fc:	4b1d      	ldr	r3, [pc, #116]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 80126fe:	681b      	ldr	r3, [r3, #0]
 8012700:	08db      	lsrs	r3, r3, #3
 8012702:	f003 0303 	and.w	r3, r3, #3
 8012706:	4a1c      	ldr	r2, [pc, #112]	@ (8012778 <HAL_RCCEx_GetPeriphCLKFreq+0xd60>)
 8012708:	fa22 f303 	lsr.w	r3, r2, r3
 801270c:	637b      	str	r3, [r7, #52]	@ 0x34
 801270e:	e020      	b.n	8012752 <HAL_RCCEx_GetPeriphCLKFreq+0xd3a>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_USART6CLKSOURCE_CSI))
 8012710:	4b18      	ldr	r3, [pc, #96]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 8012712:	681b      	ldr	r3, [r3, #0]
 8012714:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8012718:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 801271c:	d106      	bne.n	801272c <HAL_RCCEx_GetPeriphCLKFreq+0xd14>
 801271e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012720:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8012724:	d102      	bne.n	801272c <HAL_RCCEx_GetPeriphCLKFreq+0xd14>
          frequency = CSI_VALUE;
 8012726:	4b15      	ldr	r3, [pc, #84]	@ (801277c <HAL_RCCEx_GetPeriphCLKFreq+0xd64>)
 8012728:	637b      	str	r3, [r7, #52]	@ 0x34
 801272a:	e012      	b.n	8012752 <HAL_RCCEx_GetPeriphCLKFreq+0xd3a>
        else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART6CLKSOURCE_LSE))
 801272c:	4b11      	ldr	r3, [pc, #68]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 801272e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8012732:	f003 0302 	and.w	r3, r3, #2
 8012736:	2b02      	cmp	r3, #2
 8012738:	d107      	bne.n	801274a <HAL_RCCEx_GetPeriphCLKFreq+0xd32>
 801273a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801273c:	f5b3 3f20 	cmp.w	r3, #163840	@ 0x28000
 8012740:	d103      	bne.n	801274a <HAL_RCCEx_GetPeriphCLKFreq+0xd32>
          frequency = LSE_VALUE;
 8012742:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8012746:	637b      	str	r3, [r7, #52]	@ 0x34
 8012748:	e003      	b.n	8012752 <HAL_RCCEx_GetPeriphCLKFreq+0xd3a>
          frequency = 0U;
 801274a:	2300      	movs	r3, #0
 801274c:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 801274e:	f001 bcae 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8012752:	f001 bcac 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* USART6 */

#if defined(UART7)
      case RCC_PERIPHCLK_UART7:
        /* Get the current UART7 source */
        srcclk = __HAL_RCC_GET_UART7_SOURCE();
 8012756:	4b07      	ldr	r3, [pc, #28]	@ (8012774 <HAL_RCCEx_GetPeriphCLKFreq+0xd5c>)
 8012758:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801275c:	f403 13e0 	and.w	r3, r3, #1835008	@ 0x1c0000
 8012760:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_UART7CLKSOURCE_PCLK1)
 8012762:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012764:	2b00      	cmp	r3, #0
 8012766:	d10b      	bne.n	8012780 <HAL_RCCEx_GetPeriphCLKFreq+0xd68>
        {
          frequency = HAL_RCC_GetPCLK1Freq();
 8012768:	f7fc fd46 	bl	800f1f8 <HAL_RCC_GetPCLK1Freq>
 801276c:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Clock not enabled for UART7 */
        else
        {
          frequency = 0U;
        }
        break;
 801276e:	f001 bc9e 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8012772:	bf00      	nop
 8012774:	44020c00 	.word	0x44020c00
 8012778:	03d09000 	.word	0x03d09000
 801277c:	003d0900 	.word	0x003d0900
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_UART7CLKSOURCE_PLL2Q))
 8012780:	4ba0      	ldr	r3, [pc, #640]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 8012782:	681b      	ldr	r3, [r3, #0]
 8012784:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8012788:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 801278c:	d10b      	bne.n	80127a6 <HAL_RCCEx_GetPeriphCLKFreq+0xd8e>
 801278e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012790:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8012794:	d107      	bne.n	80127a6 <HAL_RCCEx_GetPeriphCLKFreq+0xd8e>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8012796:	f107 0314 	add.w	r3, r7, #20
 801279a:	4618      	mov	r0, r3
 801279c:	f7fe fe64 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 80127a0:	69bb      	ldr	r3, [r7, #24]
 80127a2:	637b      	str	r3, [r7, #52]	@ 0x34
 80127a4:	e047      	b.n	8012836 <HAL_RCCEx_GetPeriphCLKFreq+0xe1e>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_UART7CLKSOURCE_PLL3Q))
 80127a6:	4b97      	ldr	r3, [pc, #604]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 80127a8:	681b      	ldr	r3, [r3, #0]
 80127aa:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 80127ae:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 80127b2:	d10b      	bne.n	80127cc <HAL_RCCEx_GetPeriphCLKFreq+0xdb4>
 80127b4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80127b6:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 80127ba:	d107      	bne.n	80127cc <HAL_RCCEx_GetPeriphCLKFreq+0xdb4>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 80127bc:	f107 0308 	add.w	r3, r7, #8
 80127c0:	4618      	mov	r0, r3
 80127c2:	f7fe ffbd 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 80127c6:	68fb      	ldr	r3, [r7, #12]
 80127c8:	637b      	str	r3, [r7, #52]	@ 0x34
 80127ca:	e034      	b.n	8012836 <HAL_RCCEx_GetPeriphCLKFreq+0xe1e>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART7CLKSOURCE_HSI))
 80127cc:	4b8d      	ldr	r3, [pc, #564]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 80127ce:	681b      	ldr	r3, [r3, #0]
 80127d0:	f003 0302 	and.w	r3, r3, #2
 80127d4:	2b02      	cmp	r3, #2
 80127d6:	d10d      	bne.n	80127f4 <HAL_RCCEx_GetPeriphCLKFreq+0xddc>
 80127d8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80127da:	f5b3 2f40 	cmp.w	r3, #786432	@ 0xc0000
 80127de:	d109      	bne.n	80127f4 <HAL_RCCEx_GetPeriphCLKFreq+0xddc>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 80127e0:	4b88      	ldr	r3, [pc, #544]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 80127e2:	681b      	ldr	r3, [r3, #0]
 80127e4:	08db      	lsrs	r3, r3, #3
 80127e6:	f003 0303 	and.w	r3, r3, #3
 80127ea:	4a87      	ldr	r2, [pc, #540]	@ (8012a08 <HAL_RCCEx_GetPeriphCLKFreq+0xff0>)
 80127ec:	fa22 f303 	lsr.w	r3, r2, r3
 80127f0:	637b      	str	r3, [r7, #52]	@ 0x34
 80127f2:	e020      	b.n	8012836 <HAL_RCCEx_GetPeriphCLKFreq+0xe1e>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_UART7CLKSOURCE_CSI))
 80127f4:	4b83      	ldr	r3, [pc, #524]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 80127f6:	681b      	ldr	r3, [r3, #0]
 80127f8:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 80127fc:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8012800:	d106      	bne.n	8012810 <HAL_RCCEx_GetPeriphCLKFreq+0xdf8>
 8012802:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012804:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8012808:	d102      	bne.n	8012810 <HAL_RCCEx_GetPeriphCLKFreq+0xdf8>
          frequency = CSI_VALUE;
 801280a:	4b80      	ldr	r3, [pc, #512]	@ (8012a0c <HAL_RCCEx_GetPeriphCLKFreq+0xff4>)
 801280c:	637b      	str	r3, [r7, #52]	@ 0x34
 801280e:	e012      	b.n	8012836 <HAL_RCCEx_GetPeriphCLKFreq+0xe1e>
        else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART7CLKSOURCE_LSE))
 8012810:	4b7c      	ldr	r3, [pc, #496]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 8012812:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8012816:	f003 0302 	and.w	r3, r3, #2
 801281a:	2b02      	cmp	r3, #2
 801281c:	d107      	bne.n	801282e <HAL_RCCEx_GetPeriphCLKFreq+0xe16>
 801281e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012820:	f5b3 1fa0 	cmp.w	r3, #1310720	@ 0x140000
 8012824:	d103      	bne.n	801282e <HAL_RCCEx_GetPeriphCLKFreq+0xe16>
          frequency = LSE_VALUE;
 8012826:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 801282a:	637b      	str	r3, [r7, #52]	@ 0x34
 801282c:	e003      	b.n	8012836 <HAL_RCCEx_GetPeriphCLKFreq+0xe1e>
          frequency = 0U;
 801282e:	2300      	movs	r3, #0
 8012830:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012832:	f001 bc3c 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8012836:	f001 bc3a 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* UART7 */

#if defined(UART8)
      case RCC_PERIPHCLK_UART8:
        /* Get the current UART8 source */
        srcclk = __HAL_RCC_GET_UART8_SOURCE();
 801283a:	4b72      	ldr	r3, [pc, #456]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 801283c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8012840:	f403 0360 	and.w	r3, r3, #14680064	@ 0xe00000
 8012844:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_UART8CLKSOURCE_PCLK1)
 8012846:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012848:	2b00      	cmp	r3, #0
 801284a:	d104      	bne.n	8012856 <HAL_RCCEx_GetPeriphCLKFreq+0xe3e>
        {
          frequency = HAL_RCC_GetPCLK1Freq();
 801284c:	f7fc fcd4 	bl	800f1f8 <HAL_RCC_GetPCLK1Freq>
 8012850:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Clock not enabled for UART8 */
        else
        {
          frequency = 0U;
        }
        break;
 8012852:	f001 bc2c 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_UART8CLKSOURCE_PLL2Q))
 8012856:	4b6b      	ldr	r3, [pc, #428]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 8012858:	681b      	ldr	r3, [r3, #0]
 801285a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 801285e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8012862:	d10b      	bne.n	801287c <HAL_RCCEx_GetPeriphCLKFreq+0xe64>
 8012864:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012866:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 801286a:	d107      	bne.n	801287c <HAL_RCCEx_GetPeriphCLKFreq+0xe64>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 801286c:	f107 0314 	add.w	r3, r7, #20
 8012870:	4618      	mov	r0, r3
 8012872:	f7fe fdf9 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8012876:	69bb      	ldr	r3, [r7, #24]
 8012878:	637b      	str	r3, [r7, #52]	@ 0x34
 801287a:	e047      	b.n	801290c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_UART8CLKSOURCE_PLL3Q))
 801287c:	4b61      	ldr	r3, [pc, #388]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 801287e:	681b      	ldr	r3, [r3, #0]
 8012880:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8012884:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8012888:	d10b      	bne.n	80128a2 <HAL_RCCEx_GetPeriphCLKFreq+0xe8a>
 801288a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801288c:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8012890:	d107      	bne.n	80128a2 <HAL_RCCEx_GetPeriphCLKFreq+0xe8a>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8012892:	f107 0308 	add.w	r3, r7, #8
 8012896:	4618      	mov	r0, r3
 8012898:	f7fe ff52 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 801289c:	68fb      	ldr	r3, [r7, #12]
 801289e:	637b      	str	r3, [r7, #52]	@ 0x34
 80128a0:	e034      	b.n	801290c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART8CLKSOURCE_HSI))
 80128a2:	4b58      	ldr	r3, [pc, #352]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 80128a4:	681b      	ldr	r3, [r3, #0]
 80128a6:	f003 0302 	and.w	r3, r3, #2
 80128aa:	2b02      	cmp	r3, #2
 80128ac:	d10d      	bne.n	80128ca <HAL_RCCEx_GetPeriphCLKFreq+0xeb2>
 80128ae:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80128b0:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
 80128b4:	d109      	bne.n	80128ca <HAL_RCCEx_GetPeriphCLKFreq+0xeb2>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 80128b6:	4b53      	ldr	r3, [pc, #332]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 80128b8:	681b      	ldr	r3, [r3, #0]
 80128ba:	08db      	lsrs	r3, r3, #3
 80128bc:	f003 0303 	and.w	r3, r3, #3
 80128c0:	4a51      	ldr	r2, [pc, #324]	@ (8012a08 <HAL_RCCEx_GetPeriphCLKFreq+0xff0>)
 80128c2:	fa22 f303 	lsr.w	r3, r2, r3
 80128c6:	637b      	str	r3, [r7, #52]	@ 0x34
 80128c8:	e020      	b.n	801290c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_UART8CLKSOURCE_CSI))
 80128ca:	4b4e      	ldr	r3, [pc, #312]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 80128cc:	681b      	ldr	r3, [r3, #0]
 80128ce:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 80128d2:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80128d6:	d106      	bne.n	80128e6 <HAL_RCCEx_GetPeriphCLKFreq+0xece>
 80128d8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80128da:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 80128de:	d102      	bne.n	80128e6 <HAL_RCCEx_GetPeriphCLKFreq+0xece>
          frequency = CSI_VALUE;
 80128e0:	4b4a      	ldr	r3, [pc, #296]	@ (8012a0c <HAL_RCCEx_GetPeriphCLKFreq+0xff4>)
 80128e2:	637b      	str	r3, [r7, #52]	@ 0x34
 80128e4:	e012      	b.n	801290c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>
        else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART8CLKSOURCE_LSE))
 80128e6:	4b47      	ldr	r3, [pc, #284]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 80128e8:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80128ec:	f003 0302 	and.w	r3, r3, #2
 80128f0:	2b02      	cmp	r3, #2
 80128f2:	d107      	bne.n	8012904 <HAL_RCCEx_GetPeriphCLKFreq+0xeec>
 80128f4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80128f6:	f5b3 0f20 	cmp.w	r3, #10485760	@ 0xa00000
 80128fa:	d103      	bne.n	8012904 <HAL_RCCEx_GetPeriphCLKFreq+0xeec>
          frequency = LSE_VALUE;
 80128fc:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8012900:	637b      	str	r3, [r7, #52]	@ 0x34
 8012902:	e003      	b.n	801290c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>
          frequency = 0U;
 8012904:	2300      	movs	r3, #0
 8012906:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012908:	f001 bbd1 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 801290c:	f001 bbcf 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* UART8 */

#if defined(UART9)
      case RCC_PERIPHCLK_UART9:
        /* Get the current UART9 source */
        srcclk = __HAL_RCC_GET_UART9_SOURCE();
 8012910:	4b3c      	ldr	r3, [pc, #240]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 8012912:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8012916:	f003 63e0 	and.w	r3, r3, #117440512	@ 0x7000000
 801291a:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_UART9CLKSOURCE_PCLK1)
 801291c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801291e:	2b00      	cmp	r3, #0
 8012920:	d104      	bne.n	801292c <HAL_RCCEx_GetPeriphCLKFreq+0xf14>
        {
          frequency = HAL_RCC_GetPCLK1Freq();
 8012922:	f7fc fc69 	bl	800f1f8 <HAL_RCC_GetPCLK1Freq>
 8012926:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Clock not enabled for UART9 */
        else
        {
          frequency = 0U;
        }
        break;
 8012928:	f001 bbc1 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_UART9CLKSOURCE_PLL2Q))
 801292c:	4b35      	ldr	r3, [pc, #212]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 801292e:	681b      	ldr	r3, [r3, #0]
 8012930:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8012934:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8012938:	d10b      	bne.n	8012952 <HAL_RCCEx_GetPeriphCLKFreq+0xf3a>
 801293a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801293c:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8012940:	d107      	bne.n	8012952 <HAL_RCCEx_GetPeriphCLKFreq+0xf3a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8012942:	f107 0314 	add.w	r3, r7, #20
 8012946:	4618      	mov	r0, r3
 8012948:	f7fe fd8e 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 801294c:	69bb      	ldr	r3, [r7, #24]
 801294e:	637b      	str	r3, [r7, #52]	@ 0x34
 8012950:	e047      	b.n	80129e2 <HAL_RCCEx_GetPeriphCLKFreq+0xfca>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_UART9CLKSOURCE_PLL3Q))
 8012952:	4b2c      	ldr	r3, [pc, #176]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 8012954:	681b      	ldr	r3, [r3, #0]
 8012956:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 801295a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 801295e:	d10b      	bne.n	8012978 <HAL_RCCEx_GetPeriphCLKFreq+0xf60>
 8012960:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012962:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8012966:	d107      	bne.n	8012978 <HAL_RCCEx_GetPeriphCLKFreq+0xf60>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8012968:	f107 0308 	add.w	r3, r7, #8
 801296c:	4618      	mov	r0, r3
 801296e:	f7fe fee7 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 8012972:	68fb      	ldr	r3, [r7, #12]
 8012974:	637b      	str	r3, [r7, #52]	@ 0x34
 8012976:	e034      	b.n	80129e2 <HAL_RCCEx_GetPeriphCLKFreq+0xfca>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART9CLKSOURCE_HSI))
 8012978:	4b22      	ldr	r3, [pc, #136]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 801297a:	681b      	ldr	r3, [r3, #0]
 801297c:	f003 0302 	and.w	r3, r3, #2
 8012980:	2b02      	cmp	r3, #2
 8012982:	d10d      	bne.n	80129a0 <HAL_RCCEx_GetPeriphCLKFreq+0xf88>
 8012984:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012986:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 801298a:	d109      	bne.n	80129a0 <HAL_RCCEx_GetPeriphCLKFreq+0xf88>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 801298c:	4b1d      	ldr	r3, [pc, #116]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 801298e:	681b      	ldr	r3, [r3, #0]
 8012990:	08db      	lsrs	r3, r3, #3
 8012992:	f003 0303 	and.w	r3, r3, #3
 8012996:	4a1c      	ldr	r2, [pc, #112]	@ (8012a08 <HAL_RCCEx_GetPeriphCLKFreq+0xff0>)
 8012998:	fa22 f303 	lsr.w	r3, r2, r3
 801299c:	637b      	str	r3, [r7, #52]	@ 0x34
 801299e:	e020      	b.n	80129e2 <HAL_RCCEx_GetPeriphCLKFreq+0xfca>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_UART9CLKSOURCE_CSI))
 80129a0:	4b18      	ldr	r3, [pc, #96]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 80129a2:	681b      	ldr	r3, [r3, #0]
 80129a4:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 80129a8:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80129ac:	d106      	bne.n	80129bc <HAL_RCCEx_GetPeriphCLKFreq+0xfa4>
 80129ae:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80129b0:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 80129b4:	d102      	bne.n	80129bc <HAL_RCCEx_GetPeriphCLKFreq+0xfa4>
          frequency = CSI_VALUE;
 80129b6:	4b15      	ldr	r3, [pc, #84]	@ (8012a0c <HAL_RCCEx_GetPeriphCLKFreq+0xff4>)
 80129b8:	637b      	str	r3, [r7, #52]	@ 0x34
 80129ba:	e012      	b.n	80129e2 <HAL_RCCEx_GetPeriphCLKFreq+0xfca>
        else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART9CLKSOURCE_LSE))
 80129bc:	4b11      	ldr	r3, [pc, #68]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 80129be:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80129c2:	f003 0302 	and.w	r3, r3, #2
 80129c6:	2b02      	cmp	r3, #2
 80129c8:	d107      	bne.n	80129da <HAL_RCCEx_GetPeriphCLKFreq+0xfc2>
 80129ca:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80129cc:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
 80129d0:	d103      	bne.n	80129da <HAL_RCCEx_GetPeriphCLKFreq+0xfc2>
          frequency = LSE_VALUE;
 80129d2:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80129d6:	637b      	str	r3, [r7, #52]	@ 0x34
 80129d8:	e003      	b.n	80129e2 <HAL_RCCEx_GetPeriphCLKFreq+0xfca>
          frequency = 0U;
 80129da:	2300      	movs	r3, #0
 80129dc:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80129de:	f001 bb66 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 80129e2:	f001 bb64 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* UART9 */

#if defined(USART10)
      case RCC_PERIPHCLK_USART10:
        /* Get the current USART10 source */
        srcclk = __HAL_RCC_GET_USART10_SOURCE();
 80129e6:	4b07      	ldr	r3, [pc, #28]	@ (8012a04 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 80129e8:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 80129ec:	f003 5360 	and.w	r3, r3, #939524096	@ 0x38000000
 80129f0:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_USART10CLKSOURCE_PCLK1)
 80129f2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80129f4:	2b00      	cmp	r3, #0
 80129f6:	d10b      	bne.n	8012a10 <HAL_RCCEx_GetPeriphCLKFreq+0xff8>
        {
          frequency = HAL_RCC_GetPCLK1Freq();
 80129f8:	f7fc fbfe 	bl	800f1f8 <HAL_RCC_GetPCLK1Freq>
 80129fc:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Clock not enabled for USART10 */
        else
        {
          frequency = 0U;
        }
        break;
 80129fe:	f001 bb56 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8012a02:	bf00      	nop
 8012a04:	44020c00 	.word	0x44020c00
 8012a08:	03d09000 	.word	0x03d09000
 8012a0c:	003d0900 	.word	0x003d0900
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_USART10CLKSOURCE_PLL2Q))
 8012a10:	4ba1      	ldr	r3, [pc, #644]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012a12:	681b      	ldr	r3, [r3, #0]
 8012a14:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8012a18:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8012a1c:	d10b      	bne.n	8012a36 <HAL_RCCEx_GetPeriphCLKFreq+0x101e>
 8012a1e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012a20:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8012a24:	d107      	bne.n	8012a36 <HAL_RCCEx_GetPeriphCLKFreq+0x101e>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8012a26:	f107 0314 	add.w	r3, r7, #20
 8012a2a:	4618      	mov	r0, r3
 8012a2c:	f7fe fd1c 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8012a30:	69bb      	ldr	r3, [r7, #24]
 8012a32:	637b      	str	r3, [r7, #52]	@ 0x34
 8012a34:	e047      	b.n	8012ac6 <HAL_RCCEx_GetPeriphCLKFreq+0x10ae>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_USART10CLKSOURCE_PLL3Q))
 8012a36:	4b98      	ldr	r3, [pc, #608]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012a38:	681b      	ldr	r3, [r3, #0]
 8012a3a:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8012a3e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8012a42:	d10b      	bne.n	8012a5c <HAL_RCCEx_GetPeriphCLKFreq+0x1044>
 8012a44:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012a46:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8012a4a:	d107      	bne.n	8012a5c <HAL_RCCEx_GetPeriphCLKFreq+0x1044>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8012a4c:	f107 0308 	add.w	r3, r7, #8
 8012a50:	4618      	mov	r0, r3
 8012a52:	f7fe fe75 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 8012a56:	68fb      	ldr	r3, [r7, #12]
 8012a58:	637b      	str	r3, [r7, #52]	@ 0x34
 8012a5a:	e034      	b.n	8012ac6 <HAL_RCCEx_GetPeriphCLKFreq+0x10ae>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART10CLKSOURCE_HSI))
 8012a5c:	4b8e      	ldr	r3, [pc, #568]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012a5e:	681b      	ldr	r3, [r3, #0]
 8012a60:	f003 0302 	and.w	r3, r3, #2
 8012a64:	2b02      	cmp	r3, #2
 8012a66:	d10d      	bne.n	8012a84 <HAL_RCCEx_GetPeriphCLKFreq+0x106c>
 8012a68:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012a6a:	f1b3 5fc0 	cmp.w	r3, #402653184	@ 0x18000000
 8012a6e:	d109      	bne.n	8012a84 <HAL_RCCEx_GetPeriphCLKFreq+0x106c>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8012a70:	4b89      	ldr	r3, [pc, #548]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012a72:	681b      	ldr	r3, [r3, #0]
 8012a74:	08db      	lsrs	r3, r3, #3
 8012a76:	f003 0303 	and.w	r3, r3, #3
 8012a7a:	4a88      	ldr	r2, [pc, #544]	@ (8012c9c <HAL_RCCEx_GetPeriphCLKFreq+0x1284>)
 8012a7c:	fa22 f303 	lsr.w	r3, r2, r3
 8012a80:	637b      	str	r3, [r7, #52]	@ 0x34
 8012a82:	e020      	b.n	8012ac6 <HAL_RCCEx_GetPeriphCLKFreq+0x10ae>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_USART10CLKSOURCE_CSI))
 8012a84:	4b84      	ldr	r3, [pc, #528]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012a86:	681b      	ldr	r3, [r3, #0]
 8012a88:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8012a8c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8012a90:	d106      	bne.n	8012aa0 <HAL_RCCEx_GetPeriphCLKFreq+0x1088>
 8012a92:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012a94:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8012a98:	d102      	bne.n	8012aa0 <HAL_RCCEx_GetPeriphCLKFreq+0x1088>
          frequency = CSI_VALUE;
 8012a9a:	4b81      	ldr	r3, [pc, #516]	@ (8012ca0 <HAL_RCCEx_GetPeriphCLKFreq+0x1288>)
 8012a9c:	637b      	str	r3, [r7, #52]	@ 0x34
 8012a9e:	e012      	b.n	8012ac6 <HAL_RCCEx_GetPeriphCLKFreq+0x10ae>
        else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART10CLKSOURCE_LSE))
 8012aa0:	4b7d      	ldr	r3, [pc, #500]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012aa2:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8012aa6:	f003 0302 	and.w	r3, r3, #2
 8012aaa:	2b02      	cmp	r3, #2
 8012aac:	d107      	bne.n	8012abe <HAL_RCCEx_GetPeriphCLKFreq+0x10a6>
 8012aae:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012ab0:	f1b3 5f20 	cmp.w	r3, #671088640	@ 0x28000000
 8012ab4:	d103      	bne.n	8012abe <HAL_RCCEx_GetPeriphCLKFreq+0x10a6>
          frequency = LSE_VALUE;
 8012ab6:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8012aba:	637b      	str	r3, [r7, #52]	@ 0x34
 8012abc:	e003      	b.n	8012ac6 <HAL_RCCEx_GetPeriphCLKFreq+0x10ae>
          frequency = 0U;
 8012abe:	2300      	movs	r3, #0
 8012ac0:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012ac2:	f001 baf4 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8012ac6:	f001 baf2 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* USART10 */

#if defined(USART11)
      case RCC_PERIPHCLK_USART11:
        /* Get the current USART11 source */
        srcclk = __HAL_RCC_GET_USART11_SOURCE();
 8012aca:	4b73      	ldr	r3, [pc, #460]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012acc:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 8012ad0:	f003 0307 	and.w	r3, r3, #7
 8012ad4:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_USART11CLKSOURCE_PCLK1)
 8012ad6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012ad8:	2b00      	cmp	r3, #0
 8012ada:	d104      	bne.n	8012ae6 <HAL_RCCEx_GetPeriphCLKFreq+0x10ce>
        {
          frequency = HAL_RCC_GetPCLK1Freq();
 8012adc:	f7fc fb8c 	bl	800f1f8 <HAL_RCC_GetPCLK1Freq>
 8012ae0:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Clock not enabled for USART11 */
        else
        {
          frequency = 0U;
        }
        break;
 8012ae2:	f001 bae4 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_USART11CLKSOURCE_PLL2Q))
 8012ae6:	4b6c      	ldr	r3, [pc, #432]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012ae8:	681b      	ldr	r3, [r3, #0]
 8012aea:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8012aee:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8012af2:	d10a      	bne.n	8012b0a <HAL_RCCEx_GetPeriphCLKFreq+0x10f2>
 8012af4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012af6:	2b01      	cmp	r3, #1
 8012af8:	d107      	bne.n	8012b0a <HAL_RCCEx_GetPeriphCLKFreq+0x10f2>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8012afa:	f107 0314 	add.w	r3, r7, #20
 8012afe:	4618      	mov	r0, r3
 8012b00:	f7fe fcb2 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8012b04:	69bb      	ldr	r3, [r7, #24]
 8012b06:	637b      	str	r3, [r7, #52]	@ 0x34
 8012b08:	e043      	b.n	8012b92 <HAL_RCCEx_GetPeriphCLKFreq+0x117a>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_USART11CLKSOURCE_PLL3Q))
 8012b0a:	4b63      	ldr	r3, [pc, #396]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012b0c:	681b      	ldr	r3, [r3, #0]
 8012b0e:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8012b12:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8012b16:	d10a      	bne.n	8012b2e <HAL_RCCEx_GetPeriphCLKFreq+0x1116>
 8012b18:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012b1a:	2b02      	cmp	r3, #2
 8012b1c:	d107      	bne.n	8012b2e <HAL_RCCEx_GetPeriphCLKFreq+0x1116>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8012b1e:	f107 0308 	add.w	r3, r7, #8
 8012b22:	4618      	mov	r0, r3
 8012b24:	f7fe fe0c 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 8012b28:	68fb      	ldr	r3, [r7, #12]
 8012b2a:	637b      	str	r3, [r7, #52]	@ 0x34
 8012b2c:	e031      	b.n	8012b92 <HAL_RCCEx_GetPeriphCLKFreq+0x117a>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART11CLKSOURCE_HSI))
 8012b2e:	4b5a      	ldr	r3, [pc, #360]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012b30:	681b      	ldr	r3, [r3, #0]
 8012b32:	f003 0302 	and.w	r3, r3, #2
 8012b36:	2b02      	cmp	r3, #2
 8012b38:	d10c      	bne.n	8012b54 <HAL_RCCEx_GetPeriphCLKFreq+0x113c>
 8012b3a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012b3c:	2b03      	cmp	r3, #3
 8012b3e:	d109      	bne.n	8012b54 <HAL_RCCEx_GetPeriphCLKFreq+0x113c>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8012b40:	4b55      	ldr	r3, [pc, #340]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012b42:	681b      	ldr	r3, [r3, #0]
 8012b44:	08db      	lsrs	r3, r3, #3
 8012b46:	f003 0303 	and.w	r3, r3, #3
 8012b4a:	4a54      	ldr	r2, [pc, #336]	@ (8012c9c <HAL_RCCEx_GetPeriphCLKFreq+0x1284>)
 8012b4c:	fa22 f303 	lsr.w	r3, r2, r3
 8012b50:	637b      	str	r3, [r7, #52]	@ 0x34
 8012b52:	e01e      	b.n	8012b92 <HAL_RCCEx_GetPeriphCLKFreq+0x117a>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_USART11CLKSOURCE_CSI))
 8012b54:	4b50      	ldr	r3, [pc, #320]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012b56:	681b      	ldr	r3, [r3, #0]
 8012b58:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8012b5c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8012b60:	d105      	bne.n	8012b6e <HAL_RCCEx_GetPeriphCLKFreq+0x1156>
 8012b62:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012b64:	2b04      	cmp	r3, #4
 8012b66:	d102      	bne.n	8012b6e <HAL_RCCEx_GetPeriphCLKFreq+0x1156>
          frequency = CSI_VALUE;
 8012b68:	4b4d      	ldr	r3, [pc, #308]	@ (8012ca0 <HAL_RCCEx_GetPeriphCLKFreq+0x1288>)
 8012b6a:	637b      	str	r3, [r7, #52]	@ 0x34
 8012b6c:	e011      	b.n	8012b92 <HAL_RCCEx_GetPeriphCLKFreq+0x117a>
        else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART11CLKSOURCE_LSE))
 8012b6e:	4b4a      	ldr	r3, [pc, #296]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012b70:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8012b74:	f003 0302 	and.w	r3, r3, #2
 8012b78:	2b02      	cmp	r3, #2
 8012b7a:	d106      	bne.n	8012b8a <HAL_RCCEx_GetPeriphCLKFreq+0x1172>
 8012b7c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012b7e:	2b05      	cmp	r3, #5
 8012b80:	d103      	bne.n	8012b8a <HAL_RCCEx_GetPeriphCLKFreq+0x1172>
          frequency = LSE_VALUE;
 8012b82:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8012b86:	637b      	str	r3, [r7, #52]	@ 0x34
 8012b88:	e003      	b.n	8012b92 <HAL_RCCEx_GetPeriphCLKFreq+0x117a>
          frequency = 0U;
 8012b8a:	2300      	movs	r3, #0
 8012b8c:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012b8e:	f001 ba8e 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8012b92:	f001 ba8c 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* USART11 */

#if defined(UART12)
      case RCC_PERIPHCLK_UART12:
        /* Get the current UART12 source */
        srcclk = __HAL_RCC_GET_UART12_SOURCE();
 8012b96:	4b40      	ldr	r3, [pc, #256]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012b98:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 8012b9c:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8012ba0:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_UART12CLKSOURCE_PCLK1)
 8012ba2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012ba4:	2b00      	cmp	r3, #0
 8012ba6:	d104      	bne.n	8012bb2 <HAL_RCCEx_GetPeriphCLKFreq+0x119a>
        {
          frequency = HAL_RCC_GetPCLK1Freq();
 8012ba8:	f7fc fb26 	bl	800f1f8 <HAL_RCC_GetPCLK1Freq>
 8012bac:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Clock not enabled for UART12 */
        else
        {
          frequency = 0U;
        }
        break;
 8012bae:	f001 ba7e 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_UART12CLKSOURCE_PLL2Q))
 8012bb2:	4b39      	ldr	r3, [pc, #228]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012bb4:	681b      	ldr	r3, [r3, #0]
 8012bb6:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8012bba:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8012bbe:	d10a      	bne.n	8012bd6 <HAL_RCCEx_GetPeriphCLKFreq+0x11be>
 8012bc0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012bc2:	2b10      	cmp	r3, #16
 8012bc4:	d107      	bne.n	8012bd6 <HAL_RCCEx_GetPeriphCLKFreq+0x11be>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8012bc6:	f107 0314 	add.w	r3, r7, #20
 8012bca:	4618      	mov	r0, r3
 8012bcc:	f7fe fc4c 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8012bd0:	69bb      	ldr	r3, [r7, #24]
 8012bd2:	637b      	str	r3, [r7, #52]	@ 0x34
 8012bd4:	e043      	b.n	8012c5e <HAL_RCCEx_GetPeriphCLKFreq+0x1246>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_UART12CLKSOURCE_PLL3Q))
 8012bd6:	4b30      	ldr	r3, [pc, #192]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012bd8:	681b      	ldr	r3, [r3, #0]
 8012bda:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8012bde:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8012be2:	d10a      	bne.n	8012bfa <HAL_RCCEx_GetPeriphCLKFreq+0x11e2>
 8012be4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012be6:	2b20      	cmp	r3, #32
 8012be8:	d107      	bne.n	8012bfa <HAL_RCCEx_GetPeriphCLKFreq+0x11e2>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8012bea:	f107 0308 	add.w	r3, r7, #8
 8012bee:	4618      	mov	r0, r3
 8012bf0:	f7fe fda6 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 8012bf4:	68fb      	ldr	r3, [r7, #12]
 8012bf6:	637b      	str	r3, [r7, #52]	@ 0x34
 8012bf8:	e031      	b.n	8012c5e <HAL_RCCEx_GetPeriphCLKFreq+0x1246>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART12CLKSOURCE_HSI))
 8012bfa:	4b27      	ldr	r3, [pc, #156]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012bfc:	681b      	ldr	r3, [r3, #0]
 8012bfe:	f003 0302 	and.w	r3, r3, #2
 8012c02:	2b02      	cmp	r3, #2
 8012c04:	d10c      	bne.n	8012c20 <HAL_RCCEx_GetPeriphCLKFreq+0x1208>
 8012c06:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012c08:	2b30      	cmp	r3, #48	@ 0x30
 8012c0a:	d109      	bne.n	8012c20 <HAL_RCCEx_GetPeriphCLKFreq+0x1208>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8012c0c:	4b22      	ldr	r3, [pc, #136]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012c0e:	681b      	ldr	r3, [r3, #0]
 8012c10:	08db      	lsrs	r3, r3, #3
 8012c12:	f003 0303 	and.w	r3, r3, #3
 8012c16:	4a21      	ldr	r2, [pc, #132]	@ (8012c9c <HAL_RCCEx_GetPeriphCLKFreq+0x1284>)
 8012c18:	fa22 f303 	lsr.w	r3, r2, r3
 8012c1c:	637b      	str	r3, [r7, #52]	@ 0x34
 8012c1e:	e01e      	b.n	8012c5e <HAL_RCCEx_GetPeriphCLKFreq+0x1246>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_UART12CLKSOURCE_CSI))
 8012c20:	4b1d      	ldr	r3, [pc, #116]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012c22:	681b      	ldr	r3, [r3, #0]
 8012c24:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8012c28:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8012c2c:	d105      	bne.n	8012c3a <HAL_RCCEx_GetPeriphCLKFreq+0x1222>
 8012c2e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012c30:	2b40      	cmp	r3, #64	@ 0x40
 8012c32:	d102      	bne.n	8012c3a <HAL_RCCEx_GetPeriphCLKFreq+0x1222>
          frequency = CSI_VALUE;
 8012c34:	4b1a      	ldr	r3, [pc, #104]	@ (8012ca0 <HAL_RCCEx_GetPeriphCLKFreq+0x1288>)
 8012c36:	637b      	str	r3, [r7, #52]	@ 0x34
 8012c38:	e011      	b.n	8012c5e <HAL_RCCEx_GetPeriphCLKFreq+0x1246>
        else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART12CLKSOURCE_LSE))
 8012c3a:	4b17      	ldr	r3, [pc, #92]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012c3c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8012c40:	f003 0302 	and.w	r3, r3, #2
 8012c44:	2b02      	cmp	r3, #2
 8012c46:	d106      	bne.n	8012c56 <HAL_RCCEx_GetPeriphCLKFreq+0x123e>
 8012c48:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012c4a:	2b50      	cmp	r3, #80	@ 0x50
 8012c4c:	d103      	bne.n	8012c56 <HAL_RCCEx_GetPeriphCLKFreq+0x123e>
          frequency = LSE_VALUE;
 8012c4e:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8012c52:	637b      	str	r3, [r7, #52]	@ 0x34
 8012c54:	e003      	b.n	8012c5e <HAL_RCCEx_GetPeriphCLKFreq+0x1246>
          frequency = 0U;
 8012c56:	2300      	movs	r3, #0
 8012c58:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012c5a:	f001 ba28 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8012c5e:	f001 ba26 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* UART12 */

      case RCC_PERIPHCLK_LPUART1:
        /* Get the current LPUART1 source */
        srcclk = __HAL_RCC_GET_LPUART1_SOURCE();
 8012c62:	4b0d      	ldr	r3, [pc, #52]	@ (8012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 8012c64:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8012c68:	f003 63e0 	and.w	r3, r3, #117440512	@ 0x7000000
 8012c6c:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_LPUART1CLKSOURCE_PCLK3)
 8012c6e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012c70:	2b00      	cmp	r3, #0
 8012c72:	d104      	bne.n	8012c7e <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
        {
          frequency = HAL_RCC_GetPCLK3Freq();
 8012c74:	f7fc faec 	bl	800f250 <HAL_RCC_GetPCLK3Freq>
 8012c78:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Clock not enabled for LPUART1 */
        else
        {
          frequency = 0U;
        }
        break;
 8012c7a:	f001 ba18 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if (srcclk == RCC_LPUART1CLKSOURCE_PLL2Q)
 8012c7e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012c80:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8012c84:	d10e      	bne.n	8012ca4 <HAL_RCCEx_GetPeriphCLKFreq+0x128c>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8012c86:	f107 0314 	add.w	r3, r7, #20
 8012c8a:	4618      	mov	r0, r3
 8012c8c:	f7fe fbec 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8012c90:	69bb      	ldr	r3, [r7, #24]
 8012c92:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012c94:	f001 ba0b 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8012c98:	44020c00 	.word	0x44020c00
 8012c9c:	03d09000 	.word	0x03d09000
 8012ca0:	003d0900 	.word	0x003d0900
        else if (srcclk == RCC_LPUART1CLKSOURCE_PLL3Q)
 8012ca4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012ca6:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8012caa:	d108      	bne.n	8012cbe <HAL_RCCEx_GetPeriphCLKFreq+0x12a6>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8012cac:	f107 0308 	add.w	r3, r7, #8
 8012cb0:	4618      	mov	r0, r3
 8012cb2:	f7fe fd45 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 8012cb6:	68fb      	ldr	r3, [r7, #12]
 8012cb8:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012cba:	f001 b9f8 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPUART1CLKSOURCE_HSI))
 8012cbe:	4ba4      	ldr	r3, [pc, #656]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012cc0:	681b      	ldr	r3, [r3, #0]
 8012cc2:	f003 0302 	and.w	r3, r3, #2
 8012cc6:	2b02      	cmp	r3, #2
 8012cc8:	d10d      	bne.n	8012ce6 <HAL_RCCEx_GetPeriphCLKFreq+0x12ce>
 8012cca:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012ccc:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 8012cd0:	d109      	bne.n	8012ce6 <HAL_RCCEx_GetPeriphCLKFreq+0x12ce>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8012cd2:	4b9f      	ldr	r3, [pc, #636]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012cd4:	681b      	ldr	r3, [r3, #0]
 8012cd6:	08db      	lsrs	r3, r3, #3
 8012cd8:	f003 0303 	and.w	r3, r3, #3
 8012cdc:	4a9d      	ldr	r2, [pc, #628]	@ (8012f54 <HAL_RCCEx_GetPeriphCLKFreq+0x153c>)
 8012cde:	fa22 f303 	lsr.w	r3, r2, r3
 8012ce2:	637b      	str	r3, [r7, #52]	@ 0x34
 8012ce4:	e020      	b.n	8012d28 <HAL_RCCEx_GetPeriphCLKFreq+0x1310>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_LPUART1CLKSOURCE_CSI))
 8012ce6:	4b9a      	ldr	r3, [pc, #616]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012ce8:	681b      	ldr	r3, [r3, #0]
 8012cea:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8012cee:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8012cf2:	d106      	bne.n	8012d02 <HAL_RCCEx_GetPeriphCLKFreq+0x12ea>
 8012cf4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012cf6:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 8012cfa:	d102      	bne.n	8012d02 <HAL_RCCEx_GetPeriphCLKFreq+0x12ea>
          frequency = CSI_VALUE;
 8012cfc:	4b96      	ldr	r3, [pc, #600]	@ (8012f58 <HAL_RCCEx_GetPeriphCLKFreq+0x1540>)
 8012cfe:	637b      	str	r3, [r7, #52]	@ 0x34
 8012d00:	e012      	b.n	8012d28 <HAL_RCCEx_GetPeriphCLKFreq+0x1310>
        else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPUART1CLKSOURCE_LSE))
 8012d02:	4b93      	ldr	r3, [pc, #588]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012d04:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8012d08:	f003 0302 	and.w	r3, r3, #2
 8012d0c:	2b02      	cmp	r3, #2
 8012d0e:	d107      	bne.n	8012d20 <HAL_RCCEx_GetPeriphCLKFreq+0x1308>
 8012d10:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012d12:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
 8012d16:	d103      	bne.n	8012d20 <HAL_RCCEx_GetPeriphCLKFreq+0x1308>
          frequency = LSE_VALUE;
 8012d18:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8012d1c:	637b      	str	r3, [r7, #52]	@ 0x34
 8012d1e:	e003      	b.n	8012d28 <HAL_RCCEx_GetPeriphCLKFreq+0x1310>
          frequency = 0U;
 8012d20:	2300      	movs	r3, #0
 8012d22:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012d24:	f001 b9c3 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8012d28:	f001 b9c1 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>

      case RCC_PERIPHCLK_ADCDAC:
        /* Get the current ADCDAC source */
        srcclk = __HAL_RCC_GET_ADCDAC_SOURCE();
 8012d2c:	4b88      	ldr	r3, [pc, #544]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012d2e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8012d32:	f003 0307 	and.w	r3, r3, #7
 8012d36:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_ADCDACCLKSOURCE_HCLK)
 8012d38:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012d3a:	2b00      	cmp	r3, #0
 8012d3c:	d104      	bne.n	8012d48 <HAL_RCCEx_GetPeriphCLKFreq+0x1330>
        {
          frequency = HAL_RCC_GetHCLKFreq();
 8012d3e:	f7fc fa3f 	bl	800f1c0 <HAL_RCC_GetHCLKFreq>
 8012d42:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Clock not enabled for ADCDAC */
        else
        {
          frequency = 0U;
        }
        break;
 8012d44:	f001 b9b3 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if (srcclk == RCC_ADCDACCLKSOURCE_SYSCLK)
 8012d48:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012d4a:	2b01      	cmp	r3, #1
 8012d4c:	d104      	bne.n	8012d58 <HAL_RCCEx_GetPeriphCLKFreq+0x1340>
          frequency = HAL_RCC_GetSysClockFreq();
 8012d4e:	f7fc f90b 	bl	800ef68 <HAL_RCC_GetSysClockFreq>
 8012d52:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 8012d54:	f001 b9ab 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if (srcclk == RCC_ADCDACCLKSOURCE_PLL2R)
 8012d58:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012d5a:	2b02      	cmp	r3, #2
 8012d5c:	d108      	bne.n	8012d70 <HAL_RCCEx_GetPeriphCLKFreq+0x1358>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8012d5e:	f107 0314 	add.w	r3, r7, #20
 8012d62:	4618      	mov	r0, r3
 8012d64:	f7fe fb80 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
 8012d68:	69fb      	ldr	r3, [r7, #28]
 8012d6a:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012d6c:	f001 b99f 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_ADCDACCLKSOURCE_HSE))
 8012d70:	4b77      	ldr	r3, [pc, #476]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012d72:	681b      	ldr	r3, [r3, #0]
 8012d74:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8012d78:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8012d7c:	d105      	bne.n	8012d8a <HAL_RCCEx_GetPeriphCLKFreq+0x1372>
 8012d7e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012d80:	2b03      	cmp	r3, #3
 8012d82:	d102      	bne.n	8012d8a <HAL_RCCEx_GetPeriphCLKFreq+0x1372>
          frequency = HSE_VALUE;
 8012d84:	4b75      	ldr	r3, [pc, #468]	@ (8012f5c <HAL_RCCEx_GetPeriphCLKFreq+0x1544>)
 8012d86:	637b      	str	r3, [r7, #52]	@ 0x34
 8012d88:	e023      	b.n	8012dd2 <HAL_RCCEx_GetPeriphCLKFreq+0x13ba>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_ADCDACCLKSOURCE_HSI))
 8012d8a:	4b71      	ldr	r3, [pc, #452]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012d8c:	681b      	ldr	r3, [r3, #0]
 8012d8e:	f003 0302 	and.w	r3, r3, #2
 8012d92:	2b02      	cmp	r3, #2
 8012d94:	d10c      	bne.n	8012db0 <HAL_RCCEx_GetPeriphCLKFreq+0x1398>
 8012d96:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012d98:	2b04      	cmp	r3, #4
 8012d9a:	d109      	bne.n	8012db0 <HAL_RCCEx_GetPeriphCLKFreq+0x1398>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8012d9c:	4b6c      	ldr	r3, [pc, #432]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012d9e:	681b      	ldr	r3, [r3, #0]
 8012da0:	08db      	lsrs	r3, r3, #3
 8012da2:	f003 0303 	and.w	r3, r3, #3
 8012da6:	4a6b      	ldr	r2, [pc, #428]	@ (8012f54 <HAL_RCCEx_GetPeriphCLKFreq+0x153c>)
 8012da8:	fa22 f303 	lsr.w	r3, r2, r3
 8012dac:	637b      	str	r3, [r7, #52]	@ 0x34
 8012dae:	e010      	b.n	8012dd2 <HAL_RCCEx_GetPeriphCLKFreq+0x13ba>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_ADCDACCLKSOURCE_CSI))
 8012db0:	4b67      	ldr	r3, [pc, #412]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012db2:	681b      	ldr	r3, [r3, #0]
 8012db4:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8012db8:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8012dbc:	d105      	bne.n	8012dca <HAL_RCCEx_GetPeriphCLKFreq+0x13b2>
 8012dbe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012dc0:	2b05      	cmp	r3, #5
 8012dc2:	d102      	bne.n	8012dca <HAL_RCCEx_GetPeriphCLKFreq+0x13b2>
          frequency = CSI_VALUE;
 8012dc4:	4b64      	ldr	r3, [pc, #400]	@ (8012f58 <HAL_RCCEx_GetPeriphCLKFreq+0x1540>)
 8012dc6:	637b      	str	r3, [r7, #52]	@ 0x34
 8012dc8:	e003      	b.n	8012dd2 <HAL_RCCEx_GetPeriphCLKFreq+0x13ba>
          frequency = 0U;
 8012dca:	2300      	movs	r3, #0
 8012dcc:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012dce:	f001 b96e 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8012dd2:	f001 b96c 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>


      case RCC_PERIPHCLK_DAC_LP:
        /* Get the current DAC low-power source */
        srcclk = __HAL_RCC_GET_DAC_LP_SOURCE();
 8012dd6:	4b5e      	ldr	r3, [pc, #376]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012dd8:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8012ddc:	f003 0308 	and.w	r3, r3, #8
 8012de0:	633b      	str	r3, [r7, #48]	@ 0x30

        if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_DACLPCLKSOURCE_LSE))
 8012de2:	4b5b      	ldr	r3, [pc, #364]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012de4:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8012de8:	f003 0302 	and.w	r3, r3, #2
 8012dec:	2b02      	cmp	r3, #2
 8012dee:	d106      	bne.n	8012dfe <HAL_RCCEx_GetPeriphCLKFreq+0x13e6>
 8012df0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012df2:	2b00      	cmp	r3, #0
 8012df4:	d103      	bne.n	8012dfe <HAL_RCCEx_GetPeriphCLKFreq+0x13e6>
        {
          frequency = LSE_VALUE;
 8012df6:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8012dfa:	637b      	str	r3, [r7, #52]	@ 0x34
 8012dfc:	e012      	b.n	8012e24 <HAL_RCCEx_GetPeriphCLKFreq+0x140c>
        }
        else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_DACLPCLKSOURCE_LSI))
 8012dfe:	4b54      	ldr	r3, [pc, #336]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012e00:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8012e04:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8012e08:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8012e0c:	d106      	bne.n	8012e1c <HAL_RCCEx_GetPeriphCLKFreq+0x1404>
 8012e0e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012e10:	2b08      	cmp	r3, #8
 8012e12:	d103      	bne.n	8012e1c <HAL_RCCEx_GetPeriphCLKFreq+0x1404>
        {
          frequency = LSI_VALUE;
 8012e14:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 8012e18:	637b      	str	r3, [r7, #52]	@ 0x34
 8012e1a:	e003      	b.n	8012e24 <HAL_RCCEx_GetPeriphCLKFreq+0x140c>
        }

        /* Clock not enabled for DAC */
        else
        {
          frequency = 0U;
 8012e1c:	2300      	movs	r3, #0
 8012e1e:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        break;
 8012e20:	f001 b945 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8012e24:	f001 b943 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>

      case RCC_PERIPHCLK_I2C1:
        /* Get the current I2C1 source */
        srcclk = __HAL_RCC_GET_I2C1_SOURCE();
 8012e28:	4b49      	ldr	r3, [pc, #292]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012e2a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8012e2e:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 8012e32:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_I2C1CLKSOURCE_PCLK1)
 8012e34:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012e36:	2b00      	cmp	r3, #0
 8012e38:	d104      	bne.n	8012e44 <HAL_RCCEx_GetPeriphCLKFreq+0x142c>
        {
          frequency = HAL_RCC_GetPCLK1Freq();
 8012e3a:	f7fc f9dd 	bl	800f1f8 <HAL_RCC_GetPCLK1Freq>
 8012e3e:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Clock not enabled for I2C1 */
        else
        {
          frequency = 0U;
        }
        break;
 8012e40:	f001 b935 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if (srcclk ==  RCC_I2C1CLKSOURCE_PLL3R)
 8012e44:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012e46:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8012e4a:	d108      	bne.n	8012e5e <HAL_RCCEx_GetPeriphCLKFreq+0x1446>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8012e4c:	f107 0308 	add.w	r3, r7, #8
 8012e50:	4618      	mov	r0, r3
 8012e52:	f7fe fc75 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
 8012e56:	693b      	ldr	r3, [r7, #16]
 8012e58:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012e5a:	f001 b928 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C1CLKSOURCE_HSI))
 8012e5e:	4b3c      	ldr	r3, [pc, #240]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012e60:	681b      	ldr	r3, [r3, #0]
 8012e62:	f003 0302 	and.w	r3, r3, #2
 8012e66:	2b02      	cmp	r3, #2
 8012e68:	d10d      	bne.n	8012e86 <HAL_RCCEx_GetPeriphCLKFreq+0x146e>
 8012e6a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012e6c:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8012e70:	d109      	bne.n	8012e86 <HAL_RCCEx_GetPeriphCLKFreq+0x146e>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8012e72:	4b37      	ldr	r3, [pc, #220]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012e74:	681b      	ldr	r3, [r3, #0]
 8012e76:	08db      	lsrs	r3, r3, #3
 8012e78:	f003 0303 	and.w	r3, r3, #3
 8012e7c:	4a35      	ldr	r2, [pc, #212]	@ (8012f54 <HAL_RCCEx_GetPeriphCLKFreq+0x153c>)
 8012e7e:	fa22 f303 	lsr.w	r3, r2, r3
 8012e82:	637b      	str	r3, [r7, #52]	@ 0x34
 8012e84:	e011      	b.n	8012eaa <HAL_RCCEx_GetPeriphCLKFreq+0x1492>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk ==  RCC_I2C1CLKSOURCE_CSI))
 8012e86:	4b32      	ldr	r3, [pc, #200]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012e88:	681b      	ldr	r3, [r3, #0]
 8012e8a:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8012e8e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8012e92:	d106      	bne.n	8012ea2 <HAL_RCCEx_GetPeriphCLKFreq+0x148a>
 8012e94:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012e96:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8012e9a:	d102      	bne.n	8012ea2 <HAL_RCCEx_GetPeriphCLKFreq+0x148a>
          frequency = CSI_VALUE;
 8012e9c:	4b2e      	ldr	r3, [pc, #184]	@ (8012f58 <HAL_RCCEx_GetPeriphCLKFreq+0x1540>)
 8012e9e:	637b      	str	r3, [r7, #52]	@ 0x34
 8012ea0:	e003      	b.n	8012eaa <HAL_RCCEx_GetPeriphCLKFreq+0x1492>
          frequency = 0U;
 8012ea2:	2300      	movs	r3, #0
 8012ea4:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012ea6:	f001 b902 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8012eaa:	f001 b900 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>

      case RCC_PERIPHCLK_I2C2:
        /* Get the current I2C2 source */
        srcclk = __HAL_RCC_GET_I2C2_SOURCE();
 8012eae:	4b28      	ldr	r3, [pc, #160]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012eb0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8012eb4:	f403 2340 	and.w	r3, r3, #786432	@ 0xc0000
 8012eb8:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_I2C2CLKSOURCE_PCLK1)
 8012eba:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012ebc:	2b00      	cmp	r3, #0
 8012ebe:	d104      	bne.n	8012eca <HAL_RCCEx_GetPeriphCLKFreq+0x14b2>
        {
          frequency = HAL_RCC_GetPCLK1Freq();
 8012ec0:	f7fc f99a 	bl	800f1f8 <HAL_RCC_GetPCLK1Freq>
 8012ec4:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Clock not enabled for I2C2 */
        else
        {
          frequency = 0U;
        }
        break;
 8012ec6:	f001 b8f2 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if (srcclk ==  RCC_I2C2CLKSOURCE_PLL3R)
 8012eca:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012ecc:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8012ed0:	d108      	bne.n	8012ee4 <HAL_RCCEx_GetPeriphCLKFreq+0x14cc>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8012ed2:	f107 0308 	add.w	r3, r7, #8
 8012ed6:	4618      	mov	r0, r3
 8012ed8:	f7fe fc32 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
 8012edc:	693b      	ldr	r3, [r7, #16]
 8012ede:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012ee0:	f001 b8e5 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C2CLKSOURCE_HSI))
 8012ee4:	4b1a      	ldr	r3, [pc, #104]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012ee6:	681b      	ldr	r3, [r3, #0]
 8012ee8:	f003 0302 	and.w	r3, r3, #2
 8012eec:	2b02      	cmp	r3, #2
 8012eee:	d10d      	bne.n	8012f0c <HAL_RCCEx_GetPeriphCLKFreq+0x14f4>
 8012ef0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012ef2:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 8012ef6:	d109      	bne.n	8012f0c <HAL_RCCEx_GetPeriphCLKFreq+0x14f4>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8012ef8:	4b15      	ldr	r3, [pc, #84]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012efa:	681b      	ldr	r3, [r3, #0]
 8012efc:	08db      	lsrs	r3, r3, #3
 8012efe:	f003 0303 	and.w	r3, r3, #3
 8012f02:	4a14      	ldr	r2, [pc, #80]	@ (8012f54 <HAL_RCCEx_GetPeriphCLKFreq+0x153c>)
 8012f04:	fa22 f303 	lsr.w	r3, r2, r3
 8012f08:	637b      	str	r3, [r7, #52]	@ 0x34
 8012f0a:	e011      	b.n	8012f30 <HAL_RCCEx_GetPeriphCLKFreq+0x1518>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk ==  RCC_I2C2CLKSOURCE_CSI))
 8012f0c:	4b10      	ldr	r3, [pc, #64]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012f0e:	681b      	ldr	r3, [r3, #0]
 8012f10:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8012f14:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8012f18:	d106      	bne.n	8012f28 <HAL_RCCEx_GetPeriphCLKFreq+0x1510>
 8012f1a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012f1c:	f5b3 2f40 	cmp.w	r3, #786432	@ 0xc0000
 8012f20:	d102      	bne.n	8012f28 <HAL_RCCEx_GetPeriphCLKFreq+0x1510>
          frequency = CSI_VALUE;
 8012f22:	4b0d      	ldr	r3, [pc, #52]	@ (8012f58 <HAL_RCCEx_GetPeriphCLKFreq+0x1540>)
 8012f24:	637b      	str	r3, [r7, #52]	@ 0x34
 8012f26:	e003      	b.n	8012f30 <HAL_RCCEx_GetPeriphCLKFreq+0x1518>
          frequency = 0U;
 8012f28:	2300      	movs	r3, #0
 8012f2a:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012f2c:	f001 b8bf 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8012f30:	f001 b8bd 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>

#if defined(I2C3)
      case RCC_PERIPHCLK_I2C3:
        /* Get the current I2C3 source */
        srcclk = __HAL_RCC_GET_I2C3_SOURCE();
 8012f34:	4b06      	ldr	r3, [pc, #24]	@ (8012f50 <HAL_RCCEx_GetPeriphCLKFreq+0x1538>)
 8012f36:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8012f3a:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
 8012f3e:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_I2C3CLKSOURCE_PCLK3)
 8012f40:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012f42:	2b00      	cmp	r3, #0
 8012f44:	d10c      	bne.n	8012f60 <HAL_RCCEx_GetPeriphCLKFreq+0x1548>
        {
          frequency = HAL_RCC_GetPCLK3Freq();
 8012f46:	f7fc f983 	bl	800f250 <HAL_RCC_GetPCLK3Freq>
 8012f4a:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Clock not enabled for I2C3 */
        else
        {
          frequency = 0U;
        }
        break;
 8012f4c:	f001 b8af 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8012f50:	44020c00 	.word	0x44020c00
 8012f54:	03d09000 	.word	0x03d09000
 8012f58:	003d0900 	.word	0x003d0900
 8012f5c:	017d7840 	.word	0x017d7840
        else if (srcclk ==  RCC_I2C3CLKSOURCE_PLL3R)
 8012f60:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012f62:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8012f66:	d108      	bne.n	8012f7a <HAL_RCCEx_GetPeriphCLKFreq+0x1562>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8012f68:	f107 0308 	add.w	r3, r7, #8
 8012f6c:	4618      	mov	r0, r3
 8012f6e:	f7fe fbe7 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
 8012f72:	693b      	ldr	r3, [r7, #16]
 8012f74:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012f76:	f001 b89a 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C3CLKSOURCE_HSI))
 8012f7a:	4b9f      	ldr	r3, [pc, #636]	@ (80131f8 <HAL_RCCEx_GetPeriphCLKFreq+0x17e0>)
 8012f7c:	681b      	ldr	r3, [r3, #0]
 8012f7e:	f003 0302 	and.w	r3, r3, #2
 8012f82:	2b02      	cmp	r3, #2
 8012f84:	d10d      	bne.n	8012fa2 <HAL_RCCEx_GetPeriphCLKFreq+0x158a>
 8012f86:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012f88:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8012f8c:	d109      	bne.n	8012fa2 <HAL_RCCEx_GetPeriphCLKFreq+0x158a>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8012f8e:	4b9a      	ldr	r3, [pc, #616]	@ (80131f8 <HAL_RCCEx_GetPeriphCLKFreq+0x17e0>)
 8012f90:	681b      	ldr	r3, [r3, #0]
 8012f92:	08db      	lsrs	r3, r3, #3
 8012f94:	f003 0303 	and.w	r3, r3, #3
 8012f98:	4a98      	ldr	r2, [pc, #608]	@ (80131fc <HAL_RCCEx_GetPeriphCLKFreq+0x17e4>)
 8012f9a:	fa22 f303 	lsr.w	r3, r2, r3
 8012f9e:	637b      	str	r3, [r7, #52]	@ 0x34
 8012fa0:	e011      	b.n	8012fc6 <HAL_RCCEx_GetPeriphCLKFreq+0x15ae>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk ==  RCC_I2C3CLKSOURCE_CSI))
 8012fa2:	4b95      	ldr	r3, [pc, #596]	@ (80131f8 <HAL_RCCEx_GetPeriphCLKFreq+0x17e0>)
 8012fa4:	681b      	ldr	r3, [r3, #0]
 8012fa6:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8012faa:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8012fae:	d106      	bne.n	8012fbe <HAL_RCCEx_GetPeriphCLKFreq+0x15a6>
 8012fb0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012fb2:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 8012fb6:	d102      	bne.n	8012fbe <HAL_RCCEx_GetPeriphCLKFreq+0x15a6>
          frequency = CSI_VALUE;
 8012fb8:	4b91      	ldr	r3, [pc, #580]	@ (8013200 <HAL_RCCEx_GetPeriphCLKFreq+0x17e8>)
 8012fba:	637b      	str	r3, [r7, #52]	@ 0x34
 8012fbc:	e003      	b.n	8012fc6 <HAL_RCCEx_GetPeriphCLKFreq+0x15ae>
          frequency = 0U;
 8012fbe:	2300      	movs	r3, #0
 8012fc0:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012fc2:	f001 b874 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8012fc6:	f001 b872 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* I2C3 */

#if defined(I2C4)
      case RCC_PERIPHCLK_I2C4:
        /* Get the current I2C4 source */
        srcclk = __HAL_RCC_GET_I2C4_SOURCE();
 8012fca:	4b8b      	ldr	r3, [pc, #556]	@ (80131f8 <HAL_RCCEx_GetPeriphCLKFreq+0x17e0>)
 8012fcc:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8012fd0:	f403 0340 	and.w	r3, r3, #12582912	@ 0xc00000
 8012fd4:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_I2C4CLKSOURCE_PCLK3)
 8012fd6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012fd8:	2b00      	cmp	r3, #0
 8012fda:	d104      	bne.n	8012fe6 <HAL_RCCEx_GetPeriphCLKFreq+0x15ce>
        {
          frequency = HAL_RCC_GetPCLK3Freq();
 8012fdc:	f7fc f938 	bl	800f250 <HAL_RCC_GetPCLK3Freq>
 8012fe0:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Clock not enabled for I2C4 */
        else
        {
          frequency = 0U;
        }
        break;
 8012fe2:	f001 b864 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if (srcclk ==  RCC_I2C4CLKSOURCE_PLL3R)
 8012fe6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012fe8:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8012fec:	d108      	bne.n	8013000 <HAL_RCCEx_GetPeriphCLKFreq+0x15e8>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8012fee:	f107 0308 	add.w	r3, r7, #8
 8012ff2:	4618      	mov	r0, r3
 8012ff4:	f7fe fba4 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
 8012ff8:	693b      	ldr	r3, [r7, #16]
 8012ffa:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8012ffc:	f001 b857 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C4CLKSOURCE_HSI))
 8013000:	4b7d      	ldr	r3, [pc, #500]	@ (80131f8 <HAL_RCCEx_GetPeriphCLKFreq+0x17e0>)
 8013002:	681b      	ldr	r3, [r3, #0]
 8013004:	f003 0302 	and.w	r3, r3, #2
 8013008:	2b02      	cmp	r3, #2
 801300a:	d10d      	bne.n	8013028 <HAL_RCCEx_GetPeriphCLKFreq+0x1610>
 801300c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801300e:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 8013012:	d109      	bne.n	8013028 <HAL_RCCEx_GetPeriphCLKFreq+0x1610>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8013014:	4b78      	ldr	r3, [pc, #480]	@ (80131f8 <HAL_RCCEx_GetPeriphCLKFreq+0x17e0>)
 8013016:	681b      	ldr	r3, [r3, #0]
 8013018:	08db      	lsrs	r3, r3, #3
 801301a:	f003 0303 	and.w	r3, r3, #3
 801301e:	4a77      	ldr	r2, [pc, #476]	@ (80131fc <HAL_RCCEx_GetPeriphCLKFreq+0x17e4>)
 8013020:	fa22 f303 	lsr.w	r3, r2, r3
 8013024:	637b      	str	r3, [r7, #52]	@ 0x34
 8013026:	e011      	b.n	801304c <HAL_RCCEx_GetPeriphCLKFreq+0x1634>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk ==  RCC_I2C4CLKSOURCE_CSI))
 8013028:	4b73      	ldr	r3, [pc, #460]	@ (80131f8 <HAL_RCCEx_GetPeriphCLKFreq+0x17e0>)
 801302a:	681b      	ldr	r3, [r3, #0]
 801302c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8013030:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8013034:	d106      	bne.n	8013044 <HAL_RCCEx_GetPeriphCLKFreq+0x162c>
 8013036:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013038:	f5b3 0f40 	cmp.w	r3, #12582912	@ 0xc00000
 801303c:	d102      	bne.n	8013044 <HAL_RCCEx_GetPeriphCLKFreq+0x162c>
          frequency = CSI_VALUE;
 801303e:	4b70      	ldr	r3, [pc, #448]	@ (8013200 <HAL_RCCEx_GetPeriphCLKFreq+0x17e8>)
 8013040:	637b      	str	r3, [r7, #52]	@ 0x34
 8013042:	e003      	b.n	801304c <HAL_RCCEx_GetPeriphCLKFreq+0x1634>
          frequency = 0U;
 8013044:	2300      	movs	r3, #0
 8013046:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8013048:	f001 b831 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 801304c:	f001 b82f 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* I2C4 */

      case RCC_PERIPHCLK_I3C1:
        /* Get the current I3C1 source */
        srcclk = __HAL_RCC_GET_I3C1_SOURCE();
 8013050:	4b69      	ldr	r3, [pc, #420]	@ (80131f8 <HAL_RCCEx_GetPeriphCLKFreq+0x17e0>)
 8013052:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8013056:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
 801305a:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_I3C1CLKSOURCE_PCLK1)
 801305c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801305e:	2b00      	cmp	r3, #0
 8013060:	d104      	bne.n	801306c <HAL_RCCEx_GetPeriphCLKFreq+0x1654>
        {
          frequency = HAL_RCC_GetPCLK1Freq();
 8013062:	f7fc f8c9 	bl	800f1f8 <HAL_RCC_GetPCLK1Freq>
 8013066:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Clock not enabled for I3C1 */
        else
        {
          frequency = 0U;
        }
        break;
 8013068:	f001 b821 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if (srcclk ==  RCC_I3C1CLKSOURCE_PLL3R)
 801306c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801306e:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8013072:	d108      	bne.n	8013086 <HAL_RCCEx_GetPeriphCLKFreq+0x166e>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8013074:	f107 0308 	add.w	r3, r7, #8
 8013078:	4618      	mov	r0, r3
 801307a:	f7fe fb61 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
 801307e:	693b      	ldr	r3, [r7, #16]
 8013080:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8013082:	f001 b814 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I3C1CLKSOURCE_HSI))
 8013086:	4b5c      	ldr	r3, [pc, #368]	@ (80131f8 <HAL_RCCEx_GetPeriphCLKFreq+0x17e0>)
 8013088:	681b      	ldr	r3, [r3, #0]
 801308a:	f003 0302 	and.w	r3, r3, #2
 801308e:	2b02      	cmp	r3, #2
 8013090:	d10e      	bne.n	80130b0 <HAL_RCCEx_GetPeriphCLKFreq+0x1698>
 8013092:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013094:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8013098:	d10a      	bne.n	80130b0 <HAL_RCCEx_GetPeriphCLKFreq+0x1698>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 801309a:	4b57      	ldr	r3, [pc, #348]	@ (80131f8 <HAL_RCCEx_GetPeriphCLKFreq+0x17e0>)
 801309c:	681b      	ldr	r3, [r3, #0]
 801309e:	08db      	lsrs	r3, r3, #3
 80130a0:	f003 0303 	and.w	r3, r3, #3
 80130a4:	4a55      	ldr	r2, [pc, #340]	@ (80131fc <HAL_RCCEx_GetPeriphCLKFreq+0x17e4>)
 80130a6:	fa22 f303 	lsr.w	r3, r2, r3
 80130aa:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80130ac:	f000 bfff 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
          frequency = 0U;
 80130b0:	2300      	movs	r3, #0
 80130b2:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80130b4:	f000 bffb 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        break;
#endif /* I3C2*/

      case RCC_PERIPHCLK_LPTIM1:
        /* Get the current LPTIM1 source */
        srcclk = __HAL_RCC_GET_LPTIM1_SOURCE();
 80130b8:	4b4f      	ldr	r3, [pc, #316]	@ (80131f8 <HAL_RCCEx_GetPeriphCLKFreq+0x17e0>)
 80130ba:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 80130be:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
 80130c2:	633b      	str	r3, [r7, #48]	@ 0x30

        switch (srcclk)
 80130c4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80130c6:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
 80130ca:	d056      	beq.n	801317a <HAL_RCCEx_GetPeriphCLKFreq+0x1762>
 80130cc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80130ce:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
 80130d2:	f200 808b 	bhi.w	80131ec <HAL_RCCEx_GetPeriphCLKFreq+0x17d4>
 80130d6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80130d8:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 80130dc:	d03e      	beq.n	801315c <HAL_RCCEx_GetPeriphCLKFreq+0x1744>
 80130de:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80130e0:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 80130e4:	f200 8082 	bhi.w	80131ec <HAL_RCCEx_GetPeriphCLKFreq+0x17d4>
 80130e8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80130ea:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 80130ee:	d027      	beq.n	8013140 <HAL_RCCEx_GetPeriphCLKFreq+0x1728>
 80130f0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80130f2:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 80130f6:	d879      	bhi.n	80131ec <HAL_RCCEx_GetPeriphCLKFreq+0x17d4>
 80130f8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80130fa:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80130fe:	d017      	beq.n	8013130 <HAL_RCCEx_GetPeriphCLKFreq+0x1718>
 8013100:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013102:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8013106:	d871      	bhi.n	80131ec <HAL_RCCEx_GetPeriphCLKFreq+0x17d4>
 8013108:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801310a:	2b00      	cmp	r3, #0
 801310c:	d004      	beq.n	8013118 <HAL_RCCEx_GetPeriphCLKFreq+0x1700>
 801310e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013110:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8013114:	d004      	beq.n	8013120 <HAL_RCCEx_GetPeriphCLKFreq+0x1708>
 8013116:	e069      	b.n	80131ec <HAL_RCCEx_GetPeriphCLKFreq+0x17d4>
        {
          case RCC_LPTIM1CLKSOURCE_PCLK3:
          {
            frequency = HAL_RCC_GetPCLK3Freq();
 8013118:	f7fc f89a 	bl	800f250 <HAL_RCC_GetPCLK3Freq>
 801311c:	6378      	str	r0, [r7, #52]	@ 0x34
            break;
 801311e:	e068      	b.n	80131f2 <HAL_RCCEx_GetPeriphCLKFreq+0x17da>
          }
          case RCC_LPTIM1CLKSOURCE_PLL2P:
          {
            HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8013120:	f107 0314 	add.w	r3, r7, #20
 8013124:	4618      	mov	r0, r3
 8013126:	f7fe f99f 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
            frequency = pll2_clocks.PLL2_P_Frequency;
 801312a:	697b      	ldr	r3, [r7, #20]
 801312c:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 801312e:	e060      	b.n	80131f2 <HAL_RCCEx_GetPeriphCLKFreq+0x17da>
          }
#if defined(RCC_LPTIM1CLKSOURCE_PLL3R)
          case RCC_LPTIM1CLKSOURCE_PLL3R:
          {
            HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8013130:	f107 0308 	add.w	r3, r7, #8
 8013134:	4618      	mov	r0, r3
 8013136:	f7fe fb03 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
            frequency = pll3_clocks.PLL3_R_Frequency;
 801313a:	693b      	ldr	r3, [r7, #16]
 801313c:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 801313e:	e058      	b.n	80131f2 <HAL_RCCEx_GetPeriphCLKFreq+0x17da>
          }
#endif /* RCC_LPTIM1CLKSOURCE_PLL3R */
          case RCC_LPTIM1CLKSOURCE_LSE:
          {
            if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
 8013140:	4b2d      	ldr	r3, [pc, #180]	@ (80131f8 <HAL_RCCEx_GetPeriphCLKFreq+0x17e0>)
 8013142:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8013146:	f003 0302 	and.w	r3, r3, #2
 801314a:	2b02      	cmp	r3, #2
 801314c:	d103      	bne.n	8013156 <HAL_RCCEx_GetPeriphCLKFreq+0x173e>
            {
              frequency = LSE_VALUE;
 801314e:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8013152:	637b      	str	r3, [r7, #52]	@ 0x34
            }
            else
            {
              frequency = 0;
            }
            break;
 8013154:	e04d      	b.n	80131f2 <HAL_RCCEx_GetPeriphCLKFreq+0x17da>
              frequency = 0;
 8013156:	2300      	movs	r3, #0
 8013158:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 801315a:	e04a      	b.n	80131f2 <HAL_RCCEx_GetPeriphCLKFreq+0x17da>
          }
          case RCC_LPTIM1CLKSOURCE_LSI:
          {
            if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY))
 801315c:	4b26      	ldr	r3, [pc, #152]	@ (80131f8 <HAL_RCCEx_GetPeriphCLKFreq+0x17e0>)
 801315e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8013162:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8013166:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 801316a:	d103      	bne.n	8013174 <HAL_RCCEx_GetPeriphCLKFreq+0x175c>
            {
              frequency = LSI_VALUE;
 801316c:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 8013170:	637b      	str	r3, [r7, #52]	@ 0x34
            }
            else
            {
              frequency = 0;
            }
            break;
 8013172:	e03e      	b.n	80131f2 <HAL_RCCEx_GetPeriphCLKFreq+0x17da>
              frequency = 0;
 8013174:	2300      	movs	r3, #0
 8013176:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013178:	e03b      	b.n	80131f2 <HAL_RCCEx_GetPeriphCLKFreq+0x17da>
          }
          case RCC_LPTIM1CLKSOURCE_CLKP: /* CLKP is the clock source for LPTIM1 */
          {
            ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 801317a:	4b1f      	ldr	r3, [pc, #124]	@ (80131f8 <HAL_RCCEx_GetPeriphCLKFreq+0x17e0>)
 801317c:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8013180:	f003 4340 	and.w	r3, r3, #3221225472	@ 0xc0000000
 8013184:	62fb      	str	r3, [r7, #44]	@ 0x2c

            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 8013186:	4b1c      	ldr	r3, [pc, #112]	@ (80131f8 <HAL_RCCEx_GetPeriphCLKFreq+0x17e0>)
 8013188:	681b      	ldr	r3, [r3, #0]
 801318a:	f003 0302 	and.w	r3, r3, #2
 801318e:	2b02      	cmp	r3, #2
 8013190:	d10c      	bne.n	80131ac <HAL_RCCEx_GetPeriphCLKFreq+0x1794>
 8013192:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013194:	2b00      	cmp	r3, #0
 8013196:	d109      	bne.n	80131ac <HAL_RCCEx_GetPeriphCLKFreq+0x1794>
            {
              /* In Case the CKPER Source is HSI */
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8013198:	4b17      	ldr	r3, [pc, #92]	@ (80131f8 <HAL_RCCEx_GetPeriphCLKFreq+0x17e0>)
 801319a:	681b      	ldr	r3, [r3, #0]
 801319c:	08db      	lsrs	r3, r3, #3
 801319e:	f003 0303 	and.w	r3, r3, #3
 80131a2:	4a16      	ldr	r2, [pc, #88]	@ (80131fc <HAL_RCCEx_GetPeriphCLKFreq+0x17e4>)
 80131a4:	fa22 f303 	lsr.w	r3, r2, r3
 80131a8:	637b      	str	r3, [r7, #52]	@ 0x34
 80131aa:	e01e      	b.n	80131ea <HAL_RCCEx_GetPeriphCLKFreq+0x17d2>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 80131ac:	4b12      	ldr	r3, [pc, #72]	@ (80131f8 <HAL_RCCEx_GetPeriphCLKFreq+0x17e0>)
 80131ae:	681b      	ldr	r3, [r3, #0]
 80131b0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 80131b4:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80131b8:	d106      	bne.n	80131c8 <HAL_RCCEx_GetPeriphCLKFreq+0x17b0>
 80131ba:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80131bc:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 80131c0:	d102      	bne.n	80131c8 <HAL_RCCEx_GetPeriphCLKFreq+0x17b0>
            {
              /* In Case the CKPER Source is CSI */
              frequency = CSI_VALUE;
 80131c2:	4b0f      	ldr	r3, [pc, #60]	@ (8013200 <HAL_RCCEx_GetPeriphCLKFreq+0x17e8>)
 80131c4:	637b      	str	r3, [r7, #52]	@ 0x34
 80131c6:	e010      	b.n	80131ea <HAL_RCCEx_GetPeriphCLKFreq+0x17d2>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 80131c8:	4b0b      	ldr	r3, [pc, #44]	@ (80131f8 <HAL_RCCEx_GetPeriphCLKFreq+0x17e0>)
 80131ca:	681b      	ldr	r3, [r3, #0]
 80131cc:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80131d0:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 80131d4:	d106      	bne.n	80131e4 <HAL_RCCEx_GetPeriphCLKFreq+0x17cc>
 80131d6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80131d8:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 80131dc:	d102      	bne.n	80131e4 <HAL_RCCEx_GetPeriphCLKFreq+0x17cc>
            {
              /* In Case the CKPER Source is HSE */
              frequency = HSE_VALUE;
 80131de:	4b09      	ldr	r3, [pc, #36]	@ (8013204 <HAL_RCCEx_GetPeriphCLKFreq+0x17ec>)
 80131e0:	637b      	str	r3, [r7, #52]	@ 0x34
 80131e2:	e002      	b.n	80131ea <HAL_RCCEx_GetPeriphCLKFreq+0x17d2>
            }

            else
            {
              /* In Case the CKPER is disabled*/
              frequency = 0;
 80131e4:	2300      	movs	r3, #0
 80131e6:	637b      	str	r3, [r7, #52]	@ 0x34
            }

            break;
 80131e8:	e003      	b.n	80131f2 <HAL_RCCEx_GetPeriphCLKFreq+0x17da>
 80131ea:	e002      	b.n	80131f2 <HAL_RCCEx_GetPeriphCLKFreq+0x17da>
          }
          default :
          {
            frequency = 0U;
 80131ec:	2300      	movs	r3, #0
 80131ee:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 80131f0:	bf00      	nop
          }
        }
        break;
 80131f2:	f000 bf5c 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 80131f6:	bf00      	nop
 80131f8:	44020c00 	.word	0x44020c00
 80131fc:	03d09000 	.word	0x03d09000
 8013200:	003d0900 	.word	0x003d0900
 8013204:	017d7840 	.word	0x017d7840

      case RCC_PERIPHCLK_LPTIM2:
        /* Get the current LPTIM2 source */
        srcclk = __HAL_RCC_GET_LPTIM2_SOURCE();
 8013208:	4b9e      	ldr	r3, [pc, #632]	@ (8013484 <HAL_RCCEx_GetPeriphCLKFreq+0x1a6c>)
 801320a:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 801320e:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
 8013212:	633b      	str	r3, [r7, #48]	@ 0x30

        switch (srcclk)
 8013214:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013216:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
 801321a:	d056      	beq.n	80132ca <HAL_RCCEx_GetPeriphCLKFreq+0x18b2>
 801321c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801321e:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
 8013222:	f200 808b 	bhi.w	801333c <HAL_RCCEx_GetPeriphCLKFreq+0x1924>
 8013226:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013228:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 801322c:	d03e      	beq.n	80132ac <HAL_RCCEx_GetPeriphCLKFreq+0x1894>
 801322e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013230:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8013234:	f200 8082 	bhi.w	801333c <HAL_RCCEx_GetPeriphCLKFreq+0x1924>
 8013238:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801323a:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 801323e:	d027      	beq.n	8013290 <HAL_RCCEx_GetPeriphCLKFreq+0x1878>
 8013240:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013242:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8013246:	d879      	bhi.n	801333c <HAL_RCCEx_GetPeriphCLKFreq+0x1924>
 8013248:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801324a:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 801324e:	d017      	beq.n	8013280 <HAL_RCCEx_GetPeriphCLKFreq+0x1868>
 8013250:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013252:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8013256:	d871      	bhi.n	801333c <HAL_RCCEx_GetPeriphCLKFreq+0x1924>
 8013258:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801325a:	2b00      	cmp	r3, #0
 801325c:	d004      	beq.n	8013268 <HAL_RCCEx_GetPeriphCLKFreq+0x1850>
 801325e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013260:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8013264:	d004      	beq.n	8013270 <HAL_RCCEx_GetPeriphCLKFreq+0x1858>
 8013266:	e069      	b.n	801333c <HAL_RCCEx_GetPeriphCLKFreq+0x1924>
        {
          case RCC_LPTIM2CLKSOURCE_PCLK1:
          {
            frequency = HAL_RCC_GetPCLK1Freq();
 8013268:	f7fb ffc6 	bl	800f1f8 <HAL_RCC_GetPCLK1Freq>
 801326c:	6378      	str	r0, [r7, #52]	@ 0x34
            break;
 801326e:	e068      	b.n	8013342 <HAL_RCCEx_GetPeriphCLKFreq+0x192a>
          }
          case RCC_LPTIM2CLKSOURCE_PLL2P:
          {
            HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8013270:	f107 0314 	add.w	r3, r7, #20
 8013274:	4618      	mov	r0, r3
 8013276:	f7fe f8f7 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
            frequency = pll2_clocks.PLL2_P_Frequency;
 801327a:	697b      	ldr	r3, [r7, #20]
 801327c:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 801327e:	e060      	b.n	8013342 <HAL_RCCEx_GetPeriphCLKFreq+0x192a>
          }
#if defined(RCC_LPTIM2CLKSOURCE_PLL3R)
          case RCC_LPTIM2CLKSOURCE_PLL3R:
          {
            HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8013280:	f107 0308 	add.w	r3, r7, #8
 8013284:	4618      	mov	r0, r3
 8013286:	f7fe fa5b 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
            frequency = pll3_clocks.PLL3_R_Frequency;
 801328a:	693b      	ldr	r3, [r7, #16]
 801328c:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 801328e:	e058      	b.n	8013342 <HAL_RCCEx_GetPeriphCLKFreq+0x192a>
          }
#endif /* RCC_LPTIM2CLKSOURCE_PLL3R */
          case RCC_LPTIM2CLKSOURCE_LSE:
          {
            if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
 8013290:	4b7c      	ldr	r3, [pc, #496]	@ (8013484 <HAL_RCCEx_GetPeriphCLKFreq+0x1a6c>)
 8013292:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8013296:	f003 0302 	and.w	r3, r3, #2
 801329a:	2b02      	cmp	r3, #2
 801329c:	d103      	bne.n	80132a6 <HAL_RCCEx_GetPeriphCLKFreq+0x188e>
            {
              frequency = LSE_VALUE;
 801329e:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80132a2:	637b      	str	r3, [r7, #52]	@ 0x34
            }
            else
            {
              frequency = 0;
            }
            break;
 80132a4:	e04d      	b.n	8013342 <HAL_RCCEx_GetPeriphCLKFreq+0x192a>
              frequency = 0;
 80132a6:	2300      	movs	r3, #0
 80132a8:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 80132aa:	e04a      	b.n	8013342 <HAL_RCCEx_GetPeriphCLKFreq+0x192a>
          }
          case RCC_LPTIM2CLKSOURCE_LSI:
          {
            if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY))
 80132ac:	4b75      	ldr	r3, [pc, #468]	@ (8013484 <HAL_RCCEx_GetPeriphCLKFreq+0x1a6c>)
 80132ae:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80132b2:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 80132b6:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 80132ba:	d103      	bne.n	80132c4 <HAL_RCCEx_GetPeriphCLKFreq+0x18ac>
            {
              frequency = LSI_VALUE;
 80132bc:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 80132c0:	637b      	str	r3, [r7, #52]	@ 0x34
            }
            else
            {
              frequency = 0;
            }
            break;
 80132c2:	e03e      	b.n	8013342 <HAL_RCCEx_GetPeriphCLKFreq+0x192a>
              frequency = 0;
 80132c4:	2300      	movs	r3, #0
 80132c6:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 80132c8:	e03b      	b.n	8013342 <HAL_RCCEx_GetPeriphCLKFreq+0x192a>
          }
          case RCC_LPTIM2CLKSOURCE_CLKP: /* CLKP is the clock source for LPTIM2 */
          {
            ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 80132ca:	4b6e      	ldr	r3, [pc, #440]	@ (8013484 <HAL_RCCEx_GetPeriphCLKFreq+0x1a6c>)
 80132cc:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 80132d0:	f003 4340 	and.w	r3, r3, #3221225472	@ 0xc0000000
 80132d4:	62fb      	str	r3, [r7, #44]	@ 0x2c

            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 80132d6:	4b6b      	ldr	r3, [pc, #428]	@ (8013484 <HAL_RCCEx_GetPeriphCLKFreq+0x1a6c>)
 80132d8:	681b      	ldr	r3, [r3, #0]
 80132da:	f003 0302 	and.w	r3, r3, #2
 80132de:	2b02      	cmp	r3, #2
 80132e0:	d10c      	bne.n	80132fc <HAL_RCCEx_GetPeriphCLKFreq+0x18e4>
 80132e2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80132e4:	2b00      	cmp	r3, #0
 80132e6:	d109      	bne.n	80132fc <HAL_RCCEx_GetPeriphCLKFreq+0x18e4>
            {
              /* In Case the CKPER Source is HSI */
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 80132e8:	4b66      	ldr	r3, [pc, #408]	@ (8013484 <HAL_RCCEx_GetPeriphCLKFreq+0x1a6c>)
 80132ea:	681b      	ldr	r3, [r3, #0]
 80132ec:	08db      	lsrs	r3, r3, #3
 80132ee:	f003 0303 	and.w	r3, r3, #3
 80132f2:	4a65      	ldr	r2, [pc, #404]	@ (8013488 <HAL_RCCEx_GetPeriphCLKFreq+0x1a70>)
 80132f4:	fa22 f303 	lsr.w	r3, r2, r3
 80132f8:	637b      	str	r3, [r7, #52]	@ 0x34
 80132fa:	e01e      	b.n	801333a <HAL_RCCEx_GetPeriphCLKFreq+0x1922>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 80132fc:	4b61      	ldr	r3, [pc, #388]	@ (8013484 <HAL_RCCEx_GetPeriphCLKFreq+0x1a6c>)
 80132fe:	681b      	ldr	r3, [r3, #0]
 8013300:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8013304:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8013308:	d106      	bne.n	8013318 <HAL_RCCEx_GetPeriphCLKFreq+0x1900>
 801330a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801330c:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8013310:	d102      	bne.n	8013318 <HAL_RCCEx_GetPeriphCLKFreq+0x1900>
            {
              /* In Case the CKPER Source is CSI */
              frequency = CSI_VALUE;
 8013312:	4b5e      	ldr	r3, [pc, #376]	@ (801348c <HAL_RCCEx_GetPeriphCLKFreq+0x1a74>)
 8013314:	637b      	str	r3, [r7, #52]	@ 0x34
 8013316:	e010      	b.n	801333a <HAL_RCCEx_GetPeriphCLKFreq+0x1922>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8013318:	4b5a      	ldr	r3, [pc, #360]	@ (8013484 <HAL_RCCEx_GetPeriphCLKFreq+0x1a6c>)
 801331a:	681b      	ldr	r3, [r3, #0]
 801331c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8013320:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8013324:	d106      	bne.n	8013334 <HAL_RCCEx_GetPeriphCLKFreq+0x191c>
 8013326:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013328:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 801332c:	d102      	bne.n	8013334 <HAL_RCCEx_GetPeriphCLKFreq+0x191c>
            {
              /* In Case the CKPER Source is HSE */
              frequency = HSE_VALUE;
 801332e:	4b58      	ldr	r3, [pc, #352]	@ (8013490 <HAL_RCCEx_GetPeriphCLKFreq+0x1a78>)
 8013330:	637b      	str	r3, [r7, #52]	@ 0x34
 8013332:	e002      	b.n	801333a <HAL_RCCEx_GetPeriphCLKFreq+0x1922>
            }

            else
            {
              /* In Case the CKPER is disabled*/
              frequency = 0;
 8013334:	2300      	movs	r3, #0
 8013336:	637b      	str	r3, [r7, #52]	@ 0x34
            }

            break;
 8013338:	e003      	b.n	8013342 <HAL_RCCEx_GetPeriphCLKFreq+0x192a>
 801333a:	e002      	b.n	8013342 <HAL_RCCEx_GetPeriphCLKFreq+0x192a>
          }
          default :
          {
            frequency = 0U;
 801333c:	2300      	movs	r3, #0
 801333e:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013340:	bf00      	nop
          }
        }
        break;
 8013342:	f000 beb4 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>

#if defined(LPTIM3)
      case RCC_PERIPHCLK_LPTIM3:
        /* Get the current LPTIM3 source */
        srcclk = __HAL_RCC_GET_LPTIM3_SOURCE();
 8013346:	4b4f      	ldr	r3, [pc, #316]	@ (8013484 <HAL_RCCEx_GetPeriphCLKFreq+0x1a6c>)
 8013348:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 801334c:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
 8013350:	633b      	str	r3, [r7, #48]	@ 0x30

        switch (srcclk)
 8013352:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013354:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8013358:	d056      	beq.n	8013408 <HAL_RCCEx_GetPeriphCLKFreq+0x19f0>
 801335a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801335c:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8013360:	f200 808b 	bhi.w	801347a <HAL_RCCEx_GetPeriphCLKFreq+0x1a62>
 8013364:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013366:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 801336a:	d03e      	beq.n	80133ea <HAL_RCCEx_GetPeriphCLKFreq+0x19d2>
 801336c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801336e:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8013372:	f200 8082 	bhi.w	801347a <HAL_RCCEx_GetPeriphCLKFreq+0x1a62>
 8013376:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013378:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 801337c:	d027      	beq.n	80133ce <HAL_RCCEx_GetPeriphCLKFreq+0x19b6>
 801337e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013380:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8013384:	d879      	bhi.n	801347a <HAL_RCCEx_GetPeriphCLKFreq+0x1a62>
 8013386:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013388:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 801338c:	d017      	beq.n	80133be <HAL_RCCEx_GetPeriphCLKFreq+0x19a6>
 801338e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013390:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8013394:	d871      	bhi.n	801347a <HAL_RCCEx_GetPeriphCLKFreq+0x1a62>
 8013396:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013398:	2b00      	cmp	r3, #0
 801339a:	d004      	beq.n	80133a6 <HAL_RCCEx_GetPeriphCLKFreq+0x198e>
 801339c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801339e:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 80133a2:	d004      	beq.n	80133ae <HAL_RCCEx_GetPeriphCLKFreq+0x1996>
 80133a4:	e069      	b.n	801347a <HAL_RCCEx_GetPeriphCLKFreq+0x1a62>
        {
          case RCC_LPTIM3CLKSOURCE_PCLK3:
          {
            frequency = HAL_RCC_GetPCLK3Freq();
 80133a6:	f7fb ff53 	bl	800f250 <HAL_RCC_GetPCLK3Freq>
 80133aa:	6378      	str	r0, [r7, #52]	@ 0x34
            break;
 80133ac:	e068      	b.n	8013480 <HAL_RCCEx_GetPeriphCLKFreq+0x1a68>
          }
          case RCC_LPTIM3CLKSOURCE_PLL2P:
          {
            HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 80133ae:	f107 0314 	add.w	r3, r7, #20
 80133b2:	4618      	mov	r0, r3
 80133b4:	f7fe f858 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
            frequency = pll2_clocks.PLL2_P_Frequency;
 80133b8:	697b      	ldr	r3, [r7, #20]
 80133ba:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 80133bc:	e060      	b.n	8013480 <HAL_RCCEx_GetPeriphCLKFreq+0x1a68>
          }
          case RCC_LPTIM3CLKSOURCE_PLL3R:
          {
            HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 80133be:	f107 0308 	add.w	r3, r7, #8
 80133c2:	4618      	mov	r0, r3
 80133c4:	f7fe f9bc 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
            frequency = pll3_clocks.PLL3_R_Frequency;
 80133c8:	693b      	ldr	r3, [r7, #16]
 80133ca:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 80133cc:	e058      	b.n	8013480 <HAL_RCCEx_GetPeriphCLKFreq+0x1a68>
          }
          case RCC_LPTIM3CLKSOURCE_LSE:
          {
            if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
 80133ce:	4b2d      	ldr	r3, [pc, #180]	@ (8013484 <HAL_RCCEx_GetPeriphCLKFreq+0x1a6c>)
 80133d0:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80133d4:	f003 0302 	and.w	r3, r3, #2
 80133d8:	2b02      	cmp	r3, #2
 80133da:	d103      	bne.n	80133e4 <HAL_RCCEx_GetPeriphCLKFreq+0x19cc>
            {
              frequency = LSE_VALUE;
 80133dc:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80133e0:	637b      	str	r3, [r7, #52]	@ 0x34
            }
            else
            {
              frequency = 0;
            }
            break;
 80133e2:	e04d      	b.n	8013480 <HAL_RCCEx_GetPeriphCLKFreq+0x1a68>
              frequency = 0;
 80133e4:	2300      	movs	r3, #0
 80133e6:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 80133e8:	e04a      	b.n	8013480 <HAL_RCCEx_GetPeriphCLKFreq+0x1a68>
          }
          case RCC_LPTIM3CLKSOURCE_LSI:
          {
            if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY))
 80133ea:	4b26      	ldr	r3, [pc, #152]	@ (8013484 <HAL_RCCEx_GetPeriphCLKFreq+0x1a6c>)
 80133ec:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80133f0:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 80133f4:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 80133f8:	d103      	bne.n	8013402 <HAL_RCCEx_GetPeriphCLKFreq+0x19ea>
            {
              frequency = LSI_VALUE;
 80133fa:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 80133fe:	637b      	str	r3, [r7, #52]	@ 0x34
            }
            else
            {
              frequency = 0;
            }
            break;
 8013400:	e03e      	b.n	8013480 <HAL_RCCEx_GetPeriphCLKFreq+0x1a68>
              frequency = 0;
 8013402:	2300      	movs	r3, #0
 8013404:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013406:	e03b      	b.n	8013480 <HAL_RCCEx_GetPeriphCLKFreq+0x1a68>
          }
          case RCC_LPTIM3CLKSOURCE_CLKP: /* CLKP is the clock source for LPTIM3 */
          {
            ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 8013408:	4b1e      	ldr	r3, [pc, #120]	@ (8013484 <HAL_RCCEx_GetPeriphCLKFreq+0x1a6c>)
 801340a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 801340e:	f003 4340 	and.w	r3, r3, #3221225472	@ 0xc0000000
 8013412:	62fb      	str	r3, [r7, #44]	@ 0x2c

            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 8013414:	4b1b      	ldr	r3, [pc, #108]	@ (8013484 <HAL_RCCEx_GetPeriphCLKFreq+0x1a6c>)
 8013416:	681b      	ldr	r3, [r3, #0]
 8013418:	f003 0302 	and.w	r3, r3, #2
 801341c:	2b02      	cmp	r3, #2
 801341e:	d10c      	bne.n	801343a <HAL_RCCEx_GetPeriphCLKFreq+0x1a22>
 8013420:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013422:	2b00      	cmp	r3, #0
 8013424:	d109      	bne.n	801343a <HAL_RCCEx_GetPeriphCLKFreq+0x1a22>
            {
              /* In Case the CKPER Source is HSI */
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8013426:	4b17      	ldr	r3, [pc, #92]	@ (8013484 <HAL_RCCEx_GetPeriphCLKFreq+0x1a6c>)
 8013428:	681b      	ldr	r3, [r3, #0]
 801342a:	08db      	lsrs	r3, r3, #3
 801342c:	f003 0303 	and.w	r3, r3, #3
 8013430:	4a15      	ldr	r2, [pc, #84]	@ (8013488 <HAL_RCCEx_GetPeriphCLKFreq+0x1a70>)
 8013432:	fa22 f303 	lsr.w	r3, r2, r3
 8013436:	637b      	str	r3, [r7, #52]	@ 0x34
 8013438:	e01e      	b.n	8013478 <HAL_RCCEx_GetPeriphCLKFreq+0x1a60>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 801343a:	4b12      	ldr	r3, [pc, #72]	@ (8013484 <HAL_RCCEx_GetPeriphCLKFreq+0x1a6c>)
 801343c:	681b      	ldr	r3, [r3, #0]
 801343e:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8013442:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8013446:	d106      	bne.n	8013456 <HAL_RCCEx_GetPeriphCLKFreq+0x1a3e>
 8013448:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801344a:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 801344e:	d102      	bne.n	8013456 <HAL_RCCEx_GetPeriphCLKFreq+0x1a3e>
            {
              /* In Case the CKPER Source is CSI */
              frequency = CSI_VALUE;
 8013450:	4b0e      	ldr	r3, [pc, #56]	@ (801348c <HAL_RCCEx_GetPeriphCLKFreq+0x1a74>)
 8013452:	637b      	str	r3, [r7, #52]	@ 0x34
 8013454:	e010      	b.n	8013478 <HAL_RCCEx_GetPeriphCLKFreq+0x1a60>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8013456:	4b0b      	ldr	r3, [pc, #44]	@ (8013484 <HAL_RCCEx_GetPeriphCLKFreq+0x1a6c>)
 8013458:	681b      	ldr	r3, [r3, #0]
 801345a:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 801345e:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8013462:	d106      	bne.n	8013472 <HAL_RCCEx_GetPeriphCLKFreq+0x1a5a>
 8013464:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013466:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 801346a:	d102      	bne.n	8013472 <HAL_RCCEx_GetPeriphCLKFreq+0x1a5a>
            {
              /* In Case the CKPER Source is HSE */
              frequency = HSE_VALUE;
 801346c:	4b08      	ldr	r3, [pc, #32]	@ (8013490 <HAL_RCCEx_GetPeriphCLKFreq+0x1a78>)
 801346e:	637b      	str	r3, [r7, #52]	@ 0x34
 8013470:	e002      	b.n	8013478 <HAL_RCCEx_GetPeriphCLKFreq+0x1a60>
            }

            else
            {
              /* In Case the CKPER is disabled*/
              frequency = 0;
 8013472:	2300      	movs	r3, #0
 8013474:	637b      	str	r3, [r7, #52]	@ 0x34
            }

            break;
 8013476:	e003      	b.n	8013480 <HAL_RCCEx_GetPeriphCLKFreq+0x1a68>
 8013478:	e002      	b.n	8013480 <HAL_RCCEx_GetPeriphCLKFreq+0x1a68>
          }
          default :
          {
            frequency = 0U;
 801347a:	2300      	movs	r3, #0
 801347c:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 801347e:	bf00      	nop
          }
        }
        break;
 8013480:	f000 be15 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8013484:	44020c00 	.word	0x44020c00
 8013488:	03d09000 	.word	0x03d09000
 801348c:	003d0900 	.word	0x003d0900
 8013490:	017d7840 	.word	0x017d7840
#endif /* LPTIM3 */

#if defined(LPTIM4)
      case RCC_PERIPHCLK_LPTIM4:
        /* Get the current LPTIM4 source */
        srcclk = __HAL_RCC_GET_LPTIM4_SOURCE();
 8013494:	4b9e      	ldr	r3, [pc, #632]	@ (8013710 <HAL_RCCEx_GetPeriphCLKFreq+0x1cf8>)
 8013496:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 801349a:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
 801349e:	633b      	str	r3, [r7, #48]	@ 0x30

        switch (srcclk)
 80134a0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80134a2:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
 80134a6:	d056      	beq.n	8013556 <HAL_RCCEx_GetPeriphCLKFreq+0x1b3e>
 80134a8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80134aa:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
 80134ae:	f200 808b 	bhi.w	80135c8 <HAL_RCCEx_GetPeriphCLKFreq+0x1bb0>
 80134b2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80134b4:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 80134b8:	d03e      	beq.n	8013538 <HAL_RCCEx_GetPeriphCLKFreq+0x1b20>
 80134ba:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80134bc:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 80134c0:	f200 8082 	bhi.w	80135c8 <HAL_RCCEx_GetPeriphCLKFreq+0x1bb0>
 80134c4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80134c6:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 80134ca:	d027      	beq.n	801351c <HAL_RCCEx_GetPeriphCLKFreq+0x1b04>
 80134cc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80134ce:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 80134d2:	d879      	bhi.n	80135c8 <HAL_RCCEx_GetPeriphCLKFreq+0x1bb0>
 80134d4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80134d6:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 80134da:	d017      	beq.n	801350c <HAL_RCCEx_GetPeriphCLKFreq+0x1af4>
 80134dc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80134de:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 80134e2:	d871      	bhi.n	80135c8 <HAL_RCCEx_GetPeriphCLKFreq+0x1bb0>
 80134e4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80134e6:	2b00      	cmp	r3, #0
 80134e8:	d004      	beq.n	80134f4 <HAL_RCCEx_GetPeriphCLKFreq+0x1adc>
 80134ea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80134ec:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 80134f0:	d004      	beq.n	80134fc <HAL_RCCEx_GetPeriphCLKFreq+0x1ae4>
 80134f2:	e069      	b.n	80135c8 <HAL_RCCEx_GetPeriphCLKFreq+0x1bb0>
        {
          case RCC_LPTIM4CLKSOURCE_PCLK3:
          {
            frequency = HAL_RCC_GetPCLK3Freq();
 80134f4:	f7fb feac 	bl	800f250 <HAL_RCC_GetPCLK3Freq>
 80134f8:	6378      	str	r0, [r7, #52]	@ 0x34
            break;
 80134fa:	e068      	b.n	80135ce <HAL_RCCEx_GetPeriphCLKFreq+0x1bb6>
          }
          case RCC_LPTIM4CLKSOURCE_PLL2P:
          {
            HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 80134fc:	f107 0314 	add.w	r3, r7, #20
 8013500:	4618      	mov	r0, r3
 8013502:	f7fd ffb1 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
            frequency = pll2_clocks.PLL2_P_Frequency;
 8013506:	697b      	ldr	r3, [r7, #20]
 8013508:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 801350a:	e060      	b.n	80135ce <HAL_RCCEx_GetPeriphCLKFreq+0x1bb6>
          }
          case RCC_LPTIM4CLKSOURCE_PLL3R:
          {
            HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 801350c:	f107 0308 	add.w	r3, r7, #8
 8013510:	4618      	mov	r0, r3
 8013512:	f7fe f915 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
            frequency = pll3_clocks.PLL3_R_Frequency;
 8013516:	693b      	ldr	r3, [r7, #16]
 8013518:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 801351a:	e058      	b.n	80135ce <HAL_RCCEx_GetPeriphCLKFreq+0x1bb6>
          }
          case RCC_LPTIM4CLKSOURCE_LSE:
          {
            if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
 801351c:	4b7c      	ldr	r3, [pc, #496]	@ (8013710 <HAL_RCCEx_GetPeriphCLKFreq+0x1cf8>)
 801351e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8013522:	f003 0302 	and.w	r3, r3, #2
 8013526:	2b02      	cmp	r3, #2
 8013528:	d103      	bne.n	8013532 <HAL_RCCEx_GetPeriphCLKFreq+0x1b1a>
            {
              frequency = LSE_VALUE;
 801352a:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 801352e:	637b      	str	r3, [r7, #52]	@ 0x34
            }
            else
            {
              frequency = 0;
            }
            break;
 8013530:	e04d      	b.n	80135ce <HAL_RCCEx_GetPeriphCLKFreq+0x1bb6>
              frequency = 0;
 8013532:	2300      	movs	r3, #0
 8013534:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013536:	e04a      	b.n	80135ce <HAL_RCCEx_GetPeriphCLKFreq+0x1bb6>
          }
          case RCC_LPTIM4CLKSOURCE_LSI:
          {
            if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY))
 8013538:	4b75      	ldr	r3, [pc, #468]	@ (8013710 <HAL_RCCEx_GetPeriphCLKFreq+0x1cf8>)
 801353a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 801353e:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8013542:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8013546:	d103      	bne.n	8013550 <HAL_RCCEx_GetPeriphCLKFreq+0x1b38>
            {
              frequency = LSI_VALUE;
 8013548:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 801354c:	637b      	str	r3, [r7, #52]	@ 0x34
            }
            else
            {
              frequency = 0;
            }
            break;
 801354e:	e03e      	b.n	80135ce <HAL_RCCEx_GetPeriphCLKFreq+0x1bb6>
              frequency = 0;
 8013550:	2300      	movs	r3, #0
 8013552:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013554:	e03b      	b.n	80135ce <HAL_RCCEx_GetPeriphCLKFreq+0x1bb6>
          }
          case RCC_LPTIM4CLKSOURCE_CLKP: /* CLKP is the clock source for LPTIM4 */
          {
            ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 8013556:	4b6e      	ldr	r3, [pc, #440]	@ (8013710 <HAL_RCCEx_GetPeriphCLKFreq+0x1cf8>)
 8013558:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 801355c:	f003 4340 	and.w	r3, r3, #3221225472	@ 0xc0000000
 8013560:	62fb      	str	r3, [r7, #44]	@ 0x2c

            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 8013562:	4b6b      	ldr	r3, [pc, #428]	@ (8013710 <HAL_RCCEx_GetPeriphCLKFreq+0x1cf8>)
 8013564:	681b      	ldr	r3, [r3, #0]
 8013566:	f003 0302 	and.w	r3, r3, #2
 801356a:	2b02      	cmp	r3, #2
 801356c:	d10c      	bne.n	8013588 <HAL_RCCEx_GetPeriphCLKFreq+0x1b70>
 801356e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013570:	2b00      	cmp	r3, #0
 8013572:	d109      	bne.n	8013588 <HAL_RCCEx_GetPeriphCLKFreq+0x1b70>
            {
              /* In Case the CKPER Source is HSI */
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8013574:	4b66      	ldr	r3, [pc, #408]	@ (8013710 <HAL_RCCEx_GetPeriphCLKFreq+0x1cf8>)
 8013576:	681b      	ldr	r3, [r3, #0]
 8013578:	08db      	lsrs	r3, r3, #3
 801357a:	f003 0303 	and.w	r3, r3, #3
 801357e:	4a65      	ldr	r2, [pc, #404]	@ (8013714 <HAL_RCCEx_GetPeriphCLKFreq+0x1cfc>)
 8013580:	fa22 f303 	lsr.w	r3, r2, r3
 8013584:	637b      	str	r3, [r7, #52]	@ 0x34
 8013586:	e01e      	b.n	80135c6 <HAL_RCCEx_GetPeriphCLKFreq+0x1bae>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 8013588:	4b61      	ldr	r3, [pc, #388]	@ (8013710 <HAL_RCCEx_GetPeriphCLKFreq+0x1cf8>)
 801358a:	681b      	ldr	r3, [r3, #0]
 801358c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8013590:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8013594:	d106      	bne.n	80135a4 <HAL_RCCEx_GetPeriphCLKFreq+0x1b8c>
 8013596:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013598:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 801359c:	d102      	bne.n	80135a4 <HAL_RCCEx_GetPeriphCLKFreq+0x1b8c>
            {
              /* In Case the CKPER Source is CSI */
              frequency = CSI_VALUE;
 801359e:	4b5e      	ldr	r3, [pc, #376]	@ (8013718 <HAL_RCCEx_GetPeriphCLKFreq+0x1d00>)
 80135a0:	637b      	str	r3, [r7, #52]	@ 0x34
 80135a2:	e010      	b.n	80135c6 <HAL_RCCEx_GetPeriphCLKFreq+0x1bae>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 80135a4:	4b5a      	ldr	r3, [pc, #360]	@ (8013710 <HAL_RCCEx_GetPeriphCLKFreq+0x1cf8>)
 80135a6:	681b      	ldr	r3, [r3, #0]
 80135a8:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80135ac:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 80135b0:	d106      	bne.n	80135c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1ba8>
 80135b2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80135b4:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 80135b8:	d102      	bne.n	80135c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1ba8>
            {
              /* In Case the CKPER Source is HSE */
              frequency = HSE_VALUE;
 80135ba:	4b58      	ldr	r3, [pc, #352]	@ (801371c <HAL_RCCEx_GetPeriphCLKFreq+0x1d04>)
 80135bc:	637b      	str	r3, [r7, #52]	@ 0x34
 80135be:	e002      	b.n	80135c6 <HAL_RCCEx_GetPeriphCLKFreq+0x1bae>
            }

            else
            {
              /* In Case the CKPER is disabled*/
              frequency = 0;
 80135c0:	2300      	movs	r3, #0
 80135c2:	637b      	str	r3, [r7, #52]	@ 0x34
            }

            break;
 80135c4:	e003      	b.n	80135ce <HAL_RCCEx_GetPeriphCLKFreq+0x1bb6>
 80135c6:	e002      	b.n	80135ce <HAL_RCCEx_GetPeriphCLKFreq+0x1bb6>
          }
          default :
          {
            frequency = 0U;
 80135c8:	2300      	movs	r3, #0
 80135ca:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 80135cc:	bf00      	nop
          }
        }
        break;
 80135ce:	f000 bd6e 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* LPTIM4 */

#if defined(LPTIM5)
      case RCC_PERIPHCLK_LPTIM5:
        /* Get the current LPTIM5 source */
        srcclk = __HAL_RCC_GET_LPTIM5_SOURCE();
 80135d2:	4b4f      	ldr	r3, [pc, #316]	@ (8013710 <HAL_RCCEx_GetPeriphCLKFreq+0x1cf8>)
 80135d4:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 80135d8:	f003 63e0 	and.w	r3, r3, #117440512	@ 0x7000000
 80135dc:	633b      	str	r3, [r7, #48]	@ 0x30

        switch (srcclk)
 80135de:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80135e0:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
 80135e4:	d056      	beq.n	8013694 <HAL_RCCEx_GetPeriphCLKFreq+0x1c7c>
 80135e6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80135e8:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
 80135ec:	f200 808b 	bhi.w	8013706 <HAL_RCCEx_GetPeriphCLKFreq+0x1cee>
 80135f0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80135f2:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 80135f6:	d03e      	beq.n	8013676 <HAL_RCCEx_GetPeriphCLKFreq+0x1c5e>
 80135f8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80135fa:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 80135fe:	f200 8082 	bhi.w	8013706 <HAL_RCCEx_GetPeriphCLKFreq+0x1cee>
 8013602:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013604:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 8013608:	d027      	beq.n	801365a <HAL_RCCEx_GetPeriphCLKFreq+0x1c42>
 801360a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801360c:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 8013610:	d879      	bhi.n	8013706 <HAL_RCCEx_GetPeriphCLKFreq+0x1cee>
 8013612:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013614:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8013618:	d017      	beq.n	801364a <HAL_RCCEx_GetPeriphCLKFreq+0x1c32>
 801361a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801361c:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8013620:	d871      	bhi.n	8013706 <HAL_RCCEx_GetPeriphCLKFreq+0x1cee>
 8013622:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013624:	2b00      	cmp	r3, #0
 8013626:	d004      	beq.n	8013632 <HAL_RCCEx_GetPeriphCLKFreq+0x1c1a>
 8013628:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801362a:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 801362e:	d004      	beq.n	801363a <HAL_RCCEx_GetPeriphCLKFreq+0x1c22>
 8013630:	e069      	b.n	8013706 <HAL_RCCEx_GetPeriphCLKFreq+0x1cee>
        {
          case RCC_LPTIM5CLKSOURCE_PCLK3:
          {
            frequency = HAL_RCC_GetPCLK3Freq();
 8013632:	f7fb fe0d 	bl	800f250 <HAL_RCC_GetPCLK3Freq>
 8013636:	6378      	str	r0, [r7, #52]	@ 0x34
            break;
 8013638:	e068      	b.n	801370c <HAL_RCCEx_GetPeriphCLKFreq+0x1cf4>
          }
          case RCC_LPTIM5CLKSOURCE_PLL2P:
          {
            HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 801363a:	f107 0314 	add.w	r3, r7, #20
 801363e:	4618      	mov	r0, r3
 8013640:	f7fd ff12 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
            frequency = pll2_clocks.PLL2_P_Frequency;
 8013644:	697b      	ldr	r3, [r7, #20]
 8013646:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013648:	e060      	b.n	801370c <HAL_RCCEx_GetPeriphCLKFreq+0x1cf4>
          }
          case RCC_LPTIM5CLKSOURCE_PLL3R:
          {
            HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 801364a:	f107 0308 	add.w	r3, r7, #8
 801364e:	4618      	mov	r0, r3
 8013650:	f7fe f876 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
            frequency = pll3_clocks.PLL3_R_Frequency;
 8013654:	693b      	ldr	r3, [r7, #16]
 8013656:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013658:	e058      	b.n	801370c <HAL_RCCEx_GetPeriphCLKFreq+0x1cf4>
          }
          case RCC_LPTIM5CLKSOURCE_LSE:
          {
            if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
 801365a:	4b2d      	ldr	r3, [pc, #180]	@ (8013710 <HAL_RCCEx_GetPeriphCLKFreq+0x1cf8>)
 801365c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8013660:	f003 0302 	and.w	r3, r3, #2
 8013664:	2b02      	cmp	r3, #2
 8013666:	d103      	bne.n	8013670 <HAL_RCCEx_GetPeriphCLKFreq+0x1c58>
            {
              frequency = LSE_VALUE;
 8013668:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 801366c:	637b      	str	r3, [r7, #52]	@ 0x34
            }
            else
            {
              frequency = 0;
            }
            break;
 801366e:	e04d      	b.n	801370c <HAL_RCCEx_GetPeriphCLKFreq+0x1cf4>
              frequency = 0;
 8013670:	2300      	movs	r3, #0
 8013672:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013674:	e04a      	b.n	801370c <HAL_RCCEx_GetPeriphCLKFreq+0x1cf4>
          }
          case RCC_LPTIM5CLKSOURCE_LSI:
          {
            if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY))
 8013676:	4b26      	ldr	r3, [pc, #152]	@ (8013710 <HAL_RCCEx_GetPeriphCLKFreq+0x1cf8>)
 8013678:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 801367c:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8013680:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8013684:	d103      	bne.n	801368e <HAL_RCCEx_GetPeriphCLKFreq+0x1c76>
            {
              frequency = LSI_VALUE;
 8013686:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 801368a:	637b      	str	r3, [r7, #52]	@ 0x34
            }
            else
            {
              frequency = 0;
            }
            break;
 801368c:	e03e      	b.n	801370c <HAL_RCCEx_GetPeriphCLKFreq+0x1cf4>
              frequency = 0;
 801368e:	2300      	movs	r3, #0
 8013690:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013692:	e03b      	b.n	801370c <HAL_RCCEx_GetPeriphCLKFreq+0x1cf4>
          }
          case RCC_LPTIM5CLKSOURCE_CLKP: /* CLKP is the clock source for LPTIM5 */
          {
            ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 8013694:	4b1e      	ldr	r3, [pc, #120]	@ (8013710 <HAL_RCCEx_GetPeriphCLKFreq+0x1cf8>)
 8013696:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 801369a:	f003 4340 	and.w	r3, r3, #3221225472	@ 0xc0000000
 801369e:	62fb      	str	r3, [r7, #44]	@ 0x2c

            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 80136a0:	4b1b      	ldr	r3, [pc, #108]	@ (8013710 <HAL_RCCEx_GetPeriphCLKFreq+0x1cf8>)
 80136a2:	681b      	ldr	r3, [r3, #0]
 80136a4:	f003 0302 	and.w	r3, r3, #2
 80136a8:	2b02      	cmp	r3, #2
 80136aa:	d10c      	bne.n	80136c6 <HAL_RCCEx_GetPeriphCLKFreq+0x1cae>
 80136ac:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80136ae:	2b00      	cmp	r3, #0
 80136b0:	d109      	bne.n	80136c6 <HAL_RCCEx_GetPeriphCLKFreq+0x1cae>
            {
              /* In Case the CKPER Source is HSI */
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 80136b2:	4b17      	ldr	r3, [pc, #92]	@ (8013710 <HAL_RCCEx_GetPeriphCLKFreq+0x1cf8>)
 80136b4:	681b      	ldr	r3, [r3, #0]
 80136b6:	08db      	lsrs	r3, r3, #3
 80136b8:	f003 0303 	and.w	r3, r3, #3
 80136bc:	4a15      	ldr	r2, [pc, #84]	@ (8013714 <HAL_RCCEx_GetPeriphCLKFreq+0x1cfc>)
 80136be:	fa22 f303 	lsr.w	r3, r2, r3
 80136c2:	637b      	str	r3, [r7, #52]	@ 0x34
 80136c4:	e01e      	b.n	8013704 <HAL_RCCEx_GetPeriphCLKFreq+0x1cec>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 80136c6:	4b12      	ldr	r3, [pc, #72]	@ (8013710 <HAL_RCCEx_GetPeriphCLKFreq+0x1cf8>)
 80136c8:	681b      	ldr	r3, [r3, #0]
 80136ca:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 80136ce:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80136d2:	d106      	bne.n	80136e2 <HAL_RCCEx_GetPeriphCLKFreq+0x1cca>
 80136d4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80136d6:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 80136da:	d102      	bne.n	80136e2 <HAL_RCCEx_GetPeriphCLKFreq+0x1cca>
            {
              /* In Case the CKPER Source is CSI */
              frequency = CSI_VALUE;
 80136dc:	4b0e      	ldr	r3, [pc, #56]	@ (8013718 <HAL_RCCEx_GetPeriphCLKFreq+0x1d00>)
 80136de:	637b      	str	r3, [r7, #52]	@ 0x34
 80136e0:	e010      	b.n	8013704 <HAL_RCCEx_GetPeriphCLKFreq+0x1cec>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 80136e2:	4b0b      	ldr	r3, [pc, #44]	@ (8013710 <HAL_RCCEx_GetPeriphCLKFreq+0x1cf8>)
 80136e4:	681b      	ldr	r3, [r3, #0]
 80136e6:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80136ea:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 80136ee:	d106      	bne.n	80136fe <HAL_RCCEx_GetPeriphCLKFreq+0x1ce6>
 80136f0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80136f2:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 80136f6:	d102      	bne.n	80136fe <HAL_RCCEx_GetPeriphCLKFreq+0x1ce6>
            {
              /* In Case the CKPER Source is HSE */
              frequency = HSE_VALUE;
 80136f8:	4b08      	ldr	r3, [pc, #32]	@ (801371c <HAL_RCCEx_GetPeriphCLKFreq+0x1d04>)
 80136fa:	637b      	str	r3, [r7, #52]	@ 0x34
 80136fc:	e002      	b.n	8013704 <HAL_RCCEx_GetPeriphCLKFreq+0x1cec>
            }

            else
            {
              /* In Case the CKPER is disabled*/
              frequency = 0;
 80136fe:	2300      	movs	r3, #0
 8013700:	637b      	str	r3, [r7, #52]	@ 0x34
            }

            break;
 8013702:	e003      	b.n	801370c <HAL_RCCEx_GetPeriphCLKFreq+0x1cf4>
 8013704:	e002      	b.n	801370c <HAL_RCCEx_GetPeriphCLKFreq+0x1cf4>
          }
          default :
          {
            frequency = 0U;
 8013706:	2300      	movs	r3, #0
 8013708:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 801370a:	bf00      	nop
          }
        }
        break;
 801370c:	f000 bccf 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8013710:	44020c00 	.word	0x44020c00
 8013714:	03d09000 	.word	0x03d09000
 8013718:	003d0900 	.word	0x003d0900
 801371c:	017d7840 	.word	0x017d7840
#endif /* LPTIM5 */

#if defined(LPTIM6)
      case RCC_PERIPHCLK_LPTIM6:
        /* Get the current LPTIM6 source */
        srcclk = __HAL_RCC_GET_LPTIM6_SOURCE();
 8013720:	4b9e      	ldr	r3, [pc, #632]	@ (801399c <HAL_RCCEx_GetPeriphCLKFreq+0x1f84>)
 8013722:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 8013726:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
 801372a:	633b      	str	r3, [r7, #48]	@ 0x30

        switch (srcclk)
 801372c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801372e:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8013732:	d056      	beq.n	80137e2 <HAL_RCCEx_GetPeriphCLKFreq+0x1dca>
 8013734:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013736:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 801373a:	f200 808b 	bhi.w	8013854 <HAL_RCCEx_GetPeriphCLKFreq+0x1e3c>
 801373e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013740:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8013744:	d03e      	beq.n	80137c4 <HAL_RCCEx_GetPeriphCLKFreq+0x1dac>
 8013746:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013748:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 801374c:	f200 8082 	bhi.w	8013854 <HAL_RCCEx_GetPeriphCLKFreq+0x1e3c>
 8013750:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013752:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 8013756:	d027      	beq.n	80137a8 <HAL_RCCEx_GetPeriphCLKFreq+0x1d90>
 8013758:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801375a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 801375e:	d879      	bhi.n	8013854 <HAL_RCCEx_GetPeriphCLKFreq+0x1e3c>
 8013760:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013762:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8013766:	d017      	beq.n	8013798 <HAL_RCCEx_GetPeriphCLKFreq+0x1d80>
 8013768:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801376a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 801376e:	d871      	bhi.n	8013854 <HAL_RCCEx_GetPeriphCLKFreq+0x1e3c>
 8013770:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013772:	2b00      	cmp	r3, #0
 8013774:	d004      	beq.n	8013780 <HAL_RCCEx_GetPeriphCLKFreq+0x1d68>
 8013776:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013778:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 801377c:	d004      	beq.n	8013788 <HAL_RCCEx_GetPeriphCLKFreq+0x1d70>
 801377e:	e069      	b.n	8013854 <HAL_RCCEx_GetPeriphCLKFreq+0x1e3c>
        {
          case RCC_LPTIM6CLKSOURCE_PCLK3:
          {
            frequency = HAL_RCC_GetPCLK3Freq();
 8013780:	f7fb fd66 	bl	800f250 <HAL_RCC_GetPCLK3Freq>
 8013784:	6378      	str	r0, [r7, #52]	@ 0x34
            break;
 8013786:	e068      	b.n	801385a <HAL_RCCEx_GetPeriphCLKFreq+0x1e42>
          }
          case RCC_LPTIM6CLKSOURCE_PLL2P:
          {
            HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8013788:	f107 0314 	add.w	r3, r7, #20
 801378c:	4618      	mov	r0, r3
 801378e:	f7fd fe6b 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
            frequency = pll2_clocks.PLL2_P_Frequency;
 8013792:	697b      	ldr	r3, [r7, #20]
 8013794:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013796:	e060      	b.n	801385a <HAL_RCCEx_GetPeriphCLKFreq+0x1e42>
          }
          case RCC_LPTIM6CLKSOURCE_PLL3R:
          {
            HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8013798:	f107 0308 	add.w	r3, r7, #8
 801379c:	4618      	mov	r0, r3
 801379e:	f7fd ffcf 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
            frequency = pll3_clocks.PLL3_R_Frequency;
 80137a2:	693b      	ldr	r3, [r7, #16]
 80137a4:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 80137a6:	e058      	b.n	801385a <HAL_RCCEx_GetPeriphCLKFreq+0x1e42>
          }
          case RCC_LPTIM6CLKSOURCE_LSE:
          {
            if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
 80137a8:	4b7c      	ldr	r3, [pc, #496]	@ (801399c <HAL_RCCEx_GetPeriphCLKFreq+0x1f84>)
 80137aa:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80137ae:	f003 0302 	and.w	r3, r3, #2
 80137b2:	2b02      	cmp	r3, #2
 80137b4:	d103      	bne.n	80137be <HAL_RCCEx_GetPeriphCLKFreq+0x1da6>
            {
              frequency = LSE_VALUE;
 80137b6:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80137ba:	637b      	str	r3, [r7, #52]	@ 0x34
            }
            else
            {
              frequency = 0;
            }
            break;
 80137bc:	e04d      	b.n	801385a <HAL_RCCEx_GetPeriphCLKFreq+0x1e42>
              frequency = 0;
 80137be:	2300      	movs	r3, #0
 80137c0:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 80137c2:	e04a      	b.n	801385a <HAL_RCCEx_GetPeriphCLKFreq+0x1e42>
          }
          case RCC_LPTIM6CLKSOURCE_LSI:
          {
            if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY))
 80137c4:	4b75      	ldr	r3, [pc, #468]	@ (801399c <HAL_RCCEx_GetPeriphCLKFreq+0x1f84>)
 80137c6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80137ca:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 80137ce:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 80137d2:	d103      	bne.n	80137dc <HAL_RCCEx_GetPeriphCLKFreq+0x1dc4>
            {
              frequency = LSI_VALUE;
 80137d4:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 80137d8:	637b      	str	r3, [r7, #52]	@ 0x34
            }
            else
            {
              frequency = 0;
            }
            break;
 80137da:	e03e      	b.n	801385a <HAL_RCCEx_GetPeriphCLKFreq+0x1e42>
              frequency = 0;
 80137dc:	2300      	movs	r3, #0
 80137de:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 80137e0:	e03b      	b.n	801385a <HAL_RCCEx_GetPeriphCLKFreq+0x1e42>
          }
          case RCC_LPTIM6CLKSOURCE_CLKP: /* CLKP is the clock source for LPTIM6 */
          {
            ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 80137e2:	4b6e      	ldr	r3, [pc, #440]	@ (801399c <HAL_RCCEx_GetPeriphCLKFreq+0x1f84>)
 80137e4:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 80137e8:	f003 4340 	and.w	r3, r3, #3221225472	@ 0xc0000000
 80137ec:	62fb      	str	r3, [r7, #44]	@ 0x2c

            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 80137ee:	4b6b      	ldr	r3, [pc, #428]	@ (801399c <HAL_RCCEx_GetPeriphCLKFreq+0x1f84>)
 80137f0:	681b      	ldr	r3, [r3, #0]
 80137f2:	f003 0302 	and.w	r3, r3, #2
 80137f6:	2b02      	cmp	r3, #2
 80137f8:	d10c      	bne.n	8013814 <HAL_RCCEx_GetPeriphCLKFreq+0x1dfc>
 80137fa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80137fc:	2b00      	cmp	r3, #0
 80137fe:	d109      	bne.n	8013814 <HAL_RCCEx_GetPeriphCLKFreq+0x1dfc>
            {
              /* In Case the CKPER Source is HSI */
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8013800:	4b66      	ldr	r3, [pc, #408]	@ (801399c <HAL_RCCEx_GetPeriphCLKFreq+0x1f84>)
 8013802:	681b      	ldr	r3, [r3, #0]
 8013804:	08db      	lsrs	r3, r3, #3
 8013806:	f003 0303 	and.w	r3, r3, #3
 801380a:	4a65      	ldr	r2, [pc, #404]	@ (80139a0 <HAL_RCCEx_GetPeriphCLKFreq+0x1f88>)
 801380c:	fa22 f303 	lsr.w	r3, r2, r3
 8013810:	637b      	str	r3, [r7, #52]	@ 0x34
 8013812:	e01e      	b.n	8013852 <HAL_RCCEx_GetPeriphCLKFreq+0x1e3a>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 8013814:	4b61      	ldr	r3, [pc, #388]	@ (801399c <HAL_RCCEx_GetPeriphCLKFreq+0x1f84>)
 8013816:	681b      	ldr	r3, [r3, #0]
 8013818:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 801381c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8013820:	d106      	bne.n	8013830 <HAL_RCCEx_GetPeriphCLKFreq+0x1e18>
 8013822:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013824:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8013828:	d102      	bne.n	8013830 <HAL_RCCEx_GetPeriphCLKFreq+0x1e18>
            {
              /* In Case the CKPER Source is CSI */
              frequency = CSI_VALUE;
 801382a:	4b5e      	ldr	r3, [pc, #376]	@ (80139a4 <HAL_RCCEx_GetPeriphCLKFreq+0x1f8c>)
 801382c:	637b      	str	r3, [r7, #52]	@ 0x34
 801382e:	e010      	b.n	8013852 <HAL_RCCEx_GetPeriphCLKFreq+0x1e3a>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8013830:	4b5a      	ldr	r3, [pc, #360]	@ (801399c <HAL_RCCEx_GetPeriphCLKFreq+0x1f84>)
 8013832:	681b      	ldr	r3, [r3, #0]
 8013834:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8013838:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 801383c:	d106      	bne.n	801384c <HAL_RCCEx_GetPeriphCLKFreq+0x1e34>
 801383e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013840:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8013844:	d102      	bne.n	801384c <HAL_RCCEx_GetPeriphCLKFreq+0x1e34>
            {
              /* In Case the CKPER Source is HSE */
              frequency = HSE_VALUE;
 8013846:	4b58      	ldr	r3, [pc, #352]	@ (80139a8 <HAL_RCCEx_GetPeriphCLKFreq+0x1f90>)
 8013848:	637b      	str	r3, [r7, #52]	@ 0x34
 801384a:	e002      	b.n	8013852 <HAL_RCCEx_GetPeriphCLKFreq+0x1e3a>
            }

            else
            {
              /* In Case the CKPER is disabled*/
              frequency = 0;
 801384c:	2300      	movs	r3, #0
 801384e:	637b      	str	r3, [r7, #52]	@ 0x34
            }

            break;
 8013850:	e003      	b.n	801385a <HAL_RCCEx_GetPeriphCLKFreq+0x1e42>
 8013852:	e002      	b.n	801385a <HAL_RCCEx_GetPeriphCLKFreq+0x1e42>
          }
          default :
          {
            frequency = 0U;
 8013854:	2300      	movs	r3, #0
 8013856:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013858:	bf00      	nop
          }
        }
        break;
 801385a:	f000 bc28 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* LPTIM6 */

      case RCC_PERIPHCLK_FDCAN:
        /* Get the current FDCAN kernel source */
        srcclk = __HAL_RCC_GET_FDCAN_SOURCE();
 801385e:	4b4f      	ldr	r3, [pc, #316]	@ (801399c <HAL_RCCEx_GetPeriphCLKFreq+0x1f84>)
 8013860:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8013864:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8013868:	633b      	str	r3, [r7, #48]	@ 0x30

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_FDCANCLKSOURCE_HSE))
 801386a:	4b4c      	ldr	r3, [pc, #304]	@ (801399c <HAL_RCCEx_GetPeriphCLKFreq+0x1f84>)
 801386c:	681b      	ldr	r3, [r3, #0]
 801386e:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8013872:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8013876:	d106      	bne.n	8013886 <HAL_RCCEx_GetPeriphCLKFreq+0x1e6e>
 8013878:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801387a:	2b00      	cmp	r3, #0
 801387c:	d103      	bne.n	8013886 <HAL_RCCEx_GetPeriphCLKFreq+0x1e6e>
        {
          frequency = HSE_VALUE;
 801387e:	4b4a      	ldr	r3, [pc, #296]	@ (80139a8 <HAL_RCCEx_GetPeriphCLKFreq+0x1f90>)
 8013880:	637b      	str	r3, [r7, #52]	@ 0x34
        /* Clock not enabled for FDCAN */
        else
        {
          frequency = 0U;
        }
        break;
 8013882:	f000 bc14 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if (srcclk == RCC_FDCANCLKSOURCE_PLL1Q)
 8013886:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013888:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 801388c:	d108      	bne.n	80138a0 <HAL_RCCEx_GetPeriphCLKFreq+0x1e88>
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 801388e:	f107 0320 	add.w	r3, r7, #32
 8013892:	4618      	mov	r0, r3
 8013894:	f7fd fc7c 	bl	8011190 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 8013898:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801389a:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 801389c:	f000 bc07 	b.w	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if (srcclk == RCC_FDCANCLKSOURCE_PLL2Q)
 80138a0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80138a2:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80138a6:	d107      	bne.n	80138b8 <HAL_RCCEx_GetPeriphCLKFreq+0x1ea0>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 80138a8:	f107 0314 	add.w	r3, r7, #20
 80138ac:	4618      	mov	r0, r3
 80138ae:	f7fd fddb 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 80138b2:	69bb      	ldr	r3, [r7, #24]
 80138b4:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80138b6:	e3fa      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
          frequency = 0U;
 80138b8:	2300      	movs	r3, #0
 80138ba:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80138bc:	e3f7      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>

      case RCC_PERIPHCLK_SPI1:
        /* Get the current SPI1 kernel source */
        srcclk = __HAL_RCC_GET_SPI1_SOURCE();
 80138be:	4b37      	ldr	r3, [pc, #220]	@ (801399c <HAL_RCCEx_GetPeriphCLKFreq+0x1f84>)
 80138c0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80138c4:	f003 0307 	and.w	r3, r3, #7
 80138c8:	633b      	str	r3, [r7, #48]	@ 0x30
        switch (srcclk)
 80138ca:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80138cc:	2b04      	cmp	r3, #4
 80138ce:	d861      	bhi.n	8013994 <HAL_RCCEx_GetPeriphCLKFreq+0x1f7c>
 80138d0:	a201      	add	r2, pc, #4	@ (adr r2, 80138d8 <HAL_RCCEx_GetPeriphCLKFreq+0x1ec0>)
 80138d2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80138d6:	bf00      	nop
 80138d8:	080138ed 	.word	0x080138ed
 80138dc:	080138fd 	.word	0x080138fd
 80138e0:	0801390d 	.word	0x0801390d
 80138e4:	0801391d 	.word	0x0801391d
 80138e8:	08013923 	.word	0x08013923
        {
          case RCC_SPI1CLKSOURCE_PLL1Q:
          {
            HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 80138ec:	f107 0320 	add.w	r3, r7, #32
 80138f0:	4618      	mov	r0, r3
 80138f2:	f7fd fc4d 	bl	8011190 <HAL_RCCEx_GetPLL1ClockFreq>
            frequency = pll1_clocks.PLL1_Q_Frequency;
 80138f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80138f8:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 80138fa:	e04e      	b.n	801399a <HAL_RCCEx_GetPeriphCLKFreq+0x1f82>
          }
          case RCC_SPI1CLKSOURCE_PLL2P:
          {
            HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 80138fc:	f107 0314 	add.w	r3, r7, #20
 8013900:	4618      	mov	r0, r3
 8013902:	f7fd fdb1 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
            frequency = pll2_clocks.PLL2_P_Frequency;
 8013906:	697b      	ldr	r3, [r7, #20]
 8013908:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 801390a:	e046      	b.n	801399a <HAL_RCCEx_GetPeriphCLKFreq+0x1f82>
          }
#if defined(RCC_SPI1CLKSOURCE_PLL3P)
          case RCC_SPI1CLKSOURCE_PLL3P:
          {
            HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 801390c:	f107 0308 	add.w	r3, r7, #8
 8013910:	4618      	mov	r0, r3
 8013912:	f7fd ff15 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
            frequency = pll3_clocks.PLL3_P_Frequency;
 8013916:	68bb      	ldr	r3, [r7, #8]
 8013918:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 801391a:	e03e      	b.n	801399a <HAL_RCCEx_GetPeriphCLKFreq+0x1f82>
          }
#endif /* RCC_SPI1CLKSOURCE_PLL3P */
          case RCC_SPI1CLKSOURCE_PIN:
          {
            frequency = EXTERNAL_CLOCK_VALUE;
 801391c:	4b23      	ldr	r3, [pc, #140]	@ (80139ac <HAL_RCCEx_GetPeriphCLKFreq+0x1f94>)
 801391e:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013920:	e03b      	b.n	801399a <HAL_RCCEx_GetPeriphCLKFreq+0x1f82>
          }
          case RCC_SPI1CLKSOURCE_CLKP:
          {
            ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 8013922:	4b1e      	ldr	r3, [pc, #120]	@ (801399c <HAL_RCCEx_GetPeriphCLKFreq+0x1f84>)
 8013924:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8013928:	f003 4340 	and.w	r3, r3, #3221225472	@ 0xc0000000
 801392c:	62fb      	str	r3, [r7, #44]	@ 0x2c

            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 801392e:	4b1b      	ldr	r3, [pc, #108]	@ (801399c <HAL_RCCEx_GetPeriphCLKFreq+0x1f84>)
 8013930:	681b      	ldr	r3, [r3, #0]
 8013932:	f003 0302 	and.w	r3, r3, #2
 8013936:	2b02      	cmp	r3, #2
 8013938:	d10c      	bne.n	8013954 <HAL_RCCEx_GetPeriphCLKFreq+0x1f3c>
 801393a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801393c:	2b00      	cmp	r3, #0
 801393e:	d109      	bne.n	8013954 <HAL_RCCEx_GetPeriphCLKFreq+0x1f3c>
            {
              /* In Case the CKPER Source is HSI */
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8013940:	4b16      	ldr	r3, [pc, #88]	@ (801399c <HAL_RCCEx_GetPeriphCLKFreq+0x1f84>)
 8013942:	681b      	ldr	r3, [r3, #0]
 8013944:	08db      	lsrs	r3, r3, #3
 8013946:	f003 0303 	and.w	r3, r3, #3
 801394a:	4a15      	ldr	r2, [pc, #84]	@ (80139a0 <HAL_RCCEx_GetPeriphCLKFreq+0x1f88>)
 801394c:	fa22 f303 	lsr.w	r3, r2, r3
 8013950:	637b      	str	r3, [r7, #52]	@ 0x34
 8013952:	e01e      	b.n	8013992 <HAL_RCCEx_GetPeriphCLKFreq+0x1f7a>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 8013954:	4b11      	ldr	r3, [pc, #68]	@ (801399c <HAL_RCCEx_GetPeriphCLKFreq+0x1f84>)
 8013956:	681b      	ldr	r3, [r3, #0]
 8013958:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 801395c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8013960:	d106      	bne.n	8013970 <HAL_RCCEx_GetPeriphCLKFreq+0x1f58>
 8013962:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013964:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8013968:	d102      	bne.n	8013970 <HAL_RCCEx_GetPeriphCLKFreq+0x1f58>
            {
              /* In Case the CKPER Source is CSI */
              frequency = CSI_VALUE;
 801396a:	4b0e      	ldr	r3, [pc, #56]	@ (80139a4 <HAL_RCCEx_GetPeriphCLKFreq+0x1f8c>)
 801396c:	637b      	str	r3, [r7, #52]	@ 0x34
 801396e:	e010      	b.n	8013992 <HAL_RCCEx_GetPeriphCLKFreq+0x1f7a>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8013970:	4b0a      	ldr	r3, [pc, #40]	@ (801399c <HAL_RCCEx_GetPeriphCLKFreq+0x1f84>)
 8013972:	681b      	ldr	r3, [r3, #0]
 8013974:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8013978:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 801397c:	d106      	bne.n	801398c <HAL_RCCEx_GetPeriphCLKFreq+0x1f74>
 801397e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013980:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8013984:	d102      	bne.n	801398c <HAL_RCCEx_GetPeriphCLKFreq+0x1f74>
            {
              /* In Case the CKPER Source is HSE */
              frequency = HSE_VALUE;
 8013986:	4b08      	ldr	r3, [pc, #32]	@ (80139a8 <HAL_RCCEx_GetPeriphCLKFreq+0x1f90>)
 8013988:	637b      	str	r3, [r7, #52]	@ 0x34
 801398a:	e002      	b.n	8013992 <HAL_RCCEx_GetPeriphCLKFreq+0x1f7a>
            }

            else
            {
              /* In Case the CKPER is disabled*/
              frequency = 0;
 801398c:	2300      	movs	r3, #0
 801398e:	637b      	str	r3, [r7, #52]	@ 0x34
            }

            break;
 8013990:	e003      	b.n	801399a <HAL_RCCEx_GetPeriphCLKFreq+0x1f82>
 8013992:	e002      	b.n	801399a <HAL_RCCEx_GetPeriphCLKFreq+0x1f82>
          }
          default:
          {
            frequency = 0;
 8013994:	2300      	movs	r3, #0
 8013996:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013998:	bf00      	nop
          }
        }
        break;
 801399a:	e388      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 801399c:	44020c00 	.word	0x44020c00
 80139a0:	03d09000 	.word	0x03d09000
 80139a4:	003d0900 	.word	0x003d0900
 80139a8:	017d7840 	.word	0x017d7840
 80139ac:	00bb8000 	.word	0x00bb8000

      case RCC_PERIPHCLK_SPI2:
        /* Get the current SPI2 kernel source */
        srcclk = __HAL_RCC_GET_SPI2_SOURCE();
 80139b0:	4ba9      	ldr	r3, [pc, #676]	@ (8013c58 <HAL_RCCEx_GetPeriphCLKFreq+0x2240>)
 80139b2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80139b6:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 80139ba:	633b      	str	r3, [r7, #48]	@ 0x30
        switch (srcclk)
 80139bc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80139be:	2b20      	cmp	r3, #32
 80139c0:	f200 809a 	bhi.w	8013af8 <HAL_RCCEx_GetPeriphCLKFreq+0x20e0>
 80139c4:	a201      	add	r2, pc, #4	@ (adr r2, 80139cc <HAL_RCCEx_GetPeriphCLKFreq+0x1fb4>)
 80139c6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80139ca:	bf00      	nop
 80139cc:	08013a51 	.word	0x08013a51
 80139d0:	08013af9 	.word	0x08013af9
 80139d4:	08013af9 	.word	0x08013af9
 80139d8:	08013af9 	.word	0x08013af9
 80139dc:	08013af9 	.word	0x08013af9
 80139e0:	08013af9 	.word	0x08013af9
 80139e4:	08013af9 	.word	0x08013af9
 80139e8:	08013af9 	.word	0x08013af9
 80139ec:	08013a61 	.word	0x08013a61
 80139f0:	08013af9 	.word	0x08013af9
 80139f4:	08013af9 	.word	0x08013af9
 80139f8:	08013af9 	.word	0x08013af9
 80139fc:	08013af9 	.word	0x08013af9
 8013a00:	08013af9 	.word	0x08013af9
 8013a04:	08013af9 	.word	0x08013af9
 8013a08:	08013af9 	.word	0x08013af9
 8013a0c:	08013a71 	.word	0x08013a71
 8013a10:	08013af9 	.word	0x08013af9
 8013a14:	08013af9 	.word	0x08013af9
 8013a18:	08013af9 	.word	0x08013af9
 8013a1c:	08013af9 	.word	0x08013af9
 8013a20:	08013af9 	.word	0x08013af9
 8013a24:	08013af9 	.word	0x08013af9
 8013a28:	08013af9 	.word	0x08013af9
 8013a2c:	08013a81 	.word	0x08013a81
 8013a30:	08013af9 	.word	0x08013af9
 8013a34:	08013af9 	.word	0x08013af9
 8013a38:	08013af9 	.word	0x08013af9
 8013a3c:	08013af9 	.word	0x08013af9
 8013a40:	08013af9 	.word	0x08013af9
 8013a44:	08013af9 	.word	0x08013af9
 8013a48:	08013af9 	.word	0x08013af9
 8013a4c:	08013a87 	.word	0x08013a87
        {
          case RCC_SPI2CLKSOURCE_PLL1Q:
          {
            HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8013a50:	f107 0320 	add.w	r3, r7, #32
 8013a54:	4618      	mov	r0, r3
 8013a56:	f7fd fb9b 	bl	8011190 <HAL_RCCEx_GetPLL1ClockFreq>
            frequency = pll1_clocks.PLL1_Q_Frequency;
 8013a5a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013a5c:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013a5e:	e04e      	b.n	8013afe <HAL_RCCEx_GetPeriphCLKFreq+0x20e6>
          }
          case RCC_SPI2CLKSOURCE_PLL2P:
          {
            HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8013a60:	f107 0314 	add.w	r3, r7, #20
 8013a64:	4618      	mov	r0, r3
 8013a66:	f7fd fcff 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
            frequency = pll2_clocks.PLL2_P_Frequency;
 8013a6a:	697b      	ldr	r3, [r7, #20]
 8013a6c:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013a6e:	e046      	b.n	8013afe <HAL_RCCEx_GetPeriphCLKFreq+0x20e6>
          }
#if defined(RCC_SPI2CLKSOURCE_PLL3P)
          case RCC_SPI2CLKSOURCE_PLL3P:
          {
            HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8013a70:	f107 0308 	add.w	r3, r7, #8
 8013a74:	4618      	mov	r0, r3
 8013a76:	f7fd fe63 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
            frequency = pll3_clocks.PLL3_P_Frequency;
 8013a7a:	68bb      	ldr	r3, [r7, #8]
 8013a7c:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013a7e:	e03e      	b.n	8013afe <HAL_RCCEx_GetPeriphCLKFreq+0x20e6>
          }
#endif /* RCC_SPI2CLKSOURCE_PLL3P */
          case RCC_SPI2CLKSOURCE_PIN:
          {
            frequency = EXTERNAL_CLOCK_VALUE;
 8013a80:	4b76      	ldr	r3, [pc, #472]	@ (8013c5c <HAL_RCCEx_GetPeriphCLKFreq+0x2244>)
 8013a82:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013a84:	e03b      	b.n	8013afe <HAL_RCCEx_GetPeriphCLKFreq+0x20e6>
          }
          case RCC_SPI2CLKSOURCE_CLKP:
          {
            ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 8013a86:	4b74      	ldr	r3, [pc, #464]	@ (8013c58 <HAL_RCCEx_GetPeriphCLKFreq+0x2240>)
 8013a88:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8013a8c:	f003 4340 	and.w	r3, r3, #3221225472	@ 0xc0000000
 8013a90:	62fb      	str	r3, [r7, #44]	@ 0x2c

            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 8013a92:	4b71      	ldr	r3, [pc, #452]	@ (8013c58 <HAL_RCCEx_GetPeriphCLKFreq+0x2240>)
 8013a94:	681b      	ldr	r3, [r3, #0]
 8013a96:	f003 0302 	and.w	r3, r3, #2
 8013a9a:	2b02      	cmp	r3, #2
 8013a9c:	d10c      	bne.n	8013ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x20a0>
 8013a9e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013aa0:	2b00      	cmp	r3, #0
 8013aa2:	d109      	bne.n	8013ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x20a0>
            {
              /* In Case the CKPER Source is HSI */
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8013aa4:	4b6c      	ldr	r3, [pc, #432]	@ (8013c58 <HAL_RCCEx_GetPeriphCLKFreq+0x2240>)
 8013aa6:	681b      	ldr	r3, [r3, #0]
 8013aa8:	08db      	lsrs	r3, r3, #3
 8013aaa:	f003 0303 	and.w	r3, r3, #3
 8013aae:	4a6c      	ldr	r2, [pc, #432]	@ (8013c60 <HAL_RCCEx_GetPeriphCLKFreq+0x2248>)
 8013ab0:	fa22 f303 	lsr.w	r3, r2, r3
 8013ab4:	637b      	str	r3, [r7, #52]	@ 0x34
 8013ab6:	e01e      	b.n	8013af6 <HAL_RCCEx_GetPeriphCLKFreq+0x20de>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 8013ab8:	4b67      	ldr	r3, [pc, #412]	@ (8013c58 <HAL_RCCEx_GetPeriphCLKFreq+0x2240>)
 8013aba:	681b      	ldr	r3, [r3, #0]
 8013abc:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8013ac0:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8013ac4:	d106      	bne.n	8013ad4 <HAL_RCCEx_GetPeriphCLKFreq+0x20bc>
 8013ac6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013ac8:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8013acc:	d102      	bne.n	8013ad4 <HAL_RCCEx_GetPeriphCLKFreq+0x20bc>
            {
              /* In Case the CKPER Source is CSI */
              frequency = CSI_VALUE;
 8013ace:	4b65      	ldr	r3, [pc, #404]	@ (8013c64 <HAL_RCCEx_GetPeriphCLKFreq+0x224c>)
 8013ad0:	637b      	str	r3, [r7, #52]	@ 0x34
 8013ad2:	e010      	b.n	8013af6 <HAL_RCCEx_GetPeriphCLKFreq+0x20de>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8013ad4:	4b60      	ldr	r3, [pc, #384]	@ (8013c58 <HAL_RCCEx_GetPeriphCLKFreq+0x2240>)
 8013ad6:	681b      	ldr	r3, [r3, #0]
 8013ad8:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8013adc:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8013ae0:	d106      	bne.n	8013af0 <HAL_RCCEx_GetPeriphCLKFreq+0x20d8>
 8013ae2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013ae4:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8013ae8:	d102      	bne.n	8013af0 <HAL_RCCEx_GetPeriphCLKFreq+0x20d8>
            {
              /* In Case the CKPER Source is HSE */
              frequency = HSE_VALUE;
 8013aea:	4b5f      	ldr	r3, [pc, #380]	@ (8013c68 <HAL_RCCEx_GetPeriphCLKFreq+0x2250>)
 8013aec:	637b      	str	r3, [r7, #52]	@ 0x34
 8013aee:	e002      	b.n	8013af6 <HAL_RCCEx_GetPeriphCLKFreq+0x20de>
            }

            else
            {
              /* In Case the CKPER is disabled*/
              frequency = 0;
 8013af0:	2300      	movs	r3, #0
 8013af2:	637b      	str	r3, [r7, #52]	@ 0x34
            }

            break;
 8013af4:	e003      	b.n	8013afe <HAL_RCCEx_GetPeriphCLKFreq+0x20e6>
 8013af6:	e002      	b.n	8013afe <HAL_RCCEx_GetPeriphCLKFreq+0x20e6>
          }
          default:
          {
            frequency = 0;
 8013af8:	2300      	movs	r3, #0
 8013afa:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013afc:	bf00      	nop
          }
        }
        break;
 8013afe:	e2d6      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>

      case RCC_PERIPHCLK_SPI3:
        /* Get the current SPI3 kernel source */
        srcclk = __HAL_RCC_GET_SPI3_SOURCE();
 8013b00:	4b55      	ldr	r3, [pc, #340]	@ (8013c58 <HAL_RCCEx_GetPeriphCLKFreq+0x2240>)
 8013b02:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8013b06:	f403 73e0 	and.w	r3, r3, #448	@ 0x1c0
 8013b0a:	633b      	str	r3, [r7, #48]	@ 0x30
        switch (srcclk)
 8013b0c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013b0e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8013b12:	d031      	beq.n	8013b78 <HAL_RCCEx_GetPeriphCLKFreq+0x2160>
 8013b14:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013b16:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8013b1a:	d866      	bhi.n	8013bea <HAL_RCCEx_GetPeriphCLKFreq+0x21d2>
 8013b1c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013b1e:	2bc0      	cmp	r3, #192	@ 0xc0
 8013b20:	d027      	beq.n	8013b72 <HAL_RCCEx_GetPeriphCLKFreq+0x215a>
 8013b22:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013b24:	2bc0      	cmp	r3, #192	@ 0xc0
 8013b26:	d860      	bhi.n	8013bea <HAL_RCCEx_GetPeriphCLKFreq+0x21d2>
 8013b28:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013b2a:	2b80      	cmp	r3, #128	@ 0x80
 8013b2c:	d019      	beq.n	8013b62 <HAL_RCCEx_GetPeriphCLKFreq+0x214a>
 8013b2e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013b30:	2b80      	cmp	r3, #128	@ 0x80
 8013b32:	d85a      	bhi.n	8013bea <HAL_RCCEx_GetPeriphCLKFreq+0x21d2>
 8013b34:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013b36:	2b00      	cmp	r3, #0
 8013b38:	d003      	beq.n	8013b42 <HAL_RCCEx_GetPeriphCLKFreq+0x212a>
 8013b3a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013b3c:	2b40      	cmp	r3, #64	@ 0x40
 8013b3e:	d008      	beq.n	8013b52 <HAL_RCCEx_GetPeriphCLKFreq+0x213a>
 8013b40:	e053      	b.n	8013bea <HAL_RCCEx_GetPeriphCLKFreq+0x21d2>
        {
          case RCC_SPI3CLKSOURCE_PLL1Q:
          {
            HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8013b42:	f107 0320 	add.w	r3, r7, #32
 8013b46:	4618      	mov	r0, r3
 8013b48:	f7fd fb22 	bl	8011190 <HAL_RCCEx_GetPLL1ClockFreq>
            frequency = pll1_clocks.PLL1_Q_Frequency;
 8013b4c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013b4e:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013b50:	e04e      	b.n	8013bf0 <HAL_RCCEx_GetPeriphCLKFreq+0x21d8>
          }
          case RCC_SPI3CLKSOURCE_PLL2P:
          {
            HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8013b52:	f107 0314 	add.w	r3, r7, #20
 8013b56:	4618      	mov	r0, r3
 8013b58:	f7fd fc86 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
            frequency = pll2_clocks.PLL2_P_Frequency;
 8013b5c:	697b      	ldr	r3, [r7, #20]
 8013b5e:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013b60:	e046      	b.n	8013bf0 <HAL_RCCEx_GetPeriphCLKFreq+0x21d8>
          }
#if defined(RCC_SPI3CLKSOURCE_PLL3P)
          case RCC_SPI3CLKSOURCE_PLL3P:
          {
            HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8013b62:	f107 0308 	add.w	r3, r7, #8
 8013b66:	4618      	mov	r0, r3
 8013b68:	f7fd fdea 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
            frequency = pll3_clocks.PLL3_P_Frequency;
 8013b6c:	68bb      	ldr	r3, [r7, #8]
 8013b6e:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013b70:	e03e      	b.n	8013bf0 <HAL_RCCEx_GetPeriphCLKFreq+0x21d8>
          }
#endif /* RCC_SPI3CLKSOURCE_PLL3P */
          case RCC_SPI3CLKSOURCE_PIN:
          {
            frequency = EXTERNAL_CLOCK_VALUE;
 8013b72:	4b3a      	ldr	r3, [pc, #232]	@ (8013c5c <HAL_RCCEx_GetPeriphCLKFreq+0x2244>)
 8013b74:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013b76:	e03b      	b.n	8013bf0 <HAL_RCCEx_GetPeriphCLKFreq+0x21d8>
          }
          case RCC_SPI3CLKSOURCE_CLKP:
          {
            ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 8013b78:	4b37      	ldr	r3, [pc, #220]	@ (8013c58 <HAL_RCCEx_GetPeriphCLKFreq+0x2240>)
 8013b7a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8013b7e:	f003 4340 	and.w	r3, r3, #3221225472	@ 0xc0000000
 8013b82:	62fb      	str	r3, [r7, #44]	@ 0x2c

            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 8013b84:	4b34      	ldr	r3, [pc, #208]	@ (8013c58 <HAL_RCCEx_GetPeriphCLKFreq+0x2240>)
 8013b86:	681b      	ldr	r3, [r3, #0]
 8013b88:	f003 0302 	and.w	r3, r3, #2
 8013b8c:	2b02      	cmp	r3, #2
 8013b8e:	d10c      	bne.n	8013baa <HAL_RCCEx_GetPeriphCLKFreq+0x2192>
 8013b90:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013b92:	2b00      	cmp	r3, #0
 8013b94:	d109      	bne.n	8013baa <HAL_RCCEx_GetPeriphCLKFreq+0x2192>
            {
              /* In Case the CKPER Source is HSI */
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8013b96:	4b30      	ldr	r3, [pc, #192]	@ (8013c58 <HAL_RCCEx_GetPeriphCLKFreq+0x2240>)
 8013b98:	681b      	ldr	r3, [r3, #0]
 8013b9a:	08db      	lsrs	r3, r3, #3
 8013b9c:	f003 0303 	and.w	r3, r3, #3
 8013ba0:	4a2f      	ldr	r2, [pc, #188]	@ (8013c60 <HAL_RCCEx_GetPeriphCLKFreq+0x2248>)
 8013ba2:	fa22 f303 	lsr.w	r3, r2, r3
 8013ba6:	637b      	str	r3, [r7, #52]	@ 0x34
 8013ba8:	e01e      	b.n	8013be8 <HAL_RCCEx_GetPeriphCLKFreq+0x21d0>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 8013baa:	4b2b      	ldr	r3, [pc, #172]	@ (8013c58 <HAL_RCCEx_GetPeriphCLKFreq+0x2240>)
 8013bac:	681b      	ldr	r3, [r3, #0]
 8013bae:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8013bb2:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8013bb6:	d106      	bne.n	8013bc6 <HAL_RCCEx_GetPeriphCLKFreq+0x21ae>
 8013bb8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013bba:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8013bbe:	d102      	bne.n	8013bc6 <HAL_RCCEx_GetPeriphCLKFreq+0x21ae>
            {
              /* In Case the CKPER Source is CSI */
              frequency = CSI_VALUE;
 8013bc0:	4b28      	ldr	r3, [pc, #160]	@ (8013c64 <HAL_RCCEx_GetPeriphCLKFreq+0x224c>)
 8013bc2:	637b      	str	r3, [r7, #52]	@ 0x34
 8013bc4:	e010      	b.n	8013be8 <HAL_RCCEx_GetPeriphCLKFreq+0x21d0>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8013bc6:	4b24      	ldr	r3, [pc, #144]	@ (8013c58 <HAL_RCCEx_GetPeriphCLKFreq+0x2240>)
 8013bc8:	681b      	ldr	r3, [r3, #0]
 8013bca:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8013bce:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8013bd2:	d106      	bne.n	8013be2 <HAL_RCCEx_GetPeriphCLKFreq+0x21ca>
 8013bd4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013bd6:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8013bda:	d102      	bne.n	8013be2 <HAL_RCCEx_GetPeriphCLKFreq+0x21ca>
            {
              /* In Case the CKPER Source is HSE */
              frequency = HSE_VALUE;
 8013bdc:	4b22      	ldr	r3, [pc, #136]	@ (8013c68 <HAL_RCCEx_GetPeriphCLKFreq+0x2250>)
 8013bde:	637b      	str	r3, [r7, #52]	@ 0x34
 8013be0:	e002      	b.n	8013be8 <HAL_RCCEx_GetPeriphCLKFreq+0x21d0>
            }

            else
            {
              /* In Case the CKPER is disabled*/
              frequency = 0;
 8013be2:	2300      	movs	r3, #0
 8013be4:	637b      	str	r3, [r7, #52]	@ 0x34
            }

            break;
 8013be6:	e003      	b.n	8013bf0 <HAL_RCCEx_GetPeriphCLKFreq+0x21d8>
 8013be8:	e002      	b.n	8013bf0 <HAL_RCCEx_GetPeriphCLKFreq+0x21d8>
          }
          default:
          {
            frequency = 0;
 8013bea:	2300      	movs	r3, #0
 8013bec:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013bee:	bf00      	nop
          }
        }
        break;
 8013bf0:	e25d      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>

#if defined(SPI4)
      case RCC_PERIPHCLK_SPI4:
        /* Get the current SPI4 kernel source */
        srcclk = __HAL_RCC_GET_SPI4_SOURCE();
 8013bf2:	4b19      	ldr	r3, [pc, #100]	@ (8013c58 <HAL_RCCEx_GetPeriphCLKFreq+0x2240>)
 8013bf4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8013bf8:	f403 6360 	and.w	r3, r3, #3584	@ 0xe00
 8013bfc:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_SPI4CLKSOURCE_PCLK2)
 8013bfe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013c00:	2b00      	cmp	r3, #0
 8013c02:	d103      	bne.n	8013c0c <HAL_RCCEx_GetPeriphCLKFreq+0x21f4>
        {
          frequency = HAL_RCC_GetPCLK2Freq();
 8013c04:	f7fb fb0e 	bl	800f224 <HAL_RCC_GetPCLK2Freq>
 8013c08:	6378      	str	r0, [r7, #52]	@ 0x34
        else
        {
          frequency = 0U;
        }

        break;
 8013c0a:	e250      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_SPI4CLKSOURCE_PLL2Q))
 8013c0c:	4b12      	ldr	r3, [pc, #72]	@ (8013c58 <HAL_RCCEx_GetPeriphCLKFreq+0x2240>)
 8013c0e:	681b      	ldr	r3, [r3, #0]
 8013c10:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8013c14:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8013c18:	d10b      	bne.n	8013c32 <HAL_RCCEx_GetPeriphCLKFreq+0x221a>
 8013c1a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013c1c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8013c20:	d107      	bne.n	8013c32 <HAL_RCCEx_GetPeriphCLKFreq+0x221a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8013c22:	f107 0314 	add.w	r3, r7, #20
 8013c26:	4618      	mov	r0, r3
 8013c28:	f7fd fc1e 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8013c2c:	69bb      	ldr	r3, [r7, #24]
 8013c2e:	637b      	str	r3, [r7, #52]	@ 0x34
 8013c30:	e04f      	b.n	8013cd2 <HAL_RCCEx_GetPeriphCLKFreq+0x22ba>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_SPI4CLKSOURCE_PLL3Q))
 8013c32:	4b09      	ldr	r3, [pc, #36]	@ (8013c58 <HAL_RCCEx_GetPeriphCLKFreq+0x2240>)
 8013c34:	681b      	ldr	r3, [r3, #0]
 8013c36:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8013c3a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8013c3e:	d115      	bne.n	8013c6c <HAL_RCCEx_GetPeriphCLKFreq+0x2254>
 8013c40:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013c42:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8013c46:	d111      	bne.n	8013c6c <HAL_RCCEx_GetPeriphCLKFreq+0x2254>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8013c48:	f107 0308 	add.w	r3, r7, #8
 8013c4c:	4618      	mov	r0, r3
 8013c4e:	f7fd fd77 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 8013c52:	68fb      	ldr	r3, [r7, #12]
 8013c54:	637b      	str	r3, [r7, #52]	@ 0x34
 8013c56:	e03c      	b.n	8013cd2 <HAL_RCCEx_GetPeriphCLKFreq+0x22ba>
 8013c58:	44020c00 	.word	0x44020c00
 8013c5c:	00bb8000 	.word	0x00bb8000
 8013c60:	03d09000 	.word	0x03d09000
 8013c64:	003d0900 	.word	0x003d0900
 8013c68:	017d7840 	.word	0x017d7840
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_SPI4CLKSOURCE_HSI))
 8013c6c:	4b94      	ldr	r3, [pc, #592]	@ (8013ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x24a8>)
 8013c6e:	681b      	ldr	r3, [r3, #0]
 8013c70:	f003 0302 	and.w	r3, r3, #2
 8013c74:	2b02      	cmp	r3, #2
 8013c76:	d10d      	bne.n	8013c94 <HAL_RCCEx_GetPeriphCLKFreq+0x227c>
 8013c78:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013c7a:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
 8013c7e:	d109      	bne.n	8013c94 <HAL_RCCEx_GetPeriphCLKFreq+0x227c>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8013c80:	4b8f      	ldr	r3, [pc, #572]	@ (8013ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x24a8>)
 8013c82:	681b      	ldr	r3, [r3, #0]
 8013c84:	08db      	lsrs	r3, r3, #3
 8013c86:	f003 0303 	and.w	r3, r3, #3
 8013c8a:	4a8e      	ldr	r2, [pc, #568]	@ (8013ec4 <HAL_RCCEx_GetPeriphCLKFreq+0x24ac>)
 8013c8c:	fa22 f303 	lsr.w	r3, r2, r3
 8013c90:	637b      	str	r3, [r7, #52]	@ 0x34
 8013c92:	e01e      	b.n	8013cd2 <HAL_RCCEx_GetPeriphCLKFreq+0x22ba>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_SPI4CLKSOURCE_CSI))
 8013c94:	4b8a      	ldr	r3, [pc, #552]	@ (8013ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x24a8>)
 8013c96:	681b      	ldr	r3, [r3, #0]
 8013c98:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8013c9c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8013ca0:	d106      	bne.n	8013cb0 <HAL_RCCEx_GetPeriphCLKFreq+0x2298>
 8013ca2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013ca4:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8013ca8:	d102      	bne.n	8013cb0 <HAL_RCCEx_GetPeriphCLKFreq+0x2298>
          frequency = CSI_VALUE;
 8013caa:	4b87      	ldr	r3, [pc, #540]	@ (8013ec8 <HAL_RCCEx_GetPeriphCLKFreq+0x24b0>)
 8013cac:	637b      	str	r3, [r7, #52]	@ 0x34
 8013cae:	e010      	b.n	8013cd2 <HAL_RCCEx_GetPeriphCLKFreq+0x22ba>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_SPI4CLKSOURCE_HSE))
 8013cb0:	4b83      	ldr	r3, [pc, #524]	@ (8013ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x24a8>)
 8013cb2:	681b      	ldr	r3, [r3, #0]
 8013cb4:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8013cb8:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8013cbc:	d106      	bne.n	8013ccc <HAL_RCCEx_GetPeriphCLKFreq+0x22b4>
 8013cbe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013cc0:	f5b3 6f20 	cmp.w	r3, #2560	@ 0xa00
 8013cc4:	d102      	bne.n	8013ccc <HAL_RCCEx_GetPeriphCLKFreq+0x22b4>
          frequency = HSE_VALUE;
 8013cc6:	4b81      	ldr	r3, [pc, #516]	@ (8013ecc <HAL_RCCEx_GetPeriphCLKFreq+0x24b4>)
 8013cc8:	637b      	str	r3, [r7, #52]	@ 0x34
 8013cca:	e002      	b.n	8013cd2 <HAL_RCCEx_GetPeriphCLKFreq+0x22ba>
          frequency = 0U;
 8013ccc:	2300      	movs	r3, #0
 8013cce:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8013cd0:	e1ed      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8013cd2:	e1ec      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* SPI4 */

#if defined(SPI5)
      case RCC_PERIPHCLK_SPI5:
        /* Get the current SPI5 kernel source */
        srcclk = __HAL_RCC_GET_SPI5_SOURCE();
 8013cd4:	4b7a      	ldr	r3, [pc, #488]	@ (8013ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x24a8>)
 8013cd6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8013cda:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
 8013cde:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_SPI5CLKSOURCE_PCLK3)
 8013ce0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013ce2:	2b00      	cmp	r3, #0
 8013ce4:	d103      	bne.n	8013cee <HAL_RCCEx_GetPeriphCLKFreq+0x22d6>
        {
          frequency = HAL_RCC_GetPCLK3Freq();
 8013ce6:	f7fb fab3 	bl	800f250 <HAL_RCC_GetPCLK3Freq>
 8013cea:	6378      	str	r0, [r7, #52]	@ 0x34
        else
        {
          frequency = 0U;
        }

        break;
 8013cec:	e1df      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_SPI5CLKSOURCE_PLL2Q))
 8013cee:	4b74      	ldr	r3, [pc, #464]	@ (8013ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x24a8>)
 8013cf0:	681b      	ldr	r3, [r3, #0]
 8013cf2:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8013cf6:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8013cfa:	d10b      	bne.n	8013d14 <HAL_RCCEx_GetPeriphCLKFreq+0x22fc>
 8013cfc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013cfe:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8013d02:	d107      	bne.n	8013d14 <HAL_RCCEx_GetPeriphCLKFreq+0x22fc>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8013d04:	f107 0314 	add.w	r3, r7, #20
 8013d08:	4618      	mov	r0, r3
 8013d0a:	f7fd fbad 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8013d0e:	69bb      	ldr	r3, [r7, #24]
 8013d10:	637b      	str	r3, [r7, #52]	@ 0x34
 8013d12:	e045      	b.n	8013da0 <HAL_RCCEx_GetPeriphCLKFreq+0x2388>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_SPI5CLKSOURCE_PLL3Q))
 8013d14:	4b6a      	ldr	r3, [pc, #424]	@ (8013ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x24a8>)
 8013d16:	681b      	ldr	r3, [r3, #0]
 8013d18:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8013d1c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8013d20:	d10b      	bne.n	8013d3a <HAL_RCCEx_GetPeriphCLKFreq+0x2322>
 8013d22:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013d24:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8013d28:	d107      	bne.n	8013d3a <HAL_RCCEx_GetPeriphCLKFreq+0x2322>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8013d2a:	f107 0308 	add.w	r3, r7, #8
 8013d2e:	4618      	mov	r0, r3
 8013d30:	f7fd fd06 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 8013d34:	68fb      	ldr	r3, [r7, #12]
 8013d36:	637b      	str	r3, [r7, #52]	@ 0x34
 8013d38:	e032      	b.n	8013da0 <HAL_RCCEx_GetPeriphCLKFreq+0x2388>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_SPI5CLKSOURCE_HSI))
 8013d3a:	4b61      	ldr	r3, [pc, #388]	@ (8013ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x24a8>)
 8013d3c:	681b      	ldr	r3, [r3, #0]
 8013d3e:	f003 0302 	and.w	r3, r3, #2
 8013d42:	2b02      	cmp	r3, #2
 8013d44:	d10d      	bne.n	8013d62 <HAL_RCCEx_GetPeriphCLKFreq+0x234a>
 8013d46:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013d48:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8013d4c:	d109      	bne.n	8013d62 <HAL_RCCEx_GetPeriphCLKFreq+0x234a>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8013d4e:	4b5c      	ldr	r3, [pc, #368]	@ (8013ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x24a8>)
 8013d50:	681b      	ldr	r3, [r3, #0]
 8013d52:	08db      	lsrs	r3, r3, #3
 8013d54:	f003 0303 	and.w	r3, r3, #3
 8013d58:	4a5a      	ldr	r2, [pc, #360]	@ (8013ec4 <HAL_RCCEx_GetPeriphCLKFreq+0x24ac>)
 8013d5a:	fa22 f303 	lsr.w	r3, r2, r3
 8013d5e:	637b      	str	r3, [r7, #52]	@ 0x34
 8013d60:	e01e      	b.n	8013da0 <HAL_RCCEx_GetPeriphCLKFreq+0x2388>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_SPI5CLKSOURCE_CSI))
 8013d62:	4b57      	ldr	r3, [pc, #348]	@ (8013ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x24a8>)
 8013d64:	681b      	ldr	r3, [r3, #0]
 8013d66:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8013d6a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8013d6e:	d106      	bne.n	8013d7e <HAL_RCCEx_GetPeriphCLKFreq+0x2366>
 8013d70:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013d72:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8013d76:	d102      	bne.n	8013d7e <HAL_RCCEx_GetPeriphCLKFreq+0x2366>
          frequency = CSI_VALUE;
 8013d78:	4b53      	ldr	r3, [pc, #332]	@ (8013ec8 <HAL_RCCEx_GetPeriphCLKFreq+0x24b0>)
 8013d7a:	637b      	str	r3, [r7, #52]	@ 0x34
 8013d7c:	e010      	b.n	8013da0 <HAL_RCCEx_GetPeriphCLKFreq+0x2388>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_SPI5CLKSOURCE_HSE))
 8013d7e:	4b50      	ldr	r3, [pc, #320]	@ (8013ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x24a8>)
 8013d80:	681b      	ldr	r3, [r3, #0]
 8013d82:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8013d86:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8013d8a:	d106      	bne.n	8013d9a <HAL_RCCEx_GetPeriphCLKFreq+0x2382>
 8013d8c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013d8e:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
 8013d92:	d102      	bne.n	8013d9a <HAL_RCCEx_GetPeriphCLKFreq+0x2382>
          frequency = HSE_VALUE;
 8013d94:	4b4d      	ldr	r3, [pc, #308]	@ (8013ecc <HAL_RCCEx_GetPeriphCLKFreq+0x24b4>)
 8013d96:	637b      	str	r3, [r7, #52]	@ 0x34
 8013d98:	e002      	b.n	8013da0 <HAL_RCCEx_GetPeriphCLKFreq+0x2388>
          frequency = 0U;
 8013d9a:	2300      	movs	r3, #0
 8013d9c:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8013d9e:	e186      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8013da0:	e185      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* SPI5 */

#if defined(SPI6)
      case RCC_PERIPHCLK_SPI6:
        /* Get the current SPI6 kernel source */
        srcclk = __HAL_RCC_GET_SPI6_SOURCE();
 8013da2:	4b47      	ldr	r3, [pc, #284]	@ (8013ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x24a8>)
 8013da4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8013da8:	f403 3360 	and.w	r3, r3, #229376	@ 0x38000
 8013dac:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_SPI6CLKSOURCE_PCLK2)
 8013dae:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013db0:	2b00      	cmp	r3, #0
 8013db2:	d103      	bne.n	8013dbc <HAL_RCCEx_GetPeriphCLKFreq+0x23a4>
        {
          frequency = HAL_RCC_GetPCLK2Freq();
 8013db4:	f7fb fa36 	bl	800f224 <HAL_RCC_GetPCLK2Freq>
 8013db8:	6378      	str	r0, [r7, #52]	@ 0x34
        else
        {
          frequency = 0U;
        }

        break;
 8013dba:	e178      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_SPI6CLKSOURCE_PLL2Q))
 8013dbc:	4b40      	ldr	r3, [pc, #256]	@ (8013ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x24a8>)
 8013dbe:	681b      	ldr	r3, [r3, #0]
 8013dc0:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8013dc4:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8013dc8:	d10b      	bne.n	8013de2 <HAL_RCCEx_GetPeriphCLKFreq+0x23ca>
 8013dca:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013dcc:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8013dd0:	d107      	bne.n	8013de2 <HAL_RCCEx_GetPeriphCLKFreq+0x23ca>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8013dd2:	f107 0314 	add.w	r3, r7, #20
 8013dd6:	4618      	mov	r0, r3
 8013dd8:	f7fd fb46 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8013ddc:	69bb      	ldr	r3, [r7, #24]
 8013dde:	637b      	str	r3, [r7, #52]	@ 0x34
 8013de0:	e045      	b.n	8013e6e <HAL_RCCEx_GetPeriphCLKFreq+0x2456>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_SPI6CLKSOURCE_PLL3Q))
 8013de2:	4b37      	ldr	r3, [pc, #220]	@ (8013ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x24a8>)
 8013de4:	681b      	ldr	r3, [r3, #0]
 8013de6:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8013dea:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8013dee:	d10b      	bne.n	8013e08 <HAL_RCCEx_GetPeriphCLKFreq+0x23f0>
 8013df0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013df2:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8013df6:	d107      	bne.n	8013e08 <HAL_RCCEx_GetPeriphCLKFreq+0x23f0>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8013df8:	f107 0308 	add.w	r3, r7, #8
 8013dfc:	4618      	mov	r0, r3
 8013dfe:	f7fd fc9f 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 8013e02:	68fb      	ldr	r3, [r7, #12]
 8013e04:	637b      	str	r3, [r7, #52]	@ 0x34
 8013e06:	e032      	b.n	8013e6e <HAL_RCCEx_GetPeriphCLKFreq+0x2456>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_SPI6CLKSOURCE_HSI))
 8013e08:	4b2d      	ldr	r3, [pc, #180]	@ (8013ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x24a8>)
 8013e0a:	681b      	ldr	r3, [r3, #0]
 8013e0c:	f003 0302 	and.w	r3, r3, #2
 8013e10:	2b02      	cmp	r3, #2
 8013e12:	d10d      	bne.n	8013e30 <HAL_RCCEx_GetPeriphCLKFreq+0x2418>
 8013e14:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013e16:	f5b3 3fc0 	cmp.w	r3, #98304	@ 0x18000
 8013e1a:	d109      	bne.n	8013e30 <HAL_RCCEx_GetPeriphCLKFreq+0x2418>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8013e1c:	4b28      	ldr	r3, [pc, #160]	@ (8013ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x24a8>)
 8013e1e:	681b      	ldr	r3, [r3, #0]
 8013e20:	08db      	lsrs	r3, r3, #3
 8013e22:	f003 0303 	and.w	r3, r3, #3
 8013e26:	4a27      	ldr	r2, [pc, #156]	@ (8013ec4 <HAL_RCCEx_GetPeriphCLKFreq+0x24ac>)
 8013e28:	fa22 f303 	lsr.w	r3, r2, r3
 8013e2c:	637b      	str	r3, [r7, #52]	@ 0x34
 8013e2e:	e01e      	b.n	8013e6e <HAL_RCCEx_GetPeriphCLKFreq+0x2456>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_SPI6CLKSOURCE_CSI))
 8013e30:	4b23      	ldr	r3, [pc, #140]	@ (8013ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x24a8>)
 8013e32:	681b      	ldr	r3, [r3, #0]
 8013e34:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8013e38:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8013e3c:	d106      	bne.n	8013e4c <HAL_RCCEx_GetPeriphCLKFreq+0x2434>
 8013e3e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013e40:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8013e44:	d102      	bne.n	8013e4c <HAL_RCCEx_GetPeriphCLKFreq+0x2434>
          frequency = CSI_VALUE;
 8013e46:	4b20      	ldr	r3, [pc, #128]	@ (8013ec8 <HAL_RCCEx_GetPeriphCLKFreq+0x24b0>)
 8013e48:	637b      	str	r3, [r7, #52]	@ 0x34
 8013e4a:	e010      	b.n	8013e6e <HAL_RCCEx_GetPeriphCLKFreq+0x2456>
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_SPI6CLKSOURCE_HSE))
 8013e4c:	4b1c      	ldr	r3, [pc, #112]	@ (8013ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x24a8>)
 8013e4e:	681b      	ldr	r3, [r3, #0]
 8013e50:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8013e54:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8013e58:	d106      	bne.n	8013e68 <HAL_RCCEx_GetPeriphCLKFreq+0x2450>
 8013e5a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013e5c:	f5b3 3f20 	cmp.w	r3, #163840	@ 0x28000
 8013e60:	d102      	bne.n	8013e68 <HAL_RCCEx_GetPeriphCLKFreq+0x2450>
          frequency = HSE_VALUE;
 8013e62:	4b1a      	ldr	r3, [pc, #104]	@ (8013ecc <HAL_RCCEx_GetPeriphCLKFreq+0x24b4>)
 8013e64:	637b      	str	r3, [r7, #52]	@ 0x34
 8013e66:	e002      	b.n	8013e6e <HAL_RCCEx_GetPeriphCLKFreq+0x2456>
          frequency = 0U;
 8013e68:	2300      	movs	r3, #0
 8013e6a:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8013e6c:	e11f      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8013e6e:	e11e      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* SPI6 */

#if defined(OCTOSPI1)
      case RCC_PERIPHCLK_OSPI:
        /* Get the current OSPI kernel source */
        srcclk = __HAL_RCC_GET_OSPI_SOURCE();
 8013e70:	4b13      	ldr	r3, [pc, #76]	@ (8013ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x24a8>)
 8013e72:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8013e76:	f003 0303 	and.w	r3, r3, #3
 8013e7a:	633b      	str	r3, [r7, #48]	@ 0x30

        switch (srcclk)
 8013e7c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013e7e:	2b03      	cmp	r3, #3
 8013e80:	d85f      	bhi.n	8013f42 <HAL_RCCEx_GetPeriphCLKFreq+0x252a>
 8013e82:	a201      	add	r2, pc, #4	@ (adr r2, 8013e88 <HAL_RCCEx_GetPeriphCLKFreq+0x2470>)
 8013e84:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8013e88:	08013e99 	.word	0x08013e99
 8013e8c:	08013ea1 	.word	0x08013ea1
 8013e90:	08013eb1 	.word	0x08013eb1
 8013e94:	08013ed1 	.word	0x08013ed1
        {
          case RCC_OSPICLKSOURCE_HCLK:
          {
            frequency = HAL_RCC_GetHCLKFreq();
 8013e98:	f7fb f992 	bl	800f1c0 <HAL_RCC_GetHCLKFreq>
 8013e9c:	6378      	str	r0, [r7, #52]	@ 0x34
            break;
 8013e9e:	e053      	b.n	8013f48 <HAL_RCCEx_GetPeriphCLKFreq+0x2530>
          }
          case RCC_OSPICLKSOURCE_PLL1Q:
          {
            HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8013ea0:	f107 0320 	add.w	r3, r7, #32
 8013ea4:	4618      	mov	r0, r3
 8013ea6:	f7fd f973 	bl	8011190 <HAL_RCCEx_GetPLL1ClockFreq>
            frequency = pll1_clocks.PLL1_Q_Frequency;
 8013eaa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013eac:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013eae:	e04b      	b.n	8013f48 <HAL_RCCEx_GetPeriphCLKFreq+0x2530>
          }
          case RCC_OSPICLKSOURCE_PLL2R:
          {
            HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8013eb0:	f107 0314 	add.w	r3, r7, #20
 8013eb4:	4618      	mov	r0, r3
 8013eb6:	f7fd fad7 	bl	8011468 <HAL_RCCEx_GetPLL2ClockFreq>
            frequency = pll2_clocks.PLL2_R_Frequency;
 8013eba:	69fb      	ldr	r3, [r7, #28]
 8013ebc:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013ebe:	e043      	b.n	8013f48 <HAL_RCCEx_GetPeriphCLKFreq+0x2530>
 8013ec0:	44020c00 	.word	0x44020c00
 8013ec4:	03d09000 	.word	0x03d09000
 8013ec8:	003d0900 	.word	0x003d0900
 8013ecc:	017d7840 	.word	0x017d7840
          }
          case RCC_OSPICLKSOURCE_CLKP:
          {
            ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 8013ed0:	4b79      	ldr	r3, [pc, #484]	@ (80140b8 <HAL_RCCEx_GetPeriphCLKFreq+0x26a0>)
 8013ed2:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8013ed6:	f003 4340 	and.w	r3, r3, #3221225472	@ 0xc0000000
 8013eda:	62fb      	str	r3, [r7, #44]	@ 0x2c

            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 8013edc:	4b76      	ldr	r3, [pc, #472]	@ (80140b8 <HAL_RCCEx_GetPeriphCLKFreq+0x26a0>)
 8013ede:	681b      	ldr	r3, [r3, #0]
 8013ee0:	f003 0302 	and.w	r3, r3, #2
 8013ee4:	2b02      	cmp	r3, #2
 8013ee6:	d10c      	bne.n	8013f02 <HAL_RCCEx_GetPeriphCLKFreq+0x24ea>
 8013ee8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013eea:	2b00      	cmp	r3, #0
 8013eec:	d109      	bne.n	8013f02 <HAL_RCCEx_GetPeriphCLKFreq+0x24ea>
            {
              /* In Case the CKPER Source is HSI */
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
 8013eee:	4b72      	ldr	r3, [pc, #456]	@ (80140b8 <HAL_RCCEx_GetPeriphCLKFreq+0x26a0>)
 8013ef0:	681b      	ldr	r3, [r3, #0]
 8013ef2:	08db      	lsrs	r3, r3, #3
 8013ef4:	f003 0303 	and.w	r3, r3, #3
 8013ef8:	4a70      	ldr	r2, [pc, #448]	@ (80140bc <HAL_RCCEx_GetPeriphCLKFreq+0x26a4>)
 8013efa:	fa22 f303 	lsr.w	r3, r2, r3
 8013efe:	637b      	str	r3, [r7, #52]	@ 0x34
 8013f00:	e01e      	b.n	8013f40 <HAL_RCCEx_GetPeriphCLKFreq+0x2528>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 8013f02:	4b6d      	ldr	r3, [pc, #436]	@ (80140b8 <HAL_RCCEx_GetPeriphCLKFreq+0x26a0>)
 8013f04:	681b      	ldr	r3, [r3, #0]
 8013f06:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8013f0a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8013f0e:	d106      	bne.n	8013f1e <HAL_RCCEx_GetPeriphCLKFreq+0x2506>
 8013f10:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013f12:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8013f16:	d102      	bne.n	8013f1e <HAL_RCCEx_GetPeriphCLKFreq+0x2506>
            {
              /* In Case the CKPER Source is CSI */
              frequency = CSI_VALUE;
 8013f18:	4b69      	ldr	r3, [pc, #420]	@ (80140c0 <HAL_RCCEx_GetPeriphCLKFreq+0x26a8>)
 8013f1a:	637b      	str	r3, [r7, #52]	@ 0x34
 8013f1c:	e010      	b.n	8013f40 <HAL_RCCEx_GetPeriphCLKFreq+0x2528>
            }

            else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8013f1e:	4b66      	ldr	r3, [pc, #408]	@ (80140b8 <HAL_RCCEx_GetPeriphCLKFreq+0x26a0>)
 8013f20:	681b      	ldr	r3, [r3, #0]
 8013f22:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8013f26:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8013f2a:	d106      	bne.n	8013f3a <HAL_RCCEx_GetPeriphCLKFreq+0x2522>
 8013f2c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013f2e:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8013f32:	d102      	bne.n	8013f3a <HAL_RCCEx_GetPeriphCLKFreq+0x2522>
            {
              /* In Case the CKPER Source is HSE */
              frequency = HSE_VALUE;
 8013f34:	4b63      	ldr	r3, [pc, #396]	@ (80140c4 <HAL_RCCEx_GetPeriphCLKFreq+0x26ac>)
 8013f36:	637b      	str	r3, [r7, #52]	@ 0x34
 8013f38:	e002      	b.n	8013f40 <HAL_RCCEx_GetPeriphCLKFreq+0x2528>
            }

            else
            {
              /* In Case the CKPER is disabled*/
              frequency = 0U;
 8013f3a:	2300      	movs	r3, #0
 8013f3c:	637b      	str	r3, [r7, #52]	@ 0x34
            }

            break;
 8013f3e:	e003      	b.n	8013f48 <HAL_RCCEx_GetPeriphCLKFreq+0x2530>
 8013f40:	e002      	b.n	8013f48 <HAL_RCCEx_GetPeriphCLKFreq+0x2530>
          }
          default:
          {
            frequency = 0U;
 8013f42:	2300      	movs	r3, #0
 8013f44:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8013f46:	bf00      	nop
          }
        }
        break;
 8013f48:	e0b1      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* OCTOSPI1*/

#if defined(CEC)
      case RCC_PERIPHCLK_CEC:
        /* Get the current CEC source */
        srcclk = __HAL_RCC_GET_CEC_SOURCE();
 8013f4a:	4b5b      	ldr	r3, [pc, #364]	@ (80140b8 <HAL_RCCEx_GetPeriphCLKFreq+0x26a0>)
 8013f4c:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8013f50:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 8013f54:	633b      	str	r3, [r7, #48]	@ 0x30

        if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_CECCLKSOURCE_LSE))
 8013f56:	4b58      	ldr	r3, [pc, #352]	@ (80140b8 <HAL_RCCEx_GetPeriphCLKFreq+0x26a0>)
 8013f58:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8013f5c:	f003 0302 	and.w	r3, r3, #2
 8013f60:	2b02      	cmp	r3, #2
 8013f62:	d106      	bne.n	8013f72 <HAL_RCCEx_GetPeriphCLKFreq+0x255a>
 8013f64:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013f66:	2b00      	cmp	r3, #0
 8013f68:	d103      	bne.n	8013f72 <HAL_RCCEx_GetPeriphCLKFreq+0x255a>
        {
          frequency = LSE_VALUE;
 8013f6a:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8013f6e:	637b      	str	r3, [r7, #52]	@ 0x34
 8013f70:	e01f      	b.n	8013fb2 <HAL_RCCEx_GetPeriphCLKFreq+0x259a>
        }
        else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_CECCLKSOURCE_LSI))
 8013f72:	4b51      	ldr	r3, [pc, #324]	@ (80140b8 <HAL_RCCEx_GetPeriphCLKFreq+0x26a0>)
 8013f74:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8013f78:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8013f7c:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8013f80:	d106      	bne.n	8013f90 <HAL_RCCEx_GetPeriphCLKFreq+0x2578>
 8013f82:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013f84:	2b40      	cmp	r3, #64	@ 0x40
 8013f86:	d103      	bne.n	8013f90 <HAL_RCCEx_GetPeriphCLKFreq+0x2578>
        {
          frequency = LSI_VALUE;
 8013f88:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 8013f8c:	637b      	str	r3, [r7, #52]	@ 0x34
 8013f8e:	e010      	b.n	8013fb2 <HAL_RCCEx_GetPeriphCLKFreq+0x259a>
        }
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_CECCLKSOURCE_CSI_DIV122))
 8013f90:	4b49      	ldr	r3, [pc, #292]	@ (80140b8 <HAL_RCCEx_GetPeriphCLKFreq+0x26a0>)
 8013f92:	681b      	ldr	r3, [r3, #0]
 8013f94:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8013f98:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8013f9c:	d106      	bne.n	8013fac <HAL_RCCEx_GetPeriphCLKFreq+0x2594>
 8013f9e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013fa0:	2b80      	cmp	r3, #128	@ 0x80
 8013fa2:	d103      	bne.n	8013fac <HAL_RCCEx_GetPeriphCLKFreq+0x2594>
        {
          frequency = CSI_VALUE / 122U;
 8013fa4:	f248 0312 	movw	r3, #32786	@ 0x8012
 8013fa8:	637b      	str	r3, [r7, #52]	@ 0x34
 8013faa:	e002      	b.n	8013fb2 <HAL_RCCEx_GetPeriphCLKFreq+0x259a>
        }

        /* Clock not enabled for CEC */
        else
        {
          frequency = 0U;
 8013fac:	2300      	movs	r3, #0
 8013fae:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        break;
 8013fb0:	e07d      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 8013fb2:	e07c      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
#endif /* CEC */

      case RCC_PERIPHCLK_RNG:
        /* Get the current RNG source */
        srcclk = __HAL_RCC_GET_RNG_SOURCE();
 8013fb4:	4b40      	ldr	r3, [pc, #256]	@ (80140b8 <HAL_RCCEx_GetPeriphCLKFreq+0x26a0>)
 8013fb6:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8013fba:	f003 0330 	and.w	r3, r3, #48	@ 0x30
 8013fbe:	633b      	str	r3, [r7, #48]	@ 0x30

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI48))
 8013fc0:	4b3d      	ldr	r3, [pc, #244]	@ (80140b8 <HAL_RCCEx_GetPeriphCLKFreq+0x26a0>)
 8013fc2:	681b      	ldr	r3, [r3, #0]
 8013fc4:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8013fc8:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8013fcc:	d105      	bne.n	8013fda <HAL_RCCEx_GetPeriphCLKFreq+0x25c2>
 8013fce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013fd0:	2b00      	cmp	r3, #0
 8013fd2:	d102      	bne.n	8013fda <HAL_RCCEx_GetPeriphCLKFreq+0x25c2>
        {
          frequency = HSI48_VALUE;
 8013fd4:	4b3c      	ldr	r3, [pc, #240]	@ (80140c8 <HAL_RCCEx_GetPeriphCLKFreq+0x26b0>)
 8013fd6:	637b      	str	r3, [r7, #52]	@ 0x34
 8013fd8:	e031      	b.n	801403e <HAL_RCCEx_GetPeriphCLKFreq+0x2626>
        }
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY)) && (srcclk == RCC_RNGCLKSOURCE_PLL1Q))
 8013fda:	4b37      	ldr	r3, [pc, #220]	@ (80140b8 <HAL_RCCEx_GetPeriphCLKFreq+0x26a0>)
 8013fdc:	681b      	ldr	r3, [r3, #0]
 8013fde:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8013fe2:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8013fe6:	d10a      	bne.n	8013ffe <HAL_RCCEx_GetPeriphCLKFreq+0x25e6>
 8013fe8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013fea:	2b10      	cmp	r3, #16
 8013fec:	d107      	bne.n	8013ffe <HAL_RCCEx_GetPeriphCLKFreq+0x25e6>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8013fee:	f107 0320 	add.w	r3, r7, #32
 8013ff2:	4618      	mov	r0, r3
 8013ff4:	f7fd f8cc 	bl	8011190 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 8013ff8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013ffa:	637b      	str	r3, [r7, #52]	@ 0x34
 8013ffc:	e01f      	b.n	801403e <HAL_RCCEx_GetPeriphCLKFreq+0x2626>
        }
        else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_RNGCLKSOURCE_LSE))
 8013ffe:	4b2e      	ldr	r3, [pc, #184]	@ (80140b8 <HAL_RCCEx_GetPeriphCLKFreq+0x26a0>)
 8014000:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8014004:	f003 0302 	and.w	r3, r3, #2
 8014008:	2b02      	cmp	r3, #2
 801400a:	d106      	bne.n	801401a <HAL_RCCEx_GetPeriphCLKFreq+0x2602>
 801400c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801400e:	2b20      	cmp	r3, #32
 8014010:	d103      	bne.n	801401a <HAL_RCCEx_GetPeriphCLKFreq+0x2602>
        {
          frequency = LSE_VALUE;
 8014012:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8014016:	637b      	str	r3, [r7, #52]	@ 0x34
 8014018:	e011      	b.n	801403e <HAL_RCCEx_GetPeriphCLKFreq+0x2626>
        }
        else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_RNGCLKSOURCE_LSI))
 801401a:	4b27      	ldr	r3, [pc, #156]	@ (80140b8 <HAL_RCCEx_GetPeriphCLKFreq+0x26a0>)
 801401c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8014020:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8014024:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8014028:	d106      	bne.n	8014038 <HAL_RCCEx_GetPeriphCLKFreq+0x2620>
 801402a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801402c:	2b30      	cmp	r3, #48	@ 0x30
 801402e:	d103      	bne.n	8014038 <HAL_RCCEx_GetPeriphCLKFreq+0x2620>
        {
          frequency = LSI_VALUE;
 8014030:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 8014034:	637b      	str	r3, [r7, #52]	@ 0x34
 8014036:	e002      	b.n	801403e <HAL_RCCEx_GetPeriphCLKFreq+0x2626>
        }

        /* Clock not enabled for RNG */
        else
        {
          frequency = 0U;
 8014038:	2300      	movs	r3, #0
 801403a:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        break;
 801403c:	e037      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 801403e:	e036      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>

#if defined(USB_DRD_FS)
      case RCC_PERIPHCLK_USB:
        /* Get the current USB kernel source */
        srcclk = __HAL_RCC_GET_USB_SOURCE();
 8014040:	4b1d      	ldr	r3, [pc, #116]	@ (80140b8 <HAL_RCCEx_GetPeriphCLKFreq+0x26a0>)
 8014042:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8014046:	f003 0330 	and.w	r3, r3, #48	@ 0x30
 801404a:	633b      	str	r3, [r7, #48]	@ 0x30

        if (srcclk == RCC_USBCLKSOURCE_PLL1Q)
 801404c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801404e:	2b10      	cmp	r3, #16
 8014050:	d107      	bne.n	8014062 <HAL_RCCEx_GetPeriphCLKFreq+0x264a>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8014052:	f107 0320 	add.w	r3, r7, #32
 8014056:	4618      	mov	r0, r3
 8014058:	f7fd f89a 	bl	8011190 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 801405c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801405e:	637b      	str	r3, [r7, #52]	@ 0x34
          break;
 8014060:	e025      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
        }
#if defined(RCC_USBCLKSOURCE_PLL3Q)
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_USBCLKSOURCE_PLL3Q))
 8014062:	4b15      	ldr	r3, [pc, #84]	@ (80140b8 <HAL_RCCEx_GetPeriphCLKFreq+0x26a0>)
 8014064:	681b      	ldr	r3, [r3, #0]
 8014066:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 801406a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 801406e:	d10a      	bne.n	8014086 <HAL_RCCEx_GetPeriphCLKFreq+0x266e>
 8014070:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014072:	2b20      	cmp	r3, #32
 8014074:	d107      	bne.n	8014086 <HAL_RCCEx_GetPeriphCLKFreq+0x266e>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8014076:	f107 0308 	add.w	r3, r7, #8
 801407a:	4618      	mov	r0, r3
 801407c:	f7fd fb60 	bl	8011740 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 8014080:	68fb      	ldr	r3, [r7, #12]
 8014082:	637b      	str	r3, [r7, #52]	@ 0x34
 8014084:	e00f      	b.n	80140a6 <HAL_RCCEx_GetPeriphCLKFreq+0x268e>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
          frequency = pll2_clocks.PLL2_Q_Frequency;
        }
#endif /* RCC_USBCLKSOURCE_PLL3 */
        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY)) && (srcclk == RCC_USBCLKSOURCE_HSI48))
 8014086:	4b0c      	ldr	r3, [pc, #48]	@ (80140b8 <HAL_RCCEx_GetPeriphCLKFreq+0x26a0>)
 8014088:	681b      	ldr	r3, [r3, #0]
 801408a:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 801408e:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8014092:	d105      	bne.n	80140a0 <HAL_RCCEx_GetPeriphCLKFreq+0x2688>
 8014094:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014096:	2b30      	cmp	r3, #48	@ 0x30
 8014098:	d102      	bne.n	80140a0 <HAL_RCCEx_GetPeriphCLKFreq+0x2688>
        {
          frequency = HSI48_VALUE;
 801409a:	4b0b      	ldr	r3, [pc, #44]	@ (80140c8 <HAL_RCCEx_GetPeriphCLKFreq+0x26b0>)
 801409c:	637b      	str	r3, [r7, #52]	@ 0x34
 801409e:	e002      	b.n	80140a6 <HAL_RCCEx_GetPeriphCLKFreq+0x268e>
        }
        /* Clock not enabled for USB */
        else
        {
          frequency = 0U;
 80140a0:	2300      	movs	r3, #0
 80140a2:	637b      	str	r3, [r7, #52]	@ 0x34
        }

        break;
 80140a4:	e003      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>
 80140a6:	e002      	b.n	80140ae <HAL_RCCEx_GetPeriphCLKFreq+0x2696>


      default:
        frequency = 0U;
 80140a8:	2300      	movs	r3, #0
 80140aa:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80140ac:	bf00      	nop
#endif /* USB_DRD_FS */
    }
  }
  return (frequency);
 80140ae:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 80140b0:	4618      	mov	r0, r3
 80140b2:	373c      	adds	r7, #60	@ 0x3c
 80140b4:	46bd      	mov	sp, r7
 80140b6:	bd90      	pop	{r4, r7, pc}
 80140b8:	44020c00 	.word	0x44020c00
 80140bc:	03d09000 	.word	0x03d09000
 80140c0:	003d0900 	.word	0x003d0900
 80140c4:	017d7840 	.word	0x017d7840
 80140c8:	02dc6c00 	.word	0x02dc6c00

080140cc <RCCEx_PLL2_Config>:
  *         contains the configuration parameters M, N, FRACN, VCI/VCO ranges as well as PLL2 output clocks dividers
  * @note   PLL2 is temporary disabled to apply new parameters
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(const RCC_PLL2InitTypeDef *pll2)
{
 80140cc:	b580      	push	{r7, lr}
 80140ce:	b084      	sub	sp, #16
 80140d0:	af00      	add	r7, sp, #0
 80140d2:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_PLL2_VCIRGE_VALUE(pll2->PLL2RGE));
  assert_param(IS_RCC_PLL2_VCORGE_VALUE(pll2->PLL2VCOSEL));
  assert_param(IS_RCC_PLL2_FRACN_VALUE(pll2->PLL2FRACN));

  /* Disable  PLL2. */
  __HAL_RCC_PLL2_DISABLE();
 80140d4:	4b48      	ldr	r3, [pc, #288]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 80140d6:	681b      	ldr	r3, [r3, #0]
 80140d8:	4a47      	ldr	r2, [pc, #284]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 80140da:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
 80140de:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 80140e0:	f7f9 fe74 	bl	800ddcc <HAL_GetTick>
 80140e4:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL2 is disabled */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 80140e6:	e008      	b.n	80140fa <RCCEx_PLL2_Config+0x2e>
  {
    if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 80140e8:	f7f9 fe70 	bl	800ddcc <HAL_GetTick>
 80140ec:	4602      	mov	r2, r0
 80140ee:	68fb      	ldr	r3, [r7, #12]
 80140f0:	1ad3      	subs	r3, r2, r3
 80140f2:	2b02      	cmp	r3, #2
 80140f4:	d901      	bls.n	80140fa <RCCEx_PLL2_Config+0x2e>
    {
      return HAL_TIMEOUT;
 80140f6:	2303      	movs	r3, #3
 80140f8:	e07a      	b.n	80141f0 <RCCEx_PLL2_Config+0x124>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 80140fa:	4b3f      	ldr	r3, [pc, #252]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 80140fc:	681b      	ldr	r3, [r3, #0]
 80140fe:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8014102:	2b00      	cmp	r3, #0
 8014104:	d1f0      	bne.n	80140e8 <RCCEx_PLL2_Config+0x1c>
    }
  }

  /* Configure PLL2 multiplication and division factors. */
  __HAL_RCC_PLL2_CONFIG(pll2->PLL2Source,
 8014106:	4b3c      	ldr	r3, [pc, #240]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 8014108:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801410a:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
 801410e:	f023 0303 	bic.w	r3, r3, #3
 8014112:	687a      	ldr	r2, [r7, #4]
 8014114:	6811      	ldr	r1, [r2, #0]
 8014116:	687a      	ldr	r2, [r7, #4]
 8014118:	6852      	ldr	r2, [r2, #4]
 801411a:	0212      	lsls	r2, r2, #8
 801411c:	430a      	orrs	r2, r1
 801411e:	4936      	ldr	r1, [pc, #216]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 8014120:	4313      	orrs	r3, r2
 8014122:	62cb      	str	r3, [r1, #44]	@ 0x2c
 8014124:	687b      	ldr	r3, [r7, #4]
 8014126:	689b      	ldr	r3, [r3, #8]
 8014128:	3b01      	subs	r3, #1
 801412a:	f3c3 0208 	ubfx	r2, r3, #0, #9
 801412e:	687b      	ldr	r3, [r7, #4]
 8014130:	68db      	ldr	r3, [r3, #12]
 8014132:	3b01      	subs	r3, #1
 8014134:	025b      	lsls	r3, r3, #9
 8014136:	b29b      	uxth	r3, r3
 8014138:	431a      	orrs	r2, r3
 801413a:	687b      	ldr	r3, [r7, #4]
 801413c:	691b      	ldr	r3, [r3, #16]
 801413e:	3b01      	subs	r3, #1
 8014140:	041b      	lsls	r3, r3, #16
 8014142:	f403 03fe 	and.w	r3, r3, #8323072	@ 0x7f0000
 8014146:	431a      	orrs	r2, r3
 8014148:	687b      	ldr	r3, [r7, #4]
 801414a:	695b      	ldr	r3, [r3, #20]
 801414c:	3b01      	subs	r3, #1
 801414e:	061b      	lsls	r3, r3, #24
 8014150:	f003 43fe 	and.w	r3, r3, #2130706432	@ 0x7f000000
 8014154:	4928      	ldr	r1, [pc, #160]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 8014156:	4313      	orrs	r3, r2
 8014158:	63cb      	str	r3, [r1, #60]	@ 0x3c
                        pll2->PLL2P,
                        pll2->PLL2Q,
                        pll2->PLL2R);

  /* Select PLL2 input reference frequency range: VCI */
  __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE);
 801415a:	4b27      	ldr	r3, [pc, #156]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 801415c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801415e:	f023 020c 	bic.w	r2, r3, #12
 8014162:	687b      	ldr	r3, [r7, #4]
 8014164:	699b      	ldr	r3, [r3, #24]
 8014166:	4924      	ldr	r1, [pc, #144]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 8014168:	4313      	orrs	r3, r2
 801416a:	62cb      	str	r3, [r1, #44]	@ 0x2c

  /* Select PLL2 output frequency range : VCO */
  __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL);
 801416c:	4b22      	ldr	r3, [pc, #136]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 801416e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8014170:	f023 0220 	bic.w	r2, r3, #32
 8014174:	687b      	ldr	r3, [r7, #4]
 8014176:	69db      	ldr	r3, [r3, #28]
 8014178:	491f      	ldr	r1, [pc, #124]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 801417a:	4313      	orrs	r3, r2
 801417c:	62cb      	str	r3, [r1, #44]	@ 0x2c

  /* Configure the PLL2 Clock output(s) */
  __HAL_RCC_PLL2_CLKOUT_ENABLE(pll2->PLL2ClockOut);
 801417e:	4b1e      	ldr	r3, [pc, #120]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 8014180:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8014182:	687b      	ldr	r3, [r7, #4]
 8014184:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8014186:	491c      	ldr	r1, [pc, #112]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 8014188:	4313      	orrs	r3, r2
 801418a:	62cb      	str	r3, [r1, #44]	@ 0x2c

  /* Disable PLL2FRACN . */
  __HAL_RCC_PLL2_FRACN_DISABLE();
 801418c:	4b1a      	ldr	r3, [pc, #104]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 801418e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8014190:	4a19      	ldr	r2, [pc, #100]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 8014192:	f023 0310 	bic.w	r3, r3, #16
 8014196:	62d3      	str	r3, [r2, #44]	@ 0x2c

  /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
  __HAL_RCC_PLL2_FRACN_CONFIG(pll2->PLL2FRACN);
 8014198:	4b17      	ldr	r3, [pc, #92]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 801419a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801419c:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 80141a0:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 80141a4:	687a      	ldr	r2, [r7, #4]
 80141a6:	6a12      	ldr	r2, [r2, #32]
 80141a8:	00d2      	lsls	r2, r2, #3
 80141aa:	4913      	ldr	r1, [pc, #76]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 80141ac:	4313      	orrs	r3, r2
 80141ae:	640b      	str	r3, [r1, #64]	@ 0x40

  /* Enable PLL2FRACN . */
  __HAL_RCC_PLL2_FRACN_ENABLE();
 80141b0:	4b11      	ldr	r3, [pc, #68]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 80141b2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80141b4:	4a10      	ldr	r2, [pc, #64]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 80141b6:	f043 0310 	orr.w	r3, r3, #16
 80141ba:	62d3      	str	r3, [r2, #44]	@ 0x2c

  /* Enable  PLL2. */
  __HAL_RCC_PLL2_ENABLE();
 80141bc:	4b0e      	ldr	r3, [pc, #56]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 80141be:	681b      	ldr	r3, [r3, #0]
 80141c0:	4a0d      	ldr	r2, [pc, #52]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 80141c2:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 80141c6:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 80141c8:	f7f9 fe00 	bl	800ddcc <HAL_GetTick>
 80141cc:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL2 is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 80141ce:	e008      	b.n	80141e2 <RCCEx_PLL2_Config+0x116>
  {
    if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 80141d0:	f7f9 fdfc 	bl	800ddcc <HAL_GetTick>
 80141d4:	4602      	mov	r2, r0
 80141d6:	68fb      	ldr	r3, [r7, #12]
 80141d8:	1ad3      	subs	r3, r2, r3
 80141da:	2b02      	cmp	r3, #2
 80141dc:	d901      	bls.n	80141e2 <RCCEx_PLL2_Config+0x116>
    {
      return HAL_TIMEOUT;
 80141de:	2303      	movs	r3, #3
 80141e0:	e006      	b.n	80141f0 <RCCEx_PLL2_Config+0x124>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 80141e2:	4b05      	ldr	r3, [pc, #20]	@ (80141f8 <RCCEx_PLL2_Config+0x12c>)
 80141e4:	681b      	ldr	r3, [r3, #0]
 80141e6:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 80141ea:	2b00      	cmp	r3, #0
 80141ec:	d0f0      	beq.n	80141d0 <RCCEx_PLL2_Config+0x104>
    }
  }
  return HAL_OK;
 80141ee:	2300      	movs	r3, #0

}
 80141f0:	4618      	mov	r0, r3
 80141f2:	3710      	adds	r7, #16
 80141f4:	46bd      	mov	sp, r7
 80141f6:	bd80      	pop	{r7, pc}
 80141f8:	44020c00 	.word	0x44020c00

080141fc <RCCEx_PLL3_Config>:
  *         contains the configuration parameters M, N, FRACN, VCI/VCO ranges as well as PLL3 output clocks dividers
  * @note   PLL3 is temporary disabled to apply new parameters
  * @retval HAL status.
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(const RCC_PLL3InitTypeDef *pll3)
{
 80141fc:	b580      	push	{r7, lr}
 80141fe:	b084      	sub	sp, #16
 8014200:	af00      	add	r7, sp, #0
 8014202:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_PLL3_VCIRGE_VALUE(pll3->PLL3RGE));
  assert_param(IS_RCC_PLL3_VCORGE_VALUE(pll3->PLL3VCOSEL));
  assert_param(IS_RCC_PLL3_FRACN_VALUE(pll3->PLL3FRACN));

  /* Disable  PLL3. */
  __HAL_RCC_PLL3_DISABLE();
 8014204:	4b48      	ldr	r3, [pc, #288]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 8014206:	681b      	ldr	r3, [r3, #0]
 8014208:	4a47      	ldr	r2, [pc, #284]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 801420a:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 801420e:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8014210:	f7f9 fddc 	bl	800ddcc <HAL_GetTick>
 8014214:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL3 is disabled */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 8014216:	e008      	b.n	801422a <RCCEx_PLL3_Config+0x2e>
  {
    if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 8014218:	f7f9 fdd8 	bl	800ddcc <HAL_GetTick>
 801421c:	4602      	mov	r2, r0
 801421e:	68fb      	ldr	r3, [r7, #12]
 8014220:	1ad3      	subs	r3, r2, r3
 8014222:	2b02      	cmp	r3, #2
 8014224:	d901      	bls.n	801422a <RCCEx_PLL3_Config+0x2e>
    {
      return HAL_TIMEOUT;
 8014226:	2303      	movs	r3, #3
 8014228:	e07a      	b.n	8014320 <RCCEx_PLL3_Config+0x124>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 801422a:	4b3f      	ldr	r3, [pc, #252]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 801422c:	681b      	ldr	r3, [r3, #0]
 801422e:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8014232:	2b00      	cmp	r3, #0
 8014234:	d1f0      	bne.n	8014218 <RCCEx_PLL3_Config+0x1c>
    }
  }

  /* Configure PLL3 multiplication and division factors. */
  __HAL_RCC_PLL3_CONFIG(pll3->PLL3Source,
 8014236:	4b3c      	ldr	r3, [pc, #240]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 8014238:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801423a:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
 801423e:	f023 0303 	bic.w	r3, r3, #3
 8014242:	687a      	ldr	r2, [r7, #4]
 8014244:	6811      	ldr	r1, [r2, #0]
 8014246:	687a      	ldr	r2, [r7, #4]
 8014248:	6852      	ldr	r2, [r2, #4]
 801424a:	0212      	lsls	r2, r2, #8
 801424c:	430a      	orrs	r2, r1
 801424e:	4936      	ldr	r1, [pc, #216]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 8014250:	4313      	orrs	r3, r2
 8014252:	630b      	str	r3, [r1, #48]	@ 0x30
 8014254:	687b      	ldr	r3, [r7, #4]
 8014256:	689b      	ldr	r3, [r3, #8]
 8014258:	3b01      	subs	r3, #1
 801425a:	f3c3 0208 	ubfx	r2, r3, #0, #9
 801425e:	687b      	ldr	r3, [r7, #4]
 8014260:	68db      	ldr	r3, [r3, #12]
 8014262:	3b01      	subs	r3, #1
 8014264:	025b      	lsls	r3, r3, #9
 8014266:	b29b      	uxth	r3, r3
 8014268:	431a      	orrs	r2, r3
 801426a:	687b      	ldr	r3, [r7, #4]
 801426c:	691b      	ldr	r3, [r3, #16]
 801426e:	3b01      	subs	r3, #1
 8014270:	041b      	lsls	r3, r3, #16
 8014272:	f403 03fe 	and.w	r3, r3, #8323072	@ 0x7f0000
 8014276:	431a      	orrs	r2, r3
 8014278:	687b      	ldr	r3, [r7, #4]
 801427a:	695b      	ldr	r3, [r3, #20]
 801427c:	3b01      	subs	r3, #1
 801427e:	061b      	lsls	r3, r3, #24
 8014280:	f003 43fe 	and.w	r3, r3, #2130706432	@ 0x7f000000
 8014284:	4928      	ldr	r1, [pc, #160]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 8014286:	4313      	orrs	r3, r2
 8014288:	644b      	str	r3, [r1, #68]	@ 0x44
                        pll3->PLL3P,
                        pll3->PLL3Q,
                        pll3->PLL3R);

  /* Select PLL3 input reference frequency range: VCI */
  __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
 801428a:	4b27      	ldr	r3, [pc, #156]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 801428c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801428e:	f023 020c 	bic.w	r2, r3, #12
 8014292:	687b      	ldr	r3, [r7, #4]
 8014294:	699b      	ldr	r3, [r3, #24]
 8014296:	4924      	ldr	r1, [pc, #144]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 8014298:	4313      	orrs	r3, r2
 801429a:	630b      	str	r3, [r1, #48]	@ 0x30

  /* Select PLL3 output frequency range : VCO */
  __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL);
 801429c:	4b22      	ldr	r3, [pc, #136]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 801429e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80142a0:	f023 0220 	bic.w	r2, r3, #32
 80142a4:	687b      	ldr	r3, [r7, #4]
 80142a6:	69db      	ldr	r3, [r3, #28]
 80142a8:	491f      	ldr	r1, [pc, #124]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 80142aa:	4313      	orrs	r3, r2
 80142ac:	630b      	str	r3, [r1, #48]	@ 0x30

  /* Configure the PLL3 Clock output(s) */
  __HAL_RCC_PLL3_CLKOUT_ENABLE(pll3->PLL3ClockOut);
 80142ae:	4b1e      	ldr	r3, [pc, #120]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 80142b0:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80142b2:	687b      	ldr	r3, [r7, #4]
 80142b4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80142b6:	491c      	ldr	r1, [pc, #112]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 80142b8:	4313      	orrs	r3, r2
 80142ba:	630b      	str	r3, [r1, #48]	@ 0x30

  /* Disable PLL3FRACN . */
  __HAL_RCC_PLL3_FRACN_DISABLE();
 80142bc:	4b1a      	ldr	r3, [pc, #104]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 80142be:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80142c0:	4a19      	ldr	r2, [pc, #100]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 80142c2:	f023 0310 	bic.w	r3, r3, #16
 80142c6:	6313      	str	r3, [r2, #48]	@ 0x30

  /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
  __HAL_RCC_PLL3_FRACN_CONFIG(pll3->PLL3FRACN);
 80142c8:	4b17      	ldr	r3, [pc, #92]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 80142ca:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 80142cc:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 80142d0:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 80142d4:	687a      	ldr	r2, [r7, #4]
 80142d6:	6a12      	ldr	r2, [r2, #32]
 80142d8:	00d2      	lsls	r2, r2, #3
 80142da:	4913      	ldr	r1, [pc, #76]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 80142dc:	4313      	orrs	r3, r2
 80142de:	648b      	str	r3, [r1, #72]	@ 0x48

  /* Enable PLL3FRACN . */
  __HAL_RCC_PLL3_FRACN_ENABLE();
 80142e0:	4b11      	ldr	r3, [pc, #68]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 80142e2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80142e4:	4a10      	ldr	r2, [pc, #64]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 80142e6:	f043 0310 	orr.w	r3, r3, #16
 80142ea:	6313      	str	r3, [r2, #48]	@ 0x30

  /* Enable  PLL3. */
  __HAL_RCC_PLL3_ENABLE();
 80142ec:	4b0e      	ldr	r3, [pc, #56]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 80142ee:	681b      	ldr	r3, [r3, #0]
 80142f0:	4a0d      	ldr	r2, [pc, #52]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 80142f2:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 80142f6:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 80142f8:	f7f9 fd68 	bl	800ddcc <HAL_GetTick>
 80142fc:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL3 is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 80142fe:	e008      	b.n	8014312 <RCCEx_PLL3_Config+0x116>
  {
    if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 8014300:	f7f9 fd64 	bl	800ddcc <HAL_GetTick>
 8014304:	4602      	mov	r2, r0
 8014306:	68fb      	ldr	r3, [r7, #12]
 8014308:	1ad3      	subs	r3, r2, r3
 801430a:	2b02      	cmp	r3, #2
 801430c:	d901      	bls.n	8014312 <RCCEx_PLL3_Config+0x116>
    {
      return HAL_TIMEOUT;
 801430e:	2303      	movs	r3, #3
 8014310:	e006      	b.n	8014320 <RCCEx_PLL3_Config+0x124>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 8014312:	4b05      	ldr	r3, [pc, #20]	@ (8014328 <RCCEx_PLL3_Config+0x12c>)
 8014314:	681b      	ldr	r3, [r3, #0]
 8014316:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 801431a:	2b00      	cmp	r3, #0
 801431c:	d0f0      	beq.n	8014300 <RCCEx_PLL3_Config+0x104>
    }
  }
  return HAL_OK;
 801431e:	2300      	movs	r3, #0
}
 8014320:	4618      	mov	r0, r3
 8014322:	3710      	adds	r7, #16
 8014324:	46bd      	mov	sp, r7
 8014326:	bd80      	pop	{r7, pc}
 8014328:	44020c00 	.word	0x44020c00

0801432c <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 801432c:	b580      	push	{r7, lr}
 801432e:	b082      	sub	sp, #8
 8014330:	af00      	add	r7, sp, #0
 8014332:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 8014334:	687b      	ldr	r3, [r7, #4]
 8014336:	2b00      	cmp	r3, #0
 8014338:	d101      	bne.n	801433e <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 801433a:	2301      	movs	r3, #1
 801433c:	e042      	b.n	80143c4 <HAL_UART_Init+0x98>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 801433e:	687b      	ldr	r3, [r7, #4]
 8014340:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8014344:	2b00      	cmp	r3, #0
 8014346:	d106      	bne.n	8014356 <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8014348:	687b      	ldr	r3, [r7, #4]
 801434a:	2200      	movs	r2, #0
 801434c:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 8014350:	6878      	ldr	r0, [r7, #4]
 8014352:	f7f9 fb55 	bl	800da00 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 8014356:	687b      	ldr	r3, [r7, #4]
 8014358:	2224      	movs	r2, #36	@ 0x24
 801435a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  __HAL_UART_DISABLE(huart);
 801435e:	687b      	ldr	r3, [r7, #4]
 8014360:	681b      	ldr	r3, [r3, #0]
 8014362:	681a      	ldr	r2, [r3, #0]
 8014364:	687b      	ldr	r3, [r7, #4]
 8014366:	681b      	ldr	r3, [r3, #0]
 8014368:	f022 0201 	bic.w	r2, r2, #1
 801436c:	601a      	str	r2, [r3, #0]

  /* Perform advanced settings configuration */
  /* For some items, configuration requires to be done prior TE and RE bits are set */
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 801436e:	687b      	ldr	r3, [r7, #4]
 8014370:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8014372:	2b00      	cmp	r3, #0
 8014374:	d002      	beq.n	801437c <HAL_UART_Init+0x50>
  {
    UART_AdvFeatureConfig(huart);
 8014376:	6878      	ldr	r0, [r7, #4]
 8014378:	f000 fab4 	bl	80148e4 <UART_AdvFeatureConfig>
  }

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 801437c:	6878      	ldr	r0, [r7, #4]
 801437e:	f000 f8c3 	bl	8014508 <UART_SetConfig>
 8014382:	4603      	mov	r3, r0
 8014384:	2b01      	cmp	r3, #1
 8014386:	d101      	bne.n	801438c <HAL_UART_Init+0x60>
  {
    return HAL_ERROR;
 8014388:	2301      	movs	r3, #1
 801438a:	e01b      	b.n	80143c4 <HAL_UART_Init+0x98>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 801438c:	687b      	ldr	r3, [r7, #4]
 801438e:	681b      	ldr	r3, [r3, #0]
 8014390:	685a      	ldr	r2, [r3, #4]
 8014392:	687b      	ldr	r3, [r7, #4]
 8014394:	681b      	ldr	r3, [r3, #0]
 8014396:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
 801439a:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 801439c:	687b      	ldr	r3, [r7, #4]
 801439e:	681b      	ldr	r3, [r3, #0]
 80143a0:	689a      	ldr	r2, [r3, #8]
 80143a2:	687b      	ldr	r3, [r7, #4]
 80143a4:	681b      	ldr	r3, [r3, #0]
 80143a6:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
 80143aa:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
 80143ac:	687b      	ldr	r3, [r7, #4]
 80143ae:	681b      	ldr	r3, [r3, #0]
 80143b0:	681a      	ldr	r2, [r3, #0]
 80143b2:	687b      	ldr	r3, [r7, #4]
 80143b4:	681b      	ldr	r3, [r3, #0]
 80143b6:	f042 0201 	orr.w	r2, r2, #1
 80143ba:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 80143bc:	6878      	ldr	r0, [r7, #4]
 80143be:	f000 fb33 	bl	8014a28 <UART_CheckIdleState>
 80143c2:	4603      	mov	r3, r0
}
 80143c4:	4618      	mov	r0, r3
 80143c6:	3708      	adds	r7, #8
 80143c8:	46bd      	mov	sp, r7
 80143ca:	bd80      	pop	{r7, pc}

080143cc <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80143cc:	b580      	push	{r7, lr}
 80143ce:	b08a      	sub	sp, #40	@ 0x28
 80143d0:	af02      	add	r7, sp, #8
 80143d2:	60f8      	str	r0, [r7, #12]
 80143d4:	60b9      	str	r1, [r7, #8]
 80143d6:	603b      	str	r3, [r7, #0]
 80143d8:	4613      	mov	r3, r2
 80143da:	80fb      	strh	r3, [r7, #6]
  const uint8_t  *pdata8bits;
  const uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 80143dc:	68fb      	ldr	r3, [r7, #12]
 80143de:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80143e2:	2b20      	cmp	r3, #32
 80143e4:	f040 808b 	bne.w	80144fe <HAL_UART_Transmit+0x132>
  {
    if ((pData == NULL) || (Size == 0U))
 80143e8:	68bb      	ldr	r3, [r7, #8]
 80143ea:	2b00      	cmp	r3, #0
 80143ec:	d002      	beq.n	80143f4 <HAL_UART_Transmit+0x28>
 80143ee:	88fb      	ldrh	r3, [r7, #6]
 80143f0:	2b00      	cmp	r3, #0
 80143f2:	d101      	bne.n	80143f8 <HAL_UART_Transmit+0x2c>
    {
      return  HAL_ERROR;
 80143f4:	2301      	movs	r3, #1
 80143f6:	e083      	b.n	8014500 <HAL_UART_Transmit+0x134>
    }

#if defined(USART_DMAREQUESTS_SW_WA)
    /* Disable the UART DMA Tx request if enabled */
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
 80143f8:	68fb      	ldr	r3, [r7, #12]
 80143fa:	681b      	ldr	r3, [r3, #0]
 80143fc:	689b      	ldr	r3, [r3, #8]
 80143fe:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8014402:	2b80      	cmp	r3, #128	@ 0x80
 8014404:	d107      	bne.n	8014416 <HAL_UART_Transmit+0x4a>
    {
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8014406:	68fb      	ldr	r3, [r7, #12]
 8014408:	681b      	ldr	r3, [r3, #0]
 801440a:	689a      	ldr	r2, [r3, #8]
 801440c:	68fb      	ldr	r3, [r7, #12]
 801440e:	681b      	ldr	r3, [r3, #0]
 8014410:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8014414:	609a      	str	r2, [r3, #8]
    }

#endif /* USART_DMAREQUESTS_SW_WA */
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8014416:	68fb      	ldr	r3, [r7, #12]
 8014418:	2200      	movs	r2, #0
 801441a:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
 801441e:	68fb      	ldr	r3, [r7, #12]
 8014420:	2221      	movs	r2, #33	@ 0x21
 8014422:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 8014426:	f7f9 fcd1 	bl	800ddcc <HAL_GetTick>
 801442a:	6178      	str	r0, [r7, #20]

    huart->TxXferSize  = Size;
 801442c:	68fb      	ldr	r3, [r7, #12]
 801442e:	88fa      	ldrh	r2, [r7, #6]
 8014430:	f8a3 2054 	strh.w	r2, [r3, #84]	@ 0x54
    huart->TxXferCount = Size;
 8014434:	68fb      	ldr	r3, [r7, #12]
 8014436:	88fa      	ldrh	r2, [r7, #6]
 8014438:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 801443c:	68fb      	ldr	r3, [r7, #12]
 801443e:	689b      	ldr	r3, [r3, #8]
 8014440:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8014444:	d108      	bne.n	8014458 <HAL_UART_Transmit+0x8c>
 8014446:	68fb      	ldr	r3, [r7, #12]
 8014448:	691b      	ldr	r3, [r3, #16]
 801444a:	2b00      	cmp	r3, #0
 801444c:	d104      	bne.n	8014458 <HAL_UART_Transmit+0x8c>
    {
      pdata8bits  = NULL;
 801444e:	2300      	movs	r3, #0
 8014450:	61fb      	str	r3, [r7, #28]
      pdata16bits = (const uint16_t *) pData;
 8014452:	68bb      	ldr	r3, [r7, #8]
 8014454:	61bb      	str	r3, [r7, #24]
 8014456:	e003      	b.n	8014460 <HAL_UART_Transmit+0x94>
    }
    else
    {
      pdata8bits  = pData;
 8014458:	68bb      	ldr	r3, [r7, #8]
 801445a:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 801445c:	2300      	movs	r3, #0
 801445e:	61bb      	str	r3, [r7, #24]
    }

    while (huart->TxXferCount > 0U)
 8014460:	e030      	b.n	80144c4 <HAL_UART_Transmit+0xf8>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8014462:	683b      	ldr	r3, [r7, #0]
 8014464:	9300      	str	r3, [sp, #0]
 8014466:	697b      	ldr	r3, [r7, #20]
 8014468:	2200      	movs	r2, #0
 801446a:	2180      	movs	r1, #128	@ 0x80
 801446c:	68f8      	ldr	r0, [r7, #12]
 801446e:	f000 fb85 	bl	8014b7c <UART_WaitOnFlagUntilTimeout>
 8014472:	4603      	mov	r3, r0
 8014474:	2b00      	cmp	r3, #0
 8014476:	d005      	beq.n	8014484 <HAL_UART_Transmit+0xb8>
      {

        huart->gState = HAL_UART_STATE_READY;
 8014478:	68fb      	ldr	r3, [r7, #12]
 801447a:	2220      	movs	r2, #32
 801447c:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

        return HAL_TIMEOUT;
 8014480:	2303      	movs	r3, #3
 8014482:	e03d      	b.n	8014500 <HAL_UART_Transmit+0x134>
      }
      if (pdata8bits == NULL)
 8014484:	69fb      	ldr	r3, [r7, #28]
 8014486:	2b00      	cmp	r3, #0
 8014488:	d10b      	bne.n	80144a2 <HAL_UART_Transmit+0xd6>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 801448a:	69bb      	ldr	r3, [r7, #24]
 801448c:	881b      	ldrh	r3, [r3, #0]
 801448e:	461a      	mov	r2, r3
 8014490:	68fb      	ldr	r3, [r7, #12]
 8014492:	681b      	ldr	r3, [r3, #0]
 8014494:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8014498:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata16bits++;
 801449a:	69bb      	ldr	r3, [r7, #24]
 801449c:	3302      	adds	r3, #2
 801449e:	61bb      	str	r3, [r7, #24]
 80144a0:	e007      	b.n	80144b2 <HAL_UART_Transmit+0xe6>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 80144a2:	69fb      	ldr	r3, [r7, #28]
 80144a4:	781a      	ldrb	r2, [r3, #0]
 80144a6:	68fb      	ldr	r3, [r7, #12]
 80144a8:	681b      	ldr	r3, [r3, #0]
 80144aa:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata8bits++;
 80144ac:	69fb      	ldr	r3, [r7, #28]
 80144ae:	3301      	adds	r3, #1
 80144b0:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 80144b2:	68fb      	ldr	r3, [r7, #12]
 80144b4:	f8b3 3056 	ldrh.w	r3, [r3, #86]	@ 0x56
 80144b8:	b29b      	uxth	r3, r3
 80144ba:	3b01      	subs	r3, #1
 80144bc:	b29a      	uxth	r2, r3
 80144be:	68fb      	ldr	r3, [r7, #12]
 80144c0:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56
    while (huart->TxXferCount > 0U)
 80144c4:	68fb      	ldr	r3, [r7, #12]
 80144c6:	f8b3 3056 	ldrh.w	r3, [r3, #86]	@ 0x56
 80144ca:	b29b      	uxth	r3, r3
 80144cc:	2b00      	cmp	r3, #0
 80144ce:	d1c8      	bne.n	8014462 <HAL_UART_Transmit+0x96>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 80144d0:	683b      	ldr	r3, [r7, #0]
 80144d2:	9300      	str	r3, [sp, #0]
 80144d4:	697b      	ldr	r3, [r7, #20]
 80144d6:	2200      	movs	r2, #0
 80144d8:	2140      	movs	r1, #64	@ 0x40
 80144da:	68f8      	ldr	r0, [r7, #12]
 80144dc:	f000 fb4e 	bl	8014b7c <UART_WaitOnFlagUntilTimeout>
 80144e0:	4603      	mov	r3, r0
 80144e2:	2b00      	cmp	r3, #0
 80144e4:	d005      	beq.n	80144f2 <HAL_UART_Transmit+0x126>
    {
      huart->gState = HAL_UART_STATE_READY;
 80144e6:	68fb      	ldr	r3, [r7, #12]
 80144e8:	2220      	movs	r2, #32
 80144ea:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

      return HAL_TIMEOUT;
 80144ee:	2303      	movs	r3, #3
 80144f0:	e006      	b.n	8014500 <HAL_UART_Transmit+0x134>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 80144f2:	68fb      	ldr	r3, [r7, #12]
 80144f4:	2220      	movs	r2, #32
 80144f6:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

    return HAL_OK;
 80144fa:	2300      	movs	r3, #0
 80144fc:	e000      	b.n	8014500 <HAL_UART_Transmit+0x134>
  }
  else
  {
    return HAL_BUSY;
 80144fe:	2302      	movs	r3, #2
  }
}
 8014500:	4618      	mov	r0, r3
 8014502:	3720      	adds	r7, #32
 8014504:	46bd      	mov	sp, r7
 8014506:	bd80      	pop	{r7, pc}

08014508 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8014508:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 801450c:	b094      	sub	sp, #80	@ 0x50
 801450e:	af00      	add	r7, sp, #0
 8014510:	62f8      	str	r0, [r7, #44]	@ 0x2c
  uint32_t tmpreg;
  uint16_t brrtemp;
  uint32_t clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
 8014512:	2300      	movs	r3, #0
 8014514:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
  uint32_t pclk;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  if (UART_INSTANCE_LOWPOWER(huart))
 8014518:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801451a:	681a      	ldr	r2, [r3, #0]
 801451c:	4b78      	ldr	r3, [pc, #480]	@ (8014700 <UART_SetConfig+0x1f8>)
 801451e:	429a      	cmp	r2, r3
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8014520:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014522:	689a      	ldr	r2, [r3, #8]
 8014524:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014526:	691b      	ldr	r3, [r3, #16]
 8014528:	431a      	orrs	r2, r3
 801452a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801452c:	695b      	ldr	r3, [r3, #20]
 801452e:	431a      	orrs	r2, r3
 8014530:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014532:	69db      	ldr	r3, [r3, #28]
 8014534:	4313      	orrs	r3, r2
 8014536:	64fb      	str	r3, [r7, #76]	@ 0x4c
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8014538:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801453a:	681b      	ldr	r3, [r3, #0]
 801453c:	681b      	ldr	r3, [r3, #0]
 801453e:	4971      	ldr	r1, [pc, #452]	@ (8014704 <UART_SetConfig+0x1fc>)
 8014540:	4019      	ands	r1, r3
 8014542:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014544:	681a      	ldr	r2, [r3, #0]
 8014546:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8014548:	430b      	orrs	r3, r1
 801454a:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 801454c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801454e:	681b      	ldr	r3, [r3, #0]
 8014550:	685b      	ldr	r3, [r3, #4]
 8014552:	f423 5040 	bic.w	r0, r3, #12288	@ 0x3000
 8014556:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014558:	68d9      	ldr	r1, [r3, #12]
 801455a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801455c:	681a      	ldr	r2, [r3, #0]
 801455e:	ea40 0301 	orr.w	r3, r0, r1
 8014562:	6053      	str	r3, [r2, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8014564:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014566:	699b      	ldr	r3, [r3, #24]
 8014568:	64fb      	str	r3, [r7, #76]	@ 0x4c

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 801456a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801456c:	681a      	ldr	r2, [r3, #0]
 801456e:	4b64      	ldr	r3, [pc, #400]	@ (8014700 <UART_SetConfig+0x1f8>)
 8014570:	429a      	cmp	r2, r3
 8014572:	d009      	beq.n	8014588 <UART_SetConfig+0x80>
 8014574:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014576:	681a      	ldr	r2, [r3, #0]
 8014578:	4b63      	ldr	r3, [pc, #396]	@ (8014708 <UART_SetConfig+0x200>)
 801457a:	429a      	cmp	r2, r3
 801457c:	d004      	beq.n	8014588 <UART_SetConfig+0x80>
  {
    tmpreg |= huart->Init.OneBitSampling;
 801457e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014580:	6a1a      	ldr	r2, [r3, #32]
 8014582:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8014584:	4313      	orrs	r3, r2
 8014586:	64fb      	str	r3, [r7, #76]	@ 0x4c
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8014588:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801458a:	681b      	ldr	r3, [r3, #0]
 801458c:	689b      	ldr	r3, [r3, #8]
 801458e:	f023 416e 	bic.w	r1, r3, #3992977408	@ 0xee000000
 8014592:	f421 6130 	bic.w	r1, r1, #2816	@ 0xb00
 8014596:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014598:	681a      	ldr	r2, [r3, #0]
 801459a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801459c:	430b      	orrs	r3, r1
 801459e:	6093      	str	r3, [r2, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 80145a0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80145a2:	681b      	ldr	r3, [r3, #0]
 80145a4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80145a6:	f023 000f 	bic.w	r0, r3, #15
 80145aa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80145ac:	6a59      	ldr	r1, [r3, #36]	@ 0x24
 80145ae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80145b0:	681a      	ldr	r2, [r3, #0]
 80145b2:	ea40 0301 	orr.w	r3, r0, r1
 80145b6:	62d3      	str	r3, [r2, #44]	@ 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 80145b8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80145ba:	681a      	ldr	r2, [r3, #0]
 80145bc:	4b53      	ldr	r3, [pc, #332]	@ (801470c <UART_SetConfig+0x204>)
 80145be:	429a      	cmp	r2, r3
 80145c0:	d102      	bne.n	80145c8 <UART_SetConfig+0xc0>
 80145c2:	2301      	movs	r3, #1
 80145c4:	64bb      	str	r3, [r7, #72]	@ 0x48
 80145c6:	e066      	b.n	8014696 <UART_SetConfig+0x18e>
 80145c8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80145ca:	681a      	ldr	r2, [r3, #0]
 80145cc:	4b50      	ldr	r3, [pc, #320]	@ (8014710 <UART_SetConfig+0x208>)
 80145ce:	429a      	cmp	r2, r3
 80145d0:	d102      	bne.n	80145d8 <UART_SetConfig+0xd0>
 80145d2:	2302      	movs	r3, #2
 80145d4:	64bb      	str	r3, [r7, #72]	@ 0x48
 80145d6:	e05e      	b.n	8014696 <UART_SetConfig+0x18e>
 80145d8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80145da:	681a      	ldr	r2, [r3, #0]
 80145dc:	4b4d      	ldr	r3, [pc, #308]	@ (8014714 <UART_SetConfig+0x20c>)
 80145de:	429a      	cmp	r2, r3
 80145e0:	d102      	bne.n	80145e8 <UART_SetConfig+0xe0>
 80145e2:	2304      	movs	r3, #4
 80145e4:	64bb      	str	r3, [r7, #72]	@ 0x48
 80145e6:	e056      	b.n	8014696 <UART_SetConfig+0x18e>
 80145e8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80145ea:	681a      	ldr	r2, [r3, #0]
 80145ec:	4b4a      	ldr	r3, [pc, #296]	@ (8014718 <UART_SetConfig+0x210>)
 80145ee:	429a      	cmp	r2, r3
 80145f0:	d102      	bne.n	80145f8 <UART_SetConfig+0xf0>
 80145f2:	2308      	movs	r3, #8
 80145f4:	64bb      	str	r3, [r7, #72]	@ 0x48
 80145f6:	e04e      	b.n	8014696 <UART_SetConfig+0x18e>
 80145f8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80145fa:	681a      	ldr	r2, [r3, #0]
 80145fc:	4b47      	ldr	r3, [pc, #284]	@ (801471c <UART_SetConfig+0x214>)
 80145fe:	429a      	cmp	r2, r3
 8014600:	d102      	bne.n	8014608 <UART_SetConfig+0x100>
 8014602:	2310      	movs	r3, #16
 8014604:	64bb      	str	r3, [r7, #72]	@ 0x48
 8014606:	e046      	b.n	8014696 <UART_SetConfig+0x18e>
 8014608:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801460a:	681a      	ldr	r2, [r3, #0]
 801460c:	4b44      	ldr	r3, [pc, #272]	@ (8014720 <UART_SetConfig+0x218>)
 801460e:	429a      	cmp	r2, r3
 8014610:	d102      	bne.n	8014618 <UART_SetConfig+0x110>
 8014612:	2320      	movs	r3, #32
 8014614:	64bb      	str	r3, [r7, #72]	@ 0x48
 8014616:	e03e      	b.n	8014696 <UART_SetConfig+0x18e>
 8014618:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801461a:	681a      	ldr	r2, [r3, #0]
 801461c:	4b41      	ldr	r3, [pc, #260]	@ (8014724 <UART_SetConfig+0x21c>)
 801461e:	429a      	cmp	r2, r3
 8014620:	d102      	bne.n	8014628 <UART_SetConfig+0x120>
 8014622:	2340      	movs	r3, #64	@ 0x40
 8014624:	64bb      	str	r3, [r7, #72]	@ 0x48
 8014626:	e036      	b.n	8014696 <UART_SetConfig+0x18e>
 8014628:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801462a:	681a      	ldr	r2, [r3, #0]
 801462c:	4b3e      	ldr	r3, [pc, #248]	@ (8014728 <UART_SetConfig+0x220>)
 801462e:	429a      	cmp	r2, r3
 8014630:	d102      	bne.n	8014638 <UART_SetConfig+0x130>
 8014632:	2380      	movs	r3, #128	@ 0x80
 8014634:	64bb      	str	r3, [r7, #72]	@ 0x48
 8014636:	e02e      	b.n	8014696 <UART_SetConfig+0x18e>
 8014638:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801463a:	681a      	ldr	r2, [r3, #0]
 801463c:	4b3b      	ldr	r3, [pc, #236]	@ (801472c <UART_SetConfig+0x224>)
 801463e:	429a      	cmp	r2, r3
 8014640:	d103      	bne.n	801464a <UART_SetConfig+0x142>
 8014642:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8014646:	64bb      	str	r3, [r7, #72]	@ 0x48
 8014648:	e025      	b.n	8014696 <UART_SetConfig+0x18e>
 801464a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801464c:	681a      	ldr	r2, [r3, #0]
 801464e:	4b38      	ldr	r3, [pc, #224]	@ (8014730 <UART_SetConfig+0x228>)
 8014650:	429a      	cmp	r2, r3
 8014652:	d103      	bne.n	801465c <UART_SetConfig+0x154>
 8014654:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8014658:	64bb      	str	r3, [r7, #72]	@ 0x48
 801465a:	e01c      	b.n	8014696 <UART_SetConfig+0x18e>
 801465c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801465e:	681a      	ldr	r2, [r3, #0]
 8014660:	4b34      	ldr	r3, [pc, #208]	@ (8014734 <UART_SetConfig+0x22c>)
 8014662:	429a      	cmp	r2, r3
 8014664:	d103      	bne.n	801466e <UART_SetConfig+0x166>
 8014666:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 801466a:	64bb      	str	r3, [r7, #72]	@ 0x48
 801466c:	e013      	b.n	8014696 <UART_SetConfig+0x18e>
 801466e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014670:	681a      	ldr	r2, [r3, #0]
 8014672:	4b31      	ldr	r3, [pc, #196]	@ (8014738 <UART_SetConfig+0x230>)
 8014674:	429a      	cmp	r2, r3
 8014676:	d103      	bne.n	8014680 <UART_SetConfig+0x178>
 8014678:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 801467c:	64bb      	str	r3, [r7, #72]	@ 0x48
 801467e:	e00a      	b.n	8014696 <UART_SetConfig+0x18e>
 8014680:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014682:	681a      	ldr	r2, [r3, #0]
 8014684:	4b1e      	ldr	r3, [pc, #120]	@ (8014700 <UART_SetConfig+0x1f8>)
 8014686:	429a      	cmp	r2, r3
 8014688:	d103      	bne.n	8014692 <UART_SetConfig+0x18a>
 801468a:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 801468e:	64bb      	str	r3, [r7, #72]	@ 0x48
 8014690:	e001      	b.n	8014696 <UART_SetConfig+0x18e>
 8014692:	2300      	movs	r3, #0
 8014694:	64bb      	str	r3, [r7, #72]	@ 0x48

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
 8014696:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014698:	681a      	ldr	r2, [r3, #0]
 801469a:	4b19      	ldr	r3, [pc, #100]	@ (8014700 <UART_SetConfig+0x1f8>)
 801469c:	429a      	cmp	r2, r3
 801469e:	d005      	beq.n	80146ac <UART_SetConfig+0x1a4>
 80146a0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80146a2:	681a      	ldr	r2, [r3, #0]
 80146a4:	4b18      	ldr	r3, [pc, #96]	@ (8014708 <UART_SetConfig+0x200>)
 80146a6:	429a      	cmp	r2, r3
 80146a8:	f040 8094 	bne.w	80147d4 <UART_SetConfig+0x2cc>
  {
    /* Retrieve frequency clock */
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 80146ac:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80146ae:	2200      	movs	r2, #0
 80146b0:	623b      	str	r3, [r7, #32]
 80146b2:	627a      	str	r2, [r7, #36]	@ 0x24
 80146b4:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 80146b8:	f7fd f9ae 	bl	8011a18 <HAL_RCCEx_GetPeriphCLKFreq>
 80146bc:	6438      	str	r0, [r7, #64]	@ 0x40

    /* If proper clock source reported */
    if (pclk != 0U)
 80146be:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80146c0:	2b00      	cmp	r3, #0
 80146c2:	f000 80f7 	beq.w	80148b4 <UART_SetConfig+0x3ac>
    {
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 80146c6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80146c8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80146ca:	4a1c      	ldr	r2, [pc, #112]	@ (801473c <UART_SetConfig+0x234>)
 80146cc:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80146d0:	461a      	mov	r2, r3
 80146d2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80146d4:	fbb3 f3f2 	udiv	r3, r3, r2
 80146d8:	637b      	str	r3, [r7, #52]	@ 0x34

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 80146da:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80146dc:	685a      	ldr	r2, [r3, #4]
 80146de:	4613      	mov	r3, r2
 80146e0:	005b      	lsls	r3, r3, #1
 80146e2:	4413      	add	r3, r2
 80146e4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80146e6:	429a      	cmp	r2, r3
 80146e8:	d305      	bcc.n	80146f6 <UART_SetConfig+0x1ee>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
 80146ea:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80146ec:	685b      	ldr	r3, [r3, #4]
 80146ee:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 80146f0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80146f2:	429a      	cmp	r2, r3
 80146f4:	d924      	bls.n	8014740 <UART_SetConfig+0x238>
      {
        ret = HAL_ERROR;
 80146f6:	2301      	movs	r3, #1
 80146f8:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
 80146fc:	e069      	b.n	80147d2 <UART_SetConfig+0x2ca>
 80146fe:	bf00      	nop
 8014700:	44002400 	.word	0x44002400
 8014704:	cfff69f3 	.word	0xcfff69f3
 8014708:	54002400 	.word	0x54002400
 801470c:	40013800 	.word	0x40013800
 8014710:	40004400 	.word	0x40004400
 8014714:	40004800 	.word	0x40004800
 8014718:	40004c00 	.word	0x40004c00
 801471c:	40005000 	.word	0x40005000
 8014720:	40006400 	.word	0x40006400
 8014724:	40007800 	.word	0x40007800
 8014728:	40007c00 	.word	0x40007c00
 801472c:	40008000 	.word	0x40008000
 8014730:	40006800 	.word	0x40006800
 8014734:	40006c00 	.word	0x40006c00
 8014738:	40008400 	.word	0x40008400
 801473c:	08016fe8 	.word	0x08016fe8
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8014740:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8014742:	2200      	movs	r2, #0
 8014744:	61bb      	str	r3, [r7, #24]
 8014746:	61fa      	str	r2, [r7, #28]
 8014748:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801474a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801474c:	4a64      	ldr	r2, [pc, #400]	@ (80148e0 <UART_SetConfig+0x3d8>)
 801474e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8014752:	b29b      	uxth	r3, r3
 8014754:	2200      	movs	r2, #0
 8014756:	613b      	str	r3, [r7, #16]
 8014758:	617a      	str	r2, [r7, #20]
 801475a:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 801475e:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8014762:	f7eb fd95 	bl	8000290 <__aeabi_uldivmod>
 8014766:	4602      	mov	r2, r0
 8014768:	460b      	mov	r3, r1
 801476a:	4610      	mov	r0, r2
 801476c:	4619      	mov	r1, r3
 801476e:	f04f 0200 	mov.w	r2, #0
 8014772:	f04f 0300 	mov.w	r3, #0
 8014776:	020b      	lsls	r3, r1, #8
 8014778:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
 801477c:	0202      	lsls	r2, r0, #8
 801477e:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8014780:	6849      	ldr	r1, [r1, #4]
 8014782:	0849      	lsrs	r1, r1, #1
 8014784:	2000      	movs	r0, #0
 8014786:	460c      	mov	r4, r1
 8014788:	4605      	mov	r5, r0
 801478a:	eb12 0804 	adds.w	r8, r2, r4
 801478e:	eb43 0905 	adc.w	r9, r3, r5
 8014792:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014794:	685b      	ldr	r3, [r3, #4]
 8014796:	2200      	movs	r2, #0
 8014798:	60bb      	str	r3, [r7, #8]
 801479a:	60fa      	str	r2, [r7, #12]
 801479c:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 80147a0:	4640      	mov	r0, r8
 80147a2:	4649      	mov	r1, r9
 80147a4:	f7eb fd74 	bl	8000290 <__aeabi_uldivmod>
 80147a8:	4602      	mov	r2, r0
 80147aa:	460b      	mov	r3, r1
 80147ac:	4613      	mov	r3, r2
 80147ae:	63fb      	str	r3, [r7, #60]	@ 0x3c
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 80147b0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80147b2:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 80147b6:	d308      	bcc.n	80147ca <UART_SetConfig+0x2c2>
 80147b8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80147ba:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 80147be:	d204      	bcs.n	80147ca <UART_SetConfig+0x2c2>
        {
          huart->Instance->BRR = usartdiv;
 80147c0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80147c2:	681b      	ldr	r3, [r3, #0]
 80147c4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80147c6:	60da      	str	r2, [r3, #12]
 80147c8:	e003      	b.n	80147d2 <UART_SetConfig+0x2ca>
        }
        else
        {
          ret = HAL_ERROR;
 80147ca:	2301      	movs	r3, #1
 80147cc:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
    if (pclk != 0U)
 80147d0:	e070      	b.n	80148b4 <UART_SetConfig+0x3ac>
 80147d2:	e06f      	b.n	80148b4 <UART_SetConfig+0x3ac>
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80147d4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80147d6:	69db      	ldr	r3, [r3, #28]
 80147d8:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 80147dc:	d13c      	bne.n	8014858 <UART_SetConfig+0x350>
  {
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 80147de:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80147e0:	2200      	movs	r2, #0
 80147e2:	603b      	str	r3, [r7, #0]
 80147e4:	607a      	str	r2, [r7, #4]
 80147e6:	e9d7 0100 	ldrd	r0, r1, [r7]
 80147ea:	f7fd f915 	bl	8011a18 <HAL_RCCEx_GetPeriphCLKFreq>
 80147ee:	6438      	str	r0, [r7, #64]	@ 0x40

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
 80147f0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80147f2:	2b00      	cmp	r3, #0
 80147f4:	d05e      	beq.n	80148b4 <UART_SetConfig+0x3ac>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80147f6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80147f8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80147fa:	4a39      	ldr	r2, [pc, #228]	@ (80148e0 <UART_SetConfig+0x3d8>)
 80147fc:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8014800:	461a      	mov	r2, r3
 8014802:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8014804:	fbb3 f3f2 	udiv	r3, r3, r2
 8014808:	005a      	lsls	r2, r3, #1
 801480a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801480c:	685b      	ldr	r3, [r3, #4]
 801480e:	085b      	lsrs	r3, r3, #1
 8014810:	441a      	add	r2, r3
 8014812:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014814:	685b      	ldr	r3, [r3, #4]
 8014816:	fbb2 f3f3 	udiv	r3, r2, r3
 801481a:	63fb      	str	r3, [r7, #60]	@ 0x3c
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 801481c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801481e:	2b0f      	cmp	r3, #15
 8014820:	d916      	bls.n	8014850 <UART_SetConfig+0x348>
 8014822:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014824:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8014828:	d212      	bcs.n	8014850 <UART_SetConfig+0x348>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 801482a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801482c:	b29b      	uxth	r3, r3
 801482e:	f023 030f 	bic.w	r3, r3, #15
 8014832:	877b      	strh	r3, [r7, #58]	@ 0x3a
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8014834:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014836:	085b      	lsrs	r3, r3, #1
 8014838:	b29b      	uxth	r3, r3
 801483a:	f003 0307 	and.w	r3, r3, #7
 801483e:	b29a      	uxth	r2, r3
 8014840:	8f7b      	ldrh	r3, [r7, #58]	@ 0x3a
 8014842:	4313      	orrs	r3, r2
 8014844:	877b      	strh	r3, [r7, #58]	@ 0x3a
        huart->Instance->BRR = brrtemp;
 8014846:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014848:	681b      	ldr	r3, [r3, #0]
 801484a:	8f7a      	ldrh	r2, [r7, #58]	@ 0x3a
 801484c:	60da      	str	r2, [r3, #12]
 801484e:	e031      	b.n	80148b4 <UART_SetConfig+0x3ac>
      }
      else
      {
        ret = HAL_ERROR;
 8014850:	2301      	movs	r3, #1
 8014852:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
 8014856:	e02d      	b.n	80148b4 <UART_SetConfig+0x3ac>
      }
    }
  }
  else
  {
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 8014858:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801485a:	2200      	movs	r2, #0
 801485c:	469a      	mov	sl, r3
 801485e:	4693      	mov	fp, r2
 8014860:	4650      	mov	r0, sl
 8014862:	4659      	mov	r1, fp
 8014864:	f7fd f8d8 	bl	8011a18 <HAL_RCCEx_GetPeriphCLKFreq>
 8014868:	6438      	str	r0, [r7, #64]	@ 0x40

    if (pclk != 0U)
 801486a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801486c:	2b00      	cmp	r3, #0
 801486e:	d021      	beq.n	80148b4 <UART_SetConfig+0x3ac>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8014870:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014872:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8014874:	4a1a      	ldr	r2, [pc, #104]	@ (80148e0 <UART_SetConfig+0x3d8>)
 8014876:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 801487a:	461a      	mov	r2, r3
 801487c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801487e:	fbb3 f2f2 	udiv	r2, r3, r2
 8014882:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014884:	685b      	ldr	r3, [r3, #4]
 8014886:	085b      	lsrs	r3, r3, #1
 8014888:	441a      	add	r2, r3
 801488a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801488c:	685b      	ldr	r3, [r3, #4]
 801488e:	fbb2 f3f3 	udiv	r3, r2, r3
 8014892:	63fb      	str	r3, [r7, #60]	@ 0x3c
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8014894:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014896:	2b0f      	cmp	r3, #15
 8014898:	d909      	bls.n	80148ae <UART_SetConfig+0x3a6>
 801489a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801489c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 80148a0:	d205      	bcs.n	80148ae <UART_SetConfig+0x3a6>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
 80148a2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80148a4:	b29a      	uxth	r2, r3
 80148a6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80148a8:	681b      	ldr	r3, [r3, #0]
 80148aa:	60da      	str	r2, [r3, #12]
 80148ac:	e002      	b.n	80148b4 <UART_SetConfig+0x3ac>
      }
      else
      {
        ret = HAL_ERROR;
 80148ae:	2301      	movs	r3, #1
 80148b0:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
      }
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
 80148b4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80148b6:	2201      	movs	r2, #1
 80148b8:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
  huart->NbRxDataToProcess = 1;
 80148bc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80148be:	2201      	movs	r2, #1
 80148c0:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 80148c4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80148c6:	2200      	movs	r2, #0
 80148c8:	675a      	str	r2, [r3, #116]	@ 0x74
  huart->TxISR = NULL;
 80148ca:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80148cc:	2200      	movs	r2, #0
 80148ce:	679a      	str	r2, [r3, #120]	@ 0x78

  return ret;
 80148d0:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
}
 80148d4:	4618      	mov	r0, r3
 80148d6:	3750      	adds	r7, #80	@ 0x50
 80148d8:	46bd      	mov	sp, r7
 80148da:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 80148de:	bf00      	nop
 80148e0:	08016fe8 	.word	0x08016fe8

080148e4 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 80148e4:	b480      	push	{r7}
 80148e6:	b083      	sub	sp, #12
 80148e8:	af00      	add	r7, sp, #0
 80148ea:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 80148ec:	687b      	ldr	r3, [r7, #4]
 80148ee:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80148f0:	f003 0308 	and.w	r3, r3, #8
 80148f4:	2b00      	cmp	r3, #0
 80148f6:	d00a      	beq.n	801490e <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 80148f8:	687b      	ldr	r3, [r7, #4]
 80148fa:	681b      	ldr	r3, [r3, #0]
 80148fc:	685b      	ldr	r3, [r3, #4]
 80148fe:	f423 4100 	bic.w	r1, r3, #32768	@ 0x8000
 8014902:	687b      	ldr	r3, [r7, #4]
 8014904:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8014906:	687b      	ldr	r3, [r7, #4]
 8014908:	681b      	ldr	r3, [r3, #0]
 801490a:	430a      	orrs	r2, r1
 801490c:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 801490e:	687b      	ldr	r3, [r7, #4]
 8014910:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8014912:	f003 0301 	and.w	r3, r3, #1
 8014916:	2b00      	cmp	r3, #0
 8014918:	d00a      	beq.n	8014930 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 801491a:	687b      	ldr	r3, [r7, #4]
 801491c:	681b      	ldr	r3, [r3, #0]
 801491e:	685b      	ldr	r3, [r3, #4]
 8014920:	f423 3100 	bic.w	r1, r3, #131072	@ 0x20000
 8014924:	687b      	ldr	r3, [r7, #4]
 8014926:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8014928:	687b      	ldr	r3, [r7, #4]
 801492a:	681b      	ldr	r3, [r3, #0]
 801492c:	430a      	orrs	r2, r1
 801492e:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8014930:	687b      	ldr	r3, [r7, #4]
 8014932:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8014934:	f003 0302 	and.w	r3, r3, #2
 8014938:	2b00      	cmp	r3, #0
 801493a:	d00a      	beq.n	8014952 <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 801493c:	687b      	ldr	r3, [r7, #4]
 801493e:	681b      	ldr	r3, [r3, #0]
 8014940:	685b      	ldr	r3, [r3, #4]
 8014942:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
 8014946:	687b      	ldr	r3, [r7, #4]
 8014948:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 801494a:	687b      	ldr	r3, [r7, #4]
 801494c:	681b      	ldr	r3, [r3, #0]
 801494e:	430a      	orrs	r2, r1
 8014950:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8014952:	687b      	ldr	r3, [r7, #4]
 8014954:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8014956:	f003 0304 	and.w	r3, r3, #4
 801495a:	2b00      	cmp	r3, #0
 801495c:	d00a      	beq.n	8014974 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 801495e:	687b      	ldr	r3, [r7, #4]
 8014960:	681b      	ldr	r3, [r3, #0]
 8014962:	685b      	ldr	r3, [r3, #4]
 8014964:	f423 2180 	bic.w	r1, r3, #262144	@ 0x40000
 8014968:	687b      	ldr	r3, [r7, #4]
 801496a:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 801496c:	687b      	ldr	r3, [r7, #4]
 801496e:	681b      	ldr	r3, [r3, #0]
 8014970:	430a      	orrs	r2, r1
 8014972:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8014974:	687b      	ldr	r3, [r7, #4]
 8014976:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8014978:	f003 0310 	and.w	r3, r3, #16
 801497c:	2b00      	cmp	r3, #0
 801497e:	d00a      	beq.n	8014996 <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8014980:	687b      	ldr	r3, [r7, #4]
 8014982:	681b      	ldr	r3, [r3, #0]
 8014984:	689b      	ldr	r3, [r3, #8]
 8014986:	f423 5180 	bic.w	r1, r3, #4096	@ 0x1000
 801498a:	687b      	ldr	r3, [r7, #4]
 801498c:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 801498e:	687b      	ldr	r3, [r7, #4]
 8014990:	681b      	ldr	r3, [r3, #0]
 8014992:	430a      	orrs	r2, r1
 8014994:	609a      	str	r2, [r3, #8]
  }

#if defined(HAL_DMA_MODULE_ENABLED)
  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8014996:	687b      	ldr	r3, [r7, #4]
 8014998:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801499a:	f003 0320 	and.w	r3, r3, #32
 801499e:	2b00      	cmp	r3, #0
 80149a0:	d00a      	beq.n	80149b8 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 80149a2:	687b      	ldr	r3, [r7, #4]
 80149a4:	681b      	ldr	r3, [r3, #0]
 80149a6:	689b      	ldr	r3, [r3, #8]
 80149a8:	f423 5100 	bic.w	r1, r3, #8192	@ 0x2000
 80149ac:	687b      	ldr	r3, [r7, #4]
 80149ae:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 80149b0:	687b      	ldr	r3, [r7, #4]
 80149b2:	681b      	ldr	r3, [r3, #0]
 80149b4:	430a      	orrs	r2, r1
 80149b6:	609a      	str	r2, [r3, #8]
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 80149b8:	687b      	ldr	r3, [r7, #4]
 80149ba:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80149bc:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80149c0:	2b00      	cmp	r3, #0
 80149c2:	d01a      	beq.n	80149fa <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80149c4:	687b      	ldr	r3, [r7, #4]
 80149c6:	681b      	ldr	r3, [r3, #0]
 80149c8:	685b      	ldr	r3, [r3, #4]
 80149ca:	f423 1180 	bic.w	r1, r3, #1048576	@ 0x100000
 80149ce:	687b      	ldr	r3, [r7, #4]
 80149d0:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80149d2:	687b      	ldr	r3, [r7, #4]
 80149d4:	681b      	ldr	r3, [r3, #0]
 80149d6:	430a      	orrs	r2, r1
 80149d8:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80149da:	687b      	ldr	r3, [r7, #4]
 80149dc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80149de:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 80149e2:	d10a      	bne.n	80149fa <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 80149e4:	687b      	ldr	r3, [r7, #4]
 80149e6:	681b      	ldr	r3, [r3, #0]
 80149e8:	685b      	ldr	r3, [r3, #4]
 80149ea:	f423 01c0 	bic.w	r1, r3, #6291456	@ 0x600000
 80149ee:	687b      	ldr	r3, [r7, #4]
 80149f0:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 80149f2:	687b      	ldr	r3, [r7, #4]
 80149f4:	681b      	ldr	r3, [r3, #0]
 80149f6:	430a      	orrs	r2, r1
 80149f8:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 80149fa:	687b      	ldr	r3, [r7, #4]
 80149fc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80149fe:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8014a02:	2b00      	cmp	r3, #0
 8014a04:	d00a      	beq.n	8014a1c <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8014a06:	687b      	ldr	r3, [r7, #4]
 8014a08:	681b      	ldr	r3, [r3, #0]
 8014a0a:	685b      	ldr	r3, [r3, #4]
 8014a0c:	f423 2100 	bic.w	r1, r3, #524288	@ 0x80000
 8014a10:	687b      	ldr	r3, [r7, #4]
 8014a12:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8014a14:	687b      	ldr	r3, [r7, #4]
 8014a16:	681b      	ldr	r3, [r3, #0]
 8014a18:	430a      	orrs	r2, r1
 8014a1a:	605a      	str	r2, [r3, #4]
  }
}
 8014a1c:	bf00      	nop
 8014a1e:	370c      	adds	r7, #12
 8014a20:	46bd      	mov	sp, r7
 8014a22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014a26:	4770      	bx	lr

08014a28 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 8014a28:	b580      	push	{r7, lr}
 8014a2a:	b098      	sub	sp, #96	@ 0x60
 8014a2c:	af02      	add	r7, sp, #8
 8014a2e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8014a30:	687b      	ldr	r3, [r7, #4]
 8014a32:	2200      	movs	r2, #0
 8014a34:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 8014a38:	f7f9 f9c8 	bl	800ddcc <HAL_GetTick>
 8014a3c:	6578      	str	r0, [r7, #84]	@ 0x54

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8014a3e:	687b      	ldr	r3, [r7, #4]
 8014a40:	681b      	ldr	r3, [r3, #0]
 8014a42:	681b      	ldr	r3, [r3, #0]
 8014a44:	f003 0308 	and.w	r3, r3, #8
 8014a48:	2b08      	cmp	r3, #8
 8014a4a:	d12f      	bne.n	8014aac <UART_CheckIdleState+0x84>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8014a4c:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 8014a50:	9300      	str	r3, [sp, #0]
 8014a52:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8014a54:	2200      	movs	r2, #0
 8014a56:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
 8014a5a:	6878      	ldr	r0, [r7, #4]
 8014a5c:	f000 f88e 	bl	8014b7c <UART_WaitOnFlagUntilTimeout>
 8014a60:	4603      	mov	r3, r0
 8014a62:	2b00      	cmp	r3, #0
 8014a64:	d022      	beq.n	8014aac <UART_CheckIdleState+0x84>
    {
      /* Disable TXE interrupt for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
 8014a66:	687b      	ldr	r3, [r7, #4]
 8014a68:	681b      	ldr	r3, [r3, #0]
 8014a6a:	63bb      	str	r3, [r7, #56]	@ 0x38
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8014a6c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014a6e:	e853 3f00 	ldrex	r3, [r3]
 8014a72:	637b      	str	r3, [r7, #52]	@ 0x34
   return(result);
 8014a74:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014a76:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8014a7a:	653b      	str	r3, [r7, #80]	@ 0x50
 8014a7c:	687b      	ldr	r3, [r7, #4]
 8014a7e:	681b      	ldr	r3, [r3, #0]
 8014a80:	461a      	mov	r2, r3
 8014a82:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8014a84:	647b      	str	r3, [r7, #68]	@ 0x44
 8014a86:	643a      	str	r2, [r7, #64]	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8014a88:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 8014a8a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8014a8c:	e841 2300 	strex	r3, r2, [r1]
 8014a90:	63fb      	str	r3, [r7, #60]	@ 0x3c
   return(result);
 8014a92:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014a94:	2b00      	cmp	r3, #0
 8014a96:	d1e6      	bne.n	8014a66 <UART_CheckIdleState+0x3e>

      huart->gState = HAL_UART_STATE_READY;
 8014a98:	687b      	ldr	r3, [r7, #4]
 8014a9a:	2220      	movs	r2, #32
 8014a9c:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

      __HAL_UNLOCK(huart);
 8014aa0:	687b      	ldr	r3, [r7, #4]
 8014aa2:	2200      	movs	r2, #0
 8014aa4:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
 8014aa8:	2303      	movs	r3, #3
 8014aaa:	e063      	b.n	8014b74 <UART_CheckIdleState+0x14c>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8014aac:	687b      	ldr	r3, [r7, #4]
 8014aae:	681b      	ldr	r3, [r3, #0]
 8014ab0:	681b      	ldr	r3, [r3, #0]
 8014ab2:	f003 0304 	and.w	r3, r3, #4
 8014ab6:	2b04      	cmp	r3, #4
 8014ab8:	d149      	bne.n	8014b4e <UART_CheckIdleState+0x126>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8014aba:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 8014abe:	9300      	str	r3, [sp, #0]
 8014ac0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8014ac2:	2200      	movs	r2, #0
 8014ac4:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
 8014ac8:	6878      	ldr	r0, [r7, #4]
 8014aca:	f000 f857 	bl	8014b7c <UART_WaitOnFlagUntilTimeout>
 8014ace:	4603      	mov	r3, r0
 8014ad0:	2b00      	cmp	r3, #0
 8014ad2:	d03c      	beq.n	8014b4e <UART_CheckIdleState+0x126>
    {
      /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error)
      interrupts for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8014ad4:	687b      	ldr	r3, [r7, #4]
 8014ad6:	681b      	ldr	r3, [r3, #0]
 8014ad8:	627b      	str	r3, [r7, #36]	@ 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8014ada:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014adc:	e853 3f00 	ldrex	r3, [r3]
 8014ae0:	623b      	str	r3, [r7, #32]
   return(result);
 8014ae2:	6a3b      	ldr	r3, [r7, #32]
 8014ae4:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 8014ae8:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8014aea:	687b      	ldr	r3, [r7, #4]
 8014aec:	681b      	ldr	r3, [r3, #0]
 8014aee:	461a      	mov	r2, r3
 8014af0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8014af2:	633b      	str	r3, [r7, #48]	@ 0x30
 8014af4:	62fa      	str	r2, [r7, #44]	@ 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8014af6:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8014af8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8014afa:	e841 2300 	strex	r3, r2, [r1]
 8014afe:	62bb      	str	r3, [r7, #40]	@ 0x28
   return(result);
 8014b00:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014b02:	2b00      	cmp	r3, #0
 8014b04:	d1e6      	bne.n	8014ad4 <UART_CheckIdleState+0xac>
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8014b06:	687b      	ldr	r3, [r7, #4]
 8014b08:	681b      	ldr	r3, [r3, #0]
 8014b0a:	3308      	adds	r3, #8
 8014b0c:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8014b0e:	693b      	ldr	r3, [r7, #16]
 8014b10:	e853 3f00 	ldrex	r3, [r3]
 8014b14:	60fb      	str	r3, [r7, #12]
   return(result);
 8014b16:	68fb      	ldr	r3, [r7, #12]
 8014b18:	f023 0301 	bic.w	r3, r3, #1
 8014b1c:	64bb      	str	r3, [r7, #72]	@ 0x48
 8014b1e:	687b      	ldr	r3, [r7, #4]
 8014b20:	681b      	ldr	r3, [r3, #0]
 8014b22:	3308      	adds	r3, #8
 8014b24:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8014b26:	61fa      	str	r2, [r7, #28]
 8014b28:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8014b2a:	69b9      	ldr	r1, [r7, #24]
 8014b2c:	69fa      	ldr	r2, [r7, #28]
 8014b2e:	e841 2300 	strex	r3, r2, [r1]
 8014b32:	617b      	str	r3, [r7, #20]
   return(result);
 8014b34:	697b      	ldr	r3, [r7, #20]
 8014b36:	2b00      	cmp	r3, #0
 8014b38:	d1e5      	bne.n	8014b06 <UART_CheckIdleState+0xde>

      huart->RxState = HAL_UART_STATE_READY;
 8014b3a:	687b      	ldr	r3, [r7, #4]
 8014b3c:	2220      	movs	r2, #32
 8014b3e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

      __HAL_UNLOCK(huart);
 8014b42:	687b      	ldr	r3, [r7, #4]
 8014b44:	2200      	movs	r2, #0
 8014b46:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
 8014b4a:	2303      	movs	r3, #3
 8014b4c:	e012      	b.n	8014b74 <UART_CheckIdleState+0x14c>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 8014b4e:	687b      	ldr	r3, [r7, #4]
 8014b50:	2220      	movs	r2, #32
 8014b52:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
 8014b56:	687b      	ldr	r3, [r7, #4]
 8014b58:	2220      	movs	r2, #32
 8014b5a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8014b5e:	687b      	ldr	r3, [r7, #4]
 8014b60:	2200      	movs	r2, #0
 8014b62:	66da      	str	r2, [r3, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 8014b64:	687b      	ldr	r3, [r7, #4]
 8014b66:	2200      	movs	r2, #0
 8014b68:	671a      	str	r2, [r3, #112]	@ 0x70

  __HAL_UNLOCK(huart);
 8014b6a:	687b      	ldr	r3, [r7, #4]
 8014b6c:	2200      	movs	r2, #0
 8014b6e:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
 8014b72:	2300      	movs	r3, #0
}
 8014b74:	4618      	mov	r0, r3
 8014b76:	3758      	adds	r7, #88	@ 0x58
 8014b78:	46bd      	mov	sp, r7
 8014b7a:	bd80      	pop	{r7, pc}

08014b7c <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 8014b7c:	b580      	push	{r7, lr}
 8014b7e:	b084      	sub	sp, #16
 8014b80:	af00      	add	r7, sp, #0
 8014b82:	60f8      	str	r0, [r7, #12]
 8014b84:	60b9      	str	r1, [r7, #8]
 8014b86:	603b      	str	r3, [r7, #0]
 8014b88:	4613      	mov	r3, r2
 8014b8a:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8014b8c:	e04f      	b.n	8014c2e <UART_WaitOnFlagUntilTimeout+0xb2>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8014b8e:	69bb      	ldr	r3, [r7, #24]
 8014b90:	f1b3 3fff 	cmp.w	r3, #4294967295
 8014b94:	d04b      	beq.n	8014c2e <UART_WaitOnFlagUntilTimeout+0xb2>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8014b96:	f7f9 f919 	bl	800ddcc <HAL_GetTick>
 8014b9a:	4602      	mov	r2, r0
 8014b9c:	683b      	ldr	r3, [r7, #0]
 8014b9e:	1ad3      	subs	r3, r2, r3
 8014ba0:	69ba      	ldr	r2, [r7, #24]
 8014ba2:	429a      	cmp	r2, r3
 8014ba4:	d302      	bcc.n	8014bac <UART_WaitOnFlagUntilTimeout+0x30>
 8014ba6:	69bb      	ldr	r3, [r7, #24]
 8014ba8:	2b00      	cmp	r3, #0
 8014baa:	d101      	bne.n	8014bb0 <UART_WaitOnFlagUntilTimeout+0x34>
      {

        return HAL_TIMEOUT;
 8014bac:	2303      	movs	r3, #3
 8014bae:	e04e      	b.n	8014c4e <UART_WaitOnFlagUntilTimeout+0xd2>
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
 8014bb0:	68fb      	ldr	r3, [r7, #12]
 8014bb2:	681b      	ldr	r3, [r3, #0]
 8014bb4:	681b      	ldr	r3, [r3, #0]
 8014bb6:	f003 0304 	and.w	r3, r3, #4
 8014bba:	2b00      	cmp	r3, #0
 8014bbc:	d037      	beq.n	8014c2e <UART_WaitOnFlagUntilTimeout+0xb2>
 8014bbe:	68bb      	ldr	r3, [r7, #8]
 8014bc0:	2b80      	cmp	r3, #128	@ 0x80
 8014bc2:	d034      	beq.n	8014c2e <UART_WaitOnFlagUntilTimeout+0xb2>
 8014bc4:	68bb      	ldr	r3, [r7, #8]
 8014bc6:	2b40      	cmp	r3, #64	@ 0x40
 8014bc8:	d031      	beq.n	8014c2e <UART_WaitOnFlagUntilTimeout+0xb2>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 8014bca:	68fb      	ldr	r3, [r7, #12]
 8014bcc:	681b      	ldr	r3, [r3, #0]
 8014bce:	69db      	ldr	r3, [r3, #28]
 8014bd0:	f003 0308 	and.w	r3, r3, #8
 8014bd4:	2b08      	cmp	r3, #8
 8014bd6:	d110      	bne.n	8014bfa <UART_WaitOnFlagUntilTimeout+0x7e>
        {
          /* Clear Overrun Error flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 8014bd8:	68fb      	ldr	r3, [r7, #12]
 8014bda:	681b      	ldr	r3, [r3, #0]
 8014bdc:	2208      	movs	r2, #8
 8014bde:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
 8014be0:	68f8      	ldr	r0, [r7, #12]
 8014be2:	f000 f838 	bl	8014c56 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_ORE;
 8014be6:	68fb      	ldr	r3, [r7, #12]
 8014be8:	2208      	movs	r2, #8
 8014bea:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 8014bee:	68fb      	ldr	r3, [r7, #12]
 8014bf0:	2200      	movs	r2, #0
 8014bf2:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_ERROR;
 8014bf6:	2301      	movs	r3, #1
 8014bf8:	e029      	b.n	8014c4e <UART_WaitOnFlagUntilTimeout+0xd2>
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 8014bfa:	68fb      	ldr	r3, [r7, #12]
 8014bfc:	681b      	ldr	r3, [r3, #0]
 8014bfe:	69db      	ldr	r3, [r3, #28]
 8014c00:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8014c04:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8014c08:	d111      	bne.n	8014c2e <UART_WaitOnFlagUntilTimeout+0xb2>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8014c0a:	68fb      	ldr	r3, [r7, #12]
 8014c0c:	681b      	ldr	r3, [r3, #0]
 8014c0e:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8014c12:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
 8014c14:	68f8      	ldr	r0, [r7, #12]
 8014c16:	f000 f81e 	bl	8014c56 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_RTO;
 8014c1a:	68fb      	ldr	r3, [r7, #12]
 8014c1c:	2220      	movs	r2, #32
 8014c1e:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 8014c22:	68fb      	ldr	r3, [r7, #12]
 8014c24:	2200      	movs	r2, #0
 8014c26:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_TIMEOUT;
 8014c2a:	2303      	movs	r3, #3
 8014c2c:	e00f      	b.n	8014c4e <UART_WaitOnFlagUntilTimeout+0xd2>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8014c2e:	68fb      	ldr	r3, [r7, #12]
 8014c30:	681b      	ldr	r3, [r3, #0]
 8014c32:	69da      	ldr	r2, [r3, #28]
 8014c34:	68bb      	ldr	r3, [r7, #8]
 8014c36:	4013      	ands	r3, r2
 8014c38:	68ba      	ldr	r2, [r7, #8]
 8014c3a:	429a      	cmp	r2, r3
 8014c3c:	bf0c      	ite	eq
 8014c3e:	2301      	moveq	r3, #1
 8014c40:	2300      	movne	r3, #0
 8014c42:	b2db      	uxtb	r3, r3
 8014c44:	461a      	mov	r2, r3
 8014c46:	79fb      	ldrb	r3, [r7, #7]
 8014c48:	429a      	cmp	r2, r3
 8014c4a:	d0a0      	beq.n	8014b8e <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 8014c4c:	2300      	movs	r3, #0
}
 8014c4e:	4618      	mov	r0, r3
 8014c50:	3710      	adds	r7, #16
 8014c52:	46bd      	mov	sp, r7
 8014c54:	bd80      	pop	{r7, pc}

08014c56 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 8014c56:	b480      	push	{r7}
 8014c58:	b095      	sub	sp, #84	@ 0x54
 8014c5a:	af00      	add	r7, sp, #0
 8014c5c:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8014c5e:	687b      	ldr	r3, [r7, #4]
 8014c60:	681b      	ldr	r3, [r3, #0]
 8014c62:	637b      	str	r3, [r7, #52]	@ 0x34
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8014c64:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014c66:	e853 3f00 	ldrex	r3, [r3]
 8014c6a:	633b      	str	r3, [r7, #48]	@ 0x30
   return(result);
 8014c6c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014c6e:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 8014c72:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8014c74:	687b      	ldr	r3, [r7, #4]
 8014c76:	681b      	ldr	r3, [r3, #0]
 8014c78:	461a      	mov	r2, r3
 8014c7a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8014c7c:	643b      	str	r3, [r7, #64]	@ 0x40
 8014c7e:	63fa      	str	r2, [r7, #60]	@ 0x3c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8014c80:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8014c82:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8014c84:	e841 2300 	strex	r3, r2, [r1]
 8014c88:	63bb      	str	r3, [r7, #56]	@ 0x38
   return(result);
 8014c8a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014c8c:	2b00      	cmp	r3, #0
 8014c8e:	d1e6      	bne.n	8014c5e <UART_EndRxTransfer+0x8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8014c90:	687b      	ldr	r3, [r7, #4]
 8014c92:	681b      	ldr	r3, [r3, #0]
 8014c94:	3308      	adds	r3, #8
 8014c96:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8014c98:	6a3b      	ldr	r3, [r7, #32]
 8014c9a:	e853 3f00 	ldrex	r3, [r3]
 8014c9e:	61fb      	str	r3, [r7, #28]
   return(result);
 8014ca0:	69fb      	ldr	r3, [r7, #28]
 8014ca2:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 8014ca6:	f023 0301 	bic.w	r3, r3, #1
 8014caa:	64bb      	str	r3, [r7, #72]	@ 0x48
 8014cac:	687b      	ldr	r3, [r7, #4]
 8014cae:	681b      	ldr	r3, [r3, #0]
 8014cb0:	3308      	adds	r3, #8
 8014cb2:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8014cb4:	62fa      	str	r2, [r7, #44]	@ 0x2c
 8014cb6:	62bb      	str	r3, [r7, #40]	@ 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8014cb8:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8014cba:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8014cbc:	e841 2300 	strex	r3, r2, [r1]
 8014cc0:	627b      	str	r3, [r7, #36]	@ 0x24
   return(result);
 8014cc2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014cc4:	2b00      	cmp	r3, #0
 8014cc6:	d1e3      	bne.n	8014c90 <UART_EndRxTransfer+0x3a>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8014cc8:	687b      	ldr	r3, [r7, #4]
 8014cca:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8014ccc:	2b01      	cmp	r3, #1
 8014cce:	d118      	bne.n	8014d02 <UART_EndRxTransfer+0xac>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8014cd0:	687b      	ldr	r3, [r7, #4]
 8014cd2:	681b      	ldr	r3, [r3, #0]
 8014cd4:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8014cd6:	68fb      	ldr	r3, [r7, #12]
 8014cd8:	e853 3f00 	ldrex	r3, [r3]
 8014cdc:	60bb      	str	r3, [r7, #8]
   return(result);
 8014cde:	68bb      	ldr	r3, [r7, #8]
 8014ce0:	f023 0310 	bic.w	r3, r3, #16
 8014ce4:	647b      	str	r3, [r7, #68]	@ 0x44
 8014ce6:	687b      	ldr	r3, [r7, #4]
 8014ce8:	681b      	ldr	r3, [r3, #0]
 8014cea:	461a      	mov	r2, r3
 8014cec:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8014cee:	61bb      	str	r3, [r7, #24]
 8014cf0:	617a      	str	r2, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8014cf2:	6979      	ldr	r1, [r7, #20]
 8014cf4:	69ba      	ldr	r2, [r7, #24]
 8014cf6:	e841 2300 	strex	r3, r2, [r1]
 8014cfa:	613b      	str	r3, [r7, #16]
   return(result);
 8014cfc:	693b      	ldr	r3, [r7, #16]
 8014cfe:	2b00      	cmp	r3, #0
 8014d00:	d1e6      	bne.n	8014cd0 <UART_EndRxTransfer+0x7a>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8014d02:	687b      	ldr	r3, [r7, #4]
 8014d04:	2220      	movs	r2, #32
 8014d06:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8014d0a:	687b      	ldr	r3, [r7, #4]
 8014d0c:	2200      	movs	r2, #0
 8014d0e:	66da      	str	r2, [r3, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 8014d10:	687b      	ldr	r3, [r7, #4]
 8014d12:	2200      	movs	r2, #0
 8014d14:	675a      	str	r2, [r3, #116]	@ 0x74
}
 8014d16:	bf00      	nop
 8014d18:	3754      	adds	r7, #84	@ 0x54
 8014d1a:	46bd      	mov	sp, r7
 8014d1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014d20:	4770      	bx	lr

08014d22 <HAL_UARTEx_DisableFifoMode>:
  * @brief  Disable the FIFO mode.
  * @param huart      UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_DisableFifoMode(UART_HandleTypeDef *huart)
{
 8014d22:	b480      	push	{r7}
 8014d24:	b085      	sub	sp, #20
 8014d26:	af00      	add	r7, sp, #0
 8014d28:	6078      	str	r0, [r7, #4]

  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));

  /* Process Locked */
  __HAL_LOCK(huart);
 8014d2a:	687b      	ldr	r3, [r7, #4]
 8014d2c:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
 8014d30:	2b01      	cmp	r3, #1
 8014d32:	d101      	bne.n	8014d38 <HAL_UARTEx_DisableFifoMode+0x16>
 8014d34:	2302      	movs	r3, #2
 8014d36:	e027      	b.n	8014d88 <HAL_UARTEx_DisableFifoMode+0x66>
 8014d38:	687b      	ldr	r3, [r7, #4]
 8014d3a:	2201      	movs	r2, #1
 8014d3c:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  huart->gState = HAL_UART_STATE_BUSY;
 8014d40:	687b      	ldr	r3, [r7, #4]
 8014d42:	2224      	movs	r2, #36	@ 0x24
 8014d44:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8014d48:	687b      	ldr	r3, [r7, #4]
 8014d4a:	681b      	ldr	r3, [r3, #0]
 8014d4c:	681b      	ldr	r3, [r3, #0]
 8014d4e:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 8014d50:	687b      	ldr	r3, [r7, #4]
 8014d52:	681b      	ldr	r3, [r3, #0]
 8014d54:	681a      	ldr	r2, [r3, #0]
 8014d56:	687b      	ldr	r3, [r7, #4]
 8014d58:	681b      	ldr	r3, [r3, #0]
 8014d5a:	f022 0201 	bic.w	r2, r2, #1
 8014d5e:	601a      	str	r2, [r3, #0]

  /* Disable FIFO mode */
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
 8014d60:	68fb      	ldr	r3, [r7, #12]
 8014d62:	f023 5300 	bic.w	r3, r3, #536870912	@ 0x20000000
 8014d66:	60fb      	str	r3, [r7, #12]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 8014d68:	687b      	ldr	r3, [r7, #4]
 8014d6a:	2200      	movs	r2, #0
 8014d6c:	665a      	str	r2, [r3, #100]	@ 0x64

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8014d6e:	687b      	ldr	r3, [r7, #4]
 8014d70:	681b      	ldr	r3, [r3, #0]
 8014d72:	68fa      	ldr	r2, [r7, #12]
 8014d74:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 8014d76:	687b      	ldr	r3, [r7, #4]
 8014d78:	2220      	movs	r2, #32
 8014d7a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8014d7e:	687b      	ldr	r3, [r7, #4]
 8014d80:	2200      	movs	r2, #0
 8014d82:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
 8014d86:	2300      	movs	r3, #0
}
 8014d88:	4618      	mov	r0, r3
 8014d8a:	3714      	adds	r7, #20
 8014d8c:	46bd      	mov	sp, r7
 8014d8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014d92:	4770      	bx	lr

08014d94 <HAL_UARTEx_SetTxFifoThreshold>:
  *            @arg @ref UART_TXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_TXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetTxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
 8014d94:	b580      	push	{r7, lr}
 8014d96:	b084      	sub	sp, #16
 8014d98:	af00      	add	r7, sp, #0
 8014d9a:	6078      	str	r0, [r7, #4]
 8014d9c:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 8014d9e:	687b      	ldr	r3, [r7, #4]
 8014da0:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
 8014da4:	2b01      	cmp	r3, #1
 8014da6:	d101      	bne.n	8014dac <HAL_UARTEx_SetTxFifoThreshold+0x18>
 8014da8:	2302      	movs	r3, #2
 8014daa:	e02d      	b.n	8014e08 <HAL_UARTEx_SetTxFifoThreshold+0x74>
 8014dac:	687b      	ldr	r3, [r7, #4]
 8014dae:	2201      	movs	r2, #1
 8014db0:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  huart->gState = HAL_UART_STATE_BUSY;
 8014db4:	687b      	ldr	r3, [r7, #4]
 8014db6:	2224      	movs	r2, #36	@ 0x24
 8014db8:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8014dbc:	687b      	ldr	r3, [r7, #4]
 8014dbe:	681b      	ldr	r3, [r3, #0]
 8014dc0:	681b      	ldr	r3, [r3, #0]
 8014dc2:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 8014dc4:	687b      	ldr	r3, [r7, #4]
 8014dc6:	681b      	ldr	r3, [r3, #0]
 8014dc8:	681a      	ldr	r2, [r3, #0]
 8014dca:	687b      	ldr	r3, [r7, #4]
 8014dcc:	681b      	ldr	r3, [r3, #0]
 8014dce:	f022 0201 	bic.w	r2, r2, #1
 8014dd2:	601a      	str	r2, [r3, #0]

  /* Update TX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 8014dd4:	687b      	ldr	r3, [r7, #4]
 8014dd6:	681b      	ldr	r3, [r3, #0]
 8014dd8:	689b      	ldr	r3, [r3, #8]
 8014dda:	f023 4160 	bic.w	r1, r3, #3758096384	@ 0xe0000000
 8014dde:	687b      	ldr	r3, [r7, #4]
 8014de0:	681b      	ldr	r3, [r3, #0]
 8014de2:	683a      	ldr	r2, [r7, #0]
 8014de4:	430a      	orrs	r2, r1
 8014de6:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
 8014de8:	6878      	ldr	r0, [r7, #4]
 8014dea:	f000 f84f 	bl	8014e8c <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8014dee:	687b      	ldr	r3, [r7, #4]
 8014df0:	681b      	ldr	r3, [r3, #0]
 8014df2:	68fa      	ldr	r2, [r7, #12]
 8014df4:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 8014df6:	687b      	ldr	r3, [r7, #4]
 8014df8:	2220      	movs	r2, #32
 8014dfa:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8014dfe:	687b      	ldr	r3, [r7, #4]
 8014e00:	2200      	movs	r2, #0
 8014e02:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
 8014e06:	2300      	movs	r3, #0
}
 8014e08:	4618      	mov	r0, r3
 8014e0a:	3710      	adds	r7, #16
 8014e0c:	46bd      	mov	sp, r7
 8014e0e:	bd80      	pop	{r7, pc}

08014e10 <HAL_UARTEx_SetRxFifoThreshold>:
  *            @arg @ref UART_RXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_RXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetRxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
 8014e10:	b580      	push	{r7, lr}
 8014e12:	b084      	sub	sp, #16
 8014e14:	af00      	add	r7, sp, #0
 8014e16:	6078      	str	r0, [r7, #4]
 8014e18:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_RXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 8014e1a:	687b      	ldr	r3, [r7, #4]
 8014e1c:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
 8014e20:	2b01      	cmp	r3, #1
 8014e22:	d101      	bne.n	8014e28 <HAL_UARTEx_SetRxFifoThreshold+0x18>
 8014e24:	2302      	movs	r3, #2
 8014e26:	e02d      	b.n	8014e84 <HAL_UARTEx_SetRxFifoThreshold+0x74>
 8014e28:	687b      	ldr	r3, [r7, #4]
 8014e2a:	2201      	movs	r2, #1
 8014e2c:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  huart->gState = HAL_UART_STATE_BUSY;
 8014e30:	687b      	ldr	r3, [r7, #4]
 8014e32:	2224      	movs	r2, #36	@ 0x24
 8014e34:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8014e38:	687b      	ldr	r3, [r7, #4]
 8014e3a:	681b      	ldr	r3, [r3, #0]
 8014e3c:	681b      	ldr	r3, [r3, #0]
 8014e3e:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 8014e40:	687b      	ldr	r3, [r7, #4]
 8014e42:	681b      	ldr	r3, [r3, #0]
 8014e44:	681a      	ldr	r2, [r3, #0]
 8014e46:	687b      	ldr	r3, [r7, #4]
 8014e48:	681b      	ldr	r3, [r3, #0]
 8014e4a:	f022 0201 	bic.w	r2, r2, #1
 8014e4e:	601a      	str	r2, [r3, #0]

  /* Update RX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8014e50:	687b      	ldr	r3, [r7, #4]
 8014e52:	681b      	ldr	r3, [r3, #0]
 8014e54:	689b      	ldr	r3, [r3, #8]
 8014e56:	f023 6160 	bic.w	r1, r3, #234881024	@ 0xe000000
 8014e5a:	687b      	ldr	r3, [r7, #4]
 8014e5c:	681b      	ldr	r3, [r3, #0]
 8014e5e:	683a      	ldr	r2, [r7, #0]
 8014e60:	430a      	orrs	r2, r1
 8014e62:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
 8014e64:	6878      	ldr	r0, [r7, #4]
 8014e66:	f000 f811 	bl	8014e8c <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8014e6a:	687b      	ldr	r3, [r7, #4]
 8014e6c:	681b      	ldr	r3, [r3, #0]
 8014e6e:	68fa      	ldr	r2, [r7, #12]
 8014e70:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 8014e72:	687b      	ldr	r3, [r7, #4]
 8014e74:	2220      	movs	r2, #32
 8014e76:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8014e7a:	687b      	ldr	r3, [r7, #4]
 8014e7c:	2200      	movs	r2, #0
 8014e7e:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
 8014e82:	2300      	movs	r3, #0
}
 8014e84:	4618      	mov	r0, r3
 8014e86:	3710      	adds	r7, #16
 8014e88:	46bd      	mov	sp, r7
 8014e8a:	bd80      	pop	{r7, pc}

08014e8c <UARTEx_SetNbDataToProcess>:
  *       the UART configuration registers.
  * @param huart UART handle.
  * @retval None
  */
static void UARTEx_SetNbDataToProcess(UART_HandleTypeDef *huart)
{
 8014e8c:	b480      	push	{r7}
 8014e8e:	b085      	sub	sp, #20
 8014e90:	af00      	add	r7, sp, #0
 8014e92:	6078      	str	r0, [r7, #4]
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8014e94:	687b      	ldr	r3, [r7, #4]
 8014e96:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8014e98:	2b00      	cmp	r3, #0
 8014e9a:	d108      	bne.n	8014eae <UARTEx_SetNbDataToProcess+0x22>
  {
    huart->NbTxDataToProcess = 1U;
 8014e9c:	687b      	ldr	r3, [r7, #4]
 8014e9e:	2201      	movs	r2, #1
 8014ea0:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
    huart->NbRxDataToProcess = 1U;
 8014ea4:	687b      	ldr	r3, [r7, #4]
 8014ea6:	2201      	movs	r2, #1
 8014ea8:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
                               (uint16_t)denominator[rx_fifo_threshold];
  }
}
 8014eac:	e031      	b.n	8014f12 <UARTEx_SetNbDataToProcess+0x86>
    rx_fifo_depth = RX_FIFO_DEPTH;
 8014eae:	2308      	movs	r3, #8
 8014eb0:	73fb      	strb	r3, [r7, #15]
    tx_fifo_depth = TX_FIFO_DEPTH;
 8014eb2:	2308      	movs	r3, #8
 8014eb4:	73bb      	strb	r3, [r7, #14]
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 8014eb6:	687b      	ldr	r3, [r7, #4]
 8014eb8:	681b      	ldr	r3, [r3, #0]
 8014eba:	689b      	ldr	r3, [r3, #8]
 8014ebc:	0e5b      	lsrs	r3, r3, #25
 8014ebe:	b2db      	uxtb	r3, r3
 8014ec0:	f003 0307 	and.w	r3, r3, #7
 8014ec4:	737b      	strb	r3, [r7, #13]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8014ec6:	687b      	ldr	r3, [r7, #4]
 8014ec8:	681b      	ldr	r3, [r3, #0]
 8014eca:	689b      	ldr	r3, [r3, #8]
 8014ecc:	0f5b      	lsrs	r3, r3, #29
 8014ece:	b2db      	uxtb	r3, r3
 8014ed0:	f003 0307 	and.w	r3, r3, #7
 8014ed4:	733b      	strb	r3, [r7, #12]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8014ed6:	7bbb      	ldrb	r3, [r7, #14]
 8014ed8:	7b3a      	ldrb	r2, [r7, #12]
 8014eda:	4911      	ldr	r1, [pc, #68]	@ (8014f20 <UARTEx_SetNbDataToProcess+0x94>)
 8014edc:	5c8a      	ldrb	r2, [r1, r2]
 8014ede:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[tx_fifo_threshold];
 8014ee2:	7b3a      	ldrb	r2, [r7, #12]
 8014ee4:	490f      	ldr	r1, [pc, #60]	@ (8014f24 <UARTEx_SetNbDataToProcess+0x98>)
 8014ee6:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8014ee8:	fb93 f3f2 	sdiv	r3, r3, r2
 8014eec:	b29a      	uxth	r2, r3
 8014eee:	687b      	ldr	r3, [r7, #4]
 8014ef0:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8014ef4:	7bfb      	ldrb	r3, [r7, #15]
 8014ef6:	7b7a      	ldrb	r2, [r7, #13]
 8014ef8:	4909      	ldr	r1, [pc, #36]	@ (8014f20 <UARTEx_SetNbDataToProcess+0x94>)
 8014efa:	5c8a      	ldrb	r2, [r1, r2]
 8014efc:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[rx_fifo_threshold];
 8014f00:	7b7a      	ldrb	r2, [r7, #13]
 8014f02:	4908      	ldr	r1, [pc, #32]	@ (8014f24 <UARTEx_SetNbDataToProcess+0x98>)
 8014f04:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8014f06:	fb93 f3f2 	sdiv	r3, r3, r2
 8014f0a:	b29a      	uxth	r2, r3
 8014f0c:	687b      	ldr	r3, [r7, #4]
 8014f0e:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68
}
 8014f12:	bf00      	nop
 8014f14:	3714      	adds	r7, #20
 8014f16:	46bd      	mov	sp, r7
 8014f18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014f1c:	4770      	bx	lr
 8014f1e:	bf00      	nop
 8014f20:	08017000 	.word	0x08017000
 8014f24:	08017008 	.word	0x08017008

08014f28 <calloc>:
 8014f28:	4b02      	ldr	r3, [pc, #8]	@ (8014f34 <calloc+0xc>)
 8014f2a:	460a      	mov	r2, r1
 8014f2c:	4601      	mov	r1, r0
 8014f2e:	6818      	ldr	r0, [r3, #0]
 8014f30:	f000 b802 	b.w	8014f38 <_calloc_r>
 8014f34:	20000048 	.word	0x20000048

08014f38 <_calloc_r>:
 8014f38:	b570      	push	{r4, r5, r6, lr}
 8014f3a:	fba1 5402 	umull	r5, r4, r1, r2
 8014f3e:	b934      	cbnz	r4, 8014f4e <_calloc_r+0x16>
 8014f40:	4629      	mov	r1, r5
 8014f42:	f000 f83f 	bl	8014fc4 <_malloc_r>
 8014f46:	4606      	mov	r6, r0
 8014f48:	b928      	cbnz	r0, 8014f56 <_calloc_r+0x1e>
 8014f4a:	4630      	mov	r0, r6
 8014f4c:	bd70      	pop	{r4, r5, r6, pc}
 8014f4e:	220c      	movs	r2, #12
 8014f50:	2600      	movs	r6, #0
 8014f52:	6002      	str	r2, [r0, #0]
 8014f54:	e7f9      	b.n	8014f4a <_calloc_r+0x12>
 8014f56:	462a      	mov	r2, r5
 8014f58:	4621      	mov	r1, r4
 8014f5a:	f000 fa75 	bl	8015448 <memset>
 8014f5e:	e7f4      	b.n	8014f4a <_calloc_r+0x12>

08014f60 <malloc>:
 8014f60:	4b02      	ldr	r3, [pc, #8]	@ (8014f6c <malloc+0xc>)
 8014f62:	4601      	mov	r1, r0
 8014f64:	6818      	ldr	r0, [r3, #0]
 8014f66:	f000 b82d 	b.w	8014fc4 <_malloc_r>
 8014f6a:	bf00      	nop
 8014f6c:	20000048 	.word	0x20000048

08014f70 <free>:
 8014f70:	4b02      	ldr	r3, [pc, #8]	@ (8014f7c <free+0xc>)
 8014f72:	4601      	mov	r1, r0
 8014f74:	6818      	ldr	r0, [r3, #0]
 8014f76:	f000 baff 	b.w	8015578 <_free_r>
 8014f7a:	bf00      	nop
 8014f7c:	20000048 	.word	0x20000048

08014f80 <sbrk_aligned>:
 8014f80:	b570      	push	{r4, r5, r6, lr}
 8014f82:	4e0f      	ldr	r6, [pc, #60]	@ (8014fc0 <sbrk_aligned+0x40>)
 8014f84:	460c      	mov	r4, r1
 8014f86:	4605      	mov	r5, r0
 8014f88:	6831      	ldr	r1, [r6, #0]
 8014f8a:	b911      	cbnz	r1, 8014f92 <sbrk_aligned+0x12>
 8014f8c:	f000 fa98 	bl	80154c0 <_sbrk_r>
 8014f90:	6030      	str	r0, [r6, #0]
 8014f92:	4621      	mov	r1, r4
 8014f94:	4628      	mov	r0, r5
 8014f96:	f000 fa93 	bl	80154c0 <_sbrk_r>
 8014f9a:	1c43      	adds	r3, r0, #1
 8014f9c:	d103      	bne.n	8014fa6 <sbrk_aligned+0x26>
 8014f9e:	f04f 34ff 	mov.w	r4, #4294967295
 8014fa2:	4620      	mov	r0, r4
 8014fa4:	bd70      	pop	{r4, r5, r6, pc}
 8014fa6:	1cc4      	adds	r4, r0, #3
 8014fa8:	f024 0403 	bic.w	r4, r4, #3
 8014fac:	42a0      	cmp	r0, r4
 8014fae:	d0f8      	beq.n	8014fa2 <sbrk_aligned+0x22>
 8014fb0:	1a21      	subs	r1, r4, r0
 8014fb2:	4628      	mov	r0, r5
 8014fb4:	f000 fa84 	bl	80154c0 <_sbrk_r>
 8014fb8:	3001      	adds	r0, #1
 8014fba:	d1f2      	bne.n	8014fa2 <sbrk_aligned+0x22>
 8014fbc:	e7ef      	b.n	8014f9e <sbrk_aligned+0x1e>
 8014fbe:	bf00      	nop
 8014fc0:	20002380 	.word	0x20002380

08014fc4 <_malloc_r>:
 8014fc4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8014fc8:	1ccd      	adds	r5, r1, #3
 8014fca:	4606      	mov	r6, r0
 8014fcc:	f025 0503 	bic.w	r5, r5, #3
 8014fd0:	3508      	adds	r5, #8
 8014fd2:	2d0c      	cmp	r5, #12
 8014fd4:	bf38      	it	cc
 8014fd6:	250c      	movcc	r5, #12
 8014fd8:	2d00      	cmp	r5, #0
 8014fda:	db01      	blt.n	8014fe0 <_malloc_r+0x1c>
 8014fdc:	42a9      	cmp	r1, r5
 8014fde:	d904      	bls.n	8014fea <_malloc_r+0x26>
 8014fe0:	230c      	movs	r3, #12
 8014fe2:	6033      	str	r3, [r6, #0]
 8014fe4:	2000      	movs	r0, #0
 8014fe6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8014fea:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 80150c0 <_malloc_r+0xfc>
 8014fee:	f000 f869 	bl	80150c4 <__malloc_lock>
 8014ff2:	f8d8 3000 	ldr.w	r3, [r8]
 8014ff6:	461c      	mov	r4, r3
 8014ff8:	bb44      	cbnz	r4, 801504c <_malloc_r+0x88>
 8014ffa:	4629      	mov	r1, r5
 8014ffc:	4630      	mov	r0, r6
 8014ffe:	f7ff ffbf 	bl	8014f80 <sbrk_aligned>
 8015002:	1c43      	adds	r3, r0, #1
 8015004:	4604      	mov	r4, r0
 8015006:	d158      	bne.n	80150ba <_malloc_r+0xf6>
 8015008:	f8d8 4000 	ldr.w	r4, [r8]
 801500c:	4627      	mov	r7, r4
 801500e:	2f00      	cmp	r7, #0
 8015010:	d143      	bne.n	801509a <_malloc_r+0xd6>
 8015012:	2c00      	cmp	r4, #0
 8015014:	d04b      	beq.n	80150ae <_malloc_r+0xea>
 8015016:	6823      	ldr	r3, [r4, #0]
 8015018:	4639      	mov	r1, r7
 801501a:	4630      	mov	r0, r6
 801501c:	eb04 0903 	add.w	r9, r4, r3
 8015020:	f000 fa4e 	bl	80154c0 <_sbrk_r>
 8015024:	4581      	cmp	r9, r0
 8015026:	d142      	bne.n	80150ae <_malloc_r+0xea>
 8015028:	6821      	ldr	r1, [r4, #0]
 801502a:	4630      	mov	r0, r6
 801502c:	1a6d      	subs	r5, r5, r1
 801502e:	4629      	mov	r1, r5
 8015030:	f7ff ffa6 	bl	8014f80 <sbrk_aligned>
 8015034:	3001      	adds	r0, #1
 8015036:	d03a      	beq.n	80150ae <_malloc_r+0xea>
 8015038:	6823      	ldr	r3, [r4, #0]
 801503a:	442b      	add	r3, r5
 801503c:	6023      	str	r3, [r4, #0]
 801503e:	f8d8 3000 	ldr.w	r3, [r8]
 8015042:	685a      	ldr	r2, [r3, #4]
 8015044:	bb62      	cbnz	r2, 80150a0 <_malloc_r+0xdc>
 8015046:	f8c8 7000 	str.w	r7, [r8]
 801504a:	e00f      	b.n	801506c <_malloc_r+0xa8>
 801504c:	6822      	ldr	r2, [r4, #0]
 801504e:	1b52      	subs	r2, r2, r5
 8015050:	d420      	bmi.n	8015094 <_malloc_r+0xd0>
 8015052:	2a0b      	cmp	r2, #11
 8015054:	d917      	bls.n	8015086 <_malloc_r+0xc2>
 8015056:	1961      	adds	r1, r4, r5
 8015058:	42a3      	cmp	r3, r4
 801505a:	6025      	str	r5, [r4, #0]
 801505c:	bf18      	it	ne
 801505e:	6059      	strne	r1, [r3, #4]
 8015060:	6863      	ldr	r3, [r4, #4]
 8015062:	bf08      	it	eq
 8015064:	f8c8 1000 	streq.w	r1, [r8]
 8015068:	5162      	str	r2, [r4, r5]
 801506a:	604b      	str	r3, [r1, #4]
 801506c:	4630      	mov	r0, r6
 801506e:	f000 f82f 	bl	80150d0 <__malloc_unlock>
 8015072:	f104 000b 	add.w	r0, r4, #11
 8015076:	1d23      	adds	r3, r4, #4
 8015078:	f020 0007 	bic.w	r0, r0, #7
 801507c:	1ac2      	subs	r2, r0, r3
 801507e:	bf1c      	itt	ne
 8015080:	1a1b      	subne	r3, r3, r0
 8015082:	50a3      	strne	r3, [r4, r2]
 8015084:	e7af      	b.n	8014fe6 <_malloc_r+0x22>
 8015086:	6862      	ldr	r2, [r4, #4]
 8015088:	42a3      	cmp	r3, r4
 801508a:	bf0c      	ite	eq
 801508c:	f8c8 2000 	streq.w	r2, [r8]
 8015090:	605a      	strne	r2, [r3, #4]
 8015092:	e7eb      	b.n	801506c <_malloc_r+0xa8>
 8015094:	4623      	mov	r3, r4
 8015096:	6864      	ldr	r4, [r4, #4]
 8015098:	e7ae      	b.n	8014ff8 <_malloc_r+0x34>
 801509a:	463c      	mov	r4, r7
 801509c:	687f      	ldr	r7, [r7, #4]
 801509e:	e7b6      	b.n	801500e <_malloc_r+0x4a>
 80150a0:	461a      	mov	r2, r3
 80150a2:	685b      	ldr	r3, [r3, #4]
 80150a4:	42a3      	cmp	r3, r4
 80150a6:	d1fb      	bne.n	80150a0 <_malloc_r+0xdc>
 80150a8:	2300      	movs	r3, #0
 80150aa:	6053      	str	r3, [r2, #4]
 80150ac:	e7de      	b.n	801506c <_malloc_r+0xa8>
 80150ae:	230c      	movs	r3, #12
 80150b0:	4630      	mov	r0, r6
 80150b2:	6033      	str	r3, [r6, #0]
 80150b4:	f000 f80c 	bl	80150d0 <__malloc_unlock>
 80150b8:	e794      	b.n	8014fe4 <_malloc_r+0x20>
 80150ba:	6005      	str	r5, [r0, #0]
 80150bc:	e7d6      	b.n	801506c <_malloc_r+0xa8>
 80150be:	bf00      	nop
 80150c0:	20002384 	.word	0x20002384

080150c4 <__malloc_lock>:
 80150c4:	4801      	ldr	r0, [pc, #4]	@ (80150cc <__malloc_lock+0x8>)
 80150c6:	f000 ba48 	b.w	801555a <__retarget_lock_acquire_recursive>
 80150ca:	bf00      	nop
 80150cc:	200024c8 	.word	0x200024c8

080150d0 <__malloc_unlock>:
 80150d0:	4801      	ldr	r0, [pc, #4]	@ (80150d8 <__malloc_unlock+0x8>)
 80150d2:	f000 ba43 	b.w	801555c <__retarget_lock_release_recursive>
 80150d6:	bf00      	nop
 80150d8:	200024c8 	.word	0x200024c8

080150dc <std>:
 80150dc:	2300      	movs	r3, #0
 80150de:	b510      	push	{r4, lr}
 80150e0:	4604      	mov	r4, r0
 80150e2:	6083      	str	r3, [r0, #8]
 80150e4:	8181      	strh	r1, [r0, #12]
 80150e6:	4619      	mov	r1, r3
 80150e8:	6643      	str	r3, [r0, #100]	@ 0x64
 80150ea:	81c2      	strh	r2, [r0, #14]
 80150ec:	2208      	movs	r2, #8
 80150ee:	6183      	str	r3, [r0, #24]
 80150f0:	e9c0 3300 	strd	r3, r3, [r0]
 80150f4:	e9c0 3304 	strd	r3, r3, [r0, #16]
 80150f8:	305c      	adds	r0, #92	@ 0x5c
 80150fa:	f000 f9a5 	bl	8015448 <memset>
 80150fe:	4b0d      	ldr	r3, [pc, #52]	@ (8015134 <std+0x58>)
 8015100:	6224      	str	r4, [r4, #32]
 8015102:	6263      	str	r3, [r4, #36]	@ 0x24
 8015104:	4b0c      	ldr	r3, [pc, #48]	@ (8015138 <std+0x5c>)
 8015106:	62a3      	str	r3, [r4, #40]	@ 0x28
 8015108:	4b0c      	ldr	r3, [pc, #48]	@ (801513c <std+0x60>)
 801510a:	62e3      	str	r3, [r4, #44]	@ 0x2c
 801510c:	4b0c      	ldr	r3, [pc, #48]	@ (8015140 <std+0x64>)
 801510e:	6323      	str	r3, [r4, #48]	@ 0x30
 8015110:	4b0c      	ldr	r3, [pc, #48]	@ (8015144 <std+0x68>)
 8015112:	429c      	cmp	r4, r3
 8015114:	d006      	beq.n	8015124 <std+0x48>
 8015116:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 801511a:	4294      	cmp	r4, r2
 801511c:	d002      	beq.n	8015124 <std+0x48>
 801511e:	33d0      	adds	r3, #208	@ 0xd0
 8015120:	429c      	cmp	r4, r3
 8015122:	d105      	bne.n	8015130 <std+0x54>
 8015124:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 8015128:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801512c:	f000 ba14 	b.w	8015558 <__retarget_lock_init_recursive>
 8015130:	bd10      	pop	{r4, pc}
 8015132:	bf00      	nop
 8015134:	08015285 	.word	0x08015285
 8015138:	080152a7 	.word	0x080152a7
 801513c:	080152df 	.word	0x080152df
 8015140:	08015303 	.word	0x08015303
 8015144:	20002388 	.word	0x20002388

08015148 <stdio_exit_handler>:
 8015148:	4a02      	ldr	r2, [pc, #8]	@ (8015154 <stdio_exit_handler+0xc>)
 801514a:	4903      	ldr	r1, [pc, #12]	@ (8015158 <stdio_exit_handler+0x10>)
 801514c:	4803      	ldr	r0, [pc, #12]	@ (801515c <stdio_exit_handler+0x14>)
 801514e:	f000 b869 	b.w	8015224 <_fwalk_sglue>
 8015152:	bf00      	nop
 8015154:	2000003c 	.word	0x2000003c
 8015158:	08015cb9 	.word	0x08015cb9
 801515c:	2000004c 	.word	0x2000004c

08015160 <cleanup_stdio>:
 8015160:	6841      	ldr	r1, [r0, #4]
 8015162:	4b0c      	ldr	r3, [pc, #48]	@ (8015194 <cleanup_stdio+0x34>)
 8015164:	4299      	cmp	r1, r3
 8015166:	b510      	push	{r4, lr}
 8015168:	4604      	mov	r4, r0
 801516a:	d001      	beq.n	8015170 <cleanup_stdio+0x10>
 801516c:	f000 fda4 	bl	8015cb8 <_fflush_r>
 8015170:	68a1      	ldr	r1, [r4, #8]
 8015172:	4b09      	ldr	r3, [pc, #36]	@ (8015198 <cleanup_stdio+0x38>)
 8015174:	4299      	cmp	r1, r3
 8015176:	d002      	beq.n	801517e <cleanup_stdio+0x1e>
 8015178:	4620      	mov	r0, r4
 801517a:	f000 fd9d 	bl	8015cb8 <_fflush_r>
 801517e:	68e1      	ldr	r1, [r4, #12]
 8015180:	4b06      	ldr	r3, [pc, #24]	@ (801519c <cleanup_stdio+0x3c>)
 8015182:	4299      	cmp	r1, r3
 8015184:	d004      	beq.n	8015190 <cleanup_stdio+0x30>
 8015186:	4620      	mov	r0, r4
 8015188:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801518c:	f000 bd94 	b.w	8015cb8 <_fflush_r>
 8015190:	bd10      	pop	{r4, pc}
 8015192:	bf00      	nop
 8015194:	20002388 	.word	0x20002388
 8015198:	200023f0 	.word	0x200023f0
 801519c:	20002458 	.word	0x20002458

080151a0 <global_stdio_init.part.0>:
 80151a0:	b510      	push	{r4, lr}
 80151a2:	4b0b      	ldr	r3, [pc, #44]	@ (80151d0 <global_stdio_init.part.0+0x30>)
 80151a4:	2104      	movs	r1, #4
 80151a6:	4c0b      	ldr	r4, [pc, #44]	@ (80151d4 <global_stdio_init.part.0+0x34>)
 80151a8:	4a0b      	ldr	r2, [pc, #44]	@ (80151d8 <global_stdio_init.part.0+0x38>)
 80151aa:	4620      	mov	r0, r4
 80151ac:	601a      	str	r2, [r3, #0]
 80151ae:	2200      	movs	r2, #0
 80151b0:	f7ff ff94 	bl	80150dc <std>
 80151b4:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 80151b8:	2201      	movs	r2, #1
 80151ba:	2109      	movs	r1, #9
 80151bc:	f7ff ff8e 	bl	80150dc <std>
 80151c0:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 80151c4:	2202      	movs	r2, #2
 80151c6:	2112      	movs	r1, #18
 80151c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80151cc:	f7ff bf86 	b.w	80150dc <std>
 80151d0:	200024c0 	.word	0x200024c0
 80151d4:	20002388 	.word	0x20002388
 80151d8:	08015149 	.word	0x08015149

080151dc <__sfp_lock_acquire>:
 80151dc:	4801      	ldr	r0, [pc, #4]	@ (80151e4 <__sfp_lock_acquire+0x8>)
 80151de:	f000 b9bc 	b.w	801555a <__retarget_lock_acquire_recursive>
 80151e2:	bf00      	nop
 80151e4:	200024c9 	.word	0x200024c9

080151e8 <__sfp_lock_release>:
 80151e8:	4801      	ldr	r0, [pc, #4]	@ (80151f0 <__sfp_lock_release+0x8>)
 80151ea:	f000 b9b7 	b.w	801555c <__retarget_lock_release_recursive>
 80151ee:	bf00      	nop
 80151f0:	200024c9 	.word	0x200024c9

080151f4 <__sinit>:
 80151f4:	b510      	push	{r4, lr}
 80151f6:	4604      	mov	r4, r0
 80151f8:	f7ff fff0 	bl	80151dc <__sfp_lock_acquire>
 80151fc:	6a23      	ldr	r3, [r4, #32]
 80151fe:	b11b      	cbz	r3, 8015208 <__sinit+0x14>
 8015200:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8015204:	f7ff bff0 	b.w	80151e8 <__sfp_lock_release>
 8015208:	4b04      	ldr	r3, [pc, #16]	@ (801521c <__sinit+0x28>)
 801520a:	6223      	str	r3, [r4, #32]
 801520c:	4b04      	ldr	r3, [pc, #16]	@ (8015220 <__sinit+0x2c>)
 801520e:	681b      	ldr	r3, [r3, #0]
 8015210:	2b00      	cmp	r3, #0
 8015212:	d1f5      	bne.n	8015200 <__sinit+0xc>
 8015214:	f7ff ffc4 	bl	80151a0 <global_stdio_init.part.0>
 8015218:	e7f2      	b.n	8015200 <__sinit+0xc>
 801521a:	bf00      	nop
 801521c:	08015161 	.word	0x08015161
 8015220:	200024c0 	.word	0x200024c0

08015224 <_fwalk_sglue>:
 8015224:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8015228:	4607      	mov	r7, r0
 801522a:	4688      	mov	r8, r1
 801522c:	4614      	mov	r4, r2
 801522e:	2600      	movs	r6, #0
 8015230:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8015234:	f1b9 0901 	subs.w	r9, r9, #1
 8015238:	d505      	bpl.n	8015246 <_fwalk_sglue+0x22>
 801523a:	6824      	ldr	r4, [r4, #0]
 801523c:	2c00      	cmp	r4, #0
 801523e:	d1f7      	bne.n	8015230 <_fwalk_sglue+0xc>
 8015240:	4630      	mov	r0, r6
 8015242:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8015246:	89ab      	ldrh	r3, [r5, #12]
 8015248:	2b01      	cmp	r3, #1
 801524a:	d907      	bls.n	801525c <_fwalk_sglue+0x38>
 801524c:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8015250:	3301      	adds	r3, #1
 8015252:	d003      	beq.n	801525c <_fwalk_sglue+0x38>
 8015254:	4629      	mov	r1, r5
 8015256:	4638      	mov	r0, r7
 8015258:	47c0      	blx	r8
 801525a:	4306      	orrs	r6, r0
 801525c:	3568      	adds	r5, #104	@ 0x68
 801525e:	e7e9      	b.n	8015234 <_fwalk_sglue+0x10>

08015260 <iprintf>:
 8015260:	b40f      	push	{r0, r1, r2, r3}
 8015262:	b507      	push	{r0, r1, r2, lr}
 8015264:	4906      	ldr	r1, [pc, #24]	@ (8015280 <iprintf+0x20>)
 8015266:	ab04      	add	r3, sp, #16
 8015268:	6808      	ldr	r0, [r1, #0]
 801526a:	f853 2b04 	ldr.w	r2, [r3], #4
 801526e:	6881      	ldr	r1, [r0, #8]
 8015270:	9301      	str	r3, [sp, #4]
 8015272:	f000 f9f5 	bl	8015660 <_vfiprintf_r>
 8015276:	b003      	add	sp, #12
 8015278:	f85d eb04 	ldr.w	lr, [sp], #4
 801527c:	b004      	add	sp, #16
 801527e:	4770      	bx	lr
 8015280:	20000048 	.word	0x20000048

08015284 <__sread>:
 8015284:	b510      	push	{r4, lr}
 8015286:	460c      	mov	r4, r1
 8015288:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801528c:	f000 f906 	bl	801549c <_read_r>
 8015290:	2800      	cmp	r0, #0
 8015292:	bfab      	itete	ge
 8015294:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 8015296:	89a3      	ldrhlt	r3, [r4, #12]
 8015298:	181b      	addge	r3, r3, r0
 801529a:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 801529e:	bfac      	ite	ge
 80152a0:	6563      	strge	r3, [r4, #84]	@ 0x54
 80152a2:	81a3      	strhlt	r3, [r4, #12]
 80152a4:	bd10      	pop	{r4, pc}

080152a6 <__swrite>:
 80152a6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80152aa:	461f      	mov	r7, r3
 80152ac:	898b      	ldrh	r3, [r1, #12]
 80152ae:	4605      	mov	r5, r0
 80152b0:	460c      	mov	r4, r1
 80152b2:	05db      	lsls	r3, r3, #23
 80152b4:	4616      	mov	r6, r2
 80152b6:	d505      	bpl.n	80152c4 <__swrite+0x1e>
 80152b8:	2302      	movs	r3, #2
 80152ba:	2200      	movs	r2, #0
 80152bc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80152c0:	f000 f8da 	bl	8015478 <_lseek_r>
 80152c4:	89a3      	ldrh	r3, [r4, #12]
 80152c6:	4632      	mov	r2, r6
 80152c8:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80152cc:	4628      	mov	r0, r5
 80152ce:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 80152d2:	81a3      	strh	r3, [r4, #12]
 80152d4:	463b      	mov	r3, r7
 80152d6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80152da:	f000 b901 	b.w	80154e0 <_write_r>

080152de <__sseek>:
 80152de:	b510      	push	{r4, lr}
 80152e0:	460c      	mov	r4, r1
 80152e2:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80152e6:	f000 f8c7 	bl	8015478 <_lseek_r>
 80152ea:	1c43      	adds	r3, r0, #1
 80152ec:	89a3      	ldrh	r3, [r4, #12]
 80152ee:	bf15      	itete	ne
 80152f0:	6560      	strne	r0, [r4, #84]	@ 0x54
 80152f2:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 80152f6:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 80152fa:	81a3      	strheq	r3, [r4, #12]
 80152fc:	bf18      	it	ne
 80152fe:	81a3      	strhne	r3, [r4, #12]
 8015300:	bd10      	pop	{r4, pc}

08015302 <__sclose>:
 8015302:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8015306:	f000 b8a7 	b.w	8015458 <_close_r>
	...

0801530c <viprintf>:
 801530c:	460b      	mov	r3, r1
 801530e:	4903      	ldr	r1, [pc, #12]	@ (801531c <viprintf+0x10>)
 8015310:	4602      	mov	r2, r0
 8015312:	6808      	ldr	r0, [r1, #0]
 8015314:	6881      	ldr	r1, [r0, #8]
 8015316:	f000 b9a3 	b.w	8015660 <_vfiprintf_r>
 801531a:	bf00      	nop
 801531c:	20000048 	.word	0x20000048

08015320 <__swbuf_r>:
 8015320:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8015322:	460e      	mov	r6, r1
 8015324:	4614      	mov	r4, r2
 8015326:	4605      	mov	r5, r0
 8015328:	b118      	cbz	r0, 8015332 <__swbuf_r+0x12>
 801532a:	6a03      	ldr	r3, [r0, #32]
 801532c:	b90b      	cbnz	r3, 8015332 <__swbuf_r+0x12>
 801532e:	f7ff ff61 	bl	80151f4 <__sinit>
 8015332:	69a3      	ldr	r3, [r4, #24]
 8015334:	60a3      	str	r3, [r4, #8]
 8015336:	89a3      	ldrh	r3, [r4, #12]
 8015338:	071a      	lsls	r2, r3, #28
 801533a:	d501      	bpl.n	8015340 <__swbuf_r+0x20>
 801533c:	6923      	ldr	r3, [r4, #16]
 801533e:	b943      	cbnz	r3, 8015352 <__swbuf_r+0x32>
 8015340:	4621      	mov	r1, r4
 8015342:	4628      	mov	r0, r5
 8015344:	f000 f82a 	bl	801539c <__swsetup_r>
 8015348:	b118      	cbz	r0, 8015352 <__swbuf_r+0x32>
 801534a:	f04f 37ff 	mov.w	r7, #4294967295
 801534e:	4638      	mov	r0, r7
 8015350:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8015352:	6823      	ldr	r3, [r4, #0]
 8015354:	b2f6      	uxtb	r6, r6
 8015356:	6922      	ldr	r2, [r4, #16]
 8015358:	4637      	mov	r7, r6
 801535a:	1a98      	subs	r0, r3, r2
 801535c:	6963      	ldr	r3, [r4, #20]
 801535e:	4283      	cmp	r3, r0
 8015360:	dc05      	bgt.n	801536e <__swbuf_r+0x4e>
 8015362:	4621      	mov	r1, r4
 8015364:	4628      	mov	r0, r5
 8015366:	f000 fca7 	bl	8015cb8 <_fflush_r>
 801536a:	2800      	cmp	r0, #0
 801536c:	d1ed      	bne.n	801534a <__swbuf_r+0x2a>
 801536e:	68a3      	ldr	r3, [r4, #8]
 8015370:	3b01      	subs	r3, #1
 8015372:	60a3      	str	r3, [r4, #8]
 8015374:	6823      	ldr	r3, [r4, #0]
 8015376:	1c5a      	adds	r2, r3, #1
 8015378:	6022      	str	r2, [r4, #0]
 801537a:	701e      	strb	r6, [r3, #0]
 801537c:	1c43      	adds	r3, r0, #1
 801537e:	6962      	ldr	r2, [r4, #20]
 8015380:	429a      	cmp	r2, r3
 8015382:	d004      	beq.n	801538e <__swbuf_r+0x6e>
 8015384:	89a3      	ldrh	r3, [r4, #12]
 8015386:	07db      	lsls	r3, r3, #31
 8015388:	d5e1      	bpl.n	801534e <__swbuf_r+0x2e>
 801538a:	2e0a      	cmp	r6, #10
 801538c:	d1df      	bne.n	801534e <__swbuf_r+0x2e>
 801538e:	4621      	mov	r1, r4
 8015390:	4628      	mov	r0, r5
 8015392:	f000 fc91 	bl	8015cb8 <_fflush_r>
 8015396:	2800      	cmp	r0, #0
 8015398:	d0d9      	beq.n	801534e <__swbuf_r+0x2e>
 801539a:	e7d6      	b.n	801534a <__swbuf_r+0x2a>

0801539c <__swsetup_r>:
 801539c:	b538      	push	{r3, r4, r5, lr}
 801539e:	4b29      	ldr	r3, [pc, #164]	@ (8015444 <__swsetup_r+0xa8>)
 80153a0:	4605      	mov	r5, r0
 80153a2:	460c      	mov	r4, r1
 80153a4:	6818      	ldr	r0, [r3, #0]
 80153a6:	b118      	cbz	r0, 80153b0 <__swsetup_r+0x14>
 80153a8:	6a03      	ldr	r3, [r0, #32]
 80153aa:	b90b      	cbnz	r3, 80153b0 <__swsetup_r+0x14>
 80153ac:	f7ff ff22 	bl	80151f4 <__sinit>
 80153b0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80153b4:	0719      	lsls	r1, r3, #28
 80153b6:	d422      	bmi.n	80153fe <__swsetup_r+0x62>
 80153b8:	06da      	lsls	r2, r3, #27
 80153ba:	d407      	bmi.n	80153cc <__swsetup_r+0x30>
 80153bc:	2209      	movs	r2, #9
 80153be:	602a      	str	r2, [r5, #0]
 80153c0:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 80153c4:	f04f 30ff 	mov.w	r0, #4294967295
 80153c8:	81a3      	strh	r3, [r4, #12]
 80153ca:	e033      	b.n	8015434 <__swsetup_r+0x98>
 80153cc:	0758      	lsls	r0, r3, #29
 80153ce:	d512      	bpl.n	80153f6 <__swsetup_r+0x5a>
 80153d0:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 80153d2:	b141      	cbz	r1, 80153e6 <__swsetup_r+0x4a>
 80153d4:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 80153d8:	4299      	cmp	r1, r3
 80153da:	d002      	beq.n	80153e2 <__swsetup_r+0x46>
 80153dc:	4628      	mov	r0, r5
 80153de:	f000 f8cb 	bl	8015578 <_free_r>
 80153e2:	2300      	movs	r3, #0
 80153e4:	6363      	str	r3, [r4, #52]	@ 0x34
 80153e6:	89a3      	ldrh	r3, [r4, #12]
 80153e8:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 80153ec:	81a3      	strh	r3, [r4, #12]
 80153ee:	2300      	movs	r3, #0
 80153f0:	6063      	str	r3, [r4, #4]
 80153f2:	6923      	ldr	r3, [r4, #16]
 80153f4:	6023      	str	r3, [r4, #0]
 80153f6:	89a3      	ldrh	r3, [r4, #12]
 80153f8:	f043 0308 	orr.w	r3, r3, #8
 80153fc:	81a3      	strh	r3, [r4, #12]
 80153fe:	6923      	ldr	r3, [r4, #16]
 8015400:	b94b      	cbnz	r3, 8015416 <__swsetup_r+0x7a>
 8015402:	89a3      	ldrh	r3, [r4, #12]
 8015404:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 8015408:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 801540c:	d003      	beq.n	8015416 <__swsetup_r+0x7a>
 801540e:	4621      	mov	r1, r4
 8015410:	4628      	mov	r0, r5
 8015412:	f000 fc9e 	bl	8015d52 <__smakebuf_r>
 8015416:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801541a:	f013 0201 	ands.w	r2, r3, #1
 801541e:	d00a      	beq.n	8015436 <__swsetup_r+0x9a>
 8015420:	2200      	movs	r2, #0
 8015422:	60a2      	str	r2, [r4, #8]
 8015424:	6962      	ldr	r2, [r4, #20]
 8015426:	4252      	negs	r2, r2
 8015428:	61a2      	str	r2, [r4, #24]
 801542a:	6922      	ldr	r2, [r4, #16]
 801542c:	b942      	cbnz	r2, 8015440 <__swsetup_r+0xa4>
 801542e:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 8015432:	d1c5      	bne.n	80153c0 <__swsetup_r+0x24>
 8015434:	bd38      	pop	{r3, r4, r5, pc}
 8015436:	0799      	lsls	r1, r3, #30
 8015438:	bf58      	it	pl
 801543a:	6962      	ldrpl	r2, [r4, #20]
 801543c:	60a2      	str	r2, [r4, #8]
 801543e:	e7f4      	b.n	801542a <__swsetup_r+0x8e>
 8015440:	2000      	movs	r0, #0
 8015442:	e7f7      	b.n	8015434 <__swsetup_r+0x98>
 8015444:	20000048 	.word	0x20000048

08015448 <memset>:
 8015448:	4402      	add	r2, r0
 801544a:	4603      	mov	r3, r0
 801544c:	4293      	cmp	r3, r2
 801544e:	d100      	bne.n	8015452 <memset+0xa>
 8015450:	4770      	bx	lr
 8015452:	f803 1b01 	strb.w	r1, [r3], #1
 8015456:	e7f9      	b.n	801544c <memset+0x4>

08015458 <_close_r>:
 8015458:	b538      	push	{r3, r4, r5, lr}
 801545a:	2300      	movs	r3, #0
 801545c:	4d05      	ldr	r5, [pc, #20]	@ (8015474 <_close_r+0x1c>)
 801545e:	4604      	mov	r4, r0
 8015460:	4608      	mov	r0, r1
 8015462:	602b      	str	r3, [r5, #0]
 8015464:	f7f8 fa15 	bl	800d892 <_close>
 8015468:	1c43      	adds	r3, r0, #1
 801546a:	d102      	bne.n	8015472 <_close_r+0x1a>
 801546c:	682b      	ldr	r3, [r5, #0]
 801546e:	b103      	cbz	r3, 8015472 <_close_r+0x1a>
 8015470:	6023      	str	r3, [r4, #0]
 8015472:	bd38      	pop	{r3, r4, r5, pc}
 8015474:	200024c4 	.word	0x200024c4

08015478 <_lseek_r>:
 8015478:	b538      	push	{r3, r4, r5, lr}
 801547a:	4604      	mov	r4, r0
 801547c:	4d06      	ldr	r5, [pc, #24]	@ (8015498 <_lseek_r+0x20>)
 801547e:	4608      	mov	r0, r1
 8015480:	4611      	mov	r1, r2
 8015482:	2200      	movs	r2, #0
 8015484:	602a      	str	r2, [r5, #0]
 8015486:	461a      	mov	r2, r3
 8015488:	f7f8 fa2a 	bl	800d8e0 <_lseek>
 801548c:	1c43      	adds	r3, r0, #1
 801548e:	d102      	bne.n	8015496 <_lseek_r+0x1e>
 8015490:	682b      	ldr	r3, [r5, #0]
 8015492:	b103      	cbz	r3, 8015496 <_lseek_r+0x1e>
 8015494:	6023      	str	r3, [r4, #0]
 8015496:	bd38      	pop	{r3, r4, r5, pc}
 8015498:	200024c4 	.word	0x200024c4

0801549c <_read_r>:
 801549c:	b538      	push	{r3, r4, r5, lr}
 801549e:	4604      	mov	r4, r0
 80154a0:	4d06      	ldr	r5, [pc, #24]	@ (80154bc <_read_r+0x20>)
 80154a2:	4608      	mov	r0, r1
 80154a4:	4611      	mov	r1, r2
 80154a6:	2200      	movs	r2, #0
 80154a8:	602a      	str	r2, [r5, #0]
 80154aa:	461a      	mov	r2, r3
 80154ac:	f7f8 f9b8 	bl	800d820 <_read>
 80154b0:	1c43      	adds	r3, r0, #1
 80154b2:	d102      	bne.n	80154ba <_read_r+0x1e>
 80154b4:	682b      	ldr	r3, [r5, #0]
 80154b6:	b103      	cbz	r3, 80154ba <_read_r+0x1e>
 80154b8:	6023      	str	r3, [r4, #0]
 80154ba:	bd38      	pop	{r3, r4, r5, pc}
 80154bc:	200024c4 	.word	0x200024c4

080154c0 <_sbrk_r>:
 80154c0:	b538      	push	{r3, r4, r5, lr}
 80154c2:	2300      	movs	r3, #0
 80154c4:	4d05      	ldr	r5, [pc, #20]	@ (80154dc <_sbrk_r+0x1c>)
 80154c6:	4604      	mov	r4, r0
 80154c8:	4608      	mov	r0, r1
 80154ca:	602b      	str	r3, [r5, #0]
 80154cc:	f7f8 fa16 	bl	800d8fc <_sbrk>
 80154d0:	1c43      	adds	r3, r0, #1
 80154d2:	d102      	bne.n	80154da <_sbrk_r+0x1a>
 80154d4:	682b      	ldr	r3, [r5, #0]
 80154d6:	b103      	cbz	r3, 80154da <_sbrk_r+0x1a>
 80154d8:	6023      	str	r3, [r4, #0]
 80154da:	bd38      	pop	{r3, r4, r5, pc}
 80154dc:	200024c4 	.word	0x200024c4

080154e0 <_write_r>:
 80154e0:	b538      	push	{r3, r4, r5, lr}
 80154e2:	4604      	mov	r4, r0
 80154e4:	4d06      	ldr	r5, [pc, #24]	@ (8015500 <_write_r+0x20>)
 80154e6:	4608      	mov	r0, r1
 80154e8:	4611      	mov	r1, r2
 80154ea:	2200      	movs	r2, #0
 80154ec:	602a      	str	r2, [r5, #0]
 80154ee:	461a      	mov	r2, r3
 80154f0:	f7f8 f9b3 	bl	800d85a <_write>
 80154f4:	1c43      	adds	r3, r0, #1
 80154f6:	d102      	bne.n	80154fe <_write_r+0x1e>
 80154f8:	682b      	ldr	r3, [r5, #0]
 80154fa:	b103      	cbz	r3, 80154fe <_write_r+0x1e>
 80154fc:	6023      	str	r3, [r4, #0]
 80154fe:	bd38      	pop	{r3, r4, r5, pc}
 8015500:	200024c4 	.word	0x200024c4

08015504 <__errno>:
 8015504:	4b01      	ldr	r3, [pc, #4]	@ (801550c <__errno+0x8>)
 8015506:	6818      	ldr	r0, [r3, #0]
 8015508:	4770      	bx	lr
 801550a:	bf00      	nop
 801550c:	20000048 	.word	0x20000048

08015510 <__libc_init_array>:
 8015510:	b570      	push	{r4, r5, r6, lr}
 8015512:	4d0d      	ldr	r5, [pc, #52]	@ (8015548 <__libc_init_array+0x38>)
 8015514:	2600      	movs	r6, #0
 8015516:	4c0d      	ldr	r4, [pc, #52]	@ (801554c <__libc_init_array+0x3c>)
 8015518:	1b64      	subs	r4, r4, r5
 801551a:	10a4      	asrs	r4, r4, #2
 801551c:	42a6      	cmp	r6, r4
 801551e:	d109      	bne.n	8015534 <__libc_init_array+0x24>
 8015520:	4d0b      	ldr	r5, [pc, #44]	@ (8015550 <__libc_init_array+0x40>)
 8015522:	2600      	movs	r6, #0
 8015524:	4c0b      	ldr	r4, [pc, #44]	@ (8015554 <__libc_init_array+0x44>)
 8015526:	f000 fc81 	bl	8015e2c <_init>
 801552a:	1b64      	subs	r4, r4, r5
 801552c:	10a4      	asrs	r4, r4, #2
 801552e:	42a6      	cmp	r6, r4
 8015530:	d105      	bne.n	801553e <__libc_init_array+0x2e>
 8015532:	bd70      	pop	{r4, r5, r6, pc}
 8015534:	f855 3b04 	ldr.w	r3, [r5], #4
 8015538:	3601      	adds	r6, #1
 801553a:	4798      	blx	r3
 801553c:	e7ee      	b.n	801551c <__libc_init_array+0xc>
 801553e:	f855 3b04 	ldr.w	r3, [r5], #4
 8015542:	3601      	adds	r6, #1
 8015544:	4798      	blx	r3
 8015546:	e7f2      	b.n	801552e <__libc_init_array+0x1e>
 8015548:	0801704c 	.word	0x0801704c
 801554c:	0801704c 	.word	0x0801704c
 8015550:	0801704c 	.word	0x0801704c
 8015554:	08017050 	.word	0x08017050

08015558 <__retarget_lock_init_recursive>:
 8015558:	4770      	bx	lr

0801555a <__retarget_lock_acquire_recursive>:
 801555a:	4770      	bx	lr

0801555c <__retarget_lock_release_recursive>:
 801555c:	4770      	bx	lr

0801555e <memcpy>:
 801555e:	440a      	add	r2, r1
 8015560:	1e43      	subs	r3, r0, #1
 8015562:	4291      	cmp	r1, r2
 8015564:	d100      	bne.n	8015568 <memcpy+0xa>
 8015566:	4770      	bx	lr
 8015568:	b510      	push	{r4, lr}
 801556a:	f811 4b01 	ldrb.w	r4, [r1], #1
 801556e:	4291      	cmp	r1, r2
 8015570:	f803 4f01 	strb.w	r4, [r3, #1]!
 8015574:	d1f9      	bne.n	801556a <memcpy+0xc>
 8015576:	bd10      	pop	{r4, pc}

08015578 <_free_r>:
 8015578:	b538      	push	{r3, r4, r5, lr}
 801557a:	4605      	mov	r5, r0
 801557c:	2900      	cmp	r1, #0
 801557e:	d041      	beq.n	8015604 <_free_r+0x8c>
 8015580:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8015584:	1f0c      	subs	r4, r1, #4
 8015586:	2b00      	cmp	r3, #0
 8015588:	bfb8      	it	lt
 801558a:	18e4      	addlt	r4, r4, r3
 801558c:	f7ff fd9a 	bl	80150c4 <__malloc_lock>
 8015590:	4a1d      	ldr	r2, [pc, #116]	@ (8015608 <_free_r+0x90>)
 8015592:	6813      	ldr	r3, [r2, #0]
 8015594:	b933      	cbnz	r3, 80155a4 <_free_r+0x2c>
 8015596:	6063      	str	r3, [r4, #4]
 8015598:	6014      	str	r4, [r2, #0]
 801559a:	4628      	mov	r0, r5
 801559c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80155a0:	f7ff bd96 	b.w	80150d0 <__malloc_unlock>
 80155a4:	42a3      	cmp	r3, r4
 80155a6:	d908      	bls.n	80155ba <_free_r+0x42>
 80155a8:	6820      	ldr	r0, [r4, #0]
 80155aa:	1821      	adds	r1, r4, r0
 80155ac:	428b      	cmp	r3, r1
 80155ae:	bf01      	itttt	eq
 80155b0:	6819      	ldreq	r1, [r3, #0]
 80155b2:	685b      	ldreq	r3, [r3, #4]
 80155b4:	1809      	addeq	r1, r1, r0
 80155b6:	6021      	streq	r1, [r4, #0]
 80155b8:	e7ed      	b.n	8015596 <_free_r+0x1e>
 80155ba:	461a      	mov	r2, r3
 80155bc:	685b      	ldr	r3, [r3, #4]
 80155be:	b10b      	cbz	r3, 80155c4 <_free_r+0x4c>
 80155c0:	42a3      	cmp	r3, r4
 80155c2:	d9fa      	bls.n	80155ba <_free_r+0x42>
 80155c4:	6811      	ldr	r1, [r2, #0]
 80155c6:	1850      	adds	r0, r2, r1
 80155c8:	42a0      	cmp	r0, r4
 80155ca:	d10b      	bne.n	80155e4 <_free_r+0x6c>
 80155cc:	6820      	ldr	r0, [r4, #0]
 80155ce:	4401      	add	r1, r0
 80155d0:	1850      	adds	r0, r2, r1
 80155d2:	6011      	str	r1, [r2, #0]
 80155d4:	4283      	cmp	r3, r0
 80155d6:	d1e0      	bne.n	801559a <_free_r+0x22>
 80155d8:	6818      	ldr	r0, [r3, #0]
 80155da:	685b      	ldr	r3, [r3, #4]
 80155dc:	4408      	add	r0, r1
 80155de:	6053      	str	r3, [r2, #4]
 80155e0:	6010      	str	r0, [r2, #0]
 80155e2:	e7da      	b.n	801559a <_free_r+0x22>
 80155e4:	d902      	bls.n	80155ec <_free_r+0x74>
 80155e6:	230c      	movs	r3, #12
 80155e8:	602b      	str	r3, [r5, #0]
 80155ea:	e7d6      	b.n	801559a <_free_r+0x22>
 80155ec:	6820      	ldr	r0, [r4, #0]
 80155ee:	1821      	adds	r1, r4, r0
 80155f0:	428b      	cmp	r3, r1
 80155f2:	bf02      	ittt	eq
 80155f4:	6819      	ldreq	r1, [r3, #0]
 80155f6:	685b      	ldreq	r3, [r3, #4]
 80155f8:	1809      	addeq	r1, r1, r0
 80155fa:	6063      	str	r3, [r4, #4]
 80155fc:	bf08      	it	eq
 80155fe:	6021      	streq	r1, [r4, #0]
 8015600:	6054      	str	r4, [r2, #4]
 8015602:	e7ca      	b.n	801559a <_free_r+0x22>
 8015604:	bd38      	pop	{r3, r4, r5, pc}
 8015606:	bf00      	nop
 8015608:	20002384 	.word	0x20002384

0801560c <__sfputc_r>:
 801560c:	6893      	ldr	r3, [r2, #8]
 801560e:	3b01      	subs	r3, #1
 8015610:	2b00      	cmp	r3, #0
 8015612:	b410      	push	{r4}
 8015614:	6093      	str	r3, [r2, #8]
 8015616:	da08      	bge.n	801562a <__sfputc_r+0x1e>
 8015618:	6994      	ldr	r4, [r2, #24]
 801561a:	42a3      	cmp	r3, r4
 801561c:	db01      	blt.n	8015622 <__sfputc_r+0x16>
 801561e:	290a      	cmp	r1, #10
 8015620:	d103      	bne.n	801562a <__sfputc_r+0x1e>
 8015622:	f85d 4b04 	ldr.w	r4, [sp], #4
 8015626:	f7ff be7b 	b.w	8015320 <__swbuf_r>
 801562a:	6813      	ldr	r3, [r2, #0]
 801562c:	1c58      	adds	r0, r3, #1
 801562e:	6010      	str	r0, [r2, #0]
 8015630:	4608      	mov	r0, r1
 8015632:	7019      	strb	r1, [r3, #0]
 8015634:	f85d 4b04 	ldr.w	r4, [sp], #4
 8015638:	4770      	bx	lr

0801563a <__sfputs_r>:
 801563a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801563c:	4606      	mov	r6, r0
 801563e:	460f      	mov	r7, r1
 8015640:	4614      	mov	r4, r2
 8015642:	18d5      	adds	r5, r2, r3
 8015644:	42ac      	cmp	r4, r5
 8015646:	d101      	bne.n	801564c <__sfputs_r+0x12>
 8015648:	2000      	movs	r0, #0
 801564a:	e007      	b.n	801565c <__sfputs_r+0x22>
 801564c:	463a      	mov	r2, r7
 801564e:	f814 1b01 	ldrb.w	r1, [r4], #1
 8015652:	4630      	mov	r0, r6
 8015654:	f7ff ffda 	bl	801560c <__sfputc_r>
 8015658:	1c43      	adds	r3, r0, #1
 801565a:	d1f3      	bne.n	8015644 <__sfputs_r+0xa>
 801565c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08015660 <_vfiprintf_r>:
 8015660:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015664:	460d      	mov	r5, r1
 8015666:	b09d      	sub	sp, #116	@ 0x74
 8015668:	4614      	mov	r4, r2
 801566a:	4698      	mov	r8, r3
 801566c:	4606      	mov	r6, r0
 801566e:	b118      	cbz	r0, 8015678 <_vfiprintf_r+0x18>
 8015670:	6a03      	ldr	r3, [r0, #32]
 8015672:	b90b      	cbnz	r3, 8015678 <_vfiprintf_r+0x18>
 8015674:	f7ff fdbe 	bl	80151f4 <__sinit>
 8015678:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 801567a:	07d9      	lsls	r1, r3, #31
 801567c:	d405      	bmi.n	801568a <_vfiprintf_r+0x2a>
 801567e:	89ab      	ldrh	r3, [r5, #12]
 8015680:	059a      	lsls	r2, r3, #22
 8015682:	d402      	bmi.n	801568a <_vfiprintf_r+0x2a>
 8015684:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 8015686:	f7ff ff68 	bl	801555a <__retarget_lock_acquire_recursive>
 801568a:	89ab      	ldrh	r3, [r5, #12]
 801568c:	071b      	lsls	r3, r3, #28
 801568e:	d501      	bpl.n	8015694 <_vfiprintf_r+0x34>
 8015690:	692b      	ldr	r3, [r5, #16]
 8015692:	b99b      	cbnz	r3, 80156bc <_vfiprintf_r+0x5c>
 8015694:	4629      	mov	r1, r5
 8015696:	4630      	mov	r0, r6
 8015698:	f7ff fe80 	bl	801539c <__swsetup_r>
 801569c:	b170      	cbz	r0, 80156bc <_vfiprintf_r+0x5c>
 801569e:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 80156a0:	07dc      	lsls	r4, r3, #31
 80156a2:	d504      	bpl.n	80156ae <_vfiprintf_r+0x4e>
 80156a4:	f04f 30ff 	mov.w	r0, #4294967295
 80156a8:	b01d      	add	sp, #116	@ 0x74
 80156aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80156ae:	89ab      	ldrh	r3, [r5, #12]
 80156b0:	0598      	lsls	r0, r3, #22
 80156b2:	d4f7      	bmi.n	80156a4 <_vfiprintf_r+0x44>
 80156b4:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 80156b6:	f7ff ff51 	bl	801555c <__retarget_lock_release_recursive>
 80156ba:	e7f3      	b.n	80156a4 <_vfiprintf_r+0x44>
 80156bc:	2300      	movs	r3, #0
 80156be:	f8cd 800c 	str.w	r8, [sp, #12]
 80156c2:	f04f 0901 	mov.w	r9, #1
 80156c6:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ 801587c <_vfiprintf_r+0x21c>
 80156ca:	9309      	str	r3, [sp, #36]	@ 0x24
 80156cc:	2320      	movs	r3, #32
 80156ce:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 80156d2:	2330      	movs	r3, #48	@ 0x30
 80156d4:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 80156d8:	4623      	mov	r3, r4
 80156da:	469a      	mov	sl, r3
 80156dc:	f813 2b01 	ldrb.w	r2, [r3], #1
 80156e0:	b10a      	cbz	r2, 80156e6 <_vfiprintf_r+0x86>
 80156e2:	2a25      	cmp	r2, #37	@ 0x25
 80156e4:	d1f9      	bne.n	80156da <_vfiprintf_r+0x7a>
 80156e6:	ebba 0b04 	subs.w	fp, sl, r4
 80156ea:	d00b      	beq.n	8015704 <_vfiprintf_r+0xa4>
 80156ec:	465b      	mov	r3, fp
 80156ee:	4622      	mov	r2, r4
 80156f0:	4629      	mov	r1, r5
 80156f2:	4630      	mov	r0, r6
 80156f4:	f7ff ffa1 	bl	801563a <__sfputs_r>
 80156f8:	3001      	adds	r0, #1
 80156fa:	f000 80a7 	beq.w	801584c <_vfiprintf_r+0x1ec>
 80156fe:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8015700:	445a      	add	r2, fp
 8015702:	9209      	str	r2, [sp, #36]	@ 0x24
 8015704:	f89a 3000 	ldrb.w	r3, [sl]
 8015708:	2b00      	cmp	r3, #0
 801570a:	f000 809f 	beq.w	801584c <_vfiprintf_r+0x1ec>
 801570e:	2300      	movs	r3, #0
 8015710:	f04f 32ff 	mov.w	r2, #4294967295
 8015714:	f10a 0a01 	add.w	sl, sl, #1
 8015718:	9304      	str	r3, [sp, #16]
 801571a:	9307      	str	r3, [sp, #28]
 801571c:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 8015720:	931a      	str	r3, [sp, #104]	@ 0x68
 8015722:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8015726:	4654      	mov	r4, sl
 8015728:	2205      	movs	r2, #5
 801572a:	4854      	ldr	r0, [pc, #336]	@ (801587c <_vfiprintf_r+0x21c>)
 801572c:	f814 1b01 	ldrb.w	r1, [r4], #1
 8015730:	f000 fb6e 	bl	8015e10 <memchr>
 8015734:	9a04      	ldr	r2, [sp, #16]
 8015736:	b9d8      	cbnz	r0, 8015770 <_vfiprintf_r+0x110>
 8015738:	06d1      	lsls	r1, r2, #27
 801573a:	bf44      	itt	mi
 801573c:	2320      	movmi	r3, #32
 801573e:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 8015742:	0713      	lsls	r3, r2, #28
 8015744:	bf44      	itt	mi
 8015746:	232b      	movmi	r3, #43	@ 0x2b
 8015748:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 801574c:	f89a 3000 	ldrb.w	r3, [sl]
 8015750:	2b2a      	cmp	r3, #42	@ 0x2a
 8015752:	d015      	beq.n	8015780 <_vfiprintf_r+0x120>
 8015754:	9a07      	ldr	r2, [sp, #28]
 8015756:	4654      	mov	r4, sl
 8015758:	2000      	movs	r0, #0
 801575a:	f04f 0c0a 	mov.w	ip, #10
 801575e:	4621      	mov	r1, r4
 8015760:	f811 3b01 	ldrb.w	r3, [r1], #1
 8015764:	3b30      	subs	r3, #48	@ 0x30
 8015766:	2b09      	cmp	r3, #9
 8015768:	d94b      	bls.n	8015802 <_vfiprintf_r+0x1a2>
 801576a:	b1b0      	cbz	r0, 801579a <_vfiprintf_r+0x13a>
 801576c:	9207      	str	r2, [sp, #28]
 801576e:	e014      	b.n	801579a <_vfiprintf_r+0x13a>
 8015770:	eba0 0308 	sub.w	r3, r0, r8
 8015774:	46a2      	mov	sl, r4
 8015776:	fa09 f303 	lsl.w	r3, r9, r3
 801577a:	4313      	orrs	r3, r2
 801577c:	9304      	str	r3, [sp, #16]
 801577e:	e7d2      	b.n	8015726 <_vfiprintf_r+0xc6>
 8015780:	9b03      	ldr	r3, [sp, #12]
 8015782:	1d19      	adds	r1, r3, #4
 8015784:	681b      	ldr	r3, [r3, #0]
 8015786:	2b00      	cmp	r3, #0
 8015788:	9103      	str	r1, [sp, #12]
 801578a:	bfbb      	ittet	lt
 801578c:	425b      	neglt	r3, r3
 801578e:	f042 0202 	orrlt.w	r2, r2, #2
 8015792:	9307      	strge	r3, [sp, #28]
 8015794:	9307      	strlt	r3, [sp, #28]
 8015796:	bfb8      	it	lt
 8015798:	9204      	strlt	r2, [sp, #16]
 801579a:	7823      	ldrb	r3, [r4, #0]
 801579c:	2b2e      	cmp	r3, #46	@ 0x2e
 801579e:	d10a      	bne.n	80157b6 <_vfiprintf_r+0x156>
 80157a0:	7863      	ldrb	r3, [r4, #1]
 80157a2:	2b2a      	cmp	r3, #42	@ 0x2a
 80157a4:	d132      	bne.n	801580c <_vfiprintf_r+0x1ac>
 80157a6:	9b03      	ldr	r3, [sp, #12]
 80157a8:	3402      	adds	r4, #2
 80157aa:	1d1a      	adds	r2, r3, #4
 80157ac:	681b      	ldr	r3, [r3, #0]
 80157ae:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 80157b2:	9203      	str	r2, [sp, #12]
 80157b4:	9305      	str	r3, [sp, #20]
 80157b6:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 801588c <_vfiprintf_r+0x22c>
 80157ba:	2203      	movs	r2, #3
 80157bc:	7821      	ldrb	r1, [r4, #0]
 80157be:	4650      	mov	r0, sl
 80157c0:	f000 fb26 	bl	8015e10 <memchr>
 80157c4:	b138      	cbz	r0, 80157d6 <_vfiprintf_r+0x176>
 80157c6:	eba0 000a 	sub.w	r0, r0, sl
 80157ca:	2240      	movs	r2, #64	@ 0x40
 80157cc:	9b04      	ldr	r3, [sp, #16]
 80157ce:	3401      	adds	r4, #1
 80157d0:	4082      	lsls	r2, r0
 80157d2:	4313      	orrs	r3, r2
 80157d4:	9304      	str	r3, [sp, #16]
 80157d6:	f814 1b01 	ldrb.w	r1, [r4], #1
 80157da:	2206      	movs	r2, #6
 80157dc:	4828      	ldr	r0, [pc, #160]	@ (8015880 <_vfiprintf_r+0x220>)
 80157de:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 80157e2:	f000 fb15 	bl	8015e10 <memchr>
 80157e6:	2800      	cmp	r0, #0
 80157e8:	d03f      	beq.n	801586a <_vfiprintf_r+0x20a>
 80157ea:	4b26      	ldr	r3, [pc, #152]	@ (8015884 <_vfiprintf_r+0x224>)
 80157ec:	bb1b      	cbnz	r3, 8015836 <_vfiprintf_r+0x1d6>
 80157ee:	9b03      	ldr	r3, [sp, #12]
 80157f0:	3307      	adds	r3, #7
 80157f2:	f023 0307 	bic.w	r3, r3, #7
 80157f6:	3308      	adds	r3, #8
 80157f8:	9303      	str	r3, [sp, #12]
 80157fa:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80157fc:	443b      	add	r3, r7
 80157fe:	9309      	str	r3, [sp, #36]	@ 0x24
 8015800:	e76a      	b.n	80156d8 <_vfiprintf_r+0x78>
 8015802:	fb0c 3202 	mla	r2, ip, r2, r3
 8015806:	460c      	mov	r4, r1
 8015808:	2001      	movs	r0, #1
 801580a:	e7a8      	b.n	801575e <_vfiprintf_r+0xfe>
 801580c:	2300      	movs	r3, #0
 801580e:	3401      	adds	r4, #1
 8015810:	f04f 0c0a 	mov.w	ip, #10
 8015814:	4619      	mov	r1, r3
 8015816:	9305      	str	r3, [sp, #20]
 8015818:	4620      	mov	r0, r4
 801581a:	f810 2b01 	ldrb.w	r2, [r0], #1
 801581e:	3a30      	subs	r2, #48	@ 0x30
 8015820:	2a09      	cmp	r2, #9
 8015822:	d903      	bls.n	801582c <_vfiprintf_r+0x1cc>
 8015824:	2b00      	cmp	r3, #0
 8015826:	d0c6      	beq.n	80157b6 <_vfiprintf_r+0x156>
 8015828:	9105      	str	r1, [sp, #20]
 801582a:	e7c4      	b.n	80157b6 <_vfiprintf_r+0x156>
 801582c:	fb0c 2101 	mla	r1, ip, r1, r2
 8015830:	4604      	mov	r4, r0
 8015832:	2301      	movs	r3, #1
 8015834:	e7f0      	b.n	8015818 <_vfiprintf_r+0x1b8>
 8015836:	ab03      	add	r3, sp, #12
 8015838:	462a      	mov	r2, r5
 801583a:	a904      	add	r1, sp, #16
 801583c:	4630      	mov	r0, r6
 801583e:	9300      	str	r3, [sp, #0]
 8015840:	4b11      	ldr	r3, [pc, #68]	@ (8015888 <_vfiprintf_r+0x228>)
 8015842:	f3af 8000 	nop.w
 8015846:	4607      	mov	r7, r0
 8015848:	1c78      	adds	r0, r7, #1
 801584a:	d1d6      	bne.n	80157fa <_vfiprintf_r+0x19a>
 801584c:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 801584e:	07d9      	lsls	r1, r3, #31
 8015850:	d405      	bmi.n	801585e <_vfiprintf_r+0x1fe>
 8015852:	89ab      	ldrh	r3, [r5, #12]
 8015854:	059a      	lsls	r2, r3, #22
 8015856:	d402      	bmi.n	801585e <_vfiprintf_r+0x1fe>
 8015858:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 801585a:	f7ff fe7f 	bl	801555c <__retarget_lock_release_recursive>
 801585e:	89ab      	ldrh	r3, [r5, #12]
 8015860:	065b      	lsls	r3, r3, #25
 8015862:	f53f af1f 	bmi.w	80156a4 <_vfiprintf_r+0x44>
 8015866:	9809      	ldr	r0, [sp, #36]	@ 0x24
 8015868:	e71e      	b.n	80156a8 <_vfiprintf_r+0x48>
 801586a:	ab03      	add	r3, sp, #12
 801586c:	462a      	mov	r2, r5
 801586e:	a904      	add	r1, sp, #16
 8015870:	4630      	mov	r0, r6
 8015872:	9300      	str	r3, [sp, #0]
 8015874:	4b04      	ldr	r3, [pc, #16]	@ (8015888 <_vfiprintf_r+0x228>)
 8015876:	f000 f87d 	bl	8015974 <_printf_i>
 801587a:	e7e4      	b.n	8015846 <_vfiprintf_r+0x1e6>
 801587c:	08017010 	.word	0x08017010
 8015880:	0801701a 	.word	0x0801701a
 8015884:	00000000 	.word	0x00000000
 8015888:	0801563b 	.word	0x0801563b
 801588c:	08017016 	.word	0x08017016

08015890 <_printf_common>:
 8015890:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8015894:	4616      	mov	r6, r2
 8015896:	4698      	mov	r8, r3
 8015898:	688a      	ldr	r2, [r1, #8]
 801589a:	4607      	mov	r7, r0
 801589c:	690b      	ldr	r3, [r1, #16]
 801589e:	460c      	mov	r4, r1
 80158a0:	f8dd 9020 	ldr.w	r9, [sp, #32]
 80158a4:	4293      	cmp	r3, r2
 80158a6:	bfb8      	it	lt
 80158a8:	4613      	movlt	r3, r2
 80158aa:	6033      	str	r3, [r6, #0]
 80158ac:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 80158b0:	b10a      	cbz	r2, 80158b6 <_printf_common+0x26>
 80158b2:	3301      	adds	r3, #1
 80158b4:	6033      	str	r3, [r6, #0]
 80158b6:	6823      	ldr	r3, [r4, #0]
 80158b8:	0699      	lsls	r1, r3, #26
 80158ba:	bf42      	ittt	mi
 80158bc:	6833      	ldrmi	r3, [r6, #0]
 80158be:	3302      	addmi	r3, #2
 80158c0:	6033      	strmi	r3, [r6, #0]
 80158c2:	6825      	ldr	r5, [r4, #0]
 80158c4:	f015 0506 	ands.w	r5, r5, #6
 80158c8:	d106      	bne.n	80158d8 <_printf_common+0x48>
 80158ca:	f104 0a19 	add.w	sl, r4, #25
 80158ce:	68e3      	ldr	r3, [r4, #12]
 80158d0:	6832      	ldr	r2, [r6, #0]
 80158d2:	1a9b      	subs	r3, r3, r2
 80158d4:	42ab      	cmp	r3, r5
 80158d6:	dc2b      	bgt.n	8015930 <_printf_common+0xa0>
 80158d8:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 80158dc:	6822      	ldr	r2, [r4, #0]
 80158de:	3b00      	subs	r3, #0
 80158e0:	bf18      	it	ne
 80158e2:	2301      	movne	r3, #1
 80158e4:	0692      	lsls	r2, r2, #26
 80158e6:	d430      	bmi.n	801594a <_printf_common+0xba>
 80158e8:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 80158ec:	4641      	mov	r1, r8
 80158ee:	4638      	mov	r0, r7
 80158f0:	47c8      	blx	r9
 80158f2:	3001      	adds	r0, #1
 80158f4:	d023      	beq.n	801593e <_printf_common+0xae>
 80158f6:	6823      	ldr	r3, [r4, #0]
 80158f8:	341a      	adds	r4, #26
 80158fa:	f854 2c0a 	ldr.w	r2, [r4, #-10]
 80158fe:	f003 0306 	and.w	r3, r3, #6
 8015902:	2b04      	cmp	r3, #4
 8015904:	bf0a      	itet	eq
 8015906:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
 801590a:	2500      	movne	r5, #0
 801590c:	6833      	ldreq	r3, [r6, #0]
 801590e:	f04f 0600 	mov.w	r6, #0
 8015912:	bf08      	it	eq
 8015914:	1aed      	subeq	r5, r5, r3
 8015916:	f854 3c12 	ldr.w	r3, [r4, #-18]
 801591a:	bf08      	it	eq
 801591c:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8015920:	4293      	cmp	r3, r2
 8015922:	bfc4      	itt	gt
 8015924:	1a9b      	subgt	r3, r3, r2
 8015926:	18ed      	addgt	r5, r5, r3
 8015928:	42b5      	cmp	r5, r6
 801592a:	d11a      	bne.n	8015962 <_printf_common+0xd2>
 801592c:	2000      	movs	r0, #0
 801592e:	e008      	b.n	8015942 <_printf_common+0xb2>
 8015930:	2301      	movs	r3, #1
 8015932:	4652      	mov	r2, sl
 8015934:	4641      	mov	r1, r8
 8015936:	4638      	mov	r0, r7
 8015938:	47c8      	blx	r9
 801593a:	3001      	adds	r0, #1
 801593c:	d103      	bne.n	8015946 <_printf_common+0xb6>
 801593e:	f04f 30ff 	mov.w	r0, #4294967295
 8015942:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8015946:	3501      	adds	r5, #1
 8015948:	e7c1      	b.n	80158ce <_printf_common+0x3e>
 801594a:	18e1      	adds	r1, r4, r3
 801594c:	1c5a      	adds	r2, r3, #1
 801594e:	2030      	movs	r0, #48	@ 0x30
 8015950:	3302      	adds	r3, #2
 8015952:	4422      	add	r2, r4
 8015954:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 8015958:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 801595c:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 8015960:	e7c2      	b.n	80158e8 <_printf_common+0x58>
 8015962:	2301      	movs	r3, #1
 8015964:	4622      	mov	r2, r4
 8015966:	4641      	mov	r1, r8
 8015968:	4638      	mov	r0, r7
 801596a:	47c8      	blx	r9
 801596c:	3001      	adds	r0, #1
 801596e:	d0e6      	beq.n	801593e <_printf_common+0xae>
 8015970:	3601      	adds	r6, #1
 8015972:	e7d9      	b.n	8015928 <_printf_common+0x98>

08015974 <_printf_i>:
 8015974:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8015978:	7e0f      	ldrb	r7, [r1, #24]
 801597a:	4691      	mov	r9, r2
 801597c:	4680      	mov	r8, r0
 801597e:	460c      	mov	r4, r1
 8015980:	2f78      	cmp	r7, #120	@ 0x78
 8015982:	469a      	mov	sl, r3
 8015984:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 8015986:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 801598a:	d807      	bhi.n	801599c <_printf_i+0x28>
 801598c:	2f62      	cmp	r7, #98	@ 0x62
 801598e:	d80a      	bhi.n	80159a6 <_printf_i+0x32>
 8015990:	2f00      	cmp	r7, #0
 8015992:	f000 80d1 	beq.w	8015b38 <_printf_i+0x1c4>
 8015996:	2f58      	cmp	r7, #88	@ 0x58
 8015998:	f000 80b8 	beq.w	8015b0c <_printf_i+0x198>
 801599c:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 80159a0:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 80159a4:	e03a      	b.n	8015a1c <_printf_i+0xa8>
 80159a6:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 80159aa:	2b15      	cmp	r3, #21
 80159ac:	d8f6      	bhi.n	801599c <_printf_i+0x28>
 80159ae:	a101      	add	r1, pc, #4	@ (adr r1, 80159b4 <_printf_i+0x40>)
 80159b0:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 80159b4:	08015a0d 	.word	0x08015a0d
 80159b8:	08015a21 	.word	0x08015a21
 80159bc:	0801599d 	.word	0x0801599d
 80159c0:	0801599d 	.word	0x0801599d
 80159c4:	0801599d 	.word	0x0801599d
 80159c8:	0801599d 	.word	0x0801599d
 80159cc:	08015a21 	.word	0x08015a21
 80159d0:	0801599d 	.word	0x0801599d
 80159d4:	0801599d 	.word	0x0801599d
 80159d8:	0801599d 	.word	0x0801599d
 80159dc:	0801599d 	.word	0x0801599d
 80159e0:	08015b1f 	.word	0x08015b1f
 80159e4:	08015a4b 	.word	0x08015a4b
 80159e8:	08015ad9 	.word	0x08015ad9
 80159ec:	0801599d 	.word	0x0801599d
 80159f0:	0801599d 	.word	0x0801599d
 80159f4:	08015b41 	.word	0x08015b41
 80159f8:	0801599d 	.word	0x0801599d
 80159fc:	08015a4b 	.word	0x08015a4b
 8015a00:	0801599d 	.word	0x0801599d
 8015a04:	0801599d 	.word	0x0801599d
 8015a08:	08015ae1 	.word	0x08015ae1
 8015a0c:	6833      	ldr	r3, [r6, #0]
 8015a0e:	1d1a      	adds	r2, r3, #4
 8015a10:	681b      	ldr	r3, [r3, #0]
 8015a12:	6032      	str	r2, [r6, #0]
 8015a14:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 8015a18:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 8015a1c:	2301      	movs	r3, #1
 8015a1e:	e09c      	b.n	8015b5a <_printf_i+0x1e6>
 8015a20:	6833      	ldr	r3, [r6, #0]
 8015a22:	6820      	ldr	r0, [r4, #0]
 8015a24:	1d19      	adds	r1, r3, #4
 8015a26:	6031      	str	r1, [r6, #0]
 8015a28:	0606      	lsls	r6, r0, #24
 8015a2a:	d501      	bpl.n	8015a30 <_printf_i+0xbc>
 8015a2c:	681d      	ldr	r5, [r3, #0]
 8015a2e:	e003      	b.n	8015a38 <_printf_i+0xc4>
 8015a30:	0645      	lsls	r5, r0, #25
 8015a32:	d5fb      	bpl.n	8015a2c <_printf_i+0xb8>
 8015a34:	f9b3 5000 	ldrsh.w	r5, [r3]
 8015a38:	2d00      	cmp	r5, #0
 8015a3a:	da03      	bge.n	8015a44 <_printf_i+0xd0>
 8015a3c:	232d      	movs	r3, #45	@ 0x2d
 8015a3e:	426d      	negs	r5, r5
 8015a40:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8015a44:	4858      	ldr	r0, [pc, #352]	@ (8015ba8 <_printf_i+0x234>)
 8015a46:	230a      	movs	r3, #10
 8015a48:	e011      	b.n	8015a6e <_printf_i+0xfa>
 8015a4a:	6821      	ldr	r1, [r4, #0]
 8015a4c:	6833      	ldr	r3, [r6, #0]
 8015a4e:	0608      	lsls	r0, r1, #24
 8015a50:	f853 5b04 	ldr.w	r5, [r3], #4
 8015a54:	d402      	bmi.n	8015a5c <_printf_i+0xe8>
 8015a56:	0649      	lsls	r1, r1, #25
 8015a58:	bf48      	it	mi
 8015a5a:	b2ad      	uxthmi	r5, r5
 8015a5c:	2f6f      	cmp	r7, #111	@ 0x6f
 8015a5e:	6033      	str	r3, [r6, #0]
 8015a60:	4851      	ldr	r0, [pc, #324]	@ (8015ba8 <_printf_i+0x234>)
 8015a62:	bf14      	ite	ne
 8015a64:	230a      	movne	r3, #10
 8015a66:	2308      	moveq	r3, #8
 8015a68:	2100      	movs	r1, #0
 8015a6a:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 8015a6e:	6866      	ldr	r6, [r4, #4]
 8015a70:	2e00      	cmp	r6, #0
 8015a72:	60a6      	str	r6, [r4, #8]
 8015a74:	db05      	blt.n	8015a82 <_printf_i+0x10e>
 8015a76:	6821      	ldr	r1, [r4, #0]
 8015a78:	432e      	orrs	r6, r5
 8015a7a:	f021 0104 	bic.w	r1, r1, #4
 8015a7e:	6021      	str	r1, [r4, #0]
 8015a80:	d04b      	beq.n	8015b1a <_printf_i+0x1a6>
 8015a82:	4616      	mov	r6, r2
 8015a84:	fbb5 f1f3 	udiv	r1, r5, r3
 8015a88:	fb03 5711 	mls	r7, r3, r1, r5
 8015a8c:	5dc7      	ldrb	r7, [r0, r7]
 8015a8e:	f806 7d01 	strb.w	r7, [r6, #-1]!
 8015a92:	462f      	mov	r7, r5
 8015a94:	460d      	mov	r5, r1
 8015a96:	42bb      	cmp	r3, r7
 8015a98:	d9f4      	bls.n	8015a84 <_printf_i+0x110>
 8015a9a:	2b08      	cmp	r3, #8
 8015a9c:	d10b      	bne.n	8015ab6 <_printf_i+0x142>
 8015a9e:	6823      	ldr	r3, [r4, #0]
 8015aa0:	07df      	lsls	r7, r3, #31
 8015aa2:	d508      	bpl.n	8015ab6 <_printf_i+0x142>
 8015aa4:	6923      	ldr	r3, [r4, #16]
 8015aa6:	6861      	ldr	r1, [r4, #4]
 8015aa8:	4299      	cmp	r1, r3
 8015aaa:	bfde      	ittt	le
 8015aac:	2330      	movle	r3, #48	@ 0x30
 8015aae:	f806 3c01 	strble.w	r3, [r6, #-1]
 8015ab2:	f106 36ff 	addle.w	r6, r6, #4294967295
 8015ab6:	1b92      	subs	r2, r2, r6
 8015ab8:	6122      	str	r2, [r4, #16]
 8015aba:	464b      	mov	r3, r9
 8015abc:	aa03      	add	r2, sp, #12
 8015abe:	4621      	mov	r1, r4
 8015ac0:	4640      	mov	r0, r8
 8015ac2:	f8cd a000 	str.w	sl, [sp]
 8015ac6:	f7ff fee3 	bl	8015890 <_printf_common>
 8015aca:	3001      	adds	r0, #1
 8015acc:	d14a      	bne.n	8015b64 <_printf_i+0x1f0>
 8015ace:	f04f 30ff 	mov.w	r0, #4294967295
 8015ad2:	b004      	add	sp, #16
 8015ad4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8015ad8:	6823      	ldr	r3, [r4, #0]
 8015ada:	f043 0320 	orr.w	r3, r3, #32
 8015ade:	6023      	str	r3, [r4, #0]
 8015ae0:	2778      	movs	r7, #120	@ 0x78
 8015ae2:	4832      	ldr	r0, [pc, #200]	@ (8015bac <_printf_i+0x238>)
 8015ae4:	6823      	ldr	r3, [r4, #0]
 8015ae6:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 8015aea:	061f      	lsls	r7, r3, #24
 8015aec:	6831      	ldr	r1, [r6, #0]
 8015aee:	f851 5b04 	ldr.w	r5, [r1], #4
 8015af2:	d402      	bmi.n	8015afa <_printf_i+0x186>
 8015af4:	065f      	lsls	r7, r3, #25
 8015af6:	bf48      	it	mi
 8015af8:	b2ad      	uxthmi	r5, r5
 8015afa:	6031      	str	r1, [r6, #0]
 8015afc:	07d9      	lsls	r1, r3, #31
 8015afe:	bf44      	itt	mi
 8015b00:	f043 0320 	orrmi.w	r3, r3, #32
 8015b04:	6023      	strmi	r3, [r4, #0]
 8015b06:	b11d      	cbz	r5, 8015b10 <_printf_i+0x19c>
 8015b08:	2310      	movs	r3, #16
 8015b0a:	e7ad      	b.n	8015a68 <_printf_i+0xf4>
 8015b0c:	4826      	ldr	r0, [pc, #152]	@ (8015ba8 <_printf_i+0x234>)
 8015b0e:	e7e9      	b.n	8015ae4 <_printf_i+0x170>
 8015b10:	6823      	ldr	r3, [r4, #0]
 8015b12:	f023 0320 	bic.w	r3, r3, #32
 8015b16:	6023      	str	r3, [r4, #0]
 8015b18:	e7f6      	b.n	8015b08 <_printf_i+0x194>
 8015b1a:	4616      	mov	r6, r2
 8015b1c:	e7bd      	b.n	8015a9a <_printf_i+0x126>
 8015b1e:	6833      	ldr	r3, [r6, #0]
 8015b20:	6825      	ldr	r5, [r4, #0]
 8015b22:	1d18      	adds	r0, r3, #4
 8015b24:	6961      	ldr	r1, [r4, #20]
 8015b26:	6030      	str	r0, [r6, #0]
 8015b28:	062e      	lsls	r6, r5, #24
 8015b2a:	681b      	ldr	r3, [r3, #0]
 8015b2c:	d501      	bpl.n	8015b32 <_printf_i+0x1be>
 8015b2e:	6019      	str	r1, [r3, #0]
 8015b30:	e002      	b.n	8015b38 <_printf_i+0x1c4>
 8015b32:	0668      	lsls	r0, r5, #25
 8015b34:	d5fb      	bpl.n	8015b2e <_printf_i+0x1ba>
 8015b36:	8019      	strh	r1, [r3, #0]
 8015b38:	2300      	movs	r3, #0
 8015b3a:	4616      	mov	r6, r2
 8015b3c:	6123      	str	r3, [r4, #16]
 8015b3e:	e7bc      	b.n	8015aba <_printf_i+0x146>
 8015b40:	6833      	ldr	r3, [r6, #0]
 8015b42:	2100      	movs	r1, #0
 8015b44:	1d1a      	adds	r2, r3, #4
 8015b46:	6032      	str	r2, [r6, #0]
 8015b48:	681e      	ldr	r6, [r3, #0]
 8015b4a:	6862      	ldr	r2, [r4, #4]
 8015b4c:	4630      	mov	r0, r6
 8015b4e:	f000 f95f 	bl	8015e10 <memchr>
 8015b52:	b108      	cbz	r0, 8015b58 <_printf_i+0x1e4>
 8015b54:	1b80      	subs	r0, r0, r6
 8015b56:	6060      	str	r0, [r4, #4]
 8015b58:	6863      	ldr	r3, [r4, #4]
 8015b5a:	6123      	str	r3, [r4, #16]
 8015b5c:	2300      	movs	r3, #0
 8015b5e:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8015b62:	e7aa      	b.n	8015aba <_printf_i+0x146>
 8015b64:	6923      	ldr	r3, [r4, #16]
 8015b66:	4632      	mov	r2, r6
 8015b68:	4649      	mov	r1, r9
 8015b6a:	4640      	mov	r0, r8
 8015b6c:	47d0      	blx	sl
 8015b6e:	3001      	adds	r0, #1
 8015b70:	d0ad      	beq.n	8015ace <_printf_i+0x15a>
 8015b72:	6823      	ldr	r3, [r4, #0]
 8015b74:	079b      	lsls	r3, r3, #30
 8015b76:	d413      	bmi.n	8015ba0 <_printf_i+0x22c>
 8015b78:	68e0      	ldr	r0, [r4, #12]
 8015b7a:	9b03      	ldr	r3, [sp, #12]
 8015b7c:	4298      	cmp	r0, r3
 8015b7e:	bfb8      	it	lt
 8015b80:	4618      	movlt	r0, r3
 8015b82:	e7a6      	b.n	8015ad2 <_printf_i+0x15e>
 8015b84:	2301      	movs	r3, #1
 8015b86:	4632      	mov	r2, r6
 8015b88:	4649      	mov	r1, r9
 8015b8a:	4640      	mov	r0, r8
 8015b8c:	47d0      	blx	sl
 8015b8e:	3001      	adds	r0, #1
 8015b90:	d09d      	beq.n	8015ace <_printf_i+0x15a>
 8015b92:	3501      	adds	r5, #1
 8015b94:	68e3      	ldr	r3, [r4, #12]
 8015b96:	9903      	ldr	r1, [sp, #12]
 8015b98:	1a5b      	subs	r3, r3, r1
 8015b9a:	42ab      	cmp	r3, r5
 8015b9c:	dcf2      	bgt.n	8015b84 <_printf_i+0x210>
 8015b9e:	e7eb      	b.n	8015b78 <_printf_i+0x204>
 8015ba0:	2500      	movs	r5, #0
 8015ba2:	f104 0619 	add.w	r6, r4, #25
 8015ba6:	e7f5      	b.n	8015b94 <_printf_i+0x220>
 8015ba8:	08017021 	.word	0x08017021
 8015bac:	08017032 	.word	0x08017032

08015bb0 <__sflush_r>:
 8015bb0:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 8015bb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015bb8:	0716      	lsls	r6, r2, #28
 8015bba:	4605      	mov	r5, r0
 8015bbc:	460c      	mov	r4, r1
 8015bbe:	d454      	bmi.n	8015c6a <__sflush_r+0xba>
 8015bc0:	684b      	ldr	r3, [r1, #4]
 8015bc2:	2b00      	cmp	r3, #0
 8015bc4:	dc02      	bgt.n	8015bcc <__sflush_r+0x1c>
 8015bc6:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 8015bc8:	2b00      	cmp	r3, #0
 8015bca:	dd48      	ble.n	8015c5e <__sflush_r+0xae>
 8015bcc:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 8015bce:	2e00      	cmp	r6, #0
 8015bd0:	d045      	beq.n	8015c5e <__sflush_r+0xae>
 8015bd2:	2300      	movs	r3, #0
 8015bd4:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 8015bd8:	682f      	ldr	r7, [r5, #0]
 8015bda:	6a21      	ldr	r1, [r4, #32]
 8015bdc:	602b      	str	r3, [r5, #0]
 8015bde:	d030      	beq.n	8015c42 <__sflush_r+0x92>
 8015be0:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 8015be2:	89a3      	ldrh	r3, [r4, #12]
 8015be4:	0759      	lsls	r1, r3, #29
 8015be6:	d505      	bpl.n	8015bf4 <__sflush_r+0x44>
 8015be8:	6863      	ldr	r3, [r4, #4]
 8015bea:	1ad2      	subs	r2, r2, r3
 8015bec:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8015bee:	b10b      	cbz	r3, 8015bf4 <__sflush_r+0x44>
 8015bf0:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 8015bf2:	1ad2      	subs	r2, r2, r3
 8015bf4:	2300      	movs	r3, #0
 8015bf6:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 8015bf8:	6a21      	ldr	r1, [r4, #32]
 8015bfa:	4628      	mov	r0, r5
 8015bfc:	47b0      	blx	r6
 8015bfe:	1c43      	adds	r3, r0, #1
 8015c00:	89a3      	ldrh	r3, [r4, #12]
 8015c02:	d106      	bne.n	8015c12 <__sflush_r+0x62>
 8015c04:	6829      	ldr	r1, [r5, #0]
 8015c06:	291d      	cmp	r1, #29
 8015c08:	d82b      	bhi.n	8015c62 <__sflush_r+0xb2>
 8015c0a:	4a2a      	ldr	r2, [pc, #168]	@ (8015cb4 <__sflush_r+0x104>)
 8015c0c:	40ca      	lsrs	r2, r1
 8015c0e:	07d6      	lsls	r6, r2, #31
 8015c10:	d527      	bpl.n	8015c62 <__sflush_r+0xb2>
 8015c12:	2200      	movs	r2, #0
 8015c14:	04d9      	lsls	r1, r3, #19
 8015c16:	6062      	str	r2, [r4, #4]
 8015c18:	6922      	ldr	r2, [r4, #16]
 8015c1a:	6022      	str	r2, [r4, #0]
 8015c1c:	d504      	bpl.n	8015c28 <__sflush_r+0x78>
 8015c1e:	1c42      	adds	r2, r0, #1
 8015c20:	d101      	bne.n	8015c26 <__sflush_r+0x76>
 8015c22:	682b      	ldr	r3, [r5, #0]
 8015c24:	b903      	cbnz	r3, 8015c28 <__sflush_r+0x78>
 8015c26:	6560      	str	r0, [r4, #84]	@ 0x54
 8015c28:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8015c2a:	602f      	str	r7, [r5, #0]
 8015c2c:	b1b9      	cbz	r1, 8015c5e <__sflush_r+0xae>
 8015c2e:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 8015c32:	4299      	cmp	r1, r3
 8015c34:	d002      	beq.n	8015c3c <__sflush_r+0x8c>
 8015c36:	4628      	mov	r0, r5
 8015c38:	f7ff fc9e 	bl	8015578 <_free_r>
 8015c3c:	2300      	movs	r3, #0
 8015c3e:	6363      	str	r3, [r4, #52]	@ 0x34
 8015c40:	e00d      	b.n	8015c5e <__sflush_r+0xae>
 8015c42:	2301      	movs	r3, #1
 8015c44:	4628      	mov	r0, r5
 8015c46:	47b0      	blx	r6
 8015c48:	4602      	mov	r2, r0
 8015c4a:	1c50      	adds	r0, r2, #1
 8015c4c:	d1c9      	bne.n	8015be2 <__sflush_r+0x32>
 8015c4e:	682b      	ldr	r3, [r5, #0]
 8015c50:	2b00      	cmp	r3, #0
 8015c52:	d0c6      	beq.n	8015be2 <__sflush_r+0x32>
 8015c54:	2b1d      	cmp	r3, #29
 8015c56:	d001      	beq.n	8015c5c <__sflush_r+0xac>
 8015c58:	2b16      	cmp	r3, #22
 8015c5a:	d11d      	bne.n	8015c98 <__sflush_r+0xe8>
 8015c5c:	602f      	str	r7, [r5, #0]
 8015c5e:	2000      	movs	r0, #0
 8015c60:	e021      	b.n	8015ca6 <__sflush_r+0xf6>
 8015c62:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8015c66:	b21b      	sxth	r3, r3
 8015c68:	e01a      	b.n	8015ca0 <__sflush_r+0xf0>
 8015c6a:	690f      	ldr	r7, [r1, #16]
 8015c6c:	2f00      	cmp	r7, #0
 8015c6e:	d0f6      	beq.n	8015c5e <__sflush_r+0xae>
 8015c70:	0793      	lsls	r3, r2, #30
 8015c72:	680e      	ldr	r6, [r1, #0]
 8015c74:	600f      	str	r7, [r1, #0]
 8015c76:	bf0c      	ite	eq
 8015c78:	694b      	ldreq	r3, [r1, #20]
 8015c7a:	2300      	movne	r3, #0
 8015c7c:	eba6 0807 	sub.w	r8, r6, r7
 8015c80:	608b      	str	r3, [r1, #8]
 8015c82:	f1b8 0f00 	cmp.w	r8, #0
 8015c86:	ddea      	ble.n	8015c5e <__sflush_r+0xae>
 8015c88:	4643      	mov	r3, r8
 8015c8a:	463a      	mov	r2, r7
 8015c8c:	6a21      	ldr	r1, [r4, #32]
 8015c8e:	4628      	mov	r0, r5
 8015c90:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 8015c92:	47b0      	blx	r6
 8015c94:	2800      	cmp	r0, #0
 8015c96:	dc08      	bgt.n	8015caa <__sflush_r+0xfa>
 8015c98:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8015c9c:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8015ca0:	f04f 30ff 	mov.w	r0, #4294967295
 8015ca4:	81a3      	strh	r3, [r4, #12]
 8015ca6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8015caa:	4407      	add	r7, r0
 8015cac:	eba8 0800 	sub.w	r8, r8, r0
 8015cb0:	e7e7      	b.n	8015c82 <__sflush_r+0xd2>
 8015cb2:	bf00      	nop
 8015cb4:	20400001 	.word	0x20400001

08015cb8 <_fflush_r>:
 8015cb8:	b538      	push	{r3, r4, r5, lr}
 8015cba:	690b      	ldr	r3, [r1, #16]
 8015cbc:	4605      	mov	r5, r0
 8015cbe:	460c      	mov	r4, r1
 8015cc0:	b913      	cbnz	r3, 8015cc8 <_fflush_r+0x10>
 8015cc2:	2500      	movs	r5, #0
 8015cc4:	4628      	mov	r0, r5
 8015cc6:	bd38      	pop	{r3, r4, r5, pc}
 8015cc8:	b118      	cbz	r0, 8015cd2 <_fflush_r+0x1a>
 8015cca:	6a03      	ldr	r3, [r0, #32]
 8015ccc:	b90b      	cbnz	r3, 8015cd2 <_fflush_r+0x1a>
 8015cce:	f7ff fa91 	bl	80151f4 <__sinit>
 8015cd2:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8015cd6:	2b00      	cmp	r3, #0
 8015cd8:	d0f3      	beq.n	8015cc2 <_fflush_r+0xa>
 8015cda:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 8015cdc:	07d0      	lsls	r0, r2, #31
 8015cde:	d404      	bmi.n	8015cea <_fflush_r+0x32>
 8015ce0:	0599      	lsls	r1, r3, #22
 8015ce2:	d402      	bmi.n	8015cea <_fflush_r+0x32>
 8015ce4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8015ce6:	f7ff fc38 	bl	801555a <__retarget_lock_acquire_recursive>
 8015cea:	4628      	mov	r0, r5
 8015cec:	4621      	mov	r1, r4
 8015cee:	f7ff ff5f 	bl	8015bb0 <__sflush_r>
 8015cf2:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8015cf4:	4605      	mov	r5, r0
 8015cf6:	07da      	lsls	r2, r3, #31
 8015cf8:	d4e4      	bmi.n	8015cc4 <_fflush_r+0xc>
 8015cfa:	89a3      	ldrh	r3, [r4, #12]
 8015cfc:	059b      	lsls	r3, r3, #22
 8015cfe:	d4e1      	bmi.n	8015cc4 <_fflush_r+0xc>
 8015d00:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8015d02:	f7ff fc2b 	bl	801555c <__retarget_lock_release_recursive>
 8015d06:	e7dd      	b.n	8015cc4 <_fflush_r+0xc>

08015d08 <__swhatbuf_r>:
 8015d08:	b570      	push	{r4, r5, r6, lr}
 8015d0a:	460c      	mov	r4, r1
 8015d0c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8015d10:	b096      	sub	sp, #88	@ 0x58
 8015d12:	4615      	mov	r5, r2
 8015d14:	2900      	cmp	r1, #0
 8015d16:	461e      	mov	r6, r3
 8015d18:	da0c      	bge.n	8015d34 <__swhatbuf_r+0x2c>
 8015d1a:	89a3      	ldrh	r3, [r4, #12]
 8015d1c:	2100      	movs	r1, #0
 8015d1e:	f013 0f80 	tst.w	r3, #128	@ 0x80
 8015d22:	bf14      	ite	ne
 8015d24:	2340      	movne	r3, #64	@ 0x40
 8015d26:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 8015d2a:	2000      	movs	r0, #0
 8015d2c:	6031      	str	r1, [r6, #0]
 8015d2e:	602b      	str	r3, [r5, #0]
 8015d30:	b016      	add	sp, #88	@ 0x58
 8015d32:	bd70      	pop	{r4, r5, r6, pc}
 8015d34:	466a      	mov	r2, sp
 8015d36:	f000 f849 	bl	8015dcc <_fstat_r>
 8015d3a:	2800      	cmp	r0, #0
 8015d3c:	dbed      	blt.n	8015d1a <__swhatbuf_r+0x12>
 8015d3e:	9901      	ldr	r1, [sp, #4]
 8015d40:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 8015d44:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 8015d48:	4259      	negs	r1, r3
 8015d4a:	4159      	adcs	r1, r3
 8015d4c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8015d50:	e7eb      	b.n	8015d2a <__swhatbuf_r+0x22>

08015d52 <__smakebuf_r>:
 8015d52:	898b      	ldrh	r3, [r1, #12]
 8015d54:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8015d56:	079d      	lsls	r5, r3, #30
 8015d58:	4606      	mov	r6, r0
 8015d5a:	460c      	mov	r4, r1
 8015d5c:	d507      	bpl.n	8015d6e <__smakebuf_r+0x1c>
 8015d5e:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 8015d62:	6023      	str	r3, [r4, #0]
 8015d64:	6123      	str	r3, [r4, #16]
 8015d66:	2301      	movs	r3, #1
 8015d68:	6163      	str	r3, [r4, #20]
 8015d6a:	b003      	add	sp, #12
 8015d6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8015d6e:	ab01      	add	r3, sp, #4
 8015d70:	466a      	mov	r2, sp
 8015d72:	f7ff ffc9 	bl	8015d08 <__swhatbuf_r>
 8015d76:	9f00      	ldr	r7, [sp, #0]
 8015d78:	4605      	mov	r5, r0
 8015d7a:	4630      	mov	r0, r6
 8015d7c:	4639      	mov	r1, r7
 8015d7e:	f7ff f921 	bl	8014fc4 <_malloc_r>
 8015d82:	b948      	cbnz	r0, 8015d98 <__smakebuf_r+0x46>
 8015d84:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8015d88:	059a      	lsls	r2, r3, #22
 8015d8a:	d4ee      	bmi.n	8015d6a <__smakebuf_r+0x18>
 8015d8c:	f023 0303 	bic.w	r3, r3, #3
 8015d90:	f043 0302 	orr.w	r3, r3, #2
 8015d94:	81a3      	strh	r3, [r4, #12]
 8015d96:	e7e2      	b.n	8015d5e <__smakebuf_r+0xc>
 8015d98:	89a3      	ldrh	r3, [r4, #12]
 8015d9a:	6020      	str	r0, [r4, #0]
 8015d9c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8015da0:	81a3      	strh	r3, [r4, #12]
 8015da2:	9b01      	ldr	r3, [sp, #4]
 8015da4:	e9c4 0704 	strd	r0, r7, [r4, #16]
 8015da8:	b15b      	cbz	r3, 8015dc2 <__smakebuf_r+0x70>
 8015daa:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8015dae:	4630      	mov	r0, r6
 8015db0:	f000 f81e 	bl	8015df0 <_isatty_r>
 8015db4:	b128      	cbz	r0, 8015dc2 <__smakebuf_r+0x70>
 8015db6:	89a3      	ldrh	r3, [r4, #12]
 8015db8:	f023 0303 	bic.w	r3, r3, #3
 8015dbc:	f043 0301 	orr.w	r3, r3, #1
 8015dc0:	81a3      	strh	r3, [r4, #12]
 8015dc2:	89a3      	ldrh	r3, [r4, #12]
 8015dc4:	431d      	orrs	r5, r3
 8015dc6:	81a5      	strh	r5, [r4, #12]
 8015dc8:	e7cf      	b.n	8015d6a <__smakebuf_r+0x18>
	...

08015dcc <_fstat_r>:
 8015dcc:	b538      	push	{r3, r4, r5, lr}
 8015dce:	2300      	movs	r3, #0
 8015dd0:	4d06      	ldr	r5, [pc, #24]	@ (8015dec <_fstat_r+0x20>)
 8015dd2:	4604      	mov	r4, r0
 8015dd4:	4608      	mov	r0, r1
 8015dd6:	4611      	mov	r1, r2
 8015dd8:	602b      	str	r3, [r5, #0]
 8015dda:	f7f7 fd66 	bl	800d8aa <_fstat>
 8015dde:	1c43      	adds	r3, r0, #1
 8015de0:	d102      	bne.n	8015de8 <_fstat_r+0x1c>
 8015de2:	682b      	ldr	r3, [r5, #0]
 8015de4:	b103      	cbz	r3, 8015de8 <_fstat_r+0x1c>
 8015de6:	6023      	str	r3, [r4, #0]
 8015de8:	bd38      	pop	{r3, r4, r5, pc}
 8015dea:	bf00      	nop
 8015dec:	200024c4 	.word	0x200024c4

08015df0 <_isatty_r>:
 8015df0:	b538      	push	{r3, r4, r5, lr}
 8015df2:	2300      	movs	r3, #0
 8015df4:	4d05      	ldr	r5, [pc, #20]	@ (8015e0c <_isatty_r+0x1c>)
 8015df6:	4604      	mov	r4, r0
 8015df8:	4608      	mov	r0, r1
 8015dfa:	602b      	str	r3, [r5, #0]
 8015dfc:	f7f7 fd65 	bl	800d8ca <_isatty>
 8015e00:	1c43      	adds	r3, r0, #1
 8015e02:	d102      	bne.n	8015e0a <_isatty_r+0x1a>
 8015e04:	682b      	ldr	r3, [r5, #0]
 8015e06:	b103      	cbz	r3, 8015e0a <_isatty_r+0x1a>
 8015e08:	6023      	str	r3, [r4, #0]
 8015e0a:	bd38      	pop	{r3, r4, r5, pc}
 8015e0c:	200024c4 	.word	0x200024c4

08015e10 <memchr>:
 8015e10:	b2c9      	uxtb	r1, r1
 8015e12:	4603      	mov	r3, r0
 8015e14:	4402      	add	r2, r0
 8015e16:	b510      	push	{r4, lr}
 8015e18:	4293      	cmp	r3, r2
 8015e1a:	4618      	mov	r0, r3
 8015e1c:	d101      	bne.n	8015e22 <memchr+0x12>
 8015e1e:	2000      	movs	r0, #0
 8015e20:	e003      	b.n	8015e2a <memchr+0x1a>
 8015e22:	7804      	ldrb	r4, [r0, #0]
 8015e24:	3301      	adds	r3, #1
 8015e26:	428c      	cmp	r4, r1
 8015e28:	d1f6      	bne.n	8015e18 <memchr+0x8>
 8015e2a:	bd10      	pop	{r4, pc}

08015e2c <_init>:
 8015e2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8015e2e:	bf00      	nop
 8015e30:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8015e32:	bc08      	pop	{r3}
 8015e34:	469e      	mov	lr, r3
 8015e36:	4770      	bx	lr

08015e38 <_fini>:
 8015e38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8015e3a:	bf00      	nop
 8015e3c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8015e3e:	bc08      	pop	{r3}
 8015e40:	469e      	mov	lr, r3
 8015e42:	4770      	bx	lr
